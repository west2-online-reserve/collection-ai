[
  {
    "program_id": "251190055",
    "program_name": "NebulaGraph 集成 PyG ",
    "difficulty": "基础/Basic",
    "tech_tags": [
      "PyTorch",
      "Distributed Storage",
      "Database",
      "Graph Database"
    ],
    "org_id": "119ef0d9-7aac-431d-bb9f-d39864c168ff",
    "program_desc": "<p style=\"text-align:start;\" size=\"1\" _root=\"[object Object]\" __ownerid=\"undefined\" __hash=\"undefined\" __altered=\"false\">PyG 是一个用于在 PyTorch 中创建和训练图神经网络的强大而灵活的框架。它简化了图数据的处理，并提供了各种 GNN 模型的构建块，助力研究人员和开发者在图结构数据上进行创新。NebulaGraph 是一款开源的、分布式的、易扩展的原生图数据库，能够承载包含数千亿个点和数万亿条边的超大规模数据集，并且提供毫秒级查询。PyG 作为 GNN 的训练推理框架、它的图抽象支持从远程的分布式基础设施上存取，这个抽象叫“remote server”，有了这个抽象，我们可以连接两个项目，让 PyG 社区受益于 NebulaGraph 的超大规模分布式图存储，驱动分布式图申请网络的训练。</p>",
    "output_requirements": [
      {
        "title": "",
        "children": []
      },
      {
        "title": "1. 设计实现 PyG 的 NebulaGraph remote server ，作为其 FeatureStore 与 GraphStore.",
        "children": []
      }
    ],
    "org_program_id": 55
  },
  {
    "program_id": "251ed0128",
    "program_name": "在Occlum 库操作系统中实现Linux AIO系统调用",
    "difficulty": "基础",
    "tech_tags": [
      "Linux"
    ],
    "org_id": "1ed29059-95db-46a1-8fc9-a73059403a7b",
    "program_desc": "<p class=\"MsoNormal\">Occlum是适用于TEE环境下的内存安全的、多进程库操作系统。Occlum为了让Linux原生应用无需修改和编译无缝的迁移到TEE中，为此Occlum实现了150多个兼容Linux的系统调用。</p>",
    "output_requirements": [
      {
        "title": "1. 当前Occlum还未实现Linux原生异步IO接口 AIO系统调用，此项目的目标是在Occlum库操作系统中实现兼容Linux AIO的系统调用。",
        "children": []
      }
    ],
    "org_program_id": 128
  },
  {
    "program_id": "256ea0146",
    "program_name": "AI 模型和数据集的生命周期管理系统",
    "difficulty": "进阶/Advanced",
    "tech_tags": [
      "AI",
      "Cloud Native",
      "Distributed Storage"
    ],
    "org_id": "6ea2bb27-10bb-4ad9-8b6d-6d61e711ba2d",
    "program_desc": "<p>在当前AI模型训练和推理的生命周期中，模型和数据集的统一管理是实现高效、可重现开发流程的关键。本项目以开源版Alluxio为缓存和存储系统，基于[Lance协议格式](https://github.com/eto-ai/lance)，对Alluxio社区版的 Python客户端&#x60;alluxio-py&#x60;进行功能性扩展（），以支持对模型与数据集的检索查询、版本控制、元数据追踪、生命周期管理等高级功能。项目目标是打通数据读写与模型管理链路，提供统一的API接口，提升整体系统的数据访问效率与开发体验。</p>",
    "output_requirements": [
      {
        "title": "",
        "children": []
      },
      {
        "title": "1. 基于Lance格式的元数据方案，扩展`alluxio-py`支持对模型和数据集的注册、查询与加载；",
        "children": []
      },
      {
        "title": "2. 支持模型与数据集的生命周期操作（注册、更新、删除、归档）；",
        "children": []
      },
      {
        "title": "3. 实现至少一种持久化方案，元数据可存储在Alluxio或兼容系统中；",
        "children": []
      },
      {
        "title": "4. 实现可以很好兼容Pytorch/TensorFlow的对外API；",
        "children": []
      },
      {
        "title": "5. 完成单元测试及端到端集成测试；",
        "children": []
      },
      {
        "title": "6. PR成功Merge至主干；",
        "children": []
      },
      {
        "title": "7. 提交完整项目报告和使用文档，提供API文档与用例说明，便于下游用户集成。",
        "children": []
      }
    ],
    "org_program_id": 146
  },
  {
    "program_id": "255660173",
    "program_name": "基于RISC-V的Linux操作系统原生无人机飞控开发",
    "difficulty": "进阶",
    "tech_tags": [
      "Linux",
      "Programming Language"
    ],
    "org_id": "566bb700-9390-4044-b8ff-9f6a770587ee",
    "program_desc": "<p style=\"text-align:start;\" size=\"0\" _root=\"undefined\" __ownerid=\"undefined\" __hash=\"undefined\" __altered=\"false\">- 项目背景</p><p></p><p>随着低空经济的发展，无人机的需求越来越负责。运行在RTOS上的飞控难以满足复杂的需求，所以Linux原生的飞控逐渐被大家认可，呈现出飞控主控二合一的趋势，具有开发简单，兼容性好，生态丰富的特点。但是Linux实时性可能无法满足飞控的要求，RROS作为Linux硬实时的解决方案，在这个场景中具备明显的优势。</p><p></p><p>RROS是一个双内核实时操作系统，<span style=\"color:#000000\"><span style=\"font-size:16px\"><span style=\"background-color:#ffffff\">基于Rust-For-Linux（RFL）重构了Xenomai的实时内核</span></span></span>。具体来说，使用RFL提供的在Linux中使用Rust编写驱动的框架，与Xenomai社区的dovetail中断虚拟化接口，基于<span style=\"color:#000000\"><span style=\"font-size:16px\"><span style=\"background-color:#ffffff\">Rust语言</span></span></span>实现了一个实时内核。实时内核将Linux内核作为idle任务进行调度，优先调度实时内核的任务，同时RROS兼容了实时核心的用户态接口库libevl。</p><p></p><p>以往无人机飞控和主控都以ARM生态为主，本题目想要基于<span style=\"color:#000000\"><span style=\"font-size:16px\"><span style=\"background-color:#ffffff\">国产化的RISC-V开发板控制无人机，适配RustPilot飞控。</span></span></span></p><p></p><p>- 项目任务</p><p></p><p>基于Risc-V开发板，支持RustPilot飞控，重点完成RISC-V架构下的实时驱动开发，包括SPI驱动，imu驱动等无人机场景下常用外设。</p>",
    "output_requirements": [
      {
        "title": "1. 基于RROS在RISCV开发板上实现针对无人机的实时驱动",
        "children": []
      },
      {
        "title": "2. 将实时驱动和RustPilot框架调通",
        "children": []
      },
      {
        "title": "3. （进阶）在搭载了RROS的RISC-V开发板上，利用RustPilot做主控驱动无人机，完成调参，并成功完成飞行任务",
        "children": []
      }
    ],
    "org_program_id": 173
  },
  {
    "program_id": "2536e0180",
    "program_name": "TinyEditor 支持协同编辑",
    "difficulty": "进阶",
    "tech_tags": [
      "Vue.js"
    ],
    "org_id": "36ed1f70-33b1-47c2-a63c-d3faea6b73fc",
    "program_desc": "<p><span style=\"color:#494949\"><span style=\"font-size:16px\"><span style=\"background-color:#ffffff\">随着在线协作需求的日益增长，用户希望在 TinyEditor 富文本编辑器中实现多人实时协同编辑功能。本功能需要从0开始开发，旨在允许多个用户同时对同一文档进行编辑，并且能够实时看到彼此的修改内容，确保团队成员之间的高效协作。</span></span></span></p>",
    "output_requirements": [
      {
        "title": "1. 完成 TinyEditor 富文本编辑器的协同编辑功能开发，确保多个用户能够同时对同一个文档进行编辑，且编辑操作能够实时同步到所有参与协作的客户端。",
        "children": []
      },
      {
        "title": "2. 用户在编辑器中的操作（如文本输入、删除、格式调整、图片插入、表格编辑等）能够在极短的时间内（不超过 1 秒）反映到其他协同编辑用户的编辑器界面上，确保实时性。不同用户的编辑操作能够在编辑器中以不同的颜色、光标样式或其他可视化方式加以区分，方便用户清楚地了解每个操作是由谁执行的。",
        "children": []
      },
      {
        "title": "3. 冲突解决机制 ：在多个用户同时对同一段内容进行编辑时，能够自动检测并合理解决编辑冲突，确保文档内容的一致性和正确性。",
        "children": []
      },
      {
        "title": "4. 接口与集成 ：提供与后端服务的接口，实现编辑器内容的实时保存和同步，确保在网络中断或其他异常情况下，用户的编辑内容不会丢失，并且能够在重新连接后继续协同编辑。",
        "children": []
      },
      {
        "title": "5. 提供一个或多个完整的示例项目，展示 TinyEditor 协同编辑功能在实际应用场景中的使用方法，包括如何初始化协同编辑、如何处理用户加入和退出协同编辑等情况。编写详细的协同编辑功能使用文档和开发教程，包括功能介绍、操作步骤、接口说明、常见问题解答等内容，帮助用户快速上手并有效使用协同编辑功能。",
        "children": []
      },
      {
        "title": "6. 确保代码符合项目规范，有完整的TypeScript类型声明，UI美观体验良好。",
        "children": []
      },
      {
        "title": "7. 补充相应的文档和自动化测试用例。",
        "children": []
      },
      {
        "title": "8. 建议输出TinyEditor协同编辑的介绍文章和视频",
        "children": []
      }
    ],
    "org_program_id": 180
  },
  {
    "program_id": "25b970239",
    "program_name": "基于ct-oval的操作系统安全用例数据库及评估用例生成工具在openeuler发行版上的适配开发",
    "difficulty": "进阶/Advanced",
    "tech_tags": [
      "x86"
    ],
    "org_id": "b9770f4d-f586-4373-bdac-ce6389065946",
    "program_desc": "<p>把ct-oval开源项目对接openeuler的cve数据接口，清洗整理生成相应的openeuler cve评估用例数据库，适配openeuler24.03-lts-next等若干主力版本，达到可以实时输出主力lts版本CVE安全评估用例的效果。保证用例可用openscap正常扫描并输出结果。</p><p>（1）需要的技能：xml, sql, golang</p><p>（2）已有的工作: ct-oval项目，在openeuler一个衍生版上的测试报告</p><p>（3）存在的不足： 未适配openeuler发行版，未对接openeuler cve数据发布接口，未完成多操作系统/多CVE发布接口的架构设计及开发</p><p>（4）希望改进的点：完成多操作系统/多CVE发布接口的架构设计及开发，完成openeuler发行版及cve接口的适配</p><p>（5）最终项目实现的目标：各衍生版可以通过少许工作量便可实现适配</p>",
    "output_requirements": [
      {
        "title": "",
        "children": []
      },
      {
        "title": "1. 完成多操作系统/多CVE发布接口的架构设计及开发，完成openeuler发行版及cve接口的适配",
        "children": []
      }
    ],
    "org_program_id": 241
  },
  {
    "program_id": "25ed70261",
    "program_name": "Kmesh特性验证与补充和文档编写",
    "difficulty": "基础/Basic",
    "tech_tags": [
      "Cloud Native",
      "Kubernetes"
    ],
    "org_id": "ed765847-55a2-4051-9793-8748b9aae5a6",
    "program_desc": "<p>Kmesh 是基于 eBPF 和可编程内核的高性能、低开销服务网格数据平面。去年完成捐赠CNCF。流量治理相关的功能特性也已经基本完善。但Kmesh dual-engine mode下的流量治理特性缺少相对应的验证测试与文档。因此我们希望就以下几个特性完成验证测试与验证文档的编写。</p><ul><li><strong><span style=\"color:#000000\">locality load balance</span></strong></li><li><strong><span style=\"color:#000000\">circuit breaker</span></strong></li><li><strong><span style=\"color:#000000\">rete limit</span></strong></li><li><strong><span style=\"color:#000000\">Ingress</span></strong></li><li><strong><span style=\"color:#000000\">engress</span></strong></li></ul><p><span style=\"color:#000000\">其中关于Ingress和egress经过先行测试，欠缺DNS解析的逻辑，需要补充开发。</span></p>",
    "output_requirements": [
      {
        "title": "",
        "children": []
      },
      {
        "title": "1. egress特性针对serverEntry的开发",
        "children": [
          "1.1. DNS解析模块逻辑的补充",
          "1.2. 针对serverEntry的STATIC和NONE处理逻辑的补充",
          "1.3. UT测试覆盖",
          "1.4. e2e测试的覆盖 "
        ]
      },
      {
        "title": "2. 其他功能的验证文档",
        "children": [
          "2.1. locality load balance",
          "2.2. circuit breaker",
          "2.3. rate limit",
          "2.4. Ingress"
        ]
      }
    ],
    "org_program_id": 263
  },
  {
    "program_id": "25b970275",
    "program_name": "jailhouse到RISC-V移植支持",
    "difficulty": "基础/Basic",
    "tech_tags": [
      "Embedded Database",
      "Virtualization"
    ],
    "org_id": "b9770f4d-f586-4373-bdac-ce6389065946",
    "program_desc": "<p>（1）相关背景：openEuler embedded通过部署混合关键系统(MCS)，允许在单块硬件上同时运行多个操作系统，以实现多样化任务的资源隔离与调度。而为了确保多OS协同运作的安全性，必须确保OS间的资源隔离。openEuler embedded使用了由西门子主导的开源轻量级hypervisor——jailhouse来实现这一目标。</p><p>（2）已有的工作：openEuler embedded在ARM/X86上已经实现了基于jailhouse部署混合系统，jailhouse本身也支持在ARM/x86的QEMU上运行，并且在RISC-V方面有一定的学术成果。</p><p>（3）存在的不足：目前jailhouse主干和openEuler embedded使用的版本均缺少对RISC-V的支持，并且已有的RISC-V相关的研究成果对RISC-V新的中断架构AIA研究不足。</p><p>（4）希望改进的点：</p><p>- 补充对jailhouse的分析文档，包括对jailhouse的架构设计，jailhouse在RISC-V上的移植方案，以及基于RISC-V AIA支持jailhouse虚拟化中断直通的方案。</p><p>- 为openEuler embedded使用的jailhouse添加RISC-V以及基于AIA的中断直通支持。</p><p>（5）最终项目实现的目标：完成对jailhouse设计的全面分析以及jailhouse在RISC-V上的移植方案，在社区进行汇报和分享。并且基于移植方案在实现了AIA的RISC-V环境上使用jailhouse部署中断直通的openEuler embedded。</p>",
    "output_requirements": [
      {
        "title": "",
        "children": []
      },
      {
        "title": "1. 完成对jailhouse设计的全面分析以及jailhouse在RISC-V上的移植和基于AIA的中断直通方案，并且在社区进行分享。",
        "children": []
      },
      {
        "title": "2. 基于移植方案，在支持AIA的RISC-V环境上实现基于jailhouse和中断直通部署的openEuler embedded，并进行性能测试。",
        "children": []
      }
    ],
    "org_program_id": 277
  },
  {
    "program_id": "2574e0390",
    "program_name": "EmbodiedAI-Ops",
    "difficulty": "进阶",
    "tech_tags": [
      "PyTorch",
      "AI"
    ],
    "org_id": "74eef17f-7b15-44f6-af19-b648a7c7d056",
    "program_desc": "<p><span style=\"color:#000000\"><span style=\"font-size:16px\"><span style=\"background-color:#fcfcfc\">开发面向端到端具身操作任务的效率优化框架，通过多模态感知融合、动态技能重组与实时决策加速等技术，突破传统方法在数据效率、响应延迟和跨场景适应性方面的瓶颈。针对使用场景如工业装配、物流分拣等中实现操作成功率提升、任务执行时间缩短的目标。</span></span></span></p>",
    "output_requirements": [
      {
        "title": "1.在仿真环境如pushT，metaworld实现对应操作任务，成功率达到70%以上\n2. 完成收集真实场景任务数据，如抓取放置。并在真实机器臂部署训练好模型，实现80%以上成功率\n3.利用前沿技术如预训练，CoT，仿真与真机数据混合训练等方式，实现完成长程任务并达到成功率80%以上。 \n",
        "children": []
      }
    ],
    "org_program_id": 392
  },
  {
    "program_id": "25f3e0428",
    "program_name": "SpiderMonkey 的 64 位 RISC-V 后端修缮工作",
    "difficulty": "进阶/Advanced",
    "tech_tags": [
      "Web Application",
      "Desktop Application",
      "CI",
      "CD",
      "SVN",
      "Git",
      "Clang",
      "Compiler",
      "GCC",
      "Linux",
      "LLVM"
    ],
    "org_id": "f3ea6d02-4c9c-4638-8ec6-dfba26040cf6",
    "program_desc": "<p>Firefox 浏览器的 JS 引擎（代号 SpiderMonkey）支持多个处理器架构的 JIT 编译，即动态生成适合当前平台的机器码，以达到比普通解释器高几个数量级的性能。PC 机常用的 x64 和手机常用的 arm64 是它支持得最好的平台目标，而 riscv64 后端的单元测试通过率甚至已被即将成为历史的 mips64 反超。</p><p></p><p>该项目的主要目的是改善 riscv64 后端代码的品质和测试通过率，并以此机会引导学生接触 Firefox 补丁的上游化流程。</p>",
    "output_requirements": [
      {
        "title": "",
        "children": []
      },
      {
        "title": "1.改善 Firefox 的 JS 子项目的 riscv64 部分并根据完成进度递交上游，测试错误小于 50 个",
        "children": []
      }
    ],
    "org_program_id": 431
  }
]