问题名称,问题内容,NO.1回复,NO.2回复,NO.3回复,NO.4回复,NO.5回复,NO.6回复,NO.7回复,NO.8回复,NO.9回复,NO.10回复,NO.11回复,NO.12回复,NO.13回复,NO.14回复,NO.15回复,NO.16回复,NO.17回复,NO.18回复,NO.19回复,NO.20回复
,,,,,,,,,,,,,,,,,,,,,
为什么现在国内各大高校仍选用谭浩强的《C 程序设计》为教材？,既然这本书已经如此过时并且错误非常多，而大学教授们应该肯定写过很多代码，知道此书弊端。并且国内并不是没有更好的 C 语言书籍。,"  IT界有个万人皆知的行业准则：不要重复造轮子。
  它的意思是，你可以自己造的玩，但是如果人家已经有足够好的轮子，你就不要试图，甚至是通过各种手段，试图去取代这个轮子的地位。
  同理，如果某个学科已经有足够好的教材，您没那水平编出更好的教材，就乖乖地用人家的教材就好了，这样既节省资源，同时也能保证中国学生看到的教材内的思想和国外学生是同步的。
  中国大学有个毛病，就是什么东西也想搞个自己的出来。
  就比如线性代数教材，如此重要的学科，用脚趾头也能想见，优秀的国外教材已经遍地走了，但是各个大学仍然要请自己学校的某几个水平堪忧，语言表达能力菜得扣脚的老师来编写一个教材，最后命其名曰“精品教材”，而这些垃圾教材坑害的是一批一批的优秀学生，当然如果能被一直坑下去的，自主学习能力也是有点问题... 
  可是世界上大多数学生就是这样，他们会乖乖地去上课，听老师念PPT，然后认真看学校推荐用的课本，然后当这些垃圾教材搞得他们一头雾水的时候，他们会用“这门课难”来安慰自己，最后学的不明不白，草草了事。
  我刚来
中国科学技术大学
的时候，上学期的线性代数，学校用的教材就是所谓学校老师自己编的“精品教材”，这个教材是面向非数学专业学生的，我就看了三页就已经搞不明白它在说什么了，可以想象，这样的教材迫害了多少学生，耗费了多少学生的时间。
  而且可以想象，编这本教材的老师们从中肯定可以得到补贴，能不能得到版税不清楚，但是补贴是肯定有的，而且同时这本教材的编写也能成为所谓的资金申请的理由，“为中国科学技术大学量身定制的教材”这句话多么好听啊，可事实上呢？
  由于答主英文水平过关，当时直接去图书馆借了一本英文的线性代数教材，面向数学专业的，从第一页开始看下去，便已停不下来，连住一看就是二三十页，看完感觉畅酣淋漓，舒畅至极，从那以后，线性代数课我再也没去过，除了最后的考试我出席了。
  那次期末题不简单，我考了95分。
  线性代数资源推荐，详情参见本人文章：
  我自己知道，我并不聪明，若是我不看那本英文教材，我恐怕能考70分不错了。
  这就是事实，还有很多例子，比如贵校
叶邦角
编的的《电磁学》和
格利菲斯
的《电动力学》在易懂性和深刻性上的巨大差异，前者啥也看不懂，后者看的畅酣淋漓。
  《大学物理》与《
费恩曼物理学讲义
》的惊人对比，前者看的想要睡觉，后者看的我想要拍桌，甚至感动地流泪，甚至看完兴奋地睡不着觉。
  附费恩曼讲义的链接：
The Feynman Lectures on Physics
 
  纸质教材？？买教材？？学校让你买教材？？没有学生买教材，那这些教材不就无法带来收入了？
教材是用来教育的？No No No, 教材是用来挣钱的，相信我。
  马克思主义原理你们都上过吧？这个教材是不是必须买？它为什么不做成pdf版，在网上开源呢？
每年这本教材能卖一千万册吧？没这些钱谁来养那些教材编写委员会呢？
  
李重光
的乐理书，可能在你们眼里还算不错，但是我看完之后还是搞不明白它说的这一切是怎么运用在作曲中的，后来我有了VPN，在油管上打开了新世界，在众多即兴，乐理的视频教程中，我现在可以在任何一首歌里面即兴演奏，写歌也是手到擒来。
  音乐学习的最好方法不是看书，而是看视频，因为视频是声音和图像的结合体，比如我现在讲
Lydian音阶
，它的音阶结构是 1 2 3 #4 5 6 7，只讲这个其实你并没有真正懂它的音响效果，这个youtube频道从图像，PPT，演奏示例，记忆法等如手，教你如何记忆指板位置，如何进行特定和声进行下的solo即兴和创作。
  详情参见本人文章：
  这个世界上不存在真正无法理解的知识，只存在不会表达的糟糕教学者，大家都是人，为什么你能懂的东西我就懂不了呢？就算我笨一些，能在你脑子里运行的东西也能在我的脑子里运行，只不过可能速度慢一些。
  教材的目的是什么？教材的目的是让学生尽可能地不依靠任何外界帮助，仅仅依靠你的教材就能学会你想表达的知识。
  可以说，我国在此方面做的奇差无比。
  国内这些教材其实牵动了很多人的利益，比如学校的利益，编写者的利益等等，中国的大学可能觉得教材都用西方的，是文化不强盛的表现，总想自己搞一个，这正是不自信的表现。
  你要是能编出比国外优秀教材更优秀的，那完全可以啊！
  问题是你能吗？
  当然还有一点就是，国内的教材更新速度捉急，很多新东西早就出来了，教材上还写着那些旧东西，考试还是按照这个教材考...
  我一直觉得中国学生整体上是比较聪明的，如果我们能像美国学生那样直接接触到整个世界的优质教学信息，那我们的未来不敢想象。
  不过一个学生如果自己不会去寻求改变，看的破教材还不知道换更好的，上不了Google还不舍得花钱买V*N，那这样的学生可能也干不成什么...
  国外的大部分经典教材，我是说经典教材哦，不是所有！！经典教材是国外教材的一个很小的子集！ 差不多都有免费的pdf版本，直接下载就好，这对于那些没有机会接受高等教育，又买不起好教材的人是很友好的，而且不仅如此，教材配套的习题集，答案等往往也可以直接下载，反观国内的教材，一方面习题没答案，然后老师告诉你们习题最怕有答案，但与此同时老师也没有能力建立起一个足够高效的机制能马上让学生知道他们的结果是否正确，就相当于，不能给你肉吃，还要叫你多吃素，吃肉会长胖。
  
普林斯顿
的《Algorithms 4》是业内广受好评的教材，虽然叫算法，事实上数据结构和算法的内容都有，网址：
Algorithms, 4th Edition
  在页面的左边，可以直接这样寻找自己想要的内容，发挥了电子图书的优势，节省了搜索目录的时间。
归并算法
  在归并算法的讲解中，可以直接点击Merge.java跳转至实现该
ADT
的代码：
  这就是我为什么不喜欢看纸质书，因为太麻烦了...翻来翻去的，真的累。
  这本书有一个标准库，有绘图，排序等等，你可以直接在左下方搜索标准库里的某个API，看到该API的官方文档。
搜索栏
  测试用例，作业，PPT等等，都直接点击就好。
  我试问国内的哪个计算机教材这样做了？你恐怕是下载个pdf版都得在什么微盘，百度云，或是百度文库里面下载吧？
  来，你告诉我，
谭浩强
的
《C语言程序设计》
的开源网站在哪？让我瞻仰一下？没有？
  哦。
  我觉得国内教材编写者最大的问题就是：动机不纯。
  对于音乐行业来讲，如果教材编的太好，学生就不想找老师了...那这些音乐水平高不成低不就的人，饭碗谁给保证呢？
  这个逻辑其实挺简单的，就是：你说想要看懂这个教材必须找个好老师给你讲，那你这个所谓的好老师为啥不把他讲的写成教材呢？这样大家不是就都看懂了？哪来那么多麻烦事？
  事实上一个人编写的教材应该是比这个讲课要更好懂的，因为一个人写出来的东西往往是经过了细致思考的结果，而凭空就说的东西往往会出问题，那如果一个人教材写的奇烂无比，他的课我也建议你别去了，误人子弟。
  所以啊，现在掌握大学权力的人，都是高考刚恢复不就参加高考的那批人，他们眼中的世界和我们年轻人眼中的不太一样，再过二十年，等我们成为了掌权者，也许这一切会变好。
  学校怎么做是学校的事，你怎么做，还是看你自己。
  谢谢。
>欢迎大家参加我的Live, 本次Live将与大家一同探讨编程学习之最优方案, 届时将分享一大波开源优质教材!!!!
  看了大家的回复和评论，我挺开心的，这个答案火也是意料之中，但是能获得这么多人的认同，我深表荣幸，有人说英语差看不了英文教材的，我想说，英语的学习其实是自然而然地事情，不要在学中做，而要在用中学，忘掉中文，去完全投入英文的环境中，很快你就会适应这一切。事实上，如果你说你英文教材有些单词不认识，那我想反问你，难道这个东西翻译成中文你就一定认识了？比如线性代数的秩（Rank），你不知道秩是什么意思对吧？但你反而大概知道Rank的意思。
  还有人说，我们不能这样直接用别人的，要做出自己的，这个想法其实要真往大了说，我觉得挺肤浅的，别人造个加速器，我们要造个更大的，别人造个桥，我们也要造个更长的，快歇歇吧，干好自己的本职工作就很好了。
  世界上只有两种东西有真正的价值，一种是创世人所未见，一种是对已见之事的推进与优化，做一个比现有的还烂的东西，本身是没价值的，只能当作练习使用，这句话的逻辑已经很明晰了，再反驳我是不会回复的。
  不要过分相信教材的权威性，也不要把老师和教授当神看，大家都是普通人，老师让你做的，也许并不是你想要的，我们生在互联网时代，已经给了我们擦亮眼睛，检验真理的能力了，我们也没必要迷信任何权威。
  这世界上谎言很多，要把眼睛擦亮，做个明白人。
  第二次修改答案，给大家看看如何击退杠精：
  用一种调侃的语气顺着杠精说，他们就噎着说不出话了~
  杠精快来~我不怕~","这个答案请勿转载。
我打个比方，大家看完我讲的之后（哪怕看似与计算机无关）、估计就能想明白怎回事了。
国内的音乐理论逻辑体系基本上就是在「
李重光
＋斯波索宾」这两套教材构筑的。
可能也有其它的音乐理论教材，但基本上都围绕这一套展开。
特别是斯波索宾，从苏联体系而来。
知乎有很多对这些教材的短版的讨论，我就不赘述了。
我本科是在加拿大读的（Digital Audio Arts 专业，学位是 Bachelor of Music），现已毕业了。
在本科阶段，拯救了我调性和声理论学习的，是岛冈让的《t合和声：g技?分析?原理》。
（完全模组化设计，自学者可以自己安排学习节奏、且书中的三大部分彼此互补。）
我惊讶於世间居然有对自学者如此友好的音乐理论教材，
忽然想起我首次出国之前看李重光乐理半天看不懂的样子，似乎明白了些什么。
之后一段时间内，我在知乎推荐岛冈让的《t合和声：g技?分析?原理》这套教材，
也有想著有朝一日等自己日语精进到一定地步了、就考虑翻译这本教材。
但我现在多了几份恐惧。
我在回答某些乐理问题时，很多人说我自造术语、甚至有人专门以此攻击我。
我专门买来
斯波索宾
的教材的简体中文译本（现在被我扔在加拿大了），才发现：
岛冈让的教材当中的术语逻辑体系，与国内现行这套苏修型音乐理论术语逻辑体系，有明显差异。
我忽然意识到：
国内这些对自学者不友好的教材所以能被推荐为圭臬，也是和某一群人的利益有关：
国内这么多音乐老师（无论是院校老师、还是面向大学外招各种年龄段的钢琴学生的老师），
当中肯定是有一定比例的人受益于下面这个现状：
「国内能买到的中文教材，大多都需要老师点拨讲解、才能让你看懂。」
我也有好几次见到与斯波索宾的和声教材有关的评论说「必须得找个好老师给你讲」。
万一有人要是将岛冈让这本书（或者同种类型的优秀教材）翻译成中文引入国内，岂不是要砸了那群人的饭碗？
毕竟，优秀的音乐教育资源，在中国，非常希缺。
剩下的那群人，要用最少的成本保住自己的饭碗，最直接的方式，就是在这个圈子里面搞封闭。
（看看 Arnold Schoenberg 的「Harmonielehre」的英文翻译，再看看简体中文译本，对比下后者少了什么，你必会有所发现。至少，我不认为「用目标语言写个 summary」就可以叫翻译了。）
在中国，从来不缺业馀钢琴10级的人，
但他们当中能够对乐曲的（包括曲式与和声在内的）
格物致知
能力的好坏，又是一个未知数。
而且他们往往也是师出那些和他们一样的前辈之手：
只知道怎么演奏好一个乐器，但对音乐的赏识能力仍旧是个问题。
这些人当中，有些人可能热爱音乐，有些可能只是方便给他父母脸上贴几年的金。
这些都是产业。
破坏行业的事情，这业内会有谁乐意去做呢？会有谁乐见于这种事情成事呢？
回到正题，大家能想明白为什么很多大学教编程必须 Visual Studio 6 和 C 语言了吧？
（C 语言不是所有专攻方向都需要的；VS6 包括 VB6 和 VC++6。）
哪怕咱们大陆的资讯电子类专业出身的人们自学能力再高强，
也很难改变这群大学教师「决定教什么」。
P.S.: 对于谭本人这本书怎样，请不要与我探讨。
我只负责对那些三缺帐号们（专门新注册来的水军）批次封锁、清空其评论。
可能你觉得容易学，但没准是你老师点拨得好、或者你之前的学习经历帮到你了。
P.P.S.: 一线
音乐
院校的学生们不要来我这里当杠精，没有意义。
我这答案讨论的问题并不会影响到你们。
你们能进一线
音乐
院校的话，教材好坏根本不会对你们有多少影响，
因为你们有全国最强的师资资源、使得你们自然不会去关心二三线
音乐
教育圈的死活。
# EOF","之前的回答过于草率，周末有空会改一下
如果换教材，怕是一并要换一批老师。我校某老师讲c语言，公开表示main的返回值应该是void，int是某些环境的特殊写法。然后上机的环境是devc，全体编译报错，课件上的代码都运行不起来，公开打脸。
以及其他经典言论：我们现代计算机，内存绝对够怎么写都不会爆，怎么写都不会溢出。上世纪我们没有钱，买正版Windows系统要给Microsoft送多少钱啊，所以我们应该用盗版系统。","谭老师虽然问题多多，但还不至于太匪夷所思。给你们分享一下我985 IT强校的
编译原理
教材，几十块一本的书里蕴藏着大量
天顶星
科技。
重点我都画出来了，随便一个抛出来都是能稳拿
图灵奖
的成果，分分钟吊打IEEE全体。
不过实事求是，这本书总体没啥问题甚至比较优秀，上面那一段大概是某些不可抗力的体现，魔幻但真实。","原来我读大学的时候就是学
谭浩强
版本的C语言，这么多年了还是这本啊？烂书一直用，能说明两个问题：
1. 改变要靠自己，等别人去改变是不靠谱的事情，哪怕改变难度很大；
2. 一本书籍可以养活一批人。教材、教案早已了然于胸，熟悉的内容滚瓜烂熟张口就来，哪里需要改变了？改变了还要我花时间去备课，去熟悉适应新内容，而且我自己也不一定学得会啊？那怎么去忽悠别人呢？","大学里面有一群基础教研人员，有很多是早期留校的本科生。他们没有任何上进心，以985高校教师为荣（当然也没本事混副教授），抱着一套ppt混了20年。
可能这些人连指针都不懂，然而，他们属于历史遗留问题，不解决也很捉急的。","不可否认《C程序设计》这本书放在今天来看的确烂，比如这种低级语法错误（第四版）：
*29个字符居然只给出了28个。 
* 07页-程序4，ture 和 flase 各亮相一次。
* “后辍”。 
* rintf。
以及以下这种错误结论：
* “凡是二元运算符都可以与赋值符组合成复合赋值符”。。 
* “先定义，后使用”。 
* “C的实数常量都是双精度型”，接着在后面提到“添加f来强制指定类型”。
并且《
C程序设计
》还出版的非常非常多：
的确，很多学子被这本书弄得看见C语言就瑟瑟发抖，失去了学编程的快感。
学习 C语言推荐两本书：《
C primer plus
》、《C和指针》。
谭老的书真的一般，但是，但是回复区一堆攻击谭老的是什么鬼，，，，
谭老堪称中国第一代计算机先驱，他那本《
C语言程序设计
》中出现的dos就是明证。
计算机行业发展迅猛、新旧更替以年计、甚至以月计！
C语言是1972年问世的，彼时谭浩强已经38岁了，1989年C语言完成第一次标准化，谭浩强这个时候已经55岁了，1991年，谭老在57岁高龄写出《C程序设计》，彼时还真不算太落后。1999年，C99标准才出来，这时候
谭浩强
已经65岁了，也很难有精力再去高速的迭代他那本书了。
2000年之后，经典的C语言书籍层出不穷，甚至可以用百花齐放百家争鸣来形容了，老谭的书的确已经毫无竞争力了。
但谭老并没有什么过错，这本书放在90年代，绝对是指路明灯般的存在，也是当年的计算机经典书籍，但时过境迁，计算机科学在发展、C语言也在高速发展，就好比一个过时的古董，自然没有任何实用价值。
问题来了，谁是坑学生们的罪魁祸首？答案不言而喻了吧！
是那些偷懒的大学、那些偷懒的大学教授，不假思索的继续沿用一个上世纪90年代的教材，全然不顾计算机行业的飞速发展和经典计算机书籍的层出不穷，抱残守缺、因循守旧、冥顽不灵、顽固不化！
是这些人坑了无数学生，让很多人看见C语言就瑟瑟发抖，甚至直接劝退了无数计算机学子。
而谭老呢？他把他的一生奉献给了中国计算机科学的发展，更是在2019年，将近乎终身的积蓄全数捐给了清华：100多万。
可能这100多万在诸位眼中算不得什么，在企业家动辄过亿的捐献中，更是少得可怜。
可试问大家一句，我们何尝捐过几万，哪怕几千？
有些人，他已经奉献了他的一生，却还要承担骂名，可悲可叹！
顺便送大家一份硬核计算机资源，都是国外经典书籍为主！我把大学和工作中用的经典电子书库（包含数据结构、操作系统、C++/C、网络经典、前端编程经典、Java相关、程序员认知、职场发展）、面试找工作的资料汇总都打包放在这了，
点击下方链接直达获取：
看看这套资源的目录，非常经典：","看了某些高校教师的回答。真心感觉以后有孩子千万不要在国内学这种垃圾教材 遇到垃圾老师 上垃圾课。
18-22岁这段青春很宝贵，把人生浪费在垃圾教材上太可惜。相比CMU UIUC MIT的本科计算机课程，国内的真心垃圾","和大部分读者的观点不同，我倒没有感觉谭浩强这本《C程序设计》有多糟糕。
当然，我下面要说的，是解释为何近年来大家对国内教材质量的声讨越发强烈的原因。
首次接触谭的《C程序设计》
我是08年在中南大学读的本科，专业当时是电子信息工程。
我高中时期和大部分人一样，是没有接触过任何编程语言的。也没有受过任何系统化的计算机基础知识教育。在本科入学时对计算机一无所知（除了打游戏。。。）
而我第一次接触程序设计这门课是在大一。大一那会儿还很认真，读什么书都会想着“刨根问底”。这点很重要，因为程序设计这门课的思维和高中时期接触的数学物理的“观察者思维”不同，它是彻头彻尾的“设计师思维”。前者要求你在一组给定的规则下推算一个系统的运动结果；而后者要求你在给定的前提条件和结果（需求）下设计系统。
可以说，思维差异导致我学校程序设计这门课非常吃力。再加上当时中南大学自己也出了一本《C程序设计》的教材，而且强制要求所有人必须购买（学费内包含）。然而那本书。。。我们的程序设计课程老师说，就是一坨屎。他第一堂课就告诉我们：“如果你还想学这门语言，别用咋们学校的书，去读谭浩强的那本”。
那时候我第一次知道，原来学校自己写的书还能这么辣鸡
。
于是我在老师的推荐下去买了这本谭浩强的C程序设计。
十年前的编程学习环境
先说明一个区分点。
现在很多的学生一如大学就能带计算机进入宿舍，甚至可能在高中时就已经接触过程序设计的相关知识。但是我读本科的时候是2008年。中国社会以2008年为分界点，可以认为2008年之前是相对保守的，而之后逐渐加大了开放。所谓保守在哪呢？举个例子，我直到大学之前都没有上过网。因为当时，全国范围内对网络游戏和网瘾的管控没有完全消失。甚至我们到了中南大学后，学校有明确要求禁止学生大一大二带电脑进宿舍。当然也有人带的，当时很多人不带是因为那时候学生的经济水平并不高，大部分人的消费观念是电脑是高端消费品，不值得购买。
因此在大学本科，在没有计算机的大一，我们怎么学习编程？
你们肯定想象不到，当时我们一群喜欢写程序的小伙伴都是直接去大学的图书馆计算机室学习编程的。。。而且那个计算机室还TM不能存盘，这意味着所有的编程必须当场完成。如果无法完成呢？那么只能在去自习室的时候在草稿上面写代码！
对于那个年代接触编程的人来说，什么编译器检查啊，IDE界面友好性的东西，不存在的。像什么算法设计都是在草稿上通过自己画图，代码也是在草稿纸上靠数学证明正确完成后才写入的。所以一般只要如果我去写程序，多数时候可以直接通过编译，即时我是用vim或者
emacs
在无语法辅助的条件下。
当时我们学校图书馆的计算机用的就是VC++6，到大三我自己实习攒钱买了第一台电脑的时候，也是装的这个VC，哦，那会儿还是2010年初，VS应该是和C#一块在之后逐渐被推广的。
所以早期程序设计的学习环境和今天极为不同。因此你也不要奇怪为何那么多老前辈用的是vim, emacs一类的看起来有点反人类（其实你懂了命令操作后，比VC方便多了）。这也是为何稍微大一点的程序员用VS比较少，因为他们不存在VS这个作为过渡的IDE来训练自己的开放过程。
学习谭浩强《C程序设计》的经历
说完编程学习的社会环境之后，我们再来说这本书。
为何我们那一代学习程序的人对谭的书没有如今这么强烈的反感呢
？
首先，绝对可以肯定的是，我们那届学程序设计，并亲手写出过数据库系统和网络服务--客户端数据包传输程序作业的学生一定知道，它的书里面到处都是BUG。
但是我们并没有因此产生反感。一个很重要的原因是，
当时的编程环境实在糟糕，而理论联系实际的距离又十分之远（如果你看过同时期国内其它编程教材，你会发现谭的书已经算是很有实践指导能力的了。。。）这迫使我们当时的读书模式和现在有本质区别
，大体上就是：
（1）在书本上，我们只了解算法的基本原理或者程序运行的内在机制；
（2）去计算机上实现程序，观察程序的“实际”运作机制以及算法的“真正”实现
换句话说，
由于我们没有把，也从未想过，要把书本上的理论知识和代码当作真正的代码对待，所以谭的书虽然有缺陷，但是对我们的程序课学习没有造成太大的影响
。
而且，由于谭浩强的书很多地方都写得非常模糊。例如解释内存和地址关系的地方，数值编码以及指针部分，虽然看上去有联系，但是却缺乏系统化的阐述。
所以作为学习者，当时我们学习这种模糊的系统原理时都会直接去计算机上实践。例如直接打印一段内存地址下各个字节（char）的十六进制码，然后手算它和实际存储整数浮点数的关系。此外，内存地址的分配是由高到低还是由低到高，也可以通过打印数组，变量的字节信息来观察。换句话说，我们当时学习这本书的方式又和现在有点区别。
为了弄清楚实际原理，我们其实把整个计算机程序的运作机制当作一个系统来研究了。因此当我们实践完成后，谭的这本书上，哪里有错误，哪里没有，哪些原理说的不准确，哪些有错误，就完全了解了。到了这里，我们才是真正把那本书看完。
当然要感谢谭的这本书，要不是它写的到处漏洞百出，且阐述含糊不清，我在学习它的时候也不会花这么大功夫去研究它的每一处细节
，诸如：数组变量能不能当作指针变量赋值（不能），这种东西都是经过实际在编译器上验证的，虽然它的书也没说清楚这两种类型的区别。但是反过来，也正是因为它的这些缺陷，和当时编程环境的糟糕，才迫使我们通过大量实践了解了这些问题的根本原理，自己探索到了问题的答案。这又和只通过书本了解的知识有着天壤之别。
此外，关于谭的main函数返回类型是void。这一点也很有误导，但是为何当时我们没有抱怨呢？因为我们很自然接受了这点。。。直到后来大三学习《
Unix网络编程
》的时候，才知道unix系统（包括linux）本身是通过各类整数返回值来判断一个程序是否正常退出。
实际上，void main和int main之所以推荐后者，是因为它是一种良好的编程规范，它保证了某个调用你编写程序的外部程序可以获取你程序的内部状态值。而通过这种方法，我们也可以设计不同的程序返回值来告诉外部程序内部错误的类型。
这种规范只有有了一定编程经验的人才会知道。你当然可以一开始就教一个人必须返回int，但是在我看来，未必是一件好事
（就好像玩游戏一开始就告诉你秘籍，你可能就失去了探索它的乐趣了――）
评价谭浩强《
C程序设计
》
最后，来评价一下谭浩强的这本书吧。
这本书首先，可以肯定的是，一定有巨大的缺陷。放在今天看来，完全是糟粕。
其缺陷，其它回答已经说的很清楚了，不仅仅编程规范太复古，而且很多代码和原理讲的都不对。
不过我在这要解释的是这么一个问题：为何如今的程序语言学习者会看不起谭的书，而过去的人却容易把它奉为“经典”。
这就要了解现在的人学习编程的方式和我们的区别了。
现在的本科生，尤其是2012年之后学生，大部分都能在大学之前普遍接触过网络和计算机（像我这种老古董直到大二才有了第一个QQ，直到现在都没有接受微信）。而他们接触计算机编程的时候，大部分的计算机系统已经提供了相当友好和完善的IDE。因此他们学习程序的方式就少了很多中间步骤。
这时候，对于编程书籍的要求不再是单纯的理论，然后依靠复杂的实践完成学习。而是从书本代码直接到IDE执行这样一步到位的学习模式
。
这种高效率的学习模式自然而然地唾弃那些代码里有错，甚至讲不清楚原理的书了。而谭浩强的《C程序设计》也恰在此列。只能说，谭的书已经不适合现代人的编程实践教育了，因此它也到了要被批判的时候了。
但是我也要大家警惕这种过于简单的实践学习原则。因为它太过直接，以至于让一个学习者容易缺乏问题和兴趣去学习某些东西，以至于他们虽然写了很多书本上的代码和习题，但是未必真的了解计算机的原理（例如大端法和小端法我们那时候的人在学习完C语言的时候就通过实践了解到了，然而大部分现在的学生还要去系统学习《深入理解计算机程序》这本书）
一些结论
那么我说了这么长一段解释，又是十多年前人的学习方法和今天大部分学习方法的比较，这种比较的意义是什么呢？
其实在于提示各位：
一本书和一种学习方式，是契合于它们诞生时的那个时代的环境的
。当时没有多少界面友好的IDE，没有完善的计算机编程环境，因此对于那个时代来说，谭的书就成了“适合”那个时代学习方式的一种选择。当然，2008年前后，类似于
C++ primer
这种外国引进的教材还不是很普遍，大部分人都会首先选择国内教材。
所以我们对谭的书观感变差了，评价贬低了。原因不在于这本书本身很“糟糕”，而是在环境变化的情况下，它再也不适合作为那本“最好的”教材了
。随着08年之后大陆开放程度大幅度增加，国外引进的书籍和教材呈现大幅度增加的趋势。有了更好的选择，客户自然抛弃了谭的书；此外，随着系统上IDE环境的越发进步，谭的书极其学习模式不再适应于更加高效率，能够培养更多码农的新时代。故而退出了它的舞台。
但是我们应该正视这本书本身的存在。而且也应该意识到一个危险的现代情绪：
现代社会的舆论，喜欢对一样事物采取绝对的，静态的，非好即坏的评价机制，却忘记了这本书或者这些旧时代的东西本身就是根据它们时代量身定制的。所以批判历史的我们，总是自我感觉自己是永远正确的。但是我也因此不要奇怪，我们的下一辈人，可能带着同样鄙视我们这代人所崇拜的事物的观点来看待我们这段历史和经历。
当然也有人反驳，都8102年了，这么多年了，中国的教材为何不进行改革，向国外学习？这种反驳虽然有道理，但是忽略了另一个环境要素：那就是这种大学出版的书籍往往销量不受影响，完全可以通过让学生入学时强制购买的形式来回本。而且对谭浩强他老人家来说，都赚了几百本书的钱了，人家也没啥动力去更新。反过来，这种机制恰恰是因为老一辈学者依然占据高校教育顶层机构，而新人无法进入高层对其进行改革的无奈。
加上购买国外进口书籍的途径和价格越发下降，重新编写一本更好的国内教材也缺乏动力和市场，故而所有这些因素加在一块的结果，就是到现在为之，没有人愿意对国内大学编程教材进行改革和质量提升
。
所以我也习惯了大学老师在第一节课说的那样：学校的指定教材你们别看，就去网上买这本XXX写的就好了，我们以它为模板。
很多时候，
不愿意改革，不一定只是体制腐朽的问题，还要考虑市场的需求和历史的趋势；此外，有时对某种东西非好即坏的批判，不过是某种无聊的情绪发泄，它会使得我们无法了解产生这种事物的历史背景，从而导致我们越来越弯曲的认识我们的过去
。而因此，也会不可避免地，被我们的下一代人越来越扭曲地看待。
所以总体来说，我认为谭的书已经不再适合这个时代，但是归根到底，它也不像大部分说的是一坨狗屎，毕竟相对于同期的所有其它国内编程教材来说，其质量已经算是十分不错的了。我们批判某种东西的时候，必须结合它的具体的历史背景和那个时代的具体学习方式来看待它。客观来讲，谭的书算不上是那么的不堪，它只是不再适合这个时代的读者了。
------------------------------- 2018/11/11 ---------------------------
更新一下：我注意到一些回答提及了其它方面的因素，在这里给各位列出来作为参考：
（1）学习
谭浩强
教材的用户很多都不是专业领域的学习者，因此对他们来说，没有必要学习K&R的C Programming Language。讲实话，我很同意这一观点。我本科的时候也是一个非计算机专业的学习者，一开始用的也是谭浩强的书，通过一段时间学习后我才开始对编程感兴趣，才有了后续进一步学习C++ primer等其它优秀教材的过程。
学习的过程本身不是线性的，而是一个不断曲折的过程，一开始你不确定是否真的要钻研某个领域，对于这种情况，那些虽然有部分错误但是适合了解和入门的书就很好；当你对这个领域更加感兴趣之后，你自然会去寻找该领域的优秀教材作为深入学习的过程。我发现很多人默认了教育的过程是一个简单的线性流程，但是不要忘了，那些到知乎上问什么书籍适合学习C语言的提问者，其实都已经一定程度的了解和入门了编程语言，而对于没有了解和入门的人来说，这类专业书籍可能并不适合
。
（2）某些大学老师提及他们自己其实很清楚C和C++的现代编程方法，然而问题是
相对专业的书籍除了价格昂贵以外，还可能不适合非专业的初学者
。我觉得这个观点很好地作证了我上面的结论。
我在本科时读过很多书，有一个很基本的经验，那就是一旦一本书的厚度超过250--300页的时候，学习者就很难记忆之前的内容了。在学习一本书的过程中，学习者其实是有一个记忆曲线，这就和各位背GRE是一个德行（只要隔了一段时间不去重复背前几个List你很快就会遗忘之前的内容）。对于编程这种强调连贯性的学习来说，一个初学者一上来如果接触的就是C 
primer plus
或者c++ primer这种动辄400甚至600页的神作，他们根本就不会看得下去。这里，影响一个人能否保持长期阅读的关键在于不断重复。然而重复又是一个更困难的问题：如果一个人没有系统化学习程序语言的某个方面，那么他就很难去快速通过编程实践来重复强化此前学习的记忆的。这也是为何我从来没完全看完C++ primer的原因，因为它又臭又长，看到后面的时候，我都快不记得之前某个标准库的接口是怎么用的了。
这其实就是为何对于入门某个领域的学习者，最佳的选择反而是某些国内教材。、
有的人说K&R的书也适合入门。这是扯淡。K&R的书适合的是那些有一定编程语言基础的人但需要进一步强化去学习的人，它很强调语法和原理的部分，但是对于完全没接触过程序设计的初学者，这些人是根本无法理解什么叫做内存地址或者指针这种抽象的概念，他们看这种书和看天数没什么区别，基本上就是“词我都认识，就是不懂它在说什么”。
为何我能有所体会？因为我当初学习C语言的时候，一开始就在图书馆借到了K&R教材，当时的感觉是完全不能理解这本书里面提及的“专业词汇”概念。即使那本书给出我一些解释，我依然很难去理解它们的“实际功效”。
相反，在接触了谭浩强的书之后，我才通过一点点实践的方式开始去理解内存地址，指针，程序指令这些概念的实际意义，最后回到K&R的教材，才有了一种它是“神作”的感觉。
注意，
你能觉得一本书是好书的前提是你有了足够的见解和理解之后，对于那些不理解基础概念甚至连编程都没入门的学习者来说，他们无论看的是垃圾还是神作，对他们而言那都是天书
。这也是为何我觉得程序员去评价一本非专业入门书籍可能存在偏颇的原因。也因为如此，我只会给已经有一定编程经验的人购书建议。因为我们不能用我们“已有”的专业领域知识去套用其他人的感受，这会反而误导初学者。
我还想补充一些其它看法。某位高票说现在国内教材都是垃圾，很会误导学习者。我认为这言过其实了。大学教育早已经不是中学时期那种填鸭教育，也没有所谓的强迫你不能学习其它教材的说法。任何一个有上进心的学习者都会主动寻找专业领域的教材和材料来强化自身的基础知识。而对于那些没什么上进心的人，他们不管看什么书，都不会有所成就。另外还有人提到，不学K&R的教材就会“输在起跑线”，那么我就是一个输在起跑线上的程序员，可是我每年面试和招入的应届毕业生有很多起跑线都比我高，可他们大部分都缺乏企业级项目的开放经验，而且因为在ACM上刷题过多，导致进来之后老喜欢写过度复杂的程序，且没有良好的变量命名习惯。我倒是觉得学习本身就是个漫长的过程，而且依赖于你自身见解的不断提升，你要是觉得输在起跑线就完蛋了，这种人也不可能指望他们的起跑线向前推了几百米就能够坚持跑到终点的。对于有志向学习的人来说，书籍，只要不是太烂到无法理解，都可以用来入门。
此外，某个用户还批判谭老爷子出书是学术腐败，我觉得这种言论最好不要有。谭浩强的书相比于国内其他学者的书已经很良心了，批判他是学术腐败，除了博取舆论眼球，制造仇恨舆论外没有任何帮助。有的人学的不好，就怪书太烂，体现的不过是他们自身在学习上的怠惰和无能罢了。",作为一个三流985的学生表示深受其害，我们专业课的教材有很多是学校自己出版的，编写者是谁？没错就是你旁边的老师，编的好么，客观来说有些还不错，有些简直是垃圾中的战斗机，只是从别的教材中复制粘贴，排版混乱，错误连篇，坚涩难懂。经常有学霸拿着从图书馆借的书，告诉我xx版比某些shit要好多了。于是我看了下，嗯我们的教材是shit。那问题来了，为啥要坚持用这些垃圾祸害学生呢？首先，教材卖给我们是95折，亲，九五折，自己到图书馆领哟，良心价呢。专业课书经常一本三四十，打印店复印一本也就十来块的事，什么？你说我不尊重版权？你让那些被抄的经典版课本编者哭晕在厕所。而且编书，对于大学老师评职称等各种先进评优都是有好处的。而且考试内容都在教科书上，不买你学的多好都有可能挂，因为他考的可能是冷门知识点。不过在被坑了几次之后大家都学聪明了，都在买二手的，或者复印版。学校也发现这书卖不动，于是就出现每班必须买多少本，这种强买强卖不符合市场规律的事。还有的奇葩老师有着，你不买我的书就是和我过不去，你和我过不去，我让你考试过不去。花钱消灾吧，么么哒。,"很久以前，我也不明白为什么那么多人喷
谭浩强
。我没有看过谭浩强的任何一本书，但是经常却看到大家在讨论这个人。
主要有三种观点：
怒喷派：谭浩强的书是垃圾，错误百出误人子弟。禁止讨论任何有关谭浩强书籍中的内容，看到一律删除。很多人不仅对这个人的书嗤之以鼻甚至恨之入骨。（C 语言吧曾经有段时间置顶发帖说禁止讨论谭浩强的书）
谅解派：谭浩强的书由于年代太早，C 标准还未成熟，有错误是难免的。
赏识派：谭老是当年中国计算机技术探索的先驱者，如今却因为一本 C 语言书籍备受骂名，真是悲哀。
但是你只要看看下面的内容，就知道谭浩强这个人该不该骂。我们谷歌下谭浩强的资料：
谭浩强教授，1952年毕业于
上海市
上海中学
，1958年清华大学
自动控制
系毕业。学生时代曾担任
清华大学学生会
主席、
北京市学联
副主席、
全国学联
执行委员，
北京市
人大代表
。毕业后留在清华工作，担任清华大学
团委
副书记，同时承担教学工作。从70年代末开始，投入
计算机教育
。现担任
全国高等院校计算机基础教育研究会
会长、
教育部全国计算机应用技术证书
(
NIT
)考试委员会主任委员，
教育部
全国计算机等级考试委员会
副主任，是在
中国大陆
知名的
计算机教育
专家。
看下谭浩强创造的世界记录：
1. 20年来编著出版了130本计算机著作，此外主编了250多本计算机书籍，是出版科技著作数量最多的人。
2. 编著和主编的书发行量超过了4500万册，是读者最多的科技作家。
3. 编著的《
BASIC语言
》至1987年即发行销售过千万册，总发行量达到1200多万册，创科技书籍发行量的世界纪录。
可以发现，谭在政治圈和教育圈都有一定地位，特别是教育圈子头衔太多，而且级别很高的样子。
谭主编的书籍达到 130 + 250 = 380 本为科技著作世界记录外加两个出版发行量的世界记录。
我想象中的这个人，不是一个多么厉害的伟人。我看完这些资料以后，觉得恐怖，觉得可悲。多么腐败的教育圈在给他造势，私吞了多少手下人的成果，才帮他达成了这些“成就”啊？这就是中国科学家不受重视的原因啊，因为只有谭这样的专家教授才能拿到比明星多的钱，至于手段嘛？呵呵。
―― 大家的评论都在骂那个拿毛选做对比的人，感觉完全歪楼了。","40多个答案中有几个是一线高校教师？我来回答吧。很简单，为什么要换教材？有利于我的职称，还有有利于我的升迁，或者课时费高点？别以为就你们知道什么K&R、现代方法、c reference manual这些书，很多老师也知道，也看过，那他们为什么不作为教材？因为除了很少数还有理想的年轻教师，真的是没这个动力。我用谭的教材，课件什么的都是现成的，连教案都可以用前辈们写好的，我干嘛还要自己再费事搞新的？评职称的时候没人会因为你用了什么世界级的先进教材给你多加一分！而且你们说的什么现代方法那本书，的确不错，一本书快100块钱，对不起，不能作为教材统一征订，教务处直接就给你否了。那本经典的K&R，讲真，其实并不适合初学者。
何况很多时候，其实根本就没按照书上的讲。
我只是告诉大家现实情况，想借机搞个批判什么的请绕道。","题目描述中有这么一句话
而大学教授们应该肯定写过很多代码
大错特错。
大多数教授的项目，代码都是由手下的研究生写的，他们自己才不写代码呢。有些人都很多年不写代码了，还能站在讲台上把几十年前他们学的东西讲给学生听。这在基础学科领域没问题，数学物理定律至少在几十年之间是没有很大变化的，但是计算机技术日新月异，几十年前的东西早就过时了。","我的c++老师写个hello world不知道cout在std里，我告诉他，你该加namespace，他说了句啊？然后继续装他的逼，就是不加namespace，给换成了c的
printf
，从那以后他的课我就没去过。电子科大的哦！用
谭书
奇怪？","这本书是有一些问题，但是并不影响非计算机专业的入门学习，相反地对于入门这本书还是有一些优点的，从书本的总体结构与内容的安排来说，谭浩强写书的时候还是用心思考了的，并且给出了他的认知水平下的优秀方案。
不过现实情况是很多人水平高一点之后，察觉到了里面的一些小问题，然后满世界大吹大擂，给旁人一种我很牛逼的错觉，无形中夸大了这本书的缺点，搞得好像用这本书学编程就很致命一样。
正在吃饭 吃完饭好好讲一讲这本书的优点。
－－－－－－－－－分割线，以下补充答案－－－－－－－－－－－－－－－－－－－
要评价这本书，首先要知道这本书的目的，它在前言中讲得很明白，就是给非计算机专业的人写的教材。非计算机专业的编程课，几乎也只有两门课，一门计算机基础知识，再加一本编程语言了课程了（大部分就是这本C语言编程了）。就这两门课，没别的了。编程语言一般只讲一个学期。
在这个条件的基础上，我觉得这本书最大的优点在于：
1.不厚，三百多页，但是C语言的基础知识都讲到了，一个学期能够讲完。谭浩强是懂教学的。《
》什么的动辄大几百页、千把页能够当一个学期那种课的教材么？
2. 在教材中第二章中就很明白地讲了算法与数据结构的重要性，指明了算法是程序的灵魂。在《数组》一章中的示例中讲了排序算法，在《结构与共用体》一章中讲述了链表的原理与实现。对于许多大学四年只学一门编程课的人来说，起码没在这个大方向上让你产生什么误解。数组、链表的简单数据结构，一些简单的查找与排序算法，对于一般的工科专业来说够用了，至于更重要的数值方法，有另外的一门课《计算方法》。学好了这些对于工科专业的许多人来说够用了。反而一些别的纯粹的C语言的教材在这个上面并没有着重强调。当然，对于计算机专业的人来说，他们开了算法与数据结构的课程，编程语言的书只讲编程语言不是什么大问题。
3.附录很有用，对于一般的非计算机专业的日常编制来说，当手册用很合适。谭浩强是知道你们学生是个什么水平的，也懂学生需要什么的。
缺点当然有：
1.语法标准落伍了。
2.代码中有一些错误，还有一些不规范的、不严谨的，不过他当时用的Turbo C编译器，可能在那上面能够编译通过。还有一些是印刷错误。不过这并不是严重的问题，错误的地方，自己编译下，根据报错信息什么的在网上一搜就明白了，或者问问老师就知道了。另外一些低级错误确实很致命。
3.没有强调正确的编码风格，没有强调注释的重要性。不过有些东西，谭其实也讲到了，比如在他的前言中就讲了：”
切记过早地滥用C语言的某些容易引起错误的细节（如不适当地使用＋＋和－－的副作用）
“。
在谭的书的基础上，改进他的缺点，保留他的优点，会有更好的适用于非计算机专业的编程教材的。
批评不是不可以，要批到点子上，也要承认别的人优点，批评之余也要提一些更好的解决方案吧。可是在谭浩强之外，还有人写一本适合中文的非计算机专业的教材么？我孤陋寡闻，没见过。这不是
的耻辱，是后辈的耻辱！","这些老师都是没有开过软件公司的人. 
所以, 不知道社会上需要什么样的软件. 需要什么样的编程人才. 
------
为了维护教学的连续性, 减少每年大量写讲义, 于是就沿用过去的传统, 直到腐朽. 
------
我1987年学习程序, 1990年看的谭老师的<C程序设计>, 同年看的书还有
严蔚敏
老师的<数据结构和算法>. 
到1997年上大学, 才注意到, <C程序设计>实际是参考1977年前后国外教材编写的, 而这个时候, 学C不如学C++, 学C++,还要学Linux C或者Visual C++马上问世. Windows98系统已经发布预览 版.. 
可是, 这本20年的老教材, 还在让学生们背 C++ -- 运算符优先级. 而不知道光C的编译器有几百种, 各种编译器对语法的细微差别是不同的. 
---- 
现在的C语言程序设计, 文件保存不讲Utf-8编码问题, 流不讲视频流, 加密不讲MD5和RSA, 模板类, Lamda表达式, 都不仔细讲, 这个难度, 好比18世纪的数学... 
与时俱进, PYPL上这个月Python登顶, 可是国内大一的编程有多少开了Python的课程? 
所以, 题主的问题没有为什么, 只是教育与产业脱节. 
反正有学费赚, 反正毕业给你一个学历, 所以, 教什么呢? -- 教最容易教的. ",浙江省二级试卷上出过只有TC才能编译运行的奇葩代码，问你输出结果是什么，只有谭氏C能解释。,"这个问题很简单，因为很多人学C语言并不是为了把程序写得很好，对于没有多高追求的人，学到这么多，能应付期末考试和并没有卵用的所谓2级就够了。
还有一个问题，就是编译器配置问题，我学C也是从谭浩强开始的，学完了当然觉得这里面坑太多，但说实话，后面我在学校学C++用的教材，还不如
谭浩强
呢！这也逼着我去找参考书才发现了新天地。但当时就我只会VC6的那个水平，你说我还能玩啥，我觉得挺适合我的。
当然后来开始用高版本VS，就觉得这是什么玩意儿，好多有用的都没说，然后开始查MSDN。
之后出于对C++11的喜爱，VS支持C++11太慢，开始转向gcc，开始就会code:blocks，后来开始会配MinGW，但是各种库依赖太难受，然后发现MSYS2这个神器，就这样。
那么对于一个用MSYS2+GCC，文本编译器用Sublime Text，写Makefile组织工程的人来说，那谭浩强真就是一坨屎，我当初走了多少冤枉路啊！
这还只是对坚持Windows平台的人而言的，至于转向Linux,Unix的就另说了。
但请记住，不是所有人都要达到你这个程度的，对于大多数人而言，谭浩强的程度就够了！
当然这话对只对我这种非计算机专业的人而言，对于计算机专业的人我还是希望能早点换个现代一点的教材。
当然谭浩强的某些问题，比如指针和数组关系有点胡这种问题，你也要考虑某些考试本身就比较胡吗，他就要考这种写了会被人骂死的代码，你书上不讲不是照样被骂？这不能怪作者。","说说自己的个人情况
我08年就读于陕西某211院校软件专业，当时我们学校C语言课用的是
裘宗燕
的《从问题到程序》。当时谭浩强的教材还被奉为是初学者的经典，有人批评，但还不像现在知乎上大神人人喊打。有同学问为何不像别的学校用谭浩强的做教材。老师强烈不鼓励、不推荐大家私下去买这本书。
开始时大家还老老实实地根据裘老的书学习。约摸记得裘老的书不像很多语法教材每章介绍几个语法点，而是会连带介绍他如何解决一些问题，颇具难度。
我记得当学习到第三还是第四章的时候，很多同学崩溃了。那章应该是讲函数和递归的，一般的教材（我后来看到的）基本上在讲递归的时候会很简单的用一个斐波拉契的实现作为递归函数的说明。但是裘老的书用了
汉诺塔
。。。这问题颇具深度，对于刚刚接触编程的新生，尤其是刚刚参加完填鸭式死记硬背的高考，并且上一章才刚刚学习了基本的结构控制语句的孩子们，确实是招架不过来。并且这章还大量提出了如
状态机
等等的编程模型，尼玛。。那会我刚刚装好IDE，语法要背一背，常用的函数要记一记翻一翻, 一个全角分号编译不过都要找一下午，你让我学这个也太难为我了吧？
于是就看到当时好多同学弃坑（包括我）去选择了
谭浩强
的书。对于一个还没完全从高考死记硬背的思维惯性走出的孩子来讲，老谭的书就如同一本新东方
红宝书
，他的语法总结和常用的函数总结做的特别好（印象特别深刻的是printf的参数表整整介绍了一页半）。而且神奇的是，老师出的好多题，甚至是我们同学翻阅的历届学校习题也来自于这本书的课后习题。就这样，越来越多的同学买了老谭的书。也许是基于多数院校延续的这种中式教育氛围，谭的书不仅没有被抨击，反而越卖越好。
老实说老谭的书确实存在各种各样的问题。书中用的编译器很老旧（好像还是TC很低的版本？），代码风格一塌糊涂（拧得像麻花），更别提中间存在了很多的谬误。但是他有着适合国情的一面。喷他的人（包括我）大多都是日后学会了写代码，反过来再去批评他的书。但是不可否认，在我们都还什么都不会，什么都不懂的时候，《
C程序设计
》，《21天学通XXX》这类的读物帮我们先进入了与计算机沟通这扇大门。 就如同大多数国内学生学英语，总不是说刚开始就会用英语写作文吧？还不是靠肝了各种各样无聊的单词书，语法书？
题外话，从业之后回翻了当年放弃的裘老的书，颇感裘老功底的深厚。书中提到的很多编程思想，编程模型，代码风格，解决问题的方式确实是在以往工作中实践过、帮助自己提升效率的好东西。深感可惜，如果学校当时把这本书当做是语法学成后的拔高教材，而不是基础课本，也许效果会好很多。","    
谭浩强
的c说句实话，虽然很多内容不太严谨，但是相比之下真的算稍微新手友好的了，应该属于不算有功 但也无过，可以试试的一类书籍。
    代码写的越久，看很多代码类的东西就就越随缘，比如看书这个，尤其是技术类学习类的书籍，你看的下去，觉得适合自己，我觉得就相当不错了，毕竟最大的问题不是书上有没有一些边边角角的错误，而这书你看多久能不打瞌睡。所以正确的阅读方式是，你先找本书看，不喜欢，换一本就是了，学习本身就是一个拿时间换知识的买卖，买卖不合适，换家做就是了，明码标价童叟无欺，买卖不成仁义在，只要你肯去做，总有一款适合你。
   科普和科学是两回事，平滑的学习曲线，应该是通俗易懂的科普进门，然后再用严谨的方式去证明科学，而一个好的科普，丝毫不比严谨的科学容易，现在根据前人的教材你再做一遍严谨的推导很多时候并不是什么困难的事，但如果你完全吃透了一个知识点，并且对它有了自己的理解用大多数人能够接受的方式将它科普出来，或者理论指导实践直接将它落地变为产品变为生产力 那我觉得是相当了不起的，这个知识点你是学到家了的，比只会抄严谨结论扯着大旗告诉别人这里那里不行，这个描述不太对，茴字不应该这么写的高到不知道哪里去了。
     又不是搞数学证明搞推导造火箭，搞的那么严肃做什么。"
,,,,,,,,,,,,,,,,,,,,,
有哪些顶级水平的中国程序员？,希望写上名字，代表作，特点，轶事。（注：程序员既可以是在中国的，也包括中国人在国外工作的）,"ACM世界冠军
陆靖
，现就职阿里云，为人十分低调，公司内号称“人肉逻辑机”，他做事不轻易动手，深思熟虑后开干，一气呵成，鲜有编译错误。遇到搞不定的代码找他时，他就看代码，不调试，一遍一遍看代码，然后指出某行代码有错误。我们都觉得他看代码的时候大脑其实就是多核CPU，在一次又一次的运行代码。某次代码遇到bug,良久无策和另外一个同事打电话问他，他在电话里说你们检查下某个
cpp文件
的780行左右，是否参数传递有问题，一查果不其然，问他是否在电脑边，他说不在，在肯德基吃饭，众人大惊之下去git blame,发现这代码他8个月前提交过。特别聪明的本身少见，特别聪明而且记忆力超强的更是凤毛麟角。
他有一个爱好是看日本动画片，为此自学日语，最后能和日本人正常沟通，参与字幕组做翻译。
好多人留言问他的情况，这里统一补充答复，他是我见过的最纯粹自由的人，对钱，对名誉毫无兴趣，对别人怎么看他也不在乎，只对挑战性的问题有浓厚的兴趣和异于常人的专注。","在鹅厂职级调整前，做到T5（科学家）的程序员，水平和履历都很能打。比如下面这位大佬：
吴石曾经是全球提交漏洞数量最多的个人。
他曾独自发掘超过100个
Safari
的CVE漏洞（“Common Vulnerabilities & Exposures”，公共漏洞和暴露）。
他曾创造过单月申报微软漏洞数量全球占比10%、独自发掘15个iOS漏洞的惊人成绩――这个数字比同期苹果自家研究人员发现漏洞（6个）的两倍还要多。
他曾发现只要给对方的QQ发送一条消息，就能够得到对方电脑的权限，进而控制对方的电脑，这对于受众巨大的QQ而言无疑是颗不定时炸弹，
从此推动
腾讯安全应急响应中心
（TSRC）的成立。
据说初二之前吴石的数学非常差。但后来遇到良师启蒙，他对数学的兴趣一发不可收拾。高二拿了全国数学竞赛一等奖，后来考入了复旦大学数学系。
上了名校的吴石也和在座各位一样打游戏，但不是
帝国时代
和红警2，而是叫做“MUD”。但人家玩着玩着就黑进了游戏的服务器，并且成功修改了自己的游戏数据，从此走上了走漏洞之路。
你玩王者只想着喷队友，别人玩游戏自己开挂，这就是差距啊同学们。
*MUD（Multiple User Domain），一款上古时代的多用户虚拟空间游戏
整个大三吴石几乎都在搞计算机，他去软件公司打工，以至于几乎没有上一节课，但就是这样人家也就挂了一科。
一次偶然的机会，吴石向微软提交了可以实现系统提权的高质量漏洞，出乎他意料的是微软居然提供了奖励――要知道在当时的环境下，国内很少有公司能做到这么体面的事情。
受宠若惊的大神一发不可收拾，没多久又提交了数十个漏洞，这甚至超过了微软自家安全团队，2007年他收到了来自微软的offer。
再到后来，漏洞大牛的简历愈发丰满：
在加入
KEEN Team
后，吴石和队友们用两种不同的姿势搞定了 Safari，拿到了数万美金的奖金。第二年全世界的黑客用类似方法掀起了挖掘 IE 漏洞的狂潮。 
2013年，腾讯抛出橄榄枝，吴石成为科恩实验室的首席科学家。2016年他带领科恩实验室团队和腾讯电脑管家组成的联合战队 Sniper 一举拿下了 
Edge
、Safari、Chrome，总分38分，以超越第二名13分之多的优势摘得了“世界破解大师”，比赛中所有的破解中都至少有一个吴石系统跑出来的漏洞。
当然现在更为人所知的，是他和他带领的科恩实验室团队对特斯拉的多次破解。
参考链接：
腾讯科恩实验室吴石，站在 0 和 1 之间的人
 
没想到这个问题这么多人关注，有兴趣了解鹅厂程序员的小伙伴，可以再看看这两篇：","1、
蔡景现
 （
多隆
）
2000年加入阿里巴巴，在阿里的花名叫“多隆”；（经网友提醒是花名，不是外号，对不起我不严谨）
2003年，被马云拉进了一个秘密项目，和另外两位工程师一起从零开始，要在一个月内，搭建一个名叫“淘宝”的网站，并涵盖所有交易系统和论坛系统；
2003年-2007年，独自维护淘宝搜索引擎，并且这还不是他全部的工作；
2014年，被邀约成为阿里巴巴合伙人。
阿里系统软件事业部研究员
毕玄
说，“牛P很多，但能被称为‘神’的只有多隆一个。他在解决故障方面的能力更是无人能及，在淘宝的故障解决历史上有N多的案例。”
阿里
中间件
研究员小邪随手举了两个例子，“五彩石项目多隆完成了商城搜索的
dump逻辑
，当时如果没有多隆，整个项目需要延后2周；还有一次，淘宝session框架调用
session_tair
故障，一堆人（应该有10人+）一起排查问题，从6:00排查到第二天的6:00，最后多隆查到了问题。”
同样是
阿里合伙人
、天猫技术部副总裁
范禹
，之前在淘宝有个习惯，碰到搞不定的技术问题，就去找多隆。
2、
章亦春
春哥的编程之旅起于抄书，就算如今已是罕见的编程高手，春哥依然逢人大力推荐他的抄书学编程之法
江苏镇江人，1999年，初中的章亦春第一次接触《
C 语言程序设计
》靠手抄自学编程，进入江苏大学后，一发不可收拾的迷恋上开源世界。
结束淘宝量子统计的工作后，全心从事 
OpenResty
 等开源项目的工作；
2017年，在美国创办了 OpenResty Inc. 公司。
有人说：“这是个不需要技术圈“网红”捧的务实大牛。一个牛逼的好人。是我见过的最Geek的工程师。”
3、
陆靖
（中间捧奖杯那个）
ACM
世界冠军，为人十分低调，公司内号称“人肉逻辑机”
不调试，一遍一遍看代码，就能指出某行代码有错误；
爱看日漫，为此自学日语，最后能参与字幕组做翻译。","尤雨溪
在美国留学时，曾经用两天时间，就复制出一款H5的Clear软件，在APP Store上线一天，就取得了付费版和总版第二的成绩。
2014年2月，尤雨溪开发了一个前端库，就是我们熟悉的
Vue.js
。Vue发布后，受到很多前端程序员的喜爱，很大程度上提高了前端程序员的开发效率。
后来尤雨溪希望自己能够将所有精力都放在Vue.js上，希望全职去开发和维护，在
patreon
上进行众筹，最终众筹的效果也是让他非常满意，每月能收到一万美元的赞助。
为了大力推广Vue，他经常出现在JS的各种交流会上，给广大开发者分享Vue的开发经历，使用Vue开发的方法和技巧。
在他的带领下，Vue.js正在茁壮成长，国内很多大小公司都在使用Vue，相信你也一定使用过这款前端的开源框架。
尤雨溪全职做Vue后，已经赚取人民币上千万了，真是非常厉害的程序员，值得我们大家学习。
这就让我们不得不深思，同样是程序员，人家怎么这么厉害呢？
蔡景现
蔡景现被称为阿里的扫地僧---“
多隆
”，是阿里巴巴初创时加入的三名工程师之一，也是阿里巴巴新增的三位合伙人之一。非科班出身的他，在一个月内从零开始搭建出了现在的淘宝，为了解决项目问题，常常在半夜爬起，去排除故障、去解决问题，独自维护淘宝搜索引擎5年，被称之为“
码神
”。
他精通C/C++/Java，从前端到后端，在从技术底层和高层业务之间来回切换，阿里的CTO对他做出过很高的评价，一个人能够顶得上一个团队。比如，写一个文件系统，别人做可能是一个项目组或一个公司，而他在很短时间内就能从0到1一个人做出来。
在所有工程师的眼中，他是一个神，甚至在公司内网的便签上，他也被称之为神。他很有钻研精神，很喜欢写代码，很傻很天真，写代码可以写到出神入化的状态。
我们应该像蔡景现一样，要有钻研精神，多写代码，多做项目，多学习；编程只是一个技术活，多做练习便能熟能生巧，将来也会成为一名出色的技术专家。
陈皓
陈皓被大众称之为“皓哥/耗子哥”，他在博客上写出了很多经典文章，推荐大家可以去看看，他的博客：
http://coolshell.cn
。
他从事软件已经17年多了，对底层技术架构早已了如指掌，曾就职于亚马逊、
汤森路透
等，目前正在进行创业。
阮一峰
阮一峰是一名经济学博士研究生，依靠对技术的执著和热情，不断学习钻研，成为了一名IT专家。他热爱技术、热爱写作、也热衷于开源。
他是经济学里写博客最好的，写博客将IT技术写得最通俗易懂的。前端的同学对他应该不陌生，估计很多学前端的同学都是跟着他的博客学习的，他的文章随处可见。
他翻译的著作有：
《黑客与画家：硅谷创业之你Paul Graham文集》
《
软件随想录：程序员部落酋长Joel谈软件
》
《异常流行幻象与群众疯狂&困惑之惑》等。
章亦春
大家都称他为“春哥”，他曾经就职于中国雅虎、淘宝、Cloudflare等。他的编程之旅开始于抄书，他很喜欢向大家推荐他的抄书学习编程之法，毕竟他可是从抄书到开源之巅的。
现在的春哥已经全身心投入到
OpenResty
中，希望OpenResty未来能在工业界、互联网等行业掀起大风大浪，引领机器编程革命。
如果有小伙伴想知道春哥是如何通过抄书学编程的，可以去
图灵社区
看看春哥的专访，里面记录了春哥的成长心路历程。
陆靖
他曾经是ACM的冠军，现就职于阿里巴巴，在公司内部被称为“人肉逻辑机”。他为人十分低调，做事情深思熟虑，做人十分低调，做事不轻易动手。
当有搞不定的代码时，他不是调试代码，而是逐行逐行的看代码，然后将某一行的代码错误指正出来。我估计他在看代码的时候，大脑就已经在运行每行代码了，大脑就是他的多核CPU。
之前网上流传着他的一个传奇故事：某次代码遇到Bug，他的同事无法搞定，打电话向他求助，他在电话中直接指出某个
CPP
下第780行的代码，这里估计有传参问题，他的同事一查，果然是这里出现了问题，问他是否在电脑旁，他说他正在外面吃饭，这让他的同事很是惊讶。
田春
他号称中国Lisp第一人，人称伞哥，他的思维远比技术值得关注。曾就职于网易云，在业内声誉很高，他的成绩我就不过多的介绍了。
有情趣的同学可以去看看伞哥的日记，地址：
https://
dirtysalt.github.io/htm
l/binghe-blogs-notes.html
他的性格古怪，他坐在丁磊办公室的旁边，经常跑到丁磊办公室，将丁磊正在充电的手机拔掉，给自己的手机充电。
因为性格的古怪，后来被丁磊给开除掉了。离职时在博客上写：CEO 丁磊先生跟我性格不合，难以共事，但因为我工作成绩突出，无法直接开除，而我又深深留恋这家公司，不肯主动辞职，于是不得已将我劝退，给予 N+1 补偿，并言辞恳切地请我走人。所谓 “好聚好散”，我不得不接受。
伞哥走的时候说，他不会怀恋网易的，只会怀恋战友，等他下次回网易的时候，就是收购网易的时候。
Gray Wang
根据 
FTX
 和 alameda 的股权价值，2022 年 4 月 ， 在福布斯新一期的富豪榜上， 年仅 28 岁的 
Gary
 以 59 亿美元的身价成为了 30 岁以下最富有的人。
作为最神秘的亿万富翁高管，Gary 平时性格神秘，很少公开露面，网上照片屈指可数，连公司同事都经常很长一段时间见不到他，甚至领英的照片也只有一个背影。
Gary 出生在中国，8岁后就随父母移民
美国新泽西
，他从小学习成绩出色，尤其在数学和编程方面展示出了很高的天赋和兴趣。
2010 年他参加高中数学竞赛，刚好结识了 SBF 和 Trabucco （FTX的另外一名高管），三人共同参加麻省理工学院（MIT）举办的数学夏令营培训，三人皆顺利进入麻省理工学院的数学专业，Trabucco 和 Gary 攻读数学和计算机学士学位， SBF 则攻读物理学学士学位。
SBF 和 Gary 在大学中逐渐建立信任，他们做了三年室友，学习之余，他们常一起打游戏，做谜题。在空闲时间里，还会共同参加 
Epsilon Theta
 的兄弟会。Gary 性格沉默内敛，很多人都觉得 Gary 难以沟通、不好相处，但 SBF 在多年的观察中，深谙 Gary 的性格和能力，尤其知道 Gary 在编程和数学方面的天赋性（Gary 曾获得过 MIT 编程竞赛的冠军）。
“很多人觉得 Gary 无法相处，就和 Gary 保持距离，但我不会，我认为 Gary不想刻意远离这个世界，他非常聪明，而且他可以腾出时间去思考一些很困难的问题。”SBF 这样回忆道。
他们多年的求学经历结下了深厚的同窗友谊，毕业后 SBF 去了华尔街的交易基金 Jane Street 做交易工作，Gary 去谷歌做机票价格的整合引擎 Google flights 的开发。
2017 年 11 月， SBF 在旧金山创立了量化交易公司 
Alameda
 research ，专注于加密货币市场的量化交易。 第一时间里，SBF 就想到在谷歌工作的 Gary，他立刻飞去波士顿，说服 Gary 加入 Alameda ：“你的天赋来做交易一定能行，加密货币市场充斥着无数的新机会，我们一起创造！” SBF 为 Gary 生动地描述着他的雄心壮志与抱负。
Gary 认为在谷歌的工作确实感受不到挑战，于是接受了 SBF 邀请来到旧金山。
他们经常并肩战斗，Gary 没日没夜的编写代码， SBF 经常睡在公司，两人每天只睡 4-5 个小时。
一开始，SBF 用自有资金运作 Alameda，买卖主流币和山寨币，但业绩不佳，甚至每天的损失高达 50 万美元。
但在 Gary 加入 Alameda 之后，团队在很长时间的摸索之后，确定交易策略为利用日本、美国和韩国之间的比特币差价套利。在最关键的一环中，Gary 为 Alameda 写了整个量化程序，用于快速在不同的交易市场中套利，这套程序只要捕捉到交易所之间的价差并迅速执行，就能完成一笔无风险套利操作。凭借着这个手段，SBF 更是从投资人那里拿到了 1.7 亿美元的融资，Alameda 一天的交易量一度超过数十亿美元，每天收入可以做到惊人的 2500 万美元。
然而这并不是一切的开始，早在 2018 年， SBF 就请求 Gary 写过一个比特币交易所的程序，Gary 一个月就完成了一个交易所 
CryptonBTC
。虽然后来没有做成产品，但 SBF 深知如果让 Gary 来写合约交易所程序，他一个月内也可以完成，并且比市场上任何的交易所写出来的质量都要好。Gary 是一个不折不扣的程序天才。
但当时合约交易所普遍存在的问题是，当客户的头寸经历损失，并且需要追加保证金，交易所会先请客户追加保证金，如果市场变化太快，交易所就会先承担资金的这部分损失。
在后来的合约交易所的代码中，Gary 发明了一个新的清算引擎机制，可以按秒为单位来监控客户头寸，当客户保证金不够的情况下，立刻执行清算，从而保护了交易所的资金。虽然这个功能让交易者感到厌烦，但是解决了长期困扰众多交易所的关键问题。Gary 为 FTX 加入清算机制后，Binance、Kraken 和其他交易所也跟进开发了这个功能。
此外，在一般的合约交易中，用户需要有对应资产的抵押进行借贷， 缺少资金的灵活性。针对这一点，Gary 为FTX开发了“交叉保证金”功能，让用户可以用多种数字资产共同为一笔交易做抵押。这一功能也在后来被其他合约交易所相继推出。
实际上，作为 SBF 成就大业的“二把手”，Gary 不仅仅只是一个优秀的程序员，他还是一个顶级的产品经理！Gary 甚至可以单独通过市场需求开发出领先竞争对手的产品。 
Nishad Singh
 是 FTX 的工程主管，但是更多做工程师的协调，最核心的产品经常是 Gary 一人独自开发。
与此同时，Gary 会负责 SBF 一些特殊程序的核心请求，并且只有 Gary 和 SBF 有权限使用和查看，FTX 的工程团队甚至都不知道 Gary 写的全部的程序。其中就包括 Alameda 可以从 FTX 转移资产的 “允许负余额”这一功能，这一程序让 Alameda 可以无限制地使用 FTX 客户的资金。
在 SBF 和 Gary 的领导下，FTX 做到全球交易量排名第二，市值高达 320 亿美元。 却在 2022 年 11 月，FTX 一个星期轰然倒塌，欠下超过 100 万名的债权人的超百亿美元的债务，堪称虚拟货币世界的
雷曼时刻
。
FTX 的核心团队全部住在一栋巴哈马的顶层公寓中， 事发时刻警察上门扣押了包括 Gary 以内所有 FTX 的核心人员。
他在 2022 年 12 月承认了包括电汇欺诈、商品欺诈和证券欺诈等所有罪行，即将面临 50 年的监禁。目前，Gary 正在寻求在法庭上合作作证以减轻判罚。
一代天才程序员 
Gary Wang
 也曾名噪一时，但这样锋利的一把嗜血宝刀却被用在了错误的地方，落得一个潦草收尾的结局。
贾扬清
Caffe框架的创始人，也是
TensorFlow
的作者之一，曾就职于Google Brain、Facebook等。","左耳朵耗子
， 目前在创业： MegaEase， 主要为企业提供技术解决方案以及高可用、高并发、高性能的分布式技术产品。
耗子叔有一个访问量千万的技术博客: coolshell, 上面的文章可以说是篇篇精华，我墙裂推荐大家去看看，CSDN 经常由于访问量过大被推上首页。
耗子叔尤其擅长底层技术架构，C/C++/Java和Unix/Linux/Windows。
对高性能，高可用，分布式，高并发，大规模数据处理系统有很深入的研究。
耗子叔
是一个
肯下笨功夫的人
，他在2001年被外包到银行做开发，
他在 2001 年那年被外包到了某银行做开发，就是用 C 语言在 AIX 系统里堆一些银行的交易逻辑，他坦言，这个过程并没有让他学到什么东西，也没有什么成长，每天想的就是要离开这个地方。
所以，他在晚上 10 点以后开始看书学习到 11 点半，并使用工作环境动手实践书上的代码，一年后，精读了《
TCP/IP 详解
》《Windows 核心编程》《Java 编程思想》等书。然后，找到一份外企业的工作，月薪一下翻了三倍！！！
看书一定是系统成长最快的方式，在这里顺便送大家一份我自己整理的电子书库，绝不是在网上那种打包下载的，而是自己需要学到某个方向知识的时候，需要看了，去网上挨个找的，最后汇总而成。
这部分我是会不断把它完善的，当成自己的小电子书库，不多，但贵在精。
我整理的这些书大家可以在这里下载，对于学习计算机的同学帮助非常大，且十分系统
：
https://
zhuanlan.zhihu.com/p/36
9766867
正是凭借着这股子对底层技术的持续不断的专研劲，才有了耗子叔现在的成就，并且影响了几十万做技术的人。
在谈及程序员加班、996 这个话题的时候，耗子叔说到了他在外企的经历：
在这家公司是我成长最快的时候，然而，并不是因为我的努力，而是因为有很多比我牛逼的人在 Code Review 上给我大量的帮助，在项目上帮助我，我的努力学习虽然也有作用，但更多的是高手对我的帮助。
再回想一下我以前在职场上的很多关键点，不是因为我加班了，而是因为在某些关键问题上，我跳出来解决了其它人都解决不了的问题
，我解决了一个网络通信莫名其妙的断掉的问题，我把性能优化了很多倍，我解决了一个不能重现的一个困扰团队 3 个星期的问题（其实就是大家没有认真读文档），我在入职一个公司的第一天里就为这个公司解决了一个历史遗留问题。
在 Platform，我每周解决了 bug 数是全公司的其它人的总和还要多（从不加班），在路透，我带团队优化的系统的性能是全球所有研发中心最高的，在亚马逊，两周打通美国和德国的订单和商品列表系统。我也有失败的时候，
而我失败的时候，总是因为我搞不定事，即便是加班拼命努力也无济于事！
是的，我的职业生涯的成长，最根本的不是你有多努力，有多勤奋，而是你能搞定很多人搞不定的事！
你不信你可以看看你们公司那些不用加班，就算什么也不干，公司也要花钱养的技术人员，他们的成功一定不是努力和加班加出来的，
你会发现这些人拼的不是谁干的多，而是谁解决的问题更有难度。
我加班 996 的时候，从来都不是我成长最快的时候，而我和一群牛人在解决难题的时才是我成长最快的时候。
加班996绝对不是成长的关键点，成长最快的时候往往是解决了一个个的技术难题！！！
耗子叔坦言自己绝
不是高手，也不是牛人，离他们的距离还很大。只是从2003年开始在网上记录一些自己的技术知识和想法，今天还在努力学习希望能成长一个高手，因为，面对生活在今天这样技术日新月异的时代，我们每个人都是一个新人。
他很幸运出生在这个时代――第三次工业革命的时代，也很幸运选对了专业，所以，可以算是一只“风口上的猪”了，就是运气好，赶上了这个好的时代，他要唯一要做的就是不要辜负这个时代，无它。
希望我们也不要辜负这个时代！！
程序员想要远离996，首先是提升算法和基本功，不然就只能重复性搬砖，在这里也送大家一本帮助我拿到BAT 等一线大厂 offer 的算法笔记，是一位阿里大神写的，对于算法薄弱或者需要提高的同学都十分受用，算法一定是计算机学习的重中之重：
在这里也转一篇耗子叔的专访：：我的精神家园（
图灵访谈
）
原文链接： 
https://www.
ituring.com.cn/article/
9174
作者：盼盼姐
来源：我的精神家园（图灵访谈）
二、轶事和思考
2.1、毅然辞掉银行工作
我当时在银行做银行网络、银行的电子邮件系统和办公自动化系统。当时正处在银行信息化的阶段，加上当时互联网和IT业刚刚火起来，得到这份工作其实是很幸运的。银行正值扩张电子信息化业务的时候，其实应该有很多事可做，但是当时的主要工作都是由厂商来干。比如说IBM或Cisco拿下单子来，会把工作外包给系统集成商。作为一位技术人员，其实可以发挥的空间并不大，多数时间我只是出了问题打电话的角色。没有人会教你任何事，出了问题，就是打电话，然后按照他们的指导来完成工作。但这个还不是促使我离职的最主要原因，我离开是因为互联网和IT业的兴起让我有些心向往之，有想去看一看的冲动。我还记得当时的辞职书是这么写的：“本人对现有工作毫无兴趣，申请辞职”。处长说，“你可以这么写，但是要加上‘经调解无效’，另外，分给你的房就不能要了”。我说好啊。就这样就辞去了工作，去了上海。老实说，这个决定真不好做，因为几乎所有的朋友和亲人都很反对。
2.2、选择上海闯荡的原因
当时选择上海是有原因的，我觉得在当时的环境（2000年）下，上海的发展比较不错。没有选择深圳的原因是个人感觉那是因为政治原因凭空冒出来的一座城市，我不是很喜欢。北京我有很多同学，而我想去一个陌生的地方。但是后来发现上海也不是做技术的地方，过得有些压抑，初来到上海的时候经常会被人瞧不起，毕竟是刚刚来到大城市。
我当时感觉银行束缚了我，想看看自己可以跑多远，能发挥出多大的价值。于是决定出来闯一闯，主要就是要去经历一些应该去经历的事情，不希望老了以后会后悔年轻的时候没有去。当时IT产业的发展是一个大趋势，我感觉我必须要去一座大城市，去经历一些东西。在小地方基本没有这些机会。要学会游泳就必须要跳到水里去呛两口水，所以我就义无反顾地出来了。
2.3、工作挫折和自省
我仍然记得自己拎着皮箱站在上海火车站的样子，举目无亲。原来在老家的时候觉得自己还挺厉害的，自以为不愁找不到好工作。不过事实却不是这样的。
我还记得第一次去面试时，（面试官）问了很多和C相关的问题，问了我半个小时，我一个问题都答不上来。我一直低着头，好像被审问的犯罪分子一样。我从大学毕业出来就没经历过什么面试，再加上自己内向的性格，所以，整个过程我都在低着头，不敢看别人一眼。最后，面试官问了我一个问题是“有不懂的问题你会怎么办”，这样的问题我都不敢回答，其实这道题的答案不过就是“问别人”或是“自己看书”或是“上网查资料”什么的。很显然，这场面试我肯定是被灭掉了。但这还没完，最后面试官对我说：“你出来干什么，像你这种性格根本不适合到大城市来”。
我当时被严重地打击了，感觉到自己确实有一些东西很差。第一个是性格差，不知道怎么与人交往；第二个是技术差，很多问题不知道；第三个就是视野狭窄，没见过世面。后面的几家公司的面试都大同小异。一个人在异地他乡，经历了这些事情，心里会非常地恐慌，“我这条路是不是走错了？”，我经常这样问自己。
面对这样的情况，我被逼迫着一定要改变自己。因为，离开银行时，我的家人、同学和朋友都很反对我出来，如果这样灰溜溜地回去，我面对不了他们。而前面的人还看不起我。我当时的处境真的很难堪，就像爬在悬崖中间，上不去也下不来。所以，当时只有一个想法，就是要证明自己不是那么差的人。人被逼到那个份上，活得就比较简单，哪有什么职业发展规划，只想拼命地多学技术，提高自己的能力。这个经历有点像是一剂兴奋剂，同时也相当阵痛。但是回头想想，第一个面试官应该是我最感谢的人。
2.4、疯狂成长
在同学的帮助下我找到了在上海的第一份工作。南天公司，这是一家给银行做系统集成软件的公司，大学毕业时本来也可以进去，现在绕了一圈而且还是靠同学帮助进去的，所以那时的心态还很不平稳；另一方面因为以前是做银行的，是甲方，现在成了乙方了，两边的人都用异样的眼光看我，心态非常不好。
不过，这是个技术不错的企业，国内早期很多搞Unix/C的高手都是从这个公司培养出来的。我当时的技术还是不行，比如说到了用户站点以后，不知道怎么做，我曾经误操作把用户的数据删掉了。经常犯低级错误，不但没做好自己的工作，反而还给别人添了麻烦。这些经历都让我有一种“技术焦虑感”，或者叫“技术忧郁症”。我觉得自己这也不行，那也不行。这也是我今天仍然在拼命学习的原因。这就好像我们经常在参加工作多年后还会梦见自己的英语四级没过，或者是期末考试没过一样。我经常会梦见的是项目又做砸了，又把用户的系统搞乱了，一大堆人要审我、要训斥我。
因为技术差，沟通差，不会面试，所以，我决定经常出去面试，基本上每周都要去，不管懂不懂，也不管是什么公司，也不管别人鄙不鄙视我，反正一有机会就去面试，多见见人这样可以让我的性格有所改善，同时，也可以知道社会上需要一些什么样的技能，把别人面我回答不上来的东西都记下来，然后回头找答案。那个时候我会经常去上海书城看书，看很多很多的书。我学的东西很杂，什么做网页，Windows，Unix，Java，.NET，flash，连3DMax/Photoshop我也学，还去考CCNA的认证等等。这样散乱地学习两年后，我才慢慢确定了要走C/C++/Unix/Windows系统底层的路子。而这样扑天盖地学习的结果有一个好处就是，我成长的速度相当之快。我自己摸索到了适合我的学习方法（从基础和原理上学习），从而不再害怕各种新的技术。那时，所有人都在休黄金周出去玩的时候，我还呆在办公室或住处看书学习。
等到一年半之后，用句赵本山的台词说，我在面试中学会抢答了。面试官的问题没问完，我就能说出答案了。其实，基本上是面一个公司过一个（当然都是一些小公司），此时，我就开始挑公司了。
感到技术能力不行就去学技术，交往能力不行我就去面试，这两个问题都可以通过大量地实践和努力来弥补，但是眼界这个东西没有办法通过努力来弥补。所以，当时非常想去一些更大的公司看看，如果能去外企更好。
2.5、变得不一样
我还记得，有一天，有一个和网络相关的技术问题，同事们搞了三四个通宵，也没弄明白，后来想起我好像在看这方面的书，他们就让我去看看、试试，结果我只用了20分钟就搞定了。基础真的很重要，这受益于我看了《
TCP/IP详解
》这套书。
后来，我去了一家做电信软件的公司，他们让我做PowerBuilder，尽管我当时想做的是C++，但是因为当时各种原因很需要这份工作，就去了。进了那里的第一天发现公司里有一个论坛，上面都是一些技术上悬而未决的问题，都是关于Windows/C++的。我一看，都是些很简单的问题，一下午的时间就被我全部解决掉了，我的基础知识发挥了作用。于是，当天下午我一下子就被调到了核心组。不过，我只在那里呆了两个多月，因为那时我已经不愁找工作了，这期间有两家北京的公司录用了我，于是，02年我就来到了北京，去到一家做分布式计算平台软件的公司。
在上海的这两年的时间，从什么都不是，到得到工作上的全面肯定。那段时间感觉自己牛得不得了，有些狂妄和骄傲了，经常上网和不认识的人争论一些很傻的问题，后来发展到对当时的领导以及银行客户的领导不敬，总觉得这些人太二。现在回头看过去，我觉得那是我人生特定时期的记号，人生的痕迹。
2.6、建立
http://
coolshell.cn
的原因
我2002年在CSDN开了一个blog，当时叫专家专栏。开个专栏很简单，只要发6个帖子。我也不是什么专家，只是喜欢看书、喜欢学习而已，也喜欢做一些学习笔记。那时候没有笔记本也没有台式机，市面上好像也没有U盘和移动硬盘。正好有CSDN这么一个地方，就去CSDN的站点上把自己的一些学习笔记放在了上面。后来03年的时候技术专栏转到了博客，因为CSDN对其博客经营得不好，我09年就离开了csdn，创建了
酷壳
。花了4500块钱，租了一个server。我离开那里主要有两个原因，一个是因为当时CSDN博客有一些性能上的问题，.NET架构嘛，大家都懂的。另外一个原因就是当时出现了很多博客营销的站点，有点像今天的
36氪
。好像那时候出现最早的叫煎蛋，那上面会有一些报纸上不会出现的国外的趣闻，是以博客的方式形成的媒体。这和常规的以日记形式出现的博客大不一样。煎蛋、有意思吧等这些博客让我看到了博客还能这样写，我觉得很好玩儿。而我当时也经常会去国外社区看一些文章，也能看到一些有意思的东西（因为我当时有了学习瓶颈，国内的网站已经满足不了我了）。心想，既然这些东西这么有意思，我为什么不自己开一个博客呢？
我老婆是学新闻编辑的，她鄙视我说，你的博客虽然有很多人读，但是只能算是个书呆子的博客，全是一些书呆子式的文章。我有些不服，我觉得技术人员不全是书呆子，我们这个圈子里也有很多有趣的东西，只不过是你不知道而已。于是我想弄一个有意思的、有娱乐性质的东西，里面都是技术圈里面有意思的事儿，但是很多技术圈以外的人也能看懂。一开始酷壳和CSDN博客的风格完全迥然，如果有技术性的文章我还会在CSDN上贴，但是后来我就完全抛弃了原来CSDN上的博客。酷壳的初衷是希望很多人都可以来上面发表一些东西，但是可能是我写得太多了，别人就被压制住了。
现在博客更新频率是一周一篇，一开始的时候一周三篇。磨刀不误砍柴工，总是有时间来做这些事的。我经常看书，需要把学到的东西整理成学习笔记。自从在CSDN上写博客的时候，就有这样的习惯了，而且又有“技术焦虑症”，害怕跟不上，所以维护博客的事对我来说是很自然的。
现在我已经不用自己再租服务器了，由于酷壳的访问量比较有保证，我提供了广告位，就免费得到服务器了。
2.7、对于新技术的态度
遇到新技术我会去了解，但不会把很大的精力放在这。这些技术尚不成熟，我只需要跟得住就可以了。我的团队自己想学什么我都不干涉，但是用到项目里的技术，必须是很成熟的，（技术应用）十年以上可能是一个门槛。有人说技术更新换代很快，我一点儿都不这样想。虽然有不成熟的技术不断地涌出，但是成熟的技术，比如Unix，40多年，C，40多年，C++，30多年，Java也有将近20年了……，所以，技术并不多啊。还有很多技术比如Ruby，Lisp这样的，它们没有进入主流的原因主要是缺少企业级的应用背景。
如果要捋一个脉络下来，70年代Unix的出现，是软件发展方面的一个里程碑，那个时期的C语言，也是语言方面的里程碑。当时所有的项目都在Unix/C上，全世界人都在用这两样东西写软件。Linux跟随的是Unix，Windows下的开发也是C。这时候出现的C++很自然就被大家接受了，企业级的系统很自然就会迁移到这上面，C++虽然接过了C的接力棒，但是它的问题是它没有一个企业方面的架构，否则也不会有今天的Java。C++和C非常接近，它只不过是C的一个扩展，长年没有一个企业架构的框架。而Java出现之后，IBM把企业架构这部分的需求接了过来，J2EE的出现让C/C++捉襟见肘了，后面还有了.NET，但可惜的是这只局限在Windows平台上。这些就是企业级软件方面语言层面这条线上的技术主干。
另外一条脉络就是互联网方面的（HTML/CSS/JS/LAMP…）。这条脉络和上述的那条C/C++/Java的我都没有放，作为一个有技术忧虑症的人，这两条软件开发的主线一定不能放弃。无论是应用还是学术，我都会看，知识不愁多。何必搞应用的和搞学术的分开阵营，互相看不起呢？都是知识，学就好了。
技术的发展要根植于历史，而不是未来。不要和我描述这个技术的未来会多么美好，用这个技术可以实现什么花哨的东西。很多常青的技术都是承前的。所以说“某某（技术）要火”这样的话是没有意义的，等它火了、应用多了咱们再说嘛。有些人说不学C/C++也是没有问题的，我对此的回应是：如果连主干都可以不学的话，还有什么其他的好学呢？极端一点，我要这么说：这些是计算机发展的根、脉络、祖师爷，这样的东西怎么可以不学呢？大部分学校虽然都会教授C，但是教得都不好。学校喜欢教微软的东西，老师好教学生好学。我不是说Windows不好，但那不是计算机文化的主干，那只是微软的主干、PC的主干。整个计算机文化的主干肯定是源起于Unix/C这条线上（注意，我说的是文化不是技术）。我也写过很多与Unix文化相关的文章，大家可以看看我写的“Unix传奇”。
2.8、对于学校计算机科学教育的看法
学校教的大部分都是知识密集型的技术，但是社会上的企业大部分都是劳动密集型的。什么是劳动密集型的企业呢？麦当劳炸薯条就是劳动密集型的工作，用不到学校教授的那些知识。如果有一天你不炸薯条了，而要去做更大更专业的东西，学校里的知识就会派上用场。有人说一个语言、一个技术，能解决问题能用就行了，我不这样认为。我觉得你应该至少要知道这些演变和进化的过程。而如果你要解决一些业务和技术难题，就需要抓住某种技术很深入地学习，当成艺术一样来学习。
我在“软件开发‘
三重门
’”里说过，第一重门是业务功能，在这重门里，的确是会编程就可以了；第二重门是业务性能，在这一重门里，技术的基础就很管用了，比如：操作系统的文件管理，进程调度，内存管理，网络的
七层模型
，TCP/UDP的协议，语言用法、编译和类库的实现，数据结构，算法等等就非常关键了；第三重门是业务智能，在这一重门里，你会发现很多东西都很学院派了，比如，搜索算法，推荐算法，预测，统计，机器学习，图像识别，分布式架构和算法等等，你需要读很多计算机学院派的论文。
总之，这主要看你职业生涯的背景了，如果你整天被当作劳动力来使用，你用到的技术就比较浅，比较实用，但是如果你做一些知识密集型的工作，你就需要用心来搞搞研究，就会发现你需要理论上的知识。比如说，我之前做过的跨国库存调配，需要知道最短路径的算法，而我现在在亚马逊做的库存预测系统，数据挖掘的那些东西都需要很强的数学建模、算法、数据挖掘的功底。
我觉得真正的高手都来自知识密集型的学院派。他们更强的是，可以把那些理论的基础知识应用到现在的业务上来。但很可惜，我们国内今天的教育并没有很好地把那些学院派的理论知识和现实的业务问题很好地结合起来。比如说一些哈希表或二叉树的数据结构，如果我们的学校在讲述这些知识的时候能够结合实际的业务问题，效果会非常不错，比如：设计一个IP地址和地理位置的查询系统，设计一个分布式的NoSQL的数据库，或是设计一个地理位置的检索应用等等。在学习操作系统的时候，如果老师可以带学生做一个手机或嵌入式操作系统，或是研究一下Unix System V或是Linux的源码的话，会更有意思。在学习网络知识的时候，能带学生重点学一下以太网和TCP/IP的特性，并调优，或是能做一个网络上的Pub/Sub消息系统或是做一个像Nginx一样的web server，那会更好。如果在学图形学的过程中能带领学生实践开发一个作图工具或是一个游戏引擎，那会更有意思。
总之，我们的教育和现实脱节太严重了，教的东西无论是在技术还是在实践上都严重落后和脱节，没有通过实际的业务或技术问题来教学生那些理论知识，这是一个失败。
2.9、如何在压力下，享受技术带来的快乐
中国人中庸的思想，入世和出世，每天的工作就是入世。举个例子，在上海的时候，给交通银行做项目的时候，每周休息一天，早九点到晚十点，每天工作12个小时，这样的工作持续了一整年，没有节假日，项目上的技术也没什么意思。当时我晚上十点回到住处，还想学一些C++/Java和Unix/Windows的技术，于是就看书到晚上11:30，每天如此，一年下来学到很多东西，时间没有荒废，心里就很开心。我觉得当时是快乐的，因为有成长的感觉是快乐的。
现在的我，工作、写博客、养孩子，事情其实更多。我早上7:30起床，会浏览一下国外的新闻，hacker news，tech church，reddit，highavailability之类的站点，9点上班。晚上6、7点钟下班，开始带孩子。十点钟孩子睡了觉，我会开始重新细读一下这一天都发生了些什么事情。这个时间也有可能会用来看书。学习的过程我是不喜欢被打断的，所以从十点到十二点，家人都睡了，这正是我连续学习的好时间。可能从晚上11:30开始，我会做点笔记或者写博客。我现在对酷壳文章的质量要求比较高一些，所以大概积累一个星期的时间才可以生成一篇文章。每天我大概都在一两点钟才会睡觉。没办法，我有技术焦虑症。但是觉得这样的生活很充实，也很踏实。
另外，任何一门技术玩深了，都是很有意思的。有些人形成了一个价值取向，“我只做什么，绝不做什么”。前段时间有一个刚来亚马逊的工程师，他原来做的是数据挖掘推荐系统，后来公司重组要他做前端，他不肯。我觉得，前端后端都是编程，Javascript是编程，C++也是编程。编程不在于你用什么语言去coding，而是你组织程序、设计软件的能力，只要你上升到脑力劳动上来，用什么都一样，技术无贵贱就是这个意思。
回到问题，怎么才能享受到快乐呢？第一，入世和出世要分开，不要让世俗的东西打扰到你的内心世界，你的情绪不应该为别人所控，也不应该被世俗所污染，活得真实，你才会快乐。第二点就是要有热情，有了热情，你的心情就会很好，加班都可以是快乐的，想一想我们整个通宵用来打游戏的时光，虽然很累，但是你也很开心，这都是因为有了热情的缘故。
2.10、做自己是最难的
我承认我活在我的精神家园里面。我推荐大家看一下王小波的《我的精神家园》，这篇文章对我的影响非常大。看了这篇文章，你就会明白我为什么要躺在自己的池子里，如果不想被这个社会所污染，就必须要躺在自己的池子里。做大众是很容易的，做自己是最难的。当你老了的时候，回想过去，如果你是为自己而活的，你总会觉得很踏实。可能有人会觉得我偏激，没关系，为什么要所有人看法都一致呢？世界因为不同而美丽，多元化的价值观并不冲突。
最后送大家一份自己整理的电子书库，绝不是在网上那种打包下载的，而是自己需要学到某个方向知识的时候，需要看了，去网上挨个找的，最后汇总而成。
汇集了编程语言(Java、C++、C、Python等等)、操作系统、计算机网络、系统架构、设计模式、程序员数学、测试、中间件 、前端开发、后台开发、网络编程、Linux使用及内核、数据库、Redis....等主流的编程学习书籍。
这部分我是会不断把它完善的，当成自己的小电子书库，不多，但贵在精。
我整理的这些书大家可以在这里获取，对于学习计算机的同学帮助非常大，且十分系统
：
书单：
希望大家都能在编码的路上下笨功夫！！！远离996！，记得帮我
 
@编程指北
 
点个赞哟~
最后给大家分享一下计算机学习路线大全，很多同学照着这个路线学习进了拿到大厂offer
计算机系统学习网站
?
csguide.cn/
如何自学篇
 
计算机专业如何系统自学？
如何高效阅读计算机类书籍？
如何快速学习掌握一门编程语言？
计算机基础篇
 
操作系统超详细系统学习路线
操作系统系统书籍分类推荐
计算机网络超详细系统学习路线
如何系统学习网络编程
C++方向学习路线
 
C++ 语言超详细系统学习路线
Linux C++ 后台开发系统学习路线
Java方法学习路线
 
Java 后台超详细系统学习路线
C语言方向学习路线
 
C 语言超详细系统学习路线
后台中间件(MySQL、Redis、MQ等)
 
Redis 超详细系统学习路线
Python方向学习路线
 
Python超详细一条龙版学习路线
Python Web 开发系统学习路线","说一个大家可能不太听过的――梁肇新。
这是百度百科上的照片，无论从发量还是气质上看都像是一个乡镇企业家，而不是一个程序员，但是这并不影响他作为中国顶级程序员的地位。
在2000年至2005年的电脑城，新配的电脑不一定会装office，但是一定会装
豪杰超级解霸
，而它的作者就是梁肇新。超级解霸不管多烂多花的碟，它都能够读出内容，开玩笑说丢一块石头进去它都能播出来电影，玩笑归玩笑，软件强悍的性能可见一斑。那个时代的网络营销还不发达，产品都是靠用户口口相传积累用户，一个共享软件做成装机必备可见超级解霸的成功。可惜，超级解霸没有赶上互联网的浪潮，最终被各种影音软件拍在了沙滩上。
吃到美味的鸡蛋不会去问哪只鸡下的，普通用户也不会去关心超级解霸的作者是谁，真正让大家开始知道他的还是那本铜版纸的《
编程高手箴言
》。那本书类比练武提到程序员的六个阶段：熟练某种语言（套路）、精通平台接口（对练）、了解底层（手中有剑，心中无剑）、深入底层（手中有剑，心中有剑）、全局设计系统（手中无剑，心中有剑）、任何问题都变成思路问题（无招胜有招）。这六个阶段应该是他的书里面传播最广泛的内容，其他的比较高深，不好传播。书的内容差不多总结了那一代不依赖互联网的程序员深研的历程，现在还值得我们去学习追随。","不知道这些算不算呢？
《商业领域有着巨大影响力的程序员》
能做出好产品
又能引领企业走向巅峰的人，很厉害
01.WPS之父-求伯君
求伯君，浙江绍兴人。
1988年，一个人，一年时间，写出了和微软抗争了十多年的国产办公软件“WPS1.0”。
年仅25岁，他就成为了程序员出身最富有的创业者，他的名字早已写进中国软件的历史！是那个时代最让程序员们振奋的“英雄”，无可争议的成为“中国第一程序员”！
个人历程：
1964年，出生于浙江绍兴一个贫苦农民家庭；
1984年，国防科大信息系统专业，分配到河北某仪器厂；
1986年，仪器厂辞职，加入北京四通公司；
1988年，加入香港金山公司；
1994年，在珠海创立珠海金山电脑公司；
2011年，从金山退休，副董事长雷军接任。
个人成就：
WPS之父：以一己之力写出WPS1.0，填补了我国中文字处理软件的空白；
创立了中国第一个电脑游戏《中关村启示录》；
金山之主：带领金山上市，成为当时最富有的程序员；
IT导师：金山中，走出了雷军、
王峰
、冯鑫、尚进等，被称之为“旧金山”的IT创业者……
民族软件导师：中央电视台《东方时空》在比尔・盖茨来中国的当天，请求伯君谈民族软件以及WPS97如何抗击Word。
评价：
雷军：写求伯君的文章虽然很多，但令人满意的还没有。
网友：走进当年的IT圈，到处都是求伯君2.0版。
02.小米-雷军
雷军，湖北仙桃人。
写过加密软件、杀毒软件、财务软件、CAD软件、中文系统，焊过电路板，干过黑客，大学四年课程两年修完，就靠开发软件成了百万富翁，业界公认的劳模。
做发布小米1.0需要拍视频，陈年、
李学凌
在内的一帮兄弟都为他出镜，砸掉苹果用小米。
个人历程：
1969年，出生于湖北仙桃；
1991年，毕业于武汉大学计算机系；
1992年，进入金山软件做程序员；
2010年，创办小米科技；
2011年，后接任求伯君任金山CEO。
个人成就：与同事合著《深入DOS编程》、《深入Windows编程》等书；
个人信仰：20年前我是一名软件工程师，到今天依然是！
外界评价：
求伯君
：其实雷军是大家口中程序员的一个最佳典范，永远的精力充沛，时刻都想着去 build，并且能够及时的修复过程中的 bug，有着这么严谨的程序员思维，这也是他现在这么成功的原因。
猎豹CEO傅盛：雷军无论多成功，永远一副低姿态。第一次见他，他手里拿个小本，问我当时做360安全软件的成功经验，我说什么，他就用笔都记下来。
03.百度-李彦宏
李彦宏，山西阳泉人。
学霸级的人物，持有“超链分析”技术专利，甚至奠定了现代搜索引擎的发展方向。
年少钟爱戏曲，一度被剧团相中，但在中学时还是回归课堂，以阳泉市第一名考上北大！
个人历程：
1968年，出生于山西阳泉，他在家中是五个孩子中的唯一男孩，少年时钟爱戏曲，曾被剧团录取；
1991年，毕业于北大信息管理系，随后赴美完成计算机硕士学位；
1994年，进入华尔街道・琼斯公司，担任金融信息系统设计工作；
1997年，进入硅谷著名搜索引擎公司Infoseek(搜信)公司；
2001年，回国创立百度；
2011年，成为大陆地区的首富。
个人成就：
曾经为道.琼斯公司设计的实时金融系统，仍被广泛地应用于华尔街各大公司的网站；
最先创建了ESP技术，并将它成功地应用于Infoseek/
http://
GO.COM
的搜索引擎中；
拥有“
超链分析
”技术专利，是奠定整个现代搜索引擎发展趋势和方向的基础发明之一。
（李彦宏称之为搜索引擎第二定律，利用检索关键词在一篇文章中出现的频率多少进行网页排序的技术，被称为第一定律）
个人信仰：
技术本身并不是唯一的决定性因素，商战策略才是真正决胜千里的因素。
外界评价：
合伙人徐勇意：李彦宏不仅有技术背景，还对商战有敏锐的直觉和出色的判断。
网友：做为一个技术人，他曾经非常优秀；做为一个商人，他有很高的“觉悟”。
做出最好产品的人
很厉害
04.微信-
张小龙
一个孤独的人，生命中只有音乐、网球和代码。每当有争论，都是张小龙以长时间的沉默来结束。
个人历程：
1969年，出生于湖南省邵阳市；
1994年，华中科大电信系硕士毕业，随后在广州一家互联网公司工作，业余时间开发出Foxmail；
2000年，张小龙以1200万元的价格把Foxmail卖给博大公司，并任公司副总裁；
2005年，腾讯收购Foxmail软件，张小龙“陪嫁”到腾讯公司。
个人成就：
利用业余时间，独立开发出Foxmail，以1200万元被博大收购；
为对抗雷军“米聊”，带领13人仅用一个月上线微信，不到两年爆发2亿用户。如今微信估值8000亿，是支付宝的两倍。
个人信仰：
我说的是错的！
外界评价：
柳传志：做微信的那个小孩张小龙，确实做得漂亮，我没见过，据说也是比较宅的人。
好友和菜头：张小龙是一个生性孤独的人，烟瘾很大，“是广州深夜里最大的Kent消费者”。
05.腾讯-马化腾
不管他愿不愿意，几乎所有互联网公司，都曾向他宣战！
做过5年程序员，但真正赚到人生第一桶金却是从炒股开始，最精彩的一单是将10万元炒到70万元。
个人历程：
1971年，出生于广东汕头一个小村子；
1993年，毕业于深圳大学，主修计算机及应用；随后进入深圳润迅通讯公司，专注寻呼机软件开发；
1998年，与
张志东
一起创立腾讯；
2004年，腾讯在香港交易所主板挂牌上市；
2018年，47岁的马化腾成为全球华人首富。
个人成就：
与朋友合作开发风靡一时的股霸卡；
开发中文版的ICQ，即后来的QQ。
个人信仰：
用最笨的方式去领悟编程，用抄代码来培养感觉。
外界评价：
马云：“QQ的攻击永远是悄悄的！”
王石：马化腾能把握好底线，一个工程师控，凌晨两点发微信他还能马上就回。
敢于折腾的技术人
很厉害
06.巨人-史玉柱
史玉柱
，安徽蚌埠人。
人们熟悉史玉柱，有些是因为脑白金，有些是因为巨人网络。他不仅是个成功的营销家，而且曾经是名出色的程序员。
开发汉卡赚到了人生第一桶金，又因巨人大厦转瞬欠了几个亿。人生大起大落后，还清所有债务，重新回到IT行业，现在已是网络游戏界里的老大之一。
个人历程：
1962年，出生于安徽蚌埠；
1984年，浙江大学数学系毕业，分配至安徽省统计局工作；
1989年，深圳大学数学系研究生毕业后，下海创业；
1991年，成立巨人公司，推出M－6403；
1994年，投资保健品，第一个产品是""脑黄金""，后为投资巨人大厦，几乎破产，欠债2.5亿RMB；
2000年，再度创业，开展“脑白金”业务；
2007年，旗下的巨人网络于纽交所上市，成为在美发行规模最大的中国民营企业；
2016年1月，带领全公司展开手游研发。
个人成就：
M-6401桌面排版印刷系统；
创业之初，一己之力编写文字处理软件，关键模块用汇编语言完成，软件代码数达到50万行。
外界评价：
网友：“负债过亿，东山再起的故事，注定也是中国商人史上最为“成功”的失败样板。”
新浪网：”绝对是当今中国商界最具争议和最具传奇色彩的人物。
坚定理想主义的人
很厉害
07.搜狗-王小川
王小川
，四川成都人。
一个成功地由顶尖技术人才转型为全面的管理者，带领搜狗，快速成长为中国用户量第三的互联网公司。
个人历程：
1978年，出生于四川成都；
2003年，清华大学计算机研究生毕业；
1999年，兼职加入初创的ChinaRen公司（中国最大的校友录网站）
2000年，搜狐收购ChinaRen，王小川进入搜狐公司；
2003年，正式加入搜狐，任高级技术经理；
2005年，晋升为搜狐公司副总裁；
2010年，搜狗CEO。
个人成就：
使用分词技术，使 ChinaRen 成为当时第一家能通过“机器自动生成相关新闻内容”的网站。
个人信仰：
像老板一样思考，像员工一样工作
外界评价：
张朝阳
：小川在少年时期就是计算机的天才。
网友：也只有王小川这种具有「钝感力」的创业者才能够坚持下来，花好几年，一级一级组建自己的产品架构。
08.今日头条-张一鸣
张一鸣，福建龙岩人。
从着装到谈吐都特别“不文艺范儿”，用他的口头禅来说：“实用，是第一重要的。”
想挖人时，会拿出计算器，告诉对方如果加入今日头条收入增多少，有多少股份“如果你跟了XX，看上去是不错，但你的股价会翻十倍吗？”
个人历程：
1983年，出生于福建龙岩；
2005年，毕业于南开大学软件工程专业；
2006年，进入
酷讯
，一年后带着团队进入微软，没多久又到了饭否；
2012年，今日头条上线，上线仅90天，积累用户1000万；
2012年，创办字节跳动；  
2016年，推出抖音；
2018年，卸任今日头条CEO。
个人成就：
创造性地将机器算法和大数据技术应用于媒体传播
2018年，字节跳动估值750亿美元，成为全世界估值最高的创业公司， 国内仅次于阿里巴巴和腾讯的互联网第三强。
个人信仰：
对于编程，更注重的是实用性，数学才是对事物之间最基础关系的描绘。
外界评价：
网友：“你似乎很难从他的身上，找到其他创业者对金钱的那种渴求，他更像是一个自由纯粹的冒险家。”
09.网易-丁磊
丁磊，浙江宁波人。
一个坐飞机头等舱，不穿机舱的拖鞋而是自带；江湖里出了名的酒量惊人，环保乐观，跑着步上班，既朴实无华又富于传奇。
个人历程：
1971年，出生于浙江宁波一个高级知识分子家庭；
1993年，毕业于电子科技大学，毕业后回老家电信局做公务员；
1995年，跳槽在skybase做软件开发；
1997年，创办网易；
2000年，网易在纳斯达克上市；
2003年，丁磊成为中国首富；
2015年，投资拍摄电影《少年班》
个人成就：
设计网易的整体架构；
和
陈磊华
一起研发免费邮箱系统，成为国内最早提供邮箱服务的公司
个人信念：
勇于“归零”
外界评价：
网友：“丁磊是一个有着浓重复旦情结的人，注定又是一个理想主义者。”
不为外界所动的人
很厉害
10.奇虎360-周鸿t
周鸿t，湖北黄冈人。
曾对着一张印有键盘的纸张，敲敲打打，因为没见过真正的计算机。
他叛逆、口不择言，不忌惮与人剑拔弩张，被封为“流氓软件”之父。
他曾说：“我觉得除了百度和腾讯，以及他们的打手，都是我们的朋友。”
个人历程：
1970年，出生于湖北；
1995年，西交大管理学院硕士毕业；
1995年，就职方正，从普通程序员一路提任至总经理；
1998年，创建3721公司，6年后被雅虎以1.2亿美金收购；
2004年，任雅虎中国总裁；
2006年，创建360公司；
2016年，带领360从纽交所退市，完成私有化；
个人成就：
推出了3721“网络实名”，开创中文上网服务之先河；
创办360，成为免费安全之父。
著书：
《智能主义：未来商业与社会的新生态》
《周鸿t自述:
我的互联网方法论
》
《颠覆者：周鸿t自传》
个人宣言：
要成为一个合格的程序员，怎么也要写个10万到15万行以上的代码。如果连这个量级的代码都没有达到，那说明你还不会写程序。
外界评价：
网友：“也许周鸿t是中国互联网界最像乔布斯的人。一方面有着特立独行的叛逆思维，另一方面也有对产品的极致完美追求，还有他不满意时就口不择言的直率。”
11.点击科技-
王志东
不了解王志东的人觉得他放弃了软件，而后又被网络所抛弃。
但了解王志东的都知道他最钟爱的还是软件，而且现在他同时拥有了网络。
个人经历：
1967年，出生于广东东莞；
1988年，毕业于北大无线电电子学系；
1989年，特邀进入北大计算机技术研究所；
1993年，任四通利方总经理；
1998年，创建新浪网；
2000年，新浪纳斯达克上市；
2001年，王志东被迫离开新浪网，同年创立点击科技。
个人成就：
用时7个月，研发出“中文多窗口图形支撑环境”；
用时一年，独立完成国内第一个实用化Windows3.0中文环境――BDWin3.0，一度引起各界震惊。
外界评价：
网友：“现在的新浪和王志东显然是没什么联系了，但是唯一可以确定的是他最爱的还是开发、是软件。”
张朝阳：“他不够敏感，对于到眼前的危险、对腹背受敌的处境不够敏感。”
12.创新工场-李开复
从唯一历任苹果、微软、谷歌、高管的华人职业经理人、IT界黄埔军校的校长、大学生导师、创业者之父、抗癌战士到人工智能布道者，李开复的身份一直在变化。
但始终未变的，是他在语音识别、人工智能、三维图形及网络多媒体等领域，享有的声誉。
个人经历：
1961年，出生于台湾，现移居北京；
1972年，赴美国读中学；
1983年，哥伦比亚大学计算机科学系毕业；
1988年，获得卡内基梅隆大学计算机系博士；
1990年，任苹果公司全球副总裁；
1998年，加入微软公司，创立微软亚洲研究院；
2005年，加入Google，任全球副总裁兼中国区总裁；
2009年，创办创新工场，曾被《麻省理工学院技术评论》评为“最火的计算机实验室”；
2013年，患淋巴癌。
个人成就：
运用统计学原理开发出世界上第一个“非特定人连续语音识别系统”，把语音识别率从40%提升到96%，当年被《商业周刊》授予“最重要科学创新奖”；
著作：
《做最好的自己》
《微博：改变一切》
《与未来同行：李开复文集》
《一网情深与学生的网上对话》
《世界因你不同：李开复自传》
《向死而生：我修的死亡学分》 
外界评价：
创新工场创始人之一
王肇辉
：“李开复既能够在四合院和人喝茶吃花生米,也能在五星级酒店和外交官喝鸡尾酒。”
《技术领域有着巨大影响力的程序员》
在技术领域
有的人，凭一己之力
开发出了几千人使用的开源软件
有的创造了网络的神话，至今为传诵
有的授业解惑，或教室、或出书、或博客
他们影响了一批又一批的后来者
他们的名字经常被提起 
这是一群对技术有着最纯真热爱的人
非科班出身的大牛：
01、阿里-
蔡景现
蔡景现，一个更广为人知的名字是--“
多隆
”。
他是阿里巴巴初创团队三名工程师之一，
在一个月之内，从零起步搭建起了“淘宝”。
非科班出身的他被称“码神”，又称“阿里扫地僧“。
个人历程：
1976年，出生于浙江苍南一个农民家庭；
2000年，从杭州大学生物系硕士毕业，加入阿里；
2014年，成为阿里合伙人；
2017年，41的他以26亿身家登上胡润财富榜。
技术成就：
对于技术，既懂C/C++，又懂Java内核；
既可以深入技术底层，又能切入到高层业务领域，
从前端到后端，独自维护淘宝搜索引擎长达5年。
个人魅力：
突然得知成为阿里合伙人时，蔡景现当场蹦出一句“让我当合伙人？可我只会写代码啊！”只会写代码的纯粹，让他全票通过合伙人票选！
评价：
阿里CTO张建锋：“多隆（蔡景现）做事一个人能顶一个团队。
02、MegaEase-陈皓
江湖人称""浩哥/耗子哥""，对新手总是热心的帮助，一位百科全书类的前辈。
个人历程：
大学毕业进入云南工行，不满体制内的缓慢困滞，两年以后去了上海。
由于技术不够，面试时遭遇羞辱，于是疯狂学习，专注底层，C++，JAVA，UNIX/LINUX 等，后成为大牛！
个人成就：
曾于Amazon中国任研发经理；
曾在阿里巴巴北京研发中心任资深专家一职；
曾在阿里巴巴核心系统专家组，从事阿里云ECS相关的虚拟化平台的开发工作；
现为MegaEase创始人，为企业的高并发高可用架构，提供一整套的技术解决方案和产品。
个人魅力：
“我不是高手，我也不是牛人，我只是在跟随着我的兴趣和喜好去学习一些技术。”
网友评价：
“他是一个对技术和生活都有非常深地思考的人，很多观点都能让人醍醐灌顶。”
03、阿里-
阮一峰
上海财经大学世界经济博士研究生，自学网站制作，依靠自己对技术的热情，不断学习钻研，成为一名IT业内专家，也是中文互联网上的知名blogger。
不仅热爱技术还热爱写作，同时还热衷于开源。
学经济学的人里写博客最好的，写博客的人里写IT技术最透彻易懂的！
个人历程：
2008年取得上海财经大学经济学博士；
毕业后当了老师，任教于上海金融学院；
2014入职阿里巴巴。
个人成就：
译著：
《黑客与画家：硅谷创业之你Paul Graham文集》
《软件随想录：程序员部落酋长Joel谈软件》
《异常流行幻象与群众疯狂&困惑之惑》等
博文在网上的权重很大，IT系列教程影响了极大一批初入编程的小白！
评价：
“他像是一个我从未谋面的引路人，过褒或过贬，都是不客观的！”
""喜欢阮一峰并不是因为他有多厉害，而是因为他不停的学习，乐于跟我们分享。他写的博客总是通俗易懂，对于我们这些小白来说是很珍贵的财富""
学术界大牛
04、清华-姚期智
姚期智
，世界著名计算机学家，应该说是一位非常重量级的“程序员”。他是唯一 一位获图灵奖的华人。
在伪随机数生成、密码学和通信复杂度多个领域，都做出了巨大的贡献。
与第一位获得诺贝尔奖的华人一样，姚期智在此之前是美籍华人，2017年才恢复了中国国籍。
个人历程：
1946年出生于上海，幼年跟随父母到台湾，以麻省物理学博士身份转攻计算机。
2000年，获得计算机界最高荣誉“图灵奖”；
2004年，归国任教于清华大学，创建姚班、智班。如今71岁高龄的姚期智，致力将半生心血付于年青的学生们身上。
技术成就：
创建了理论计算机科学的重要次领域：通讯复杂性和伪随机数生成计算理论；
奠定了现代密码学基础，在基于复杂性的密码学和安全形式化方法方面有根本性贡献；
解决了线路复杂性、计算几何、数据结构及量子计算等领域的开放性问题并建立全新典范。
评价：
“姚先生是这个时代的科学诗人，他身体力行教会我如何欣赏科学的美，如何创造美好的科学，如何许诺用科学，带领人类走进一个更美好的时代。”
05、Vue.js-
尤雨溪
江湖流传一个小故事：
一款名叫Clear的软件，在正式推出的第一天，就登场了Apple Store付费榜和总榜第二。
而身在美国的中国留学生尤雨溪，仅仅花了两天的时间，就copy出了一个html5版的Clear，并且放出了源代码。
个人历程：
出生于江苏无锡，在上海读完高中后，2005年到美国主修艺术史，硕士主修美术设计与技术，开始慢慢接触编程。
毕业后曾就职于 Google Creative Labs 和 Meteor Development Group。
由于工作中大量接触开源的 JavaScript 项目，最后自己也走上了开源之路，现在全职开发和维护 Vue.js。
技术成就：
一己之力打造Vue.js框架；
构建了Web界面的Javascript库。
网友评价：
“尤雨溪做出了近几年最火的前端框架Vue.js，是开源世界华人的骄傲。”
创业者中的技术牛人
06、第四范式-戴文渊
信息学世界冠军，让“人工智能”不再冷门的时代领袖 ，他的身上光环无数。
曾经获得上海交通大学校长奖、
吴文俊
人工智能科学技术创新奖一等奖、《财富》中国 40 位 40 岁以下商业精英、MIT 35 位 35 岁以下科技创新杰出精英。
个人历程：
江苏苏州人，1983年出生，1991年，在苏州古城区读小学二年级的戴文渊，考了三次数学全班第一后，加入计算机兴趣小组。
10岁开始写logo语言，学习C语言。
在上海交通大学就读期间，带领三人团队夺得了ACM世界冠军和三个亚洲冠军，并担任ACM竞赛教练指导学生多次获得亚洲冠军。
交大没有人工智能领域的老师，
戴文渊
被送到了港科大，师从
杨强
教授
个人成就：
2007年发表的论文Boosting for Transfer Learning在迁移学习领域论文引用数至今排名世界第三；
全世界首个提出“非监督迁移学习”概念的人；
开创了“非监督迁移学习”这一重要研究方向；
此外，他也首次提出了“翻译学习”（即“跨领域迁移学习”）和“迁移学习通用框架”等...
2014 年，戴文渊和他的老师杨强成立“第四范式”，帮助企业提升效率、降低风险，获得更大的商业价值。
评价：
港科大学杨强教授：“戴文渊是全世界最优秀的青年学者之一，是产业界、特别是中国产业界 AI 落地的杰出代表，对人工智能领域的发展帮助极大。”
07、教主-
楼天成
姚期智得意门生，公认大学生计算机编程第一人。
有这么一个笑话，在编程界输入“教主”，会立即输出 “楼天城”。
在程序猿界，其他人可以称得上牛X，但被冠以传奇之名的只有一个 ――「
楼教主
」
个人历程：
1986年出生于杭州，因为数学太差，所以选择计算机编程，高中后开始屡屡获奖，2004年保送清华大学计算机系。
个人成就：
2006年，TopCoder（世界顶尖程序员）排行榜全球第三，中国区第一名；
2008、2009 年，Google Code Jam （谷歌全球编程挑战赛）冠军；
2012年3月18日，Facebook黑客杯」名列第三；
2016年创立无人驾驶公司
小马智行
（PonyAI），剑指L4级无人驾驶；获得中国自动驾驶创业公司最高估值。
评价：
“只要有楼天城参加的比赛，别人就只能想着怎么拿第二。”
“他是未来推动中国互联网产业发展的中流砥柱”--李开复
08、OpenResty -
章亦春
江湖人称“春哥”，编程之路起于看不懂而抄书，就算如今已是罕见的编程高手，春哥依然逢人大力推荐他的抄书学编程之法。
创立的OpenResty开源社区，获得了锤子科技一百万的捐赠。
个人历程：
江苏镇江人，1999年，初中的章亦春第一次接触《
C 语言程序设计
》靠手抄自学编程，进入江苏大学后，一发不可收拾的迷恋上开源世界。
结束淘宝量子统计的工作后，全心从事 OpenResty 等开源项目的工作；
2017年，在美国创办了 OpenResty Inc. 公司。
个人成就：
OpenResty的创造者（OpenResty ：开源的 Web 平台，用于开发高性能和高动态的 Web 网关或者 Web 应用。）
评价：
“这是个不需要技术圈“网红”捧的务实大牛。一个牛逼的好人。是我见过的最Geek的工程师。”
09、无线专家-
陶建辉
国际顶尖无线数据专家，连续创业者，写了34年的代码，如今50多岁，依然写代码。
个人历程：
湖南长沙人，出生于1968年，初中时手拿一本《Basic语言编程》，从此走上编程之路；
1986年，考入中科大，认为计算机太简单而选择力学系；
1994年，美国印第安纳大学攻读天体物理博士；
1997年起，在美国从事无线互联网的研发工作；
2015年荣获全国优秀无线互联网专家称号；
个人成就：
2008年创办和信，专注移动互联网IPPush和IP实时消息服务，2010年和信被台湾联发科收购。
2013年创办快乐妈咪，专注母婴智能硬件和母婴健康服务，2016年初快乐妈咪被太平洋网络收购。
2017年创办涛思数据，专注时序空间数据的实时高效的处理（存储、查询、计算等），研发出性能明显超越业内标杆产品的TDengine，可广泛运用于物联网、车联网、工业大数据、金融等领域。
评价：
51岁的陶建辉是圈子里名副其实的“老炮儿”，把物联网技术，做成了业界无法忽视的开源生态。
企业中的技术大牛
10、链家-惠新辰
一个在网上搜PHP教程的初学者，华丽转身，成为PHP开发组核心成员，
php开源组织中国唯一成员。
人称“鸟哥”，PHP NG核心开发者，PHP5.4，5.5的主要开发者。
个人历程：
陕西人，1998年，高中时期着迷网络，在网吧做网管，后被父母勒令退学。后来考上西安交通大学，调剂到计算机专业。
研究生调剂到北京国际关系学院，信息安全专业硕士毕业。
2006年第一次面试雅虎被拒，由此开始在技术上发力学习。
后来担任Zend公司外聘顾问, 任职百度、新浪，现任
链家网
技术副总裁兼总架构师。
个人成就：
PHP7的核心开发者，PHP5.4，5.5的主要开发者；
作为PECL开发者，贡献了Yaf ( Yet another framework )，Yar ( Yet another RPC framework ) 以及 Yac ( Yet another Cache )、 Taint 等多个优秀开源作品；
同时也是APC，Opcache，Msgpack等项目的维护者。
评价：
“PHP继父”
11、LVS作者-
章文嵩
他是中国计算机产业界技术大牛，国防科大六院90级校友，是国防科大的传奇人物，努力推行开源，堪称中国开源第一人。
个人经历：
生于1973年，少年时痴迷于游戏，后考入于国防科大计算机系；
原TelTel公司的首席科学家，ChinaCluster的共同创始人、阿里云CTO，花名为正明；
2016年，离开阿里巴巴加盟滴滴；
现任滴滴高级副总裁、
中国计算机学会技术前沿委员会主席。
个人成就：
LVS（Linux Virtual Server）创始人；
沉淀了CDN、TFS、Tair、Tengine、MySQL、JVM、Linux内核、图像搜索等技术和产品。
评价：
“他有技术人员的气质，也有一些文人的感觉。”
12、阿里云-陆靖
ACM世界冠军，为人十分低调，公司内号称“人肉逻辑机”
不调试，一遍一遍看代码，就能指出某行代码有错误；
爱看日漫，为此自学日语，最后能参与字幕组做翻译。
中间持奖杯者为
陆靖
个人经历：
为人太低调，找不到资料
评价：
开挂一般的存在、史上最强大脑、逆天宅男。
最后一位，搞网络安全的牛人
13、黑客-龚蔚
上海人，是中国最早黑客教父，绿色兵团创始人，计算机信息管理专业毕业。
其创建的绿色兵团注册成员最高达数万人，高手云集，可以说，那是中国黑客江湖大一统的时代！
个人历程：
大学时偶然接触到了中华学习机，苦求游戏破解方法时，看到台湾黑客coolfire（
林正隆
）的8篇黑客技术文章，从此走上黑客高手之路！
个人成就：
绿盟创始人，2001年中美对攻领导者之一，红客运动发起者。
每当中国被欺负，只能发表“严重谴责”时，红客们便开始了自己的反抗：将红旗插到DI GUO主义的每个网站头上。
个人魅力：
二十年前，是一个大侠，江湖里真正的大侠。不会轻易出手，但是一出手必会撼动江湖。
网友评价：
“近二十年里，龚蔚始终不变的，是追求无限可能的理想主义者，是一名真正的黑客。”
――――――――――――――――
版权声明：本文为CSDN博主「微笑很纯洁」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：
https://
blog.csdn.net/ityouknow
/article/details/101444059
 ","一、尤雨溪
江湖流传一个小故事：
一款名叫Clear的软件，在正式推出的第一天，就登场了Apple Store付费榜和总榜第二。
而身在美国的中国留学生尤雨溪，仅仅花了两天的时间，就copy出了一个html5版的Clear，并且放出了源代码。
2014年2月，开发了一个前端开发库Vue.js。没错，现在就是前端在广泛使用的
Vue框架
！Vue.js一经发布，就受到了很多人的追捧，可以说Vue.js就是人们苦苦寻找的那个好用的前端框架。
后来的
尤雨溪
在patreon进行了众筹，因为他希望自己可以全职去开发Vue.js。众筹的效果是非常满意的，每个月他几乎可以收到1万美元的赞助。
因此他将全部精力都投入到了
Vue.js
的开发和推广上面，他经常参加各种JS交流大会，分享Vue的开发经历，分享使用Vue进行开发的技巧和方法。很多国内的大公司还有小公司都开始使用Vue了，Vue.js在他的带领下，正在茁壮成长。
不过尤雨溪曾经发过一条推特，表示自己全职做Vue以后，赚了上千万人民币，真是厉害。
看到这条消息，这只能用一句话来表达我的心情了：
本来想用普通人的身份跟你们相处，可换来的却是疏远。不装了，我是亿万富翁，我摊牌了！――
王多鱼
二、阿里扫地僧--“多隆”。
蔡景现，一个更广为人知的名字是“多隆”
他是阿里巴巴初创团队三名工程师之一，
在一个月之内，从零起步搭建起了“淘宝”。
非科班出身的他被称“码神”，又称“阿里扫地僧“。
对于技术，既懂C/C++，又懂Java内核；
既可以深入技术底层，又能切入到高层业务领域，
从前端到后端，独自维护淘宝搜索引擎长达5年。
他是阿里巴巴新增的三位合伙人之一。阿里CTO
张建锋
这样评价他：“多隆（
蔡景现
）做事一个人能顶一个团队。
在内网的标签上，
他被称为神，
这不是恭维，在所有工程师眼中，他就是个神。多隆做事一个人能顶一个团队，比如说写一个文件系统，别人很可能是一个项目组，甚至一个公司在做，而他从头到尾都是一个人，在很短的时间内就完成了。
多隆拥有着程序员所特有的钻研精神，多隆很喜欢写代码，
彭蕾
在解释为何他能入选合伙人时说，“很傻很天真，多隆写代码可以写到入定的状态”
多隆一个人负责了淘宝第一版上线，自此，他的技术水平也突飞猛进，为了解决项目问题，他经常得在半夜爬起，去解决问题，排除故障。
“编程是一个技术活，只要练的足够多，就能熟能生巧。”
像
多隆
一样，我们只要多做项目，做学习，也总有成为技术专家的一天。
顺带推荐一下，我用时一个多月帮同学们搜集的学习资源。总是有同学问我有没有什么资料推荐学习，索性全网大搜罗了一下，用时一个多月。帮大家搜集了3T的资源，包括计算机专业46个方向入门、进阶、实战的视频和电子书都有，有的都是靠买的，视频、资料、源码都有，
大家可以去学习，记得帮我点赞就好
三、
陈皓
江湖人称""浩哥/耗子哥""，对新手总是热心的帮助，一位百科全书类的前辈
陈皓
，网名
左耳朵耗子
，酷壳
http://
coolshell.cn
博客博主，文章篇篇经典，强烈推荐大家去看看。
17年以上软件从业经历，擅长底层技术架构，曾在
汤森路透
、亚马逊、阿里云等公司就职，目前创业中。
他很谦虚，他说“我不是高手，我也不是牛人，我只是在跟随着我的兴趣和喜好去学习一些技术。”
而我觉得，他是一个对技术和生活都有非常深地思考的人，很多观点都能让人醍醐灌顶。如果你看过他的文章，想必你也会喜欢上他。
四、阿里-
阮一峰
上海财经大学世界经济博士研究生，自学网站制作，依靠自己对技术的热情，不断学习钻研，成为一名IT业内专家，也是中文互联网上的知名blogger。
不仅热爱技术还热爱写作，同时还热衷于开源。
学经济学的人里写博客最好的，写博客的人里写IT技术最透彻易懂的！
想必学习前端的同学，对他并不陌生。他的文章随处可见，我当年学习前端就是跟着他的博客来学的。
他的博文在网上的权重很大，IT系列教程影响了极大一批初入编程的小白！
他的译著有：
《黑客与画家：硅谷创业之你Paul Graham文集》
《
软件随想录：程序员部落酋长Joel谈软件
》
《异常流行幻象与群众疯狂&困惑之惑》等
五、
章亦春
江湖人称“春哥”，春哥的编程之旅起于抄书，就算如今已是罕见的
编程高手
，春哥依然逢人大力推荐他的抄书学编程之法。
春哥先后在中国雅虎、淘宝、
Cloudflare
 就职，但开源世界是他如一的眷念。
如今，春哥已全身心投入 
OpenResty
 的崭新蓝图，期待 OpenResty 未来能在工业界、互联网行业引领“
机器编程
”革命。
有兴趣的小伙伴可以看下
图灵社区
对春哥的专访，详细记录了春哥的成长和心路历程。
访谈人：六米
图灵：从抄书到开源之巅：章亦春的程序人生
六、陆靖
ACM世界冠军，现就职阿里云，为人十分低调，公司内号称“人肉逻辑机”，他做事不轻易动手，深思熟虑，鲜有编译错误。
遇到搞不定的代码找他时，他就看代码，不调试，一遍一遍看代码，然后指出某行代码有错误。人们都觉得他看代码的时候大脑其实就是多核CPU，在一次又一次的运行代码。
中间持奖杯者为陆靖
网上还流传着有关陆靖的传奇故事：
某次代码遇到bug，良久无策。一个同事打电话问他，他在电话里说：”你们检查下某个
cpp文件
的780行左右，是否参数传递有问题，一查果不其然，问他是否在电脑边，他说不在，在肯德基吃饭，众人大惊之下去git blame，发现这代码他8个月前提交过。特别聪明的本身少见，特别聪明而且记忆力超强的更是凤毛麟角“
七、田春―
伞哥
Common 
Lisp
 程序员，号称中国Lisp第一人，网名“冰河”，人称伞哥。
我不想多介绍伞哥的成绩，我只想说一说网上流传的一些奇闻轶事，如此牛人，可见一般
伞哥，大名
田春
。在网易从事
MIS
相关工作，在业内有极高的声誉。
伞哥每天一身白衣，拿一把伞。他对网易内部的人说，伞是法律允许的最长的防身武器。一身白衣是他妈妈亲自给他做的。
伞哥性格比较古怪，他坐在丁磊办公室旁边，经常冲进丁磊的办公室，拔掉
丁磊
的iphone，然后把自己的插上。
后来，网易内部需要开发一套办公区wifi的系统，伞哥自告奋勇承担并且开发出来了，在公司内赢得了好评。于是伞哥走进丁磊的办公室说，这套系统找华为做要20万美金，我不找你多要，给我20万人民币就可以了。丁磊气急，直接找到他的直接领导说，你的员工怎么这样。
然后后来又一次，伞哥又做了一些东西，又找到丁磊，说，上次只有20万美金，我不跟你计较了。这次开发的这套东西能卖200万美金。至此，丁磊坚持把伞哥开除掉了
哦对了，补充一下，伞哥离开网易的时候。部门全体人员请他吃了一顿饭。于是他走的时候说，我不会怀念网易，只会怀念这些战友。我不会再回到网易，下次回来，就是我收购网易的时候
程序员圈子里还有很多如明星般闪耀的牛人！
有的人，凭一己之力
开发出了几千人使用的开源软件
有的创造了网络的神话，至今为之传诵
有的授业解惑，或教师、或出书、或博客
他们影响了一批又一批的后来者
他们的名字经常被提起 
这是一群对技术有着最纯真热爱的人
希望有一天，这里也有你的名字
共勉
码字不易，请帮我 
@启舰
 点个赞吧，谢谢大家
我们下篇文章见","ACM竞赛界yyds――楼天城，本ACM选手永远仰视的存在。 
他参加算法比赛的时候，这个世界上就没有能干得倒他的人，任何比赛都是第一名（只要他参加）。中国公认的大学生计算机编程第一人，经常以一人单挑一个队，在CEOI、ACM界无人不晓其大名，人称“
楼教主
”。 
晒一下履历：
参加ACM比赛的时候，他的队友都是其他的 IOI 金牌，但是基本没他们事儿，他一个人单挑，ACM是3人团队赛，但是基本上有他的队伍，其他两个人只要负责读题，安静的做个翻译就好了…… 
最可怕的是，人家并不是个只会做题的大佬，其他方面也强得一批： 
2007年，
楼天城
开发了WalkScript（WalkLan）（Walk脚本），构造了
我国GIS软件的第一个测绘地理信息脚本语言
。 
在美国参加Facebook举办的2011黑客杯比赛时，楼天城就被
Facebook
邀请参加面试，两次面试后很快就给了offer，是去硅谷总部，以清华博士应届毕业生的身份被Facebook聘任。 
毕业后，楼天城曾在
Google总部
工作，从事社交网络和机器学习相关问题的研究。 
2015年11月离开Alphabet（谷歌母公司）加入Quora公司。  
2016年4月，楼天城加入百度美研，参与无人车的技术研发，成为
百度最年轻的T10级员工
。  
2017年初，楼天城从百度离职，与离职百度的
首席架构师
彭军一起创立了
自动驾驶创业公司
小马智行
（Pony.ai）。 
你梦寐以求的外企（Google、Facebook）他想进就进，百度T10、自行创业，可以说你这辈子可能都难经历过一回的事情，他全都经历了一遍。 
说个小彩蛋
，我们
九章算法的令狐冲老师
是
2006年国家集训队
的，而楼天城是2004年国家集训队的，令狐冲老师在参加acm比赛的时候还请他面授过：） 也是ACM金牌选手，并先后入职了Airbnb和FB，当然和大佬比还差得很远。
最近我们令狐冲老师还出了一套（虽然与打acm比赛毫无关系，甚至acm选手看了都想笑，）但很适合
夯实算法基础、一个月时间突击备战求职面试
的题目，看这里： 
字符串处理 String 
 
考察情况
 
考得很多，主要注重代码实现能力，算法上没有太多难点，通常是处理麻烦。 
学习难度：★★
 
最少刷题数：20
 
必刷题目：
 
1.
字符串查找
 
2.
最长回文子串
 
3.
有效回文串
 
4.
单词拆分I
 
5.
正则表达式匹配
 
6.
旋转字符串
 
7.
解码方法
 
8.
至少K个不同字符的子串
 
9.
字符串查找II
 
10.
全零子串的数量
 
11.
最长公共子序列
 
12.
编辑距离
 
13.
第一个只出现一次的字符
 
14.
乱序字符串
 
15.
Excel表列标题
 
16.
一次编辑距离
 
17.
删除无效的括号
 
18.
单词的添加与查找
 
19.
基础计算器
 
20.
比较字符串
 
双指针算法
 Two Pointers
 
考察情况
 
高频算法之王，变形特别多，算法不算特别难，但能快速想到和写好不容易。 
学习难度：★★★★
 
最少刷题数：20
 
必刷题目：
 
1.
颜色分类
 
2.
两数之和 III-数据结构设计
 
3.
排颜色
 
4.
最长子串覆盖
 
5.
有效回文
 
6.
带环链表
 
7.
交错正负数
 
8.
最接近的三数之和
 
9.
四数之和
 
10.
接雨水
 
11.
寻找重复的数
 
12.
字符大小写排序
 
13.
子串字谜
 
14.
检查缩写字
 
15.
奇偶分割数组
 
16.
三数之和小于
 
17.
移动车棚
 
18.
粉刷天花板
 
19.
装最多水的容器
 
20.
目标移动
 
二分法 Binary Search
 
考察情况
 
考察频率中等，能写好写对不容易，二分答案的问题甚至很难想到算法，要背模板。 
学习难度：★★★★
 
最少刷题数：10
 
必刷题目：
 
1.
经典二分查找问题
 
2.
搜索旋转排序数组
 
3.
寻找峰值
 
4.
最长上升子序列
 
5.
木材加工
 
6.
书籍复印
 
7.
加热器
 
8.
地图跳跃
 
9.
寻找单词
 
10.
分享巧克力
 
分治法 Divide＆Conquer
 
考察情况
 
考察频率中等，一般和二叉树一起出现和考察，题一般不难。 
学习难度：★★★
 
最少刷题数：10
 
必刷题目：
 
1.
子集
 
2.
数组划分
 
3.
验证二叉查找树
 
4.
全排列
 
5.
克隆图
 
6.
排颜色
 
7.
子数组之和
 
8.
LRU缓存策略
 
9.
单词接龙
 
10.
单词拆分I
 
宽度优先搜索 BFS
 
考察情况
 
考察频率高，实现一般都不难。 
学习难度：★
 
最少刷题数：5
 
必刷题目：
 
1.
岛屿的个数
 
2.
序列重构
 
3.
拓扑排序
 
4.
课程表
 
5.
买卖股票的最佳时期
 
深度优先搜索
 DFS / 递归 Recursion
 
考察情况
 
考察频率高，主要是考递归会不会写。 
学习难度：★★★★★
 
最少刷题数：20
 
必刷题目：
 
1.
子集
 
2.
图是否是树
 
3.
子数组之和
 
4.
电话号码的字母组合
 
5.
K数和
 
6.
因式分解
 
7.
N皇后问题
 
8.
子模式II
 
9.
寻找丢失的数II
 
10.
二叉树的最小深度
 
11.
最小路径和
 
12.
数字组合II
 
13.
下一个排列
 
14.
分割字符串
 
15.
恢复IP地址
 
16.
删除无效的括号
 
17.
数独
 
18.
单词矩阵
 
19.
组合
 
20.
左叶子的和
 
动态规划
 Dynamic Programming
 
考察情况
 
国内大厂基本都考，北美主要是G/F喜欢考，其他公司考得少。 
学习难度：★★★★★
 
最少刷题数：50
 
必刷题目：
 
1.
栅栏染色
 
2.
爬楼梯
 
3.
约翰的后花园
 
4.
单词拆分
 
5.
书籍复印
 
6.
解码方法
 
7.
通配符匹配
 
8.
旅行商问题
 
9.
青蛙跳
 
10.
骰子求和
 
拓扑排序算法
 Topological Order
 
考察情况
 
考察频率中等，但每个公司基本都有一个这个算法的题。 
学习难度：★★★
 
最少刷题数：3
 
必刷题目：
 
1.
序列重构
 
2.
外星人字典
 
3.
拓扑排序
 
链表 LinkedList
 
考察情况
 
中小公司考得多，大公司近年来考得少，题目一般不难，主要考察Reference。 
学习难度：★★
 
最少刷题数：20
 
必刷题目：
 
1.
合并k个排序链表
 
2.
带环链表
 
3.
翻转链表
 
4.
两个链表的交叉
 
5.
链表划分
 
6.
重排链表
 
7.
回文链表
 
8.
加一链表
 
9.
奇偶链表
 
10.
两数相乘
 
二叉树 Binary Search
 
考察情况
 
中小公司考得多，大公司近年来考得少，题目一般不难，主要考察Reference。 
学习难度：★★
 
最少刷题数：20
 
必刷题目：
 
1.
二叉树的后序遍历
 
2.
二叉树的所有路径
 
3.
根据前序和后序遍历构造二叉树
 
4.
对称树
 
5.
找出树中每行的最大值
 
6.
寻找重复的子树
 
7.
BST中第K小的元素
 
8.
具有最大平均数的子树
 
9.
最小路径和
 
10.
二叉树的右视图
 
堆 Heap
 
考察情况
 
高频，经常会用到，原理必须掌握，但不用掌握代码实现，应用必须掌握代码。 
学习难度：★★★
 
最少刷题数：5
 
必刷题目：
 
1.
丑数
 
2.
堆化
 
3.
滑动窗口的中位数
 
4.
大楼轮廓
 
5.
超级丑数
 
哈希表
 Hash Table
 
考察情况
 
高频，应用和原理都需要掌握且需要掌握代码实现。 
学习难度：★★★
 
最少刷题数：10
 
必刷题目：
 
1.
两数之和
 
2.
最长回文串
 
3.
两数组的交集
 
4.
数据流中第一个唯一的数字
 
5.
两数和 II-输入已排序的数组
 
6.
单词接龙
 
7.
有效回文串
 
8.
尾部的零
 
9.
跳跃游戏
 
10.
数字三角形
 
并查集
 Union Find
 
考察情况
 
考察频率中等，主要是G/F可能会考，不会的话很多时候可以用BFS替代。 
学习难度：★★★
 
最少刷题数：3
 
必刷题目：
 
1.
账户合并
 
2.
打砖块
 
3.
团队通知
 
现在
令狐冲
老师的春招公益讲座
《FB面试官揭秘算法面试速成技巧 - 怎样做到 Bug Free 和刷100题等于别人刷300题》
已经上线，讲座中会教授各种刷题技巧、算法面试的考察情况等，感兴趣的小伙伴不妨一起来交流学习下~ 
还有像是
唐文斌
，龙凡，杨沐，王小川，陈启峰，
范浩强
，陈立杰，陈丹琦，也都是水平超高的大佬，这里就不一一列举了，欢迎各位补充~ ","更新一下，我希望大家不要点赞了，我只是转述一下，不值得被点赞，被点赞的应该是他们
------------------------------------
LVS作者，
章文嵩
博士，不用多说了吧，有多少人的代码能进Linux内核呢？
淘宝霸爷，我以前的上司评价霸业是这样说的，霸爷是一个
人脑计算机
。
贴一下霸爷的博客，
系统技术非业余研究
 我一直是跪着看的","中国的所有程序员中，我只彻底佩服一位，他就是云风。我跟他在同一公司工作过，越了解他日常，我就更佩服他一筹。（我骑着摩拜单车赶去公司路上还经常看到他和老婆走路去上班）
吴云洋
（Cloud），出生于1979年2月5日，原
网易
游戏核心成员、杭州研究中心总监。 吴云洋毕业于
中南大学
机械自动化963班，具有丰富的游戏策划和程序开发经验，尤其擅长汇编语言及程序优化。早期在
cfido
和
水木清华BBS
发表了多篇关于游戏制作的文章，后来制作了第一个专题介绍游戏制作的GB码中文网站，收录个人文章超过百万字，在游戏界颇有名气。
1998年中发布看书工具C-View 2.0，被多张工具光盘收藏。
1999年初开始制作二维游戏引擎－－风魂系列，被多家公司和小组用于游戏制作。
他是《
大话西游
》、《
梦幻西游
》、《
网易泡泡
游戏》等网络游戏的主力开发者，而《
大话西游
》和《梦幻西游》是网易最主要的两款网络游戏。
2011年8月下旬从网易离职。吴云洋或将与在2011离职的网易首席运营官
詹钟晖
一起组建新团队创业。
知乎有这样一个问题，
云风在2001年拿5位数的月工资是什么水平？
―― 在2001年的时候，
丁磊
邀请云风去广州加入网易，开到了10000/月，而云风是2000年的应届毕业生。
前几年，他创立的公司也被阿里收购了，可以说，他早就财富自由了。
但现在，他还工作在一线，开发国产游戏引擎，维护开源项目
skynet
，写着硬核的技术博客，最近的文章就是：
构建工具从 Make 到 Ninja
扩展 
Lua
 的常量类型
选择开源项目的几点原则
关于 skynet 调度器的一点想法(续)
什么叫热爱技术啊，这就是。
相反你看看一些有了名气的程序员，他们还写代码吗？有代表的开源项目吗？还会写硬核技术文吗？
在我看来，云风才是顶级水平的程序员。
附上长发飘逸帅气的云风大佬：
各位可以去
学习一下。
学习不够的话，也可以看看山尽我的精华文章，虽然比不上云风大佬：
赚大钱
Tegus有人联系我做咨询，200美金一小时
我是如何靠运气在美股一分钟赚2万人民币的
HTTP 深入详解
一步步手写 http 底层客户端
不懂 http 协议，连 nginx 为什么这么设置都不懂
如果这篇文章说不清HTTP2的本质，那就过来掐死我吧！
我的HTTP/3学习笔记
提升效率
我是怎么用纯用命令行完成所有开发工作的
Notion?Roam?OneNote? 做笔记我用Tiddlywiki
设置一下shell，每开新窗口，就看一首诗
计算机程序基础
递归的实现――循环，汇编，CPS与 y 组合子","我读书的时候，特别仰慕两位大神：
一位是
云风
――
吴云洋
，这是一位水平非常高的前辈，当年他一毕业就被网易 CEO 的
丁磊
一张机票接到网易去了，担任梦幻西游的主程序，这个游戏后来成了经典，也成就了网易。我那会儿读他写的
游戏库
代码以及他去网易的前后的故事、他如何招人、如何创业，非常钦佩。
我上学的时候阅读风魂的代码，深有感慨，虽然代码的风格和变量命名如今看来略有稚嫩，但一个大学生可以熟练的用 C/C++ 和汇编写出流畅的程序，并且这个程序还能被商业公司使用的事迹，已经超过现在 99% 的计算机相关专业的大学生了。
风魂源码下载：
链接: 
https://
pan.baidu.com/s/12gKthA
EMSglYBqzrWiCH0w
 提取码: suyy
他的个人博客
云风的 BLOG
。
大神就是大神，连发型和我们都不一样～～
云风写了一本书叫《
游戏之旅――我的编程感悟
》，讲述了他学习编程的经历和成长的思考思考，书中学习技术的思路和见解值得学习。
《游戏之旅――我的编程感悟》下载链接
（链接收集于网络，侵删）
链接: 
https://
pan.baidu.com/s/1xY5Ddd
Fn01r3qUXUa2GY8g
 提取码: qudz
另外一位是
梁肇新
，
超级解霸
的作者。可能新一代的同学不知道超级解霸当年在国内作为媒体播放的地位，曾几何时，超级解霸就是媒体播放工具的代名词，是 PC 用户桌面的必备软件。
梁肇新也是那个年代的技术偏执狂和 IT 传奇英雄。超级解霸及暴风影音是国内唯一能与微软Windows Media Player、Real Player 展开争夺的桌面播放器。
大神笑容可掬
老前辈也写了一本书，叫《
编程高手箴言
》，一听这个书名就很霸气，现在没人敢说自己是“编程高手”。
《编程高手箴言》下载链接
（链接收集于网络，侵删）
（链接: 
https://
pan.baidu.com/s/1QlFoKY
0qAJI3ytuktWMWmA
 提取码: sx9f）
我学生时代开始学的是 Web 开发，后来学 PHP、ActionScript，看了这两位前辈的图书之后，坚定了我把底层原理好好学好的信念。
用一句话勉励后来想进入软件开发的学弟学妹：
不读
洛阳纸贵
之书，不赴争相参观之地，不信喧嚣一时之论。以是，大器初成。
CppGuide
我学习 C/C++ 十多年了，目前在大厂做架构，深知新手学习 C/C++ 和基础原理知识的重要性，因此特地给 C/C++ 开发的同学精心准备了一份优质学习资料――――
CppGuide
，内容从 C/C++ 语言、网络编程、操作系统原理到完整的项目源码分析，同时这份资料也包括 C/C++ 学习方法、推荐的阅读书籍、简历指导和求职技巧等。
原创不易，如果觉得有用，请给 
@张小方
 点个赞吧～","求伯君
一个人啃泡面写出来的wps为何没人提","打包狂魔 肥 @
晏然FelixYan
作 Arch Linux 的 DEV ，肥打的包能 Arch Linux 半壁江山。
svntogit/packages.git
svntogit/community.git
然後你看 
Open Hub, the open source network
 上的 commit y：
肥永h居第一，超越後面 top2 ~ top 9 加起怼
（然其中有半凳墙o Arch 打包的 commit 不^是很害）
肥f手上的算Y源太空了，不如科W事I做cI，於是就上了 LHC@HOME 主：
(其它事未完待m）","必须安利一波：
蚂蚁金服研究员王益
在去年，他整40岁。
从10岁开始，写代码整30年。
这30年来，他当过“不务正业”的学生，创纪录地在大一就考下系统分析员，“单枪匹?”闯荡过从国内到硅谷的多家知名互联网科技公司，和AI领域许多传奇人物都有所交集。不惑之年对于许多工程师来说，或许已是需要焦虑的年龄，但40岁的王益在
蚂蚁金服
每天都过得很充实：起床，自由泳一千米，然后去做他最喜欢的事――写代码和组织大家一起写代码。
2019年开源两个项目
加入蚂蚁金服后，
开源了两个项目：SQLFlow 和 ElasticDL
SQLFlow 好比一个“翻译机”，能将分析师们输入的 SQL 命令翻译成 Python语 言，这样一来，分析师无需学习 Python，使用 SQL 语言就能够处理数据、训练AI模型，并使用训练好的模型来回答业务问题。
ElasticDL 是一个分布式的智能学习系统。它能和 SQLFlow 一起，补足简短的 SQL 程序翻译成复杂的 Python 程序的过程中所需的信息。它的容错和弹性调度机制，能让集群的利用效率更高。
坚持Code Review
他与Code Review缘起于在Google写出的第一个程序。
总共不过100行代码，却被来自美国的同事和好友提出了120行意?。
在当时深受打击的他，在压制了情绪后，仔细去看那些意?，发现每一条都真诚且很有帮助。“从那一刻起， Code Review 成为了我们的工作方式。”每天和这些同事们一起coding，互相review，让中国工程师们很快知道了应当关注哪些地方，应当如何沟通合作。
他说“开源和
codereview
不仅是个技术问题，更是管理学问题、社会学问题，关系到如何把大家组织起来变成更高效的团队。” 
更多有关王益老师的轶事，可以阅读这篇文章：
支付宝王益：40岁写30年代码是一种什么体验？
?
mp.weixin.qq.com/s?__biz=MzI0Nzc3MTQyMw==&mid=2247489667&idx=1&sn=197ec674e8e1ec6894bf64e881612cd5&chksm=e9aba0f3dedc29e5cca8fc23fddd2a983c367dbd363e4d28b4bf3ebe9bcb9528a22d5f5f9d28&token=230030431&lang=zh_CN#rd","机器学习领域的顶尖：caffe作者
贾扬清
，xgboost作者，mxnet主要贡献者之一
陈天奇","左耳朵耗子叔，曾经的阿里P9+，目前做了一家技术创业公司：MegaEase。
前段时间和程序员届的左耳朵耗子叔约过一次饭：
耗子叔跟我谈了他在技术层面的积累和思考，以及每一天对梦想的坚持。可以说
耗子叔
是一个绝顶聪明的人，但言谈中，他始终在强调的却是：每一天的笨功夫。
耗子书谈到作为技术人最快的成长方式：做最好的项目、看最经典的技术书籍，深以为然。
作为程序员的我们，虽然不一定能做最好的项目，但看最经典的技术书籍还是很轻松就能做到的。
我大学期间就是看了很多经典书籍，毕业就拿到腾讯的Offer，工作中也是保持看经典计算机书籍的习惯。
另外我把大学和工作中用的经典电子书库（包含数据结构、操作系统、C++/C、网络经典、前端编程经典、Java相关、程序员认知、职场发展）、面试找工作的资料汇总都打包放在这了，这套资源可不是一般那种网上找的资源，是伴随我从学生一路成长为腾讯高级开发工程师，360技术经理、360技术总监、中小公司CTO的打包全套，非常宝贵！点击下方链接直达获取：
我已经帮大家打包好了，点击下方链接直接获取：
耗子叔谈到他为什么离开阿里，以及离开阿里后做了一年的自由人。在这个期间耗子叔帮助饿了么、58等的公司解决服务器问题，很多时候一个团队都解决不了的事情，耗子叔凭借一己之力就搞定了。
这期间，耗子叔通过技术咨询和支持的方式，月收入轻松50万以上，再加上极客时间上的专栏收入（年售卖量过千万），月收入妥妥超百万。
但这之后，他还是选择了创业，为了做出一家不一样的公司。
耗子叔还谈到了对大公司的看法、对996的看法、对新一代程序员群体的担忧，这次约饭，真的让我受益匪浅。
耗子叔用一句话总结了996：这种行为是剥夺了程序员所有余闲时间，让程序员群体无法深度思考，也很难有未来。
耗子叔也谈到他的梦想：让每一个程序员的学习之路更轻松，也期待未来耗子叔面向程序员的在线教育产品的问世～
另外，程序员要想进大厂先从刷算法做起是个好方法，算法厉害的人进大厂非常容易，这里送一本阿里P8撰写的算法刷题笔记，身边不少朋友通过它加入大厂：
看看这本书的目录和排版，相当经典，还不赶紧看起来！
祝大家都能在程序员的道路上一马平川。
要是觉得不错的话，那就帮我
@findyi
点个赞，一键三连呗哈哈哈，半夜码字不容易（现在是凌晨1点50......）","作为一个经常听各种国内开发者大会演讲的人，有幸见过一些国内的大佬~
贴一个Boolan顾问团队介绍的截图，我想这些人估计都是国内顶尖了：
因为我平时主要专注于C++，这里再贴一下我仰望的几个国内C++大佬：
侯捷
：不介绍了，谁都认识
吴咏炜
：极客时间C++专栏作者，前Intel资深
系统架构师
，30年开发及架构经验
潘爱民
：《
程序员的自我修养
》作者之一，另外两个作者是潘老师的学生，前阿里首席架构师
张银奎
：《软件调试》作者，相当知名的内核专家
刘新铭
：编译器专家，精通编译器技术
连少华
：《C++
代码整洁之道
》作者，资深架构师
陈硕
&轮子哥
：知乎上想必大家都认识
从去年年初开始写文章以来，受到很多朋友关注，我把之前写过的所有C++文章学习资料全部系统地整理成PDF电子书，可以说干货满满
，可以点击下方卡片获取：
觉得不错的话，记得帮我 
@程序喵大人
 点个赞吧，收藏关注走一波，老铁们。","这个我谈下个人感受：
1、做病毒的人很厉害。 
陈盈豪
 ，台湾鬼才，CIH 作者，极具程序员天分的少年，用当时的新闻报道来形容：看到记者全身发抖，面对电脑露出笑容 。在电脑还不是那么普及，网络还不是很发达的1998年，CIH造成全球 6000万台电脑瘫痪。厉害！
2、搞网络安全的人很厉害。
龚蔚
，
绿盟创始人，2001年中美对攻领导者之一，
红客运动
发起者，拉开了中国黑客为国争光的序幕。每当中国被外强欺负，只能发表“严重谴责”时，红客们便开始了自己的反抗。将红旗插到帝国主义的每个网站头上。
3、能做出大应用软件的很厉害。
求伯君
，
金山CEO，1998年，他一个人花了一年时间写出了WPS第一版，不用多说了， 向前辈致敬。
4、能流传很广的小软件很厉害
张宴
，消息队列服务httpsqs 作者， 这个小应用曾经占据了几乎所有中小网站的服务器，厉害。
5、能写内核的很厉害
Axel Lin , yinghai lu ,herber xu   ,
这3个人是 Linux
Kernel Patch Statistic  上中国排名前三的贡献者，不想太解释， 反正很厉害。
6、我们单位的小孙同学也很厉害
小孙（其实代表了广大一线开发者）
，去年一年的时间，写了30多万行代码，着实让我震惊，有图为证：
－－－－－－－－－－－－－－－－
今天先写到这里， 有赞的话我再继续补充。","李可文
。
高中在单片机上开发程序，获得全国科技博览会金奖。
谢绝清华保送，参加高考考取北大计算机专业。
他为人所知是在大学时，写出可以玩
GBA
游戏的DreamGBA模拟器，精确性和性能为当时业界GBA模拟器之最，在全世界模拟器玩家中名噪一时。
为惠普PDA移植自己开发的GBA模拟器。以当时移动设备较为孱弱的性能，全世界的GBA模拟器里只有李可文写的移植版能够流畅运行。
逝世前几个月（2003年底）还在商谈成为某投资千万的移动软件平台的技术总监。
1979年9月出生，2004年7月病逝。"
,,,,,,,,,,,,,,,,,,,,,
被公司卸磨杀驴能把代码删除吗？,None,"删除代码违法，但删除代码的注释不违法。
删除代码违法，但使用奇怪的函数名不违法。
删除代码违法，但调用乱七八糟的库不违法。
删除代码违法，但加入无用的代码不违法。","驴要明白一个道理，被卸磨杀驴后，你把面粉毁了，那买下一头驴重新磨一遍就行了。
但是你往面粉里加点脚皮屑，让老板吃，每次他吃的怪怪的，总觉得有问题，又不舍得扔了，然后一直吃。那才是最高效的报复。","想反抗又不敢反抗的时候
可以试着加倍努力干烂活，撸起袖子加油干.....烂活
态度一定要端正，水平一定要稀烂
――
我当年实习的时候，领导敢7点之后打我电话，我就敢10点打回去向他请示
他敢10点给我打电话，我就凌晨1点给他回","删除代码你什么也得不到，除了泄愤外屁用没有
不如在代码里埋点雷，最后还得请你回来修，要么就花大价钱重构
注释里面可以下毒，原则就是把注释写的没有参考价值，可以不按照代码实际功能来写注释，或者把注释里的参数名称调换一下，最好再夹杂大量正确的废话，增加阅读难度
活用变量
闭包
，闭包内外变量名称尽可能用一样的，这样整个代码就会看起来逻辑极其混乱难以分析，配合注释下毒就算尤雨溪来了都得琢磨半天
大量使用
语法糖
和各种简略写法，比如六七个箭头函数裹在一行里
高耦合低内聚，逼着别人必须极其谨慎的处理你的屎山
内存能不回收就不回收了，等着它
内存泄漏
不写输入参数检查，只要调接口的时候参数有任何一点不对，马上崩就完事了
把关键逻辑写成一个
开源库
再引用的办法，引用版本号一定要写latest，离职后自己把开源库release一个会炸的新版本，等下次依赖自动升级就直接全炸
总之尽可能把你的代码写成一坨粘稠的屎山，这远比直接删代码来的更能恶心人","首先，屎山，bug，是合法的
代码写的差是合法的
代码中引用一个你自己的库(一般情况下)是合法的
写的代码先不提交是合法的
git合并时删掉一些代码也是合法的(合并代码又冲突嘛)
写代码不考虑特殊情况也是合法的
sql不防注入是合法的
域名解析
源站ip是合法的
漏洞不修是合法的
多用点停止支持的库是合法的
多写点报错自动退出是合法的，什么参数错误管他什么直接报错
判断写严格点是合法的，发现问题立刻报错而且不输出问题
不写注释是合法的
什么？公司用的是1.8的jdk？没关系，用最新的jdk是合法的，直接把编译完成的代码传上去
突然又想到一个：写前端的兄弟们，用
webpack
来格式化代码如何～
但你恶意删代码
1.(可能)没有效果，gitsvn直接恢复
2.如果删掉无法恢复那等着公司法务吧，违法的
兄弟们评论区不看后悔一辈子","卧槽，你们都要埋雷给公司造成损失吗？
我当年正常写就行。","十几年前我接私活，帮别人实施一个政务软件项目，合作方老板承诺1万的好处费。
当时环境是
Windows Server
，我开了远程权限，写了脚本放在计划任务里，预防对方付款上磨磨唧唧。
后来担心的事情还是发生了。
我遂告知对方删除map（map及坐标数据是我私人提供的，没备份的话删了就彻底没有了）、删除应用程序以及格式化系统os的时间计划安排。
双方电话里相谈甚欢，互相给予对方温暖问候之后，我爽快的拿到了一张中行的支票。","劝开公司的，对各种技术人员好一点，
如果你用
maya
，这两年估计你遇到过，
有一个病毒，中招就会现实这个：
程序员要是泄愤，删代码并不是好主意，
在代码中加东西才是好方法。","接过一个项目
功能很简单，但是防破解的功能我搞了一个星期
然后给对方，每次操作软件会跳出框框说免费试用15天
15天内未输入注册码的话保持调度通讯功能，但不能操作设备；
不到3天就马上打款了","不能，这样犯法。
但是代码质量不过关是可以的。
你品你细品。","删代码涉及到违法， 可能会被抓去啃窝窝头，得不偿失。
但是在项目里面“一不小心”留几个暗坑，或者因为“技术菜”留下大坨小坨的“屎”，相信大家都是可以理解的。
真是没想到，我居然被卸磨杀驴了。入职一家公司，转正不到一个月， 帮他们把框架搭建的差不多了，然后就没我什么事了。
这操蛋的，早知道这样应该在框架里面""拉屎""的！
一年后更。
现在没啥事，就来说说这件事。这公司估计就是招我进去帮忙搭建系统框架的，框架搭建的差不多了，卡着我工作还没满半年的时间节点把我辞退了，很爽快的给2N，谈判过程不超过5分钟。他们很清楚，我也心知肚明。
过了一两个月吧，这家公司的技术人员联系我，说框架有问题，他们实在是搞不定，希望我帮帮忙，我找了个借口敷衍过去了，没理。
随后又找我好几次，说顶不住上面的压力了，再搞不定他也要走人了。我心软了，指点了几句，告诉他解决思路。
这个问题呢，其实我是知道的(当然不是我故意埋雷的)，只不过当时忙着完善日志收集和监控系统，那个问题想着放一放，后面再抽时间解决的。
只是他们太着急了，还没完全搞完，就图穷匕见了。",抗战的时候，游击队剪电话线的时候，剪断的时候还得再给它“接”起来，让外表看不出来。,"额。核心层用C++写的。大佬告诉我，不要用指针。然后我就把指针的星号都藏了起来…为了效率，也为了懒省事，数据交换经常用数组越界溢出的方法。
全局变量
和局部变量连续混用。除了我自己，别人谁都看不懂。。看懂了也不敢动。尤其是各种溢出，据我师弟说那些代码基本上都是鬼见愁的。。。","我打的人生第一份工，就被老板卸磨杀驴了。
我的报复是：我在中午没人的时候，把干活的三台电脑都下载了一个东西，这个东西很神奇，只要一关机，就会重启，然后进入DOS系统格式化非系统盘外的所有硬盘，而且是悄摸摸的，显示器上给你显示的是在检查硬盘错误，让你别动。
公司是个广告公司，当时所有的资料都保存在那三台电脑里。
这是2001年的事儿了。
没有人怀疑是我干的。因为上午的时候断了一次电，3台电脑都非正常关机了，他们都认为是断电导致的硬盘损坏。","学学Twitter的程序员，被裁掉又被
马斯克
请回来",,删掉干嘛？不如“加点啥”。删是一种破坏性行为，是对公司财富的侵害。而“加”是正常的工作行为，拿工资就是做这个的。,"某个前东家有一段代码，在各种机缘巧合之下，是我直接在生产环境一气呵成写完的，除我以外没人敢动，离职六年后还有人打电话过来问我细节。
真是……太高看我了，写完不到一个月我基本就忘光了 ",千万不要这么干,"// 补充下，有的人说我捞，这种有问题的代码一眼就看出来了。那我就分享个我自己的事吧：
上学那会自己找的实习，开发什么智慧农业，无非是c51挂几个传感器，读到数据用lora传出去。我哼哧哼哧做了一个月，有一天主管跟我说，想看看做的咋样，让我把源码，还有搜集到的资料都压缩给他看看（小作坊没有搞svn.git这种）。
我一想不对啊，你直接看我的开发板不就行了？怕不是要卸磨杀驴吧，我就随便在几个数据采集的地方，加几个随机值，随机值名字起得挺正式，看起来就是校正值啥的，给主管发过去。
后来过几天我就被开了，某天qq收到一个人加我，说大哥我是接替你的人，用了你的程序，感觉有点不对劲啊，数值忽高忽低，他们一堆人研究好久也不知道咋回事，我说不知道啊，反正我用是正常的，主管知道的。
哦对了，那个项目还是挂在某省会的什么智能研究院下面，看似高大上，实则水的一批。
～～～～～～～～～～～～～～～～
最好不要这样做，因为员工在公司的成果，属于公司财产，删代码可能负法律责任。
不过我听说有的程序员水平太次了，写的代码烂不说，还经常搞出一些极难复现的Bug。比如说在一些不起眼的地方，加个随机数，外面还套个极小概率的if条件。
这样的程序员简直是公司之耻，我劝题主以此为鉴，多去修炼技术，少想歪门邪道。"
,,,,,,,,,,,,,,,,,,,,,
有哪些让你目瞪口呆的 Bug ？,None,"关于考勤打卡的
我们单位粗心的人事在系统里删除离职人员的时候不小心把我也删除了
当了很长时间的黑户
后来虽然又添加回来
但饭卡，慰问品之类的总是出错，每次我都得解释一遍然后气急败坏的自己去单独领一份
直到我发现
我请假系统里不扣年假
哈哈哈哈哈哈哈
无限续杯","想起来以前有一年教大班，教到交通规则，红灯停绿灯行。
班里有个小孩，总是记成红灯行绿灯停。
一开始以为是故意的，后来发现不是，就算今天让他记住了红灯停绿灯行，明天他又会告诉你是红灯行绿灯停。
又以为是不是色盲，但是他是分得清红绿的。
我和主班老师都觉得很奇怪，别的小孩都能教会，这小孩虽然平时死板固执了点，也不至于都教不会一个红灯停绿灯行吧。
然后主班老师就问他，你爸爸妈妈带你上幼儿园，带你回家，过马路的时候，是红灯走还是绿灯走呀？
他:我爸爸妈妈一直都是红灯走的。
我:6
主班老师放学的时候还隐晦地提醒了小孩妈妈，说载小孩的话最好还是遵守交通规则，为了安全考虑也为了给小孩做个好榜样。
他妈妈:有啊有啊我很遵守规则的！
但是那小孩还是记不住，而且第二天问他，他妈妈还是红灯走的。
做老师的也不能过多干涉家长的习惯，我们也就没有再说什么。
后来有一天，我骑电瓶车载我闺蜜出去玩，到十字路口的时候，她说旁边的车都走了我咋不走。我没好气跟她说你看不到红灯嘛，没车也不能闯红灯！
她说我看不到！你这么大只挡在前面我怎么看得到！
然后我突然意识到，我班里那小孩，他爸爸妈妈是用自行车载他的，他坐在后座，确实是看不到正前方的红绿灯。他只能看到左右的红绿灯。
所以当他正前方是红灯，左右就是绿灯，他就会以为他看到绿灯就得停着。
当他正前方是绿灯，左右就是红灯，他就会以为，他看到红灯就代表可以通行。
我不喜欢跟家长沟通，所以我把这个想法跟主班老师说，叫她去跟家长说。他妈妈听完也是恍然大悟，带着他走了一次十字路口，跟他说明白了红绿灯得看自己正前方的。
最后这个困扰我俩大半个学期的bug就这么解决了。","魅族手机把sim卡名称改成“无sim卡”
系统就会以为真的没有这张卡 直接断服务 且整张卡选项变为灰色 无法进行更改 重启也不行
解决办法是把系统语言改成英文 因为这样会识别到卡名字叫做“无sim卡”而不是真的没有sim卡 ","一个老爷子卖酸奶
三块一瓶，十块三瓶
来个小伙子
“大爷，来瓶酸奶！”
“三块！”
“大爷，再来一瓶！”
“三块！”
“大爷，再来一瓶！”
“三块！”
“大爷你看，我买了三瓶酸奶，才九块钱，所以你那个‘十块三瓶’算错了，买的越多应该越便宜才对！”
“呵呵，每天都有你这样的来一下买三瓶！”","有，不过是店员目瞪口呆，而我稳如老狗。
06年时候在福州，华莱士汉堡三个10元，两个7元，一个4.5元。
有次晚上请同学去吃，我说先来四个汉堡。
店员，“四个汉堡，14.5元。”
我，“不是14吗？”
店员，“三个10元，加一个4.5元，是14.5元啊。”
我摆摆手，“不要三个加一个，我要两个，加两个。”
店员，………………
好了，可以点其他的了。","以前在一个小公司遇到的bug，一个只在阴雨天出现的bug，一个同事至今想起来还激动的拍轮椅
测试环境的服务器是两台实体主机放在我旁边的桌子下面，生产环境用的阿里云服务器。
某天前端开发人员反馈测试环境某些接口调不通，某些接口正常，经过排查，调不通的接口都在同一台测试机器。过去看发现机器居然关机了！
我们很奇怪，周末办公室没有断过电，为什么机器会自动关机？重启大法解决了。
然后这个问题谁都没放在心上，直到过了几天又出现了！
这下开始慌了，是不是谁写的代码里有隐藏的bug导致了机器会关机？
但是代码审查一直没有查到这样的代码，而且几个版本的迭代过程中生产环境从来没有过这样的问题
而这个bug像个梦魇一样，隔那么几天就来一回，而且我们发现每次bug出现的时候都是阴雨天。老板下令一定要找出原因，不然每次新版本上线都胆战心惊，怕问题蔓延到生产环境
于是我把两台服务器从桌子下拉出来摆在我脚边，就是要看看到底什么原因
后来...
.
.
.
.
.
.
.
.
.
.
后来问题找到了，天气一冷坐我对面的家伙就把腿抬起来放到测试服务器主机上，那里出风口暖和
不小心就把插头搞接触不良断电了
我们把他腿打断之后这个问题再也没出现过","写代码的时候记得把显示器屏幕擦干净点。。。。。。
                                -一个曾经被屏幕污点坑过的人(ノ=Д=)ノ┻━┻","有一次，上班时指头被a4纸划破，
虽然伤口不大，还是挺疼
就用创可贴把中指贴了一圈
第二天早上起来
打开一看，我去
竟然完全愈合，毫无痕迹
突然想起周星驰电影《功夫》里的
练武奇才
难道，我也是？
就在我向同事吹嘘时
他默默来了句
你看你中指旁边的指头
汗……
贴错指头了","看好多人都在说IT的事儿，我也说一个，不匿了，不嫌丢人！！
那是2008年，那时候的我...在公司主要负责数据中心这一块的项目实施和技术维护，日常比较拿手的就是服务器、存储、光纤交换机、Linux、
AIX
这些。
坐标郑州，某个项目需要去一趟张掖，对，甘肃的张掖。
那边的服务器有问题，我们做的项目，设备不到两年，掉电重启之后就是异常，卡死，进不了系统。
这个地方时以前没去过的，很远，所以很兴奋。
到了现场，确实蓝屏，各种操作都不行...其实这些不重要。
然后，那天下午，就联系了厂商，嗯，给IBM售后打了电话..
报了产品型号350和序列号...竟然查不到。
然后，我报了公司名称和我的名字，公司毕竟大客户，我在IBM也有认证证书。
服务态度很好，协助我排查问题，因为机房没外网，也只能电话沟通一项...
按照要求，做了各种配件的更换（现场还有其他机器）就是不行...
就算是重装系统，也是装不下去，一直折腾到第二天下午...
问题已经升级到了很高的位置，有个很牛逼的工程师（因为他帮我解决了问题）说：我们慢慢来，一步一步来。
到一步要进入RAID配置界面的时候，工程师说：按CTRL+H...
我按了F8进了RAID界面，随口说：这个是按F8...
然后那边沉默了会儿，幽幽的问我...兄弟，你看看服务器是IBM的吗？
我愣了一下，然后低头看到了HP的标....
当时...虽然隔着电话，我都能感受到对面那无语到透顶的语气...
真的，当时真想死了算了...
IBM有350这个型号，HP也有350这个型号....
不知道怎么挂的电话，赶紧联系了HP，工程师几句话的事儿，解决问题。
然后，我还没上火车，就接到了关系很好的公司商务（负责联系厂商、订货、培训、方案等等的部门）老总的电话，开头就是笑，然后问我：你找IBM了？
我特么...明显的，IBM估计给她讲笑话了，我没说啥，直接挂了电话！
第二年吧，参加IBM小机的一个会议...主持人在会议间隙，说讲个笑话...
当然人家没点名，只是说甘肃的一个项目，某个资深工程师为难了IBM一整天，最后发现报修的机器是HP的...
日了狗了！！","有评论说硬盘磁头防震，读取数据时拿着硬盘上下甩也没事儿。
首先上下甩是低频外力冲击，和播放青藏高原时的高频声波不一样。
其次硬盘外封装有减震作用，磁头也有防震设计，但甩硬盘还是有风险的。读写数据时磁头悬浮在硬盘盘片上的，磁头到盘片的距离是纳米级别，所以设计的防震级别也是有限的。
------------再一次的分割线-------------
有人问怎么解决问题的。就是把固定硬盘的螺丝紧了紧，固有频率改变，硬盘就不共振了。
--------------原答案的分割线-------------
听一个
希捷
的朋友说的。
有用户反映每次用笔记本播放
李娜
的青藏高原时，电脑就会死机。经测试发现，唱到最后的“那就是青藏高...”时，硬盘产生了共振，振幅过大，读写头读不出数据了。
为了抓住这个bug，朋友听了一个月的青藏高原...","        近读
欧丽娟
《诗论红楼梦》，读至第七章第一节（北京大学出版社2020年版第317页），有这样一小段：
        第六十四回“耳目所见尚如此，万瑞安能制夷狄”――宋欧阳修
《再和明妃曲》
（诗句见上）（《欧阳修全集》卷8，页132）。
图一、《诗论红楼梦》第317页截图
       读至此段，不禁哑然失笑，暗叹此书审校者不够精细，“万里”竟能误作“万瑞”。再翻几页，竟又有两处将“万里”误作“万瑞”，即本书“万里安能制夷狄”都写作了“万瑞安能制夷狄”。
      心中一动再细细一查，不仅此书，其他书籍、论文竟也有不少将“万里安能制夷狄”中的“万里”写作“万瑞”的。书籍如《古典文献学术论丛 第5辑》（李铁范等主编，黄山书社2016年版）、《桃李集》（俞樟华，潘德宝主编，黑龙江人民出版社2016年版）。论文如北京大学马里扬2012年之博士论文
《北宋士大夫词研究》
，复旦大学过元琛2010年之博士论文
《中国文学中王昭君形象的古今演变》
。这些书籍、论文均作“万瑞”。 
图二、《古典文献学术论丛 第5辑》第202页截图
图三、《桃李集》第420页截图
       我不禁大疑，《诗论红楼梦》、《桃李集》此句均转引自《红楼梦》，莫非是《红楼梦》的抄胥或印刷工匠笔误将“万里”误作“万瑞”？如此多的书论都出现“万瑞”，难道说此耳熟能详之句，尚有作“万瑞安能制夷狄”的其他版本吗？但如作“万瑞安能制夷狄”，那“万瑞”又是何意？
       于是我又仔细翻检了各种《红楼梦》古本及《欧阳修全集》、
《欧阳修诗文集校笺》
甚至宋元刻本的《居士集》、
《欧阳文忠公集》
等书，这些书却又均作“f里安能制夷狄”，而无一本是写作“f瑞安能制夷狄”的。
       真是怪哉！这个奇特现象真是让笔者百思不得其解了。
       无奈之下我想，我所看之《诗论红楼梦》，是北京大学出版社出版之大陆版，这里写作“万瑞安能制夷狄”，难道台湾原版也是如此吗？遂向诸友询问，可有《诗论红楼梦》的台湾里仁书局原版，并将所遇之谜题和盘托出。一友人听罢，笑回复道，“不用看什么里仁版，你把‘f里安能制夷狄’此句复制到WORD软件中，点一下简繁转换，将它转换成简体，一试便知。”
       我闻言一试，“f里安能制夷狄”使用办公软件转换为简体，竟然真的就是“万瑞安能制夷狄”。遂大惊，“瑞”字并非“里”字的简体字，怎么会出现这种现象？
      友人解释说道，这是因为有一些英文名字所对应的港台译法、大陆译法不同所致，例如在WORD软件中“尼克松”转换为繁体则变为“尼克森”，“约翰逊”转换为繁体则变为“詹森”。Ryan这个常见英文名，在港台被译为“里安”，在大陆则被译为“瑞安”，“f里安能制夷狄”中恰好有“里安”二字相连，因此使用办公软件自带的简繁转换功能进行转换时，“f里安能制夷狄”就变成了“万瑞安能制夷狄”。
       至此，我才恍然大悟，原来这么多书籍、论文都出现“万瑞安能制夷狄”这么奇怪的一句话，竟都是办公软件搞的鬼！嘻！虽事出有因，然竟有如此多作者、校者将作品发表之时未加细勘，亦可叹矣。
       老子云，天下难事必作于易，天下大事必作于细。岂可不深思哉！  
     经评论提示，要避免此错误，只需在使用WORD做繁简转换时，将“转换常用词汇”勾选项取消即可。
       结合评论区的指示，检索下，发现出现这种繁简转换错误的实在不少：
       1、“海内存知己”简体转繁体变为“海w知己”。百度搜索“海w知己”足有14,200个结果。
海w知己
       2、“K南捷健狈碧遄简体变为“终南快捷方式”。这个错误太常见了，出现“
终南快捷方式
”这种错误的书籍不下百种，也委实把我震惊了。
       
辛德勇
《版本与目录》三联书店2020年版：“只是这个世界上真心爱读书、一意苦读书的人少之又少，拿读书当敲门砖的人偏偏又急赤白脸地想要一夜成名天下知，能不刻意追寻终南快捷方式？”
      方勇《庄子鉴赏辞典》上海辞书出版社2010年版：“这种宛若陶潜所说的“问君何能尔，心远地自偏”的境界远要比那些隐身山林，却不忘高官厚禄、功名轩冕的欺世盗名、终南快捷方式之辈高尚可敬得多。”
     刘金柱主编
《纪晓岚全集》
大象出版社2019年版。乾隆上谕“徒以四库书馆，开幸进之阶，为终南快捷方式，又岂可不防微杜渐耶？”
      3、“巨集”繁体转简体变为“宏”，这导致很多帖子把“李彦宏”写为“李彦巨集”，百度一搜“
李彦巨集
”相关结果有近百个，全是“李彦巨集是中国网际网路企业家，也是百度搜索引擎的创始人之一”、“百度董事长兼CEO李彦巨集应邀到上海交通大学演讲”之类。
       4、“雪梨”繁体转简体变为“悉尼”，导致很多帖子把“冰糖雪梨”写为“冰糖悉尼”，百度搜“冰糖悉尼”相关结果有很多，内容读起来颇为搞笑：“川贝冰糖悉尼热量不高”、“悉尼和苹果去皮后切开”、“冰糖悉尼可以清热止渴”等等。
       5、“引怠狈碧遄简体变为“自变量”，导致很多网页文字版的《三国演义》会出错，出现很多“遂自变量骑下山坡来”，“便自自变量百骑赶来”，“凌统自变量千军马”之类。审校不细的书籍也会犯这种错误。
       廖彦博编
《三国和你想的不一样》
中国少年儿童出版社2012年版，
第60问：陆逊被困在八阵图里吗
：“逊笑曰此乃惑人之术耳，有何益焉，遂自变量骑下山坡来，直入石阵观看。”
       6、“列”繁体转简体变为“数组”，因此不少帖子和书籍会将九字真言“临兵斗者皆阵列在前”误作“临兵斗者皆数组在前”。
      李丰著
《抱朴子：不死的探求》
友谊出版公司2013年版：“祝曰：临兵斗者皆数组前行。凡九字，常当秘祝之，无所不辟。”
      王题著
《雾里看方术》
故宫出版社2011年版299页：九字源自东晋葛洪的
《抱朴子・内篇・登涉篇》
，又称“六甲秘祝”，祝曰：临兵斗者，皆数组前行，常当视之，无所不辟。
       7、“M曰o衣，c子同袍”繁体转简体变为“
岂曰无衣
，与子战友”。
       2015年华东师范大学艺术研究所编
《中国美术研究 第16辑》
：“《诗经，秦风，无衣》'岂曰无衣？与子战友'中的袍就是穿在外面的长衣。”小编，你这引文里都没有“袍”字啊喂 。","那年在淘宝买笛子，商家送了个陶笛，大概长这样：
娃上小学，笛子半天吹不响，这玩意儿就没这烦恼，于是开心地玩起来。
我上班时她得意地打来电话，说已经学会了2句，要吹给我听。  商家送的谱是“女儿情”， 她吹“鸳鸯双栖蝶双飞，满园春色惹人醉”，吹到一半电话不小心断了。好不扫兴，打过来重吹，吹到一半电话又断了！ 如是三次。 
这是碰到本专业的bug了啊，我兴趣来了。 拉着娃一遍遍试验。最终发现吹到“惹人醉”那个“惹”，电话必断。 见了鬼了！
坐在那儿分析：这是全曲第一次碰到“6”这个音，看来信道中某个设备对这个频率敏感，误检成了特殊的DTMF信号，触发挂断。 我的手机是广东联通，娃是湖北移动，经过的关口有点复杂。 我让娃打给她妈妈的同是湖北移动的号，果然没这个问题。",,"其实不算Bug
二十年前，某地电信局，一路光纤时断时续，因刚刚换过光路板，怀疑是新板子问题，各种检查、换板子均无果。
于是挂表查断点，开车上路到断点，发现线杆老化倒地，光缆被野狗咬开外皮，光纤未断，却缠住了狗嘴，狗嘴一张一合，光路断断续续。
史称“狗咬光纤”事件。",政治敏感？,"我高中同桌，上了本地一所理工大学。
大一新生入学，发现宿舍没有插座。
一群学理工的男生能忍吗？
当即分工合作，从日光灯的线上引了一根线出来搞成插座。
搞定以后集体欢呼握手。
昂首四顾。
热血澎湃。
随即发现墙边的插座。","在国内上大学的应该都知道有个校园套餐
我办的移动的，套餐里有50G校园内使用流量
还有1.5G国内流量。
BUG就是我在学校里上网，他却扣我国内流量，还记得是今年中秋节前，国内流量给我扣完了，实际上那半个月我都没出学校。
我就在宿舍坐着他还在扣，发短信了，超出流量5rmb
我就给10086打电话
跟她说了半天，
她说：我们没有权限给你补话费，等后台给您处理。
过了半天后台来电
客服：您好五块钱已经给您补上了
我：这半天他又扣了我五块钱，我一直在学校没出去，还在一直扣我钱，我校园流量还有40G没用呢。
客服：不好意思呢先生，退款每六个月只能申请一次哦。
我：我也不缺你那几块钱，可是问题你要给我解决啊、
1.马上中秋节我要回家，你能把误扣的国内流量补给我吗？难道让我用三毛钱一兆的流量？
2.而且为什么半年只能申请一次退款，这明显是你们的失误啊。
客服：不好意思我们也没有办法
 你们牛逼
移动真牛逼，无赖公司，你当爸爸就这样不管了？
果断登陆中国工信部投诉
一开始点投诉网页不会加载
我就很奇怪，为什么工信部网页能打开，这投诉界面就加载不出来
真相就是：他怕你投诉，所以你用移动网络无法登陆工信部投诉
呵呵
老子有vpn
我挂了个香港的vpn，立马能投诉了
然后填写投诉信息―提交
第二天早上
移动公司客服给我打电话
客服：您好先生balabalabalabla，我们赔钱，求您撤诉（大概这个意思反正）
我：可惜你们半年只能退款一次诶，我都被误扣三十多块啦
客服：会如数补给您
之后呢她赔给我一共70块
其实这些公司真的贱
明明自己的问题，非要推给客户
非要爸爸们举报你你才老实",猜测，可能对象没初始化。,"在10年前左右，不知道大家有没有看过一个广告：
步步高家教机
。 对，当时我老妈给我买了，为了让我提升成绩，当时是六年级，这是前提。
就是这个 家教机H8
数码圈的朋友都知道，这种家教机本质上就是换皮的安卓平板，系统是安卓4.1，这款机器的系统是高度定制化的，不能安装自带应用商城内以外的apk，自带的应用商城内的app少的可怜，绝大部分的都是学习软件，游戏也是有的，只不过都是诸如：经典五子棋，中国象棋一类的，当时流行的我的世界，天天酷跑，想都别想
没办法，很多方法我都试过，那款机器是可以插内存卡的，就是那种小的tf卡，我在别人家电脑上下载了apk，然后用tf卡安装也不行，显示无法安装，请到应用商城安装。
最绝的是有一次，机器的储存几乎满了，应用商城下载的一个应用没安装上，提示空间不够，然后apk保留在机器内了，本来也没在意，后来翻文件管理器的时候被我找到了，最最绝的来了，就是有那么一个灵感突然蹦出来了，
替换apk安装
（不愧是我），什么意思，就是说：
应用商城下载好apk他会自动安装的对吧，但是空间不够，它就会下载好但是安装不上，需要清理空间后手动点安装按钮，这就给我了替换时间，把要安装的apk包名改成应用商城下载的apk的包名，我到现在都记得，是把 我的世界.apk 改成了 中国象棋.apk ，替换进原有下载的 中国象棋.apk ，再卸载不要的软件腾出空间，然后到应用商城点安装，就能成功安装上了！
简单来说就是狸猫换太子，那真把我激动的跟周围小伙伴炫耀好久（那时候是住在城中村的小平房，小伙伴挺多的），显然他们听不懂我在炫耀哪个点，反正知道了我的那个学习平板可以打游戏了。
后来我用同样的方法下载了一些别的app，然后装上了第三方的浏览器，学会了上百度（自带的浏览器只能上官方给的几个网站，上不了百度），发现百度上也有其他人发了破解教程，破解过程跟我的方法差不多，不过更方便一点，就是直接安装个
apk安装器
，下次就不用填满储存，替换apk安装了。
总之，即使10年后的今天回想起当时破解成功那激动的心情，还是很有感触，如今玩数码圈，还是得感谢那个机器带我入坑。
――――――――分割线――――――
根据评论区网友的提醒，以上提到的“包名”为表述错误，替换为“文件名”。","说说我做Android系统遇到的一个bug。
测试妹子提了一个bug，说她在午休的时候看手机，屏幕亮度有时候会突然变亮或变暗。
我查看了log，没有特别的异常，亮度确实是变化了。午休的时候，我们是关灯的，光线比较暗，难道这个时候手机的亮度自动调节会有bug?  我把手机放到桌子下面黑暗的地方，抓取log，查看亮度，没有大的波动啊。但妹子却表示这个问题她很容易复现。
于是我决定找妹子当面聊聊。这是一个萌妹子，眉清目秀的，眼睛大大的，戴着一副圆框眼镜，微微泛着青光。在妹子描述她的测试过程的时候，我一直望着妹子美丽的面孔，不知道妹子有没有男朋友呢，妹子都有些害羞了，转过头去，突然间，我兴奋了，对妹子说，你转过来，让我看看，妹子惊愕的看着我。
我继续说，你的眼镜反光。
答案确实如此，眼镜反光，
L-sensor
接收到的亮度发生了变化，进而影响到了屏幕亮度。"
,,,,,,,,,,,,,,,,,,,,,
Bug是如何产生的？,最好可以通俗的解释一下！,"项目：学校里的一次月考。
程序：确保学生规范答题并交卷，返回学生的分数。
教务处开始提需求：要考语文和数学，高一高二高三分开来考，根据教材出题……
考务处开始写程序：要出这些题目，给学生分配考号，派监考老师防作弊……
普通用户行为：填写自己的唯一
标识符
(考号)，然后答题，交卷(上传)……
爬虫
：张三一天之内补考了1024次，把题库记的一清二楚。
身份验证漏洞：
李四
填了王五的考号替考。
DDos攻击：王六克隆了王七、王八、王九……王一二四把考场挤的水泄不通。
兼容问题：选择题只能用2B铅笔涂，老王用中性笔涂卡结果无法识别。
社工攻击：
小明
请校长喝酒，要到了试卷原题。
网络丢包
：老师收卷时滑倒，试卷飞出去找不到了
性能问题：老师需要3天的时间改试卷，这3天响应速度很慢。
木马攻击：小红帮助老师改卷，实则悄悄把自己的成绩改成了100。
逻辑bug：“春眠不觉晓，_____。”既可以填“处处闻啼鸟”，也可以填“处处闻啼鸟。夜来风雨声，花落知多少”。
热更新
：教务主任走进考场，告诉同学们“春眠不觉晓”后面只能写五个汉字，否则不给分。
抛出异常：改卷时发现学生字迹太丑无法识别。
异常捕获：规定看不清的字迹返回0分。","领导：修个房子。
程序员：好的，马上开始打地基！
领导：你看那隔壁那木房子就没有打地基，不要在小事上浪费时间，一个月水平面上面什么都看不到，你kpi不要了？
这是
敏捷开发
。
一层房子修好。
领导：我觉得两层楼的视野好，再加一层。
程序员：可是我们没有地基，重新打地基要时间……
领导：你一楼都修好了，照着再修个一模一样二楼很难？还要很多时间？
这是高速版本迭代。
二楼修好。
领导：天天走路累死了，你再修个电梯。
程序员：可是……
领导：没什么可是的，地基不稳？就在房子边上搭个电梯就行了嘛，不稳拿根木棍撑一下，这都不懂？
这是版本优化。
电梯修好。
领导：我觉得顶楼再加个游泳池就好了。
程序员：这个结构行业翘楚的房子也不支持呀！
领导：那不正显得我们牛逼么？修快点，夏天要来了。
这是快速功能追加。
游泳池修好，看着摇摇欲坠的房子，程序员跑路了，领导找来新人继续。
领导：我觉得游泳池水不够满，你加点的，一楼光线不好你在墙上打个窗户。
新人：好的，没问题领导，马上加一桶水，马上砸墙
这是打补丁。
房子塌了，电梯倒了，游泳池垮了……
领导：真是个废物，就让他加桶水，居然能把房子弄倒了，你说这是多没用？
新人：我真的就加了桶水，我怎么知道为什么。
这是软件莫名崩溃。","老婆给当程序员的老公打电话：“下班顺路买一斤包子带回来，如果看到卖西瓜的，就买一个。”
当晚，程序员老公手捧一个包子进了家门……
老婆怒道：“你怎么就买了一个包子？！”
老公答曰：“因为看到了卖西瓜的。","bug产生于人力有时穷。
知乎上看到的段子，但我不记得是在哪个答案了。。侵删：
一万个测试工程师在酒吧门外呼啸而过
一个测试工程师走进一家酒吧，什么也没要
一个测试工程师走进一家酒吧，要了一杯啤酒
一个测试工程师走进一家酒吧，要了一杯咖啡
一个测试工程师走进一家酒吧，要了0.7杯啤酒
一个测试工程师走进一家酒吧，要了NaN杯Null
一个测试工程师走进一家酒吧，要了2^32杯啤酒
一个测试工程师走进一家酒吧，要了一杯烫烫烫的
锟斤拷
一个测试工程师走进一家酒吧，要了一份asdfQwer@24dg!&*(@
一个测试工程师化装成老板走进一家酒吧，要了500杯啤酒并且不付钱
1T测试工程师冲进一家酒吧，要了500T啤酒咖啡洗脚水
野猫狼牙棒奶茶
一个测试工程师走进一家酒吧，又走出去又从窗户进来又从后门出去从下水道钻进来
一个测试工程师走进一家酒吧，又走出去又进来又出去又进来又出去，最后在外面把老板打了一顿
测试工程师们满意地离开了酒吧。
然后一名顾客点了一份炒饭，酒吧炸了。。","我以前玩过一款游戏，叫做
永恒之塔
。
里面有个巨大的BUG.
在新手村打怪，一只怪最多掉5块钱。组队平分，每人1块。
但组队可以组满6个人。
于是当你组满6个人打一只怪的时候，这5块钱就不够分了。因为1是货币的最小单位。于是惊悚的事情就出现了。系统开始每人几十万，几百万的分。这个BUG就是个逻辑错误。
最后，因为刷钱被封号了。","请出一组有点久远的图片。
---------
客户是这样描述需求的
项目经理是这样理解的
设计出来是这样的
开发出来的是这样的
测试的时候是这样的
顾问是这样形容的
实施是这样的
顾客得到的是这个样子的
顾客真正想要的是这个样子的","飞机上，乌鸦对乘务员说：给爷来杯水！
猪听后也学道：给爷也来杯水！
生气的乘务员把猪和乌鸦扔出机舱。
乌鸦笑着对猪说：傻了吧？爷会飞！
（出现BUG）
这时，猪伸出翅膀扑哧扑哧问道：你说什么？
（
修改BUG后
）乘务员发现自己莫名其妙在飞机外飞，同时还给乌鸦和猪两杯水，而且三个飞得比飞机还快......",哪有什么bug，都是规则内的可行解。,"之前在网上看到一组关于程序员的漫画，觉得用来回来这个问题很贴切！侵删
最后和程序员身边的朋友们嘱咐一句，就算程序员的工位再乱，也不要帮他整理。否则，当心会毁灭世界哦
-----------------------------------------我是分割线-----------------------------------------
请各位大佬支持一下我的这篇原创问答：","根据我从业十五年的经验，bug一共就三种原因：
我艹，没想到！
我艹，打错了！
我艹，你没告诉我啊！","     系统已上线,一切正常!","理发师：我给这个村里所有不给自己理发的人理发。
bug：理发师给不给自己理发？
补丁：给村里所有不给自己理发的人(不含理发师自己理发。)
测试：七大姑八大姨都来理发试试
用户：给我的牛理个发。",通俗易懂。,"Bug的产生，通常分为三种类型：
逻辑漏洞、越界访问、条件考虑不全面
。
为了便于你理解，我以女朋友来大姨妈举例。
某日，你收到了女朋友的一条微信，跟你说自己来大姨妈，肚子疼。这时，你要写一段文字回复，这段回复你就可以认为是你写的一段代码。
这段代码需要达到的目的是让你的女朋友感受到你对她的爱，增进（至少不减少）你俩之间的感情。我们可以把这个目的当成你对自己提出的这段代码背后的产品需求。
1，逻辑漏洞：
你：我叫外卖来给你买个热饮吧。
女朋友：滚！你是想让我从床上趴下去给外卖小哥开门么？
分析：低级错误，程序执行后无法达到想要效果。
2，越界型：
你：我给你室友打个电话，让她帮忙照顾下你。
女朋友：滚，谁让你联系我室友的。
分析：访问了非法区域，造成程序崩溃。
3，条件考虑不全面：
你：亲爱的，我早就知道有这天，所以暖宝宝、热水壶、痛经药....(此处省略一万字)，我都给你准备好了，就在家里。
女朋友：我现在在地铁站。
分析：你以为你万无一失，但你永远都不知道输入参数究竟是什么！
除了上面三种主流错误，还有一大堆，这里就不细说。
我跟其他答主不一样的是，我不光要告诉你们Bug是如何产生的，我还要跟大家解释我们程序员平常如何防范未知Bug，因为你们也看到了，Bug就像你女朋友的微信，你永远不知道她下一句攻击你哪个点。
所以，这里要祭出利器：
异常捕获
。
异常捕获一般依靠try，catch语句。很好理解：try（尝试）一下，如果有问题，直接捕获（catch）住，防止程序崩溃。
什么，你没听懂？我这么写你可能就懂了：
女朋友：我来大姨妈了，好难受。


try
 
{


你：
xxx
。


}


catch
(
Exception
 
e
)
 
{


你：对不起，我触发了“
e
”，都是我不对，你现在选个包包，我去给你买。


}


女朋友：爱你！


完。
补充：
评论中有人提到了没有理解需求导致的Bug。这里我要讲一下，对于普通程序员来说，那可能就是Bug。但是对于我胖总来说，那是我设计的feature。对于能够产出结果的东西，只要运行时没崩溃，我都能把它描述成是我故意编写的功能。
所以，在需求错位的时候，到底是低头背锅，认了那就是一个Bug；还是昂首挺胸，说就是那么设计的功能？
这！不光是你的态度问题，还决定了事情的走向。
与其战战兢兢地怕出了Bug惹女朋友生气，不如思考如何霸气回应她的Diss，把自己的所作所为描述成你精心设的结果，前提是要有理有据。
来，跟我一起说：
世界上本没有Bug，只要你放下舔犬的自卑，迎难而上，用顶层架构者的语气反击所有指出你问题的人。
你收获的不仅仅是他人的尊敬，更是没有年终奖的清心寡欲和被逐出公司的人生自由，以及孑然一身远离女色的开悟人生。
加油，你行的。",洗衣机厂家，打死也没想到，自己的产品总出问题，原来他们拿它洗土豆,"说一个DNF里面比较经典的bug
1/史诗级装备因为属性强悍是不允许交易的
2/死亡之塔内不允许任何物品进行交易
这两个条件合并起来你能猜到会触发什么bug吗？
没错！我亲眼见过有人在死亡之塔里面交易史诗装备，嗯~双重否定表示肯定~没毛病！","程序员转行后，准备开一家咖啡店
经过精密的设计、采购、装修后，程序员觉得不错，决定试运营，请一个测试来喝咖啡
测试走进了咖啡店，点了一杯卡布奇诺，然后拿着咖啡高高兴兴的走了……
测试走进了咖啡店，点了一杯美式，然后拿着咖啡高高兴兴的走了……
测试走进了咖啡店，点了一桶焦糖拿铁，然后扛着咖啡桶高高兴兴的走了……
测试走进了咖啡店，点了一箱五粮液，然后拎着五粮液高高兴兴的走了……
测试走进了咖啡店，点了一只拉布拉多，然后牵着拉布拉多高高兴兴的走了……
测试走进了咖啡店，点了一个老婆，然后抱着老婆高高兴兴的走了……
程序员对这一天的试运营很满意，于是第二天正式开业
开业当天，一个顾客走进咖啡店，问“洗手间在哪？”
然后咖啡店炸了","一个测试工程师走进一家酒吧，要了一杯啤酒；
一个测试工程师走进一家酒吧，要了一杯咖啡；
一个测试工程师走进一家酒吧，要了0.7杯啤酒；
一个测试工程师走进一家酒吧，要了-1杯啤酒；
一个测试工程师走进一家酒吧，要了2^32杯啤酒；
一个测试工程师走进一家酒吧，要了一杯洗脚水；
一个测试工程师走进一家酒吧，要了一杯蜥蜴；
一个测试工程师走进一家酒吧，要了一份asdfQwer@24dg!&*(@；
一个测试工程师走进一家酒吧，什么也没要；
一个测试工程师走进一家酒吧，又走出去又从窗户进来又从后门出去从下水道钻进来；
一个测试工程师走进一家酒吧，又走出去又进来又出去又进来又出去，最后在外面把老板打了一顿；
一个测试工程师走进一家酒吧，要了一杯烫烫烫的
锟斤拷
；
一个测试工程师走进一家酒吧，要了NaN杯Null；
一个测试工程师冲进一家酒吧，要了500T啤酒咖啡洗脚水野猫狼牙棒奶茶；
一个测试工程师把酒吧拆了；
一个测试工程师化装成老板走进一家酒吧，要了500杯啤酒并且不付钱；
一万个测试工程师在酒吧门外呼啸而过；
一个测试工程师走进一家酒吧，要了一杯啤酒';DROP TABLE 酒吧；
测试工程师们满意地离开了酒吧。
然后一名顾客点了一份炒饭，酒吧炸了。
网上搬运的","刚修复了一个BUG,给老板演示的时候","我开发了个订餐系统，金额用double类型，但我没想到，你的交易货币是
津巴布韦币
，甚至还有天地银行。"
,,,,,,,,,,,,,,,,,,,,,
将 bug 译作「Mx」，将 debug 译作「WMx」，音译兼意译，是不是很巧妙？,"因为 bug 和 debug 已经属于 IT 领域专有名词，错误和除错这种词义宽泛的词语不足以准确描述其特指软件相关的含义，中文译名也「专有」一下未必不可行。专有名词不会污染常用语。
不全是开玩笑，一个尝试，想试试那些所谓不能翻译的英文是不是真的不可译。
至于怪诞感，为了与常用语明确区别，怪一点是有意为之。专有名词，只用于特定场景，与常用语区分是必要的。英文并不是没有同义词来指缺陷和错误，但他们故意用虫子这个词，就是为了让它成为特指的专名。
将 buff 译作「B?」，将 debuff 译作「WB?」，音译兼意译，是不是很巧妙？
204 关注 ・ 128 回答
问题
【 bug 】：
1.（especially American English：a small insect）小虫子
2.（计算机程序的）错误，故障o缺陷。
【 debug 】：（计算机程序的）除错。
【 M 】bā ：伲海M。《正字通》：“M，佟＝耠南钬多用，呼海M。本草作??。” M、，一之D。古r以ぷ髫拧＃bug 即是码农的麻烦，也是码农的经济来源。）
【 x 】 gé：蛴螬。又名蛭x。金龟子的幼虫。《方言》：“螬，梁益之g或^之x，或^之蛭x。”
【 金龟子 】：昆xV，鞘翅目，金子科昆x的通Q。已知3fNN，中有1300NN。徐珂《清稗n》：“金子，俗Q金x，wL六七分，金G色，背有甲，六足，N甚多。有一N害稻者，其幼x色白，是橄螬，稻根，m食之。及化槌上x，仍食稻~，旋a卵於~鞘，r家苦之。”（农家苦之：码农苦之。）
【 W 】dì ：捐弃，去除。（词根 de：取消、除掉、去掉）","翻译得挺好
这仨字光看着就能感受到一股腥膻咸湿的
克苏鲁
气息，很是能准确复现debug时的精神状态
下次别翻译了","阁下不会就是翻译出
“
鲁棒性
”""巴勒斯坦""""泰晤士报""""车厘子""""
红地厘蛇果
""""老头滚动条""“半条命”“套套逻辑”“套接字”“诱导公式”“方程式赛车”“把属性映射为属性”""双亲委派机制""""
酉矩阵
""""秩""""卡宾""""氮宾""""
叶立德
""""缺省""""渠化""""死投""
的那位姐吧。
――――更新，应要求添加一下这些词的解释：
鲁棒性
：robustness，robust意味健壮，强壮，应该译为健壮性，稳健性，强壮性，稳定性均可，译者不知何故要音译，由于词汇太过古早，也可能是译者当时不懂这个词的含义，总之结果导致其在国内教材中广泛使用，造成了大量学生的迷惑。
诱导公式
：原文是reduction formula，即
简化公式
，译者翻译的时候可能用的是盗版书，国内标注的是induction formula，也可能是记错了单词的意思，因为其把reduction（减少）当作
induction
（归纳）来翻译，但最终的译文甚至没有体现出induction的意思，也就是说经过了两次错译才最终变成了“诱导公式”这个不明所以的名字，并且被我国高中教材广泛使用，以及各种教辅，培训班强行解释“诱导”的意思，导致越传越广。
半条命
：应为半衰期。
老头滚动条
：应为上古卷轴。
车厘子
：cherry就是樱桃，译者非要音译出另一个物种来。
红地厘蛇果：
delicious apple就是苹果，译者非要把delicious音译为地厘蛇，再加上红字，听起来像是“红地”这个地方的物种“厘蛇果”。
泰晤士报
：原文是“The Times”。并没有“泰晤士（Thames）”这个发音，不仅丢失原义，还让人对该报纸的发行地产生误解。
巴勒斯坦
：应为巴勒斯丁，见答主“
知乎用户ObE5mQ
”的回答：
套套逻辑
：tautology，原义“同义反复”，纯音译导致的怪异翻译。
套接字
：Socket，原义插座，接口。
方程式赛车
：见用户“西瓜回路遮断器”的评论：formula使用了错误的意义。
把属性映射为属性：
把property映射为attribute，译者（可能是机器）翻译时没有考虑其意义。
双亲委派机制
：parent delegation，应为父类代理，当然，对于某些用户，非要译作
母类代理
我也没有意见，译为“双”会让人误解程序的继承关系。
酉矩阵，秩
：Unitary Matrix
，
Unitary即单一的，被译作“酉”，中文意义看起来像是指十，鸡，很多，或者两年半。rank即排，列，被译作“秩”。
卡宾，氮宾，叶立德
：见知乎用户SZnCu的回答：
缺省
：默认值，原文default，不知道为什么要翻译出“缺省”，同时失去了缺少，默认两个意思。
渠化
：见用户
庆晓筱
的回答：
死投：
Dead Drop，标准译法：固定情报投放点。见用户黄金大亨的回答
Mx：
原文bug，译作“Mx”，一晃眼还以为是浏览器没安装UTF-8出乱码了。","我觉得不如叫 
涤悖格
涤 洗涤，去掉
悖 不合理，冲突，错误
格 格式，标准，规范，结构段落
悖格 谐音bug，导致错误，冲突或不合理的代码结构。
我觉得比你编的那个更加复合翻译的三要素，
信达雅
。","我觉得不巧妙。
因为你这样文字太多了，文字笔画太多就不好写了。
可以简化一下。
例如bug，音是：八各。
为了简化，可以把“各”简化成为“??”，八字没必要简化了，就两笔。
为了区分汉子和翻译，咱们可以把这部分文字增加角标。
最终成品：bug→バグ",挺不错的，一眼就有种字符集出错的感觉,"目前来说，我见过最秀的英文翻译是战锤的四大邪神名字的翻译，读音相似的同时还彰显了人物设定（而且字没那么生僻）
给路人来段背景和介绍
恐虐：Khorne，代表是颅骨与鲜血，设定中代表难以遏制的好斗，丧失心智的疯狂以及淹没战场的滚滚血海，信仰恐虐的自然都是战场狂战士。
纳垢：Nurgle，代表瘟疫和无穷无尽的死寂，世界上所有瘟疫都是在纳垢精心调配下产生，纳垢接纳所有信徒，不论老丑、善恶。
色孽：Slaanesh，代表放纵享乐堕落和感官刺激。欲望，骄傲和自我放纵是所有追随他的人的标志。
奸奇：Tzeentch，混沌四神里最多变狡猾的邪神。有人说奸奇来源于希望，象征着智慧。但那早已被邪恶的混沌所扭曲，奸奇的希望来源于受害者身处绝境无限的绝望与千方百计的求生，智慧则来源于那无穷无尽的算计与阴谋。
另外附上台湾（港译）译名：
恐虐-Khorne-哥达/科恩
纳垢-Nurgle-乐高/奈格
色孽-Slaanesh-沙莉士
奸奇-Tzeentch-
辛烈智
相比较下是不是看得出来译者很用心
更正：根据评论区 
@滴滴滴滴
 大佬提醒，现行四神的翻译最早反而是出自台湾民间论坛的，后来被gw收编，大陆传入时采用的台版翻译，最后也被gw简中部门采纳
答主举的例子其实是港译，至今仍是gw港版官译，偏向粤语音译 大陆锤圈港译一度和台译分庭抗礼，现在很多老锤友都更习惯叫色孽.“
沙历士
”
调查少了，我的问题
感谢评论区 
@苏止胡
 提醒我还有绿皮（Green skin）的翻译
先说背景，绿皮是战锤世界里的兽人（Orks），属于比较欢乐，每天只知道打打沙沙沙沙沙的种族，可以理解为绿色并且爱打架的小黄人，绿皮的科技基本全内置在dna里，并且带有搞笑角色属性，最爱做的事就是四处捡垃圾然后拼个不稳定但是能用的武器出来
整天打打杀杀的兽人信仰搞哥（Gork）和毛哥（Mork），搞哥野蛮而狡猾，毛哥狡猾而野蛮
绿皮的终极泰坦单位叫大脚（Stompa）来源于英语单词跺脚（stomp）国内一般戏称这玩意叫古巨圾，虽然没音译不过蛮传神的
这玩意长这样
另外还有绿皮的技术科研单位技术小子（Mekaniak boy简称Mekboy），这玩意的高级版本叫做大技霸（Big Mek）
兽人聚在一起会发动一次声势浩大的Waaaaaaagh！！！，而他们的头领则叫做哇博士（War Boss）",我见过把【bug】翻译成【幺蛾子】的，比你这靠谱多了,把Coca-Cola翻译成蝌蝌啃蜡的人该不会也是你吧！,"你自己大可以尽情的使用。但是建议不要跟我们讲。
大伙真没兴趣了解你那两个破虫子。
这个答案纯是被这个破问题气乐了、骂了句街，没想到有人看。多说两句。
当我看到题主的这种想法，我直接想到的是另外另一件事情。有些人在使用手机的时候，不喜欢设计师精心调教好的默认字体，而是换成了花里胡哨的个性字体。我今天刚收到过这种人发来的屏幕截图，一打开就感觉到两眼一黑。
此图片来自知乎上的另一个问题
这和题主的想法的共同点在于，在不适合追求美的地方追求美。
美当然是我们要追求的，照片，电影，诗词，小说，家居装潢，有得是地方让我们追求美。没必要在专业词汇和手机字体这样的、极大的影响着信息的传递效率和准确性的地方，牺牲效率和准确性去追求美。或者说，这些地方的高效所带来的益处，完全能让我们在其他地方得到更多“美”。
比方说，一本修仙小说，说有一种灵猴，能在太虚之中操控复杂的大型法术，叫乘虚猿；但是太虚中会滋生干扰法术运行的精怪，公的叫M，母的叫x；乘虚猿每天必须要去除Mx来使法术正常运行。这个梗虽然够烂，但毕竟是在小说中，我是乐于见到的，因为小说就是追求娱乐的地方。
但题主说的是“不全是开玩笑”“是不是很巧妙”，洋洋自得的认为，这种巧妙就是我们应该追求的东西。其实错了呀，管你
《方言》
《正字通》云云，这几个字就是生僻字，就是徒增了理解难度，就是进行了不必要的翻译，就只有你自己会玩这玩意儿。如果有人对这东西感兴趣、觉得还不错，大概率是因为他平时并不编写程序，也用不到debug。
总之，把生产力的东西归于生产力，把美的东西归于美。","恭喜你，发现了
片假名",看大家的评价，有一种小学男生花几天想了个自以为很酷的网名然后被嘲讽的美。,"我记得有个问题是“文字有没有
恐怖谷效应
”，这个题目就很适合作为例子，那五字被题主强行堆成词，一看就莫名烦恶难受，有一种强烈的不舒服的感觉。","百度搜索
鲁棒性","挺好，挺好笑的。
如果真的把 bug 显示成Mx会有人觉得你电脑出了 bug。","有一种
网易云
初中生翻译的歌词的美",你的出发点很好，但是你先别出发。,"要我说，不如
锟斤拷
烫烫烫。
debug，就叫屯屯屯锟斤拷烫烫烫
今天，在我的程序中发现了一个锟斤拷烫烫烫，我把它屯屯屯了。
一看就懂好吧。","不好。
应该把bug意译为“虫豸”。
debug叫“除虫”。
图为程序员正在debug",有一种片假不留的美,不如翻译成幺蛾子。
,,,,,,,,,,,,,,,,,,,,,
王小波的计算机水平有多好？,"王小波的计算机水平到底有多好，在王小波自己的小说中，王小波非常骄傲地说，写书的软件都是自己编写的，王小波是自学的还是教的？都会什么语言？
谢谢各位！！","以下文字都是我本人写的。为了让阅读方便，减少模糊性。我在文中以第三人视角描述。 而不用“我舅舅“，”我姥姥“，”我大舅舅“，”我小舅舅“之类的称呼。 这是一个十几年软件工程师的习惯而已。 
我舅舅是王小波。我是个禁不住人肉的老百姓。资质平庸。 王小波一篇《我是怎样做青年思想工作》的杂文在我青年单身适龄的年代，给我个人做了最大程度的广告。算是他老人家留给我最宝贵的遗产之一。 除此之外，还有他那台用了很久的PC，在他去世前一年送了我。
    他是汇编高手。自己用汇编写了
DOS
下的汉字输入法。输入法有个功能，可以加4声。 一般拼音输入法没有这功能。这需要普通话读音正确的使用者。90年代总共也没几种汉字输入法。看过他用自己输入法打汉字。速度几乎和盲打英文一样。那时候我大学，正在疯狂苦练吉他。并没有弄懂他用了何种技术。虽然我从小学也用Z80和
APPLE II
 做些机器码编程做游戏。但到了中学为了高考，计算机就荒废了。
    他人生最后几年，WINDOWS 3.2开始普及。然后是
WIN95
。 他开始从DOS转向
WIN32 SDK
编程。最终非常任性地熬夜苦干了很长时间，把输入法转为WIN32 SDK 在WINDOWS下正常工作。当时WINDOWS已经有不少汉字输入法。 尤其到了WIN95时代。 他这么做也只是出于兴趣而不是在DOS时代的必须。就WIN32 SDK我们还讨论过一些。那时候win32 
sdk
真的是很难用。主要是互联网还没有（我是96年后用上的），资料很少。
匈牙利命名法
陌生。WIN32的体系和DOS大相径庭。全部都很陌生。而且完全抛弃了DOS那套东西。所有90年代DOS底层程序员向WIN32的迁徙都是一部血泪史。
    他人生最后一年，多媒体开始普及。光驱，声卡，2D加速卡普及。95-96年他开始和我合计做多媒体出版。原因现在想起来很悲伤 ------ 他的书很难在大陆出版 。 他不得不想办法让他的作品能够让更多人看见。而平时维持生计，只能忍着严重的痔疮，每日给各种杂志写杂文稿件。 多媒体的兴起，让他感觉也许可以利用他的技术优势，自行制作电子出版物。配上插图，音乐，用电子书籍方式可以让自己作品为大众所见。他给我看了已经制作了一部分的DEMO。就和现在用Micromedia多媒体制作软件制作的电子多媒体制品很像。电子书内容是
黄金时代
。有图案的背景。按空格可以翻页。同时有音乐。好像偶尔还会有一点动画的特效（我记不清了） 。但当时的DEMO完全是他自己用WIN32写的EXE 可执行程序。 他那是从WIN32 SDK移植输入法时，基本掌握了消息处理，
GDI
，窗口控制等方法。还有一些底层的TRICK。
    我大学后和王小波比较近。那几年每周末都在他母亲家相聚。他母亲5个儿女，只有他1个人在国内。于是他就经常住在母亲家，怕老人一个人，是个大孝子。母亲家旁边有个
筒子楼
里2间房的小屋，公共厕所和水房，冬天暖气烧得极热。偶尔我会和他住一块。里屋是他的生活起居和写作桌。外屋很小只有张床。他弟弟的孩子和我偶然会睡外屋。印象最深的就是他烧普洱茶的电炉和玻璃茶壶。里面总是有极浓的茶水，下面沉淀着大量茶叶。估计熬夜就靠那个。
    目睹了他后半截人生（从我记事起到他去世，中间他出国很多年）。感慨很多。王小波有个八叔，当时双手打算盘，无比聪明是个天才。年少夭折。王小波父亲因为搞逻辑学，引起毛泽东注意，被毛接见聊了一下逻辑学的学术相关问题。69岁心脏病发独自倒在家中过世。王小波去世方式和他父亲一模一样。区别仅在更加年轻。王小波哥哥在受文革影响挖了10年煤。后来去美国博士念
数理逻辑
，解决了一个100多年未解的数理逻辑问题。最后的博士毕业论文自己系的教授搞不定，专门找了数学系的教授来看。毕业后他哥哥因为被文革耽误岁数太大。没有继续科研工作。
    我的最大感慨是，留得青山在，不怕没柴烧。天才也好，资质普通如我也好，人都只有一个人生。王小波妈妈去年92岁，10月刚去世，白发人送走了自己两个儿子，又过了十几年才走。之前得过癌症，靠自己毅力锻炼，恢复了。王小波去世后一年，王小波弟弟又突然去世。当时孩子都没敢告诉老人。老太太感觉不对，但又无法得知真相。只是和我说她的疑心。当时国内只有我一人，只能瞒着。不停劝慰老人没事。老太太喃喃说，“除死无大事，除死无大事啊” 。 
    除死无大事。 人生在世，碰到什么坎，都只会是你人生中一个普通的节点。时间一长，什么都会成为过眼云烟。 留份宽心，也许这样导致目标感没有强到能和社会精英逐鹿。但只要有耐心，不怕挫折，假以时日，目标总会实现的。作为一个42岁还在以玩游戏看动漫为生活主体的大叔，保持健康和有活力地追求智慧和有趣，做自己热爱的工作，保持善良，做精神自由的人，是我从王小波的人生学到最重要的东西。希望每个喜欢王小波的人，都有自己充实和健康的身体和精神。","这个月有两个人被拿出来隆重纪念，都是早就计划好的。
一个是张国荣，一个是王小波。
你得承认不少人是在张国荣自杀之后才听说并喜欢上这个“哥哥”，王小波也一样，97年他死得很突然，名声也在身后突然爆炸了起来。
1994年，王小波的
《黄金时代》
终于在大陆出版了，华夏出版社搞了一个研讨会，一共只有20多个人参加，李银河亲自上阵做了会议记录。
1994年也是中国互联网元年，中科院高能物理所第一个接入了互联网，丁磊从同学那里借来了一个账号登上了yahoo，张朝阳从MIT回国，
王志东
创办四通利方，马云创办
海博翻译社
并在美国第一次看到了互联网，
张小龙
也是那一年毕业直接辞掉了电信局的工作去了广州。
如果你在那个时候搞一个互联网研讨会，估计能到场的也就是20多人。
说不定里面就有王小波。
1992年前后，王小波写了两年“科技博客”
知乎网友Vernsu把王小波作品、书信里面和计算机、互联网有关的信息全都摘录出来做了一个网页，大家可以点击 
王小波和编程
 查看全文。
一共18条，其中14条写于1991年春节后到1993年春节前这两年时间里。1992年“更新”最为频繁，王小波写了自己做统计软件、输入法的事情，还有购买、维修计算机的经验之谈。
从中能看出来王小波是在美国读研究生期间接触的计算机，回国之后在人大负责一个计算机室，但是因为软件奇缺，又要做一些社会学研究的东西，所以开始自己接触编程。
王小波先后学了
Fortran
、汇编语言和C语言。为了做出软件需要的中文窗口和在电脑上输入自己的小说，他参考严氏拼音做了自己的输入法，实现了自定义拼音字库、输入后再修改这样的“高级功能”。
因为王小波的
IBM
 PC/XT内存很小，
李银河
又不准他花钱买新的，所以他费了很大精力把软件的大小控制在55K以内，这让他很得意。但是因为turbo.c的原因，软件兼容性不太好，而且图形显示的速度一直不行，让他承认自己技不如人。
如果当时有互联网让王小波可以把这些文字共享出来，那他可以称得上是中国第一代科技博客作者。
但是1995年，中国接通互联网后不久，王小波的“科技博客”却停止更新了，最后一条是：
本来中国有几个国内网发展得很快，现在又出了问题，谁要上Internet，必须到有关部门去登记，留个案底，以备当局监控，很有一点监狱的气味。我还不想找这份麻烦，再说，通过ChinaNet联网，每月也要交七八百的月费，我也没有这么多的钱。既然×反对信息时代，我们就不进这个时代罢，有什么法子。所以还是写信好了。
来不及创业
王小波如果不是这么耿直的Boy，他本来是有机会创业的，在他的“科技博客”里面，他已经看出来很多商机，
现在国内软件一面混乱，又逐渐有形成市场之势。首先以年兄学统计这一事实来看，回来做事非有会用的软件不可。
中文软件（严氏By×）我用着尚好，而且又用C语言仿编了一个，程序是我的，拼音字典是人家的，执此招摇撞骗，骗了一些钱。
史玉柱
、雷军的第一桶金都是
汉卡
，如果王小波抓住了
软件汉化
和中文输入这个“风口”，就不只是骗一些钱的事情了。
我有一段时间很关心PC的发展，听说美国微机多媒体搞得甚火，微机接电视，音响，
vedio
等等。这玩艺听上去倒是蛮有意思的……
Macintosh
根本就没打进中国市场，你非带几个可用的IBM微机软件回来不可。照我看，苹果机还是买不得。因为IBM-PC的兼容机队伍庞大。
INTEL
又总能推出新一代CPU，将来还有大发展。
机器坏了。居然叫人敲去150dollars，老兄真是有钱。现在的微机修理都是换线换板，机器一坏，先找块表量量是不是电源坏了。只要不是电源坏，估摸是哪部分不好，就去买块版换上。我的机器里什么牌子的板子都有了。送出去也是这么修，还要敲你手工钱。我看150什么板子都能买来……中国要加入关贸总协定，这类东西要掉价。
王小波还关心了一阵硬件的发展，研究了国内进口电子产品的政策。因为穷，所以锻炼了自己维修装配电脑的动手能力。如果继续朝着这个方向发展，王小波应该在中关村盘下一个档口销售、维修兼容机，说不定就没有后来刘强东的故事了。
可惜王小波很快见异思迁，开始把精力放到了文学上面，
我现在软件写得出神入化，并做出了各种写小说的工具，别人的软件已不用了。
不过现在我对微机已无兴趣，因为发现写小说也可赚到钱。
从今年初开始写长篇，首先做了写长篇的专用软件，现在基本调通，开始写了。
我们知道写下了《
大连金州不相信眼泪
》的老榕，后来做了中国第一代B2B电子商务网站8848。一大批文艺青年，包括张向东和
王微
，先后投身媒体、门户和视频网站的创办。
更不要说今年是内容创业的风口，王小波若是活着，即使已经是接近65岁的人，也符合超级IP的设定，出来拿投资，
Papi酱
的1200万肯定是不在话下。
但是有个创业的外甥
然而王小波毕竟是个耿直的Boy。
我们没办法验证他如果创业究竟会发生什么，历史不容假设。
但是王小波在《我怎么做青年的思想工作》一文里面写过他的一个外甥姚勇（
姚勇
本尊 
@王书
 也跑过来答题了，大家速去围观），也是一个耿直的Boy，喜欢摇滚，喜欢文艺，又喜欢编程，一心把王小波当成楷模。爸妈的话不听，舅舅说话就听。
姚勇听舅舅的话考上了清华，毕业做了程序员，但是没放下摇滚梦，帮
水木年华
做了一段时间音乐。07年他接受《
南方人物周刊
》采访回忆王小波，说丁磊曾经来挖他做3D游戏引擎，他不认识丁磊拒绝了，后来发现
丁磊
居然成了中国首富，
“我当时还摇滚青年的范儿，傻逼嗬嗬还真拒了个首富。要知道后来想做的这白日梦会给我带来那么多技术之外的破事儿，我早上赶着颠儿颠儿给人写3D引擎去了。”
所以就在07年，这个耿直的Boy上赶着颠儿颠儿去给马化腾写了《QQ炫舞》，全盘抄袭了
《劲舞团》
。
但是毕竟是王小波的外甥，抄完了在
CSDN
上骂娘，
“下一款游戏没人逼着全盘抄了”。
所以你看，王小波要是生在了今天，说不定就跟这个外甥一样，去给人写网络小说、编段子、做游戏去了。做得不顺，也会吐槽骂娘，骂得比别人都好看。
王小波说过，
“这个世界自始至终只有两种人：一种是像我这样的人，一种是不像我这样的人”。
我们创业者，究竟是像他的那种人，还是不像他的那种人？
----------------------
本文作者老编辑，首发于
微信公众号
老道消息（laodaoxx），原标题《1995年，王小波的博客停止更新》。老编辑的团队正在招募一名对世界不太友善的女性写手，对时尚和设计要有点感觉，对科技互联网有点兴趣。简历发送到4@bushangban.com","说说我自己的理解。
王小波，新中国历史上最早的程序员之一，小说圈中的Geek！
早在90年，王小波就
自学编程、C等语言
独立研发了
中文编辑器和输入法
靠买软件赚了一大笔钱
深受很多中关村老板的喜爱
纷纷邀请他做
资深程序员
当时的马化腾还蛰伏在深圳电信，腾讯还没有影子，马云还在思考
中国黄页
的出路，李彦宏还在加州的院子里种菜养花，日后统率中国互联网的BAT连一个萌芽都算不上啊！
这位
神奇的程序员
究竟有着怎样的职场故事？
他是如何做到从编程到文学的无缝跨越的？
且看下文
王小波，骨子里有着极客的精神
早在90年代初，王小波就接触了计算机。1988年，他毕业于美国匹兹堡大学东亚研究中心，获硕士学位，那时就知道
Macintosh
，玩过
IBM
PS/2
。
90年，
学习
FORTRAN
，开始进行数据统计，并开始在北大教统计学。
91年，搞了个用
调整字模发生器方法
输出汉字的系统
92年开始
自学C
，做出了各种写小说的工具。
93年开始
搞汇编
，“下决心买了一台286，这些日子在改造软件，作了不少汇编工作。其核心是它在虚拟保护方式(virtual address protected)下工作，以便利扩展内存(expandedmemory)”。
……
没有理想的应用软件，那就自己创造
早期，因为国内应用软件缺乏，尤其是中文编辑器和输入法。很喜欢写文字的王小波，就琢磨着，能不能自己编一套出来。说干就干，爱捣鼓东西的王小波就利用闲暇时间学习了FORTRAN，汇编，C等各种语言，接着又学习了数据结构，算法的相关知识，还有编译原理，终于创造出了中文编辑器和输入法。
在当时，这两个软件中的任何一个，都是大牛级的Geek才会去尝试的东西。这对一个当时爱写文字的他来说，简直天方夜谭，而且，类似的中文编辑器也就
严援朝
的CCDOS和
求伯君
WPS1.0
，都是个人倾毕生所学以及背后的长城公司、金山公司投入大量的人力物力的结果。
通过卖软件，王小波也赚了一些钱，这算是最早的商业模式了。很多中关村老板，纷纷向王小波投去橄榄枝，邀请他加入公司做一名资深程序员，但被他一一拒绝。
有钱了干嘛？给自己投资呗。
身后这台就是王小波花大价钱买的286。王小波高兴得一塌糊涂，特意拍下了一张合照。
在当年3月份的日记中对此有翔实的记述，行文之间，甚是得意：
“我终于下决心买了一台286，这些日子在改造软件，作了不少汇编工作。现在终于完全成功，我的软件现在可以编辑400K长的文件，可以把一部长篇小说全部调到内存里编写了。”
当问及王小波为什么要自己开发文字编辑程序？
王小波很淡然地说，
别人编的软件我既使不惯，也信不过，就这么点原因。
这种坚韧就像是领导让你去改别人写的代码，看了几分钟之后，你一摔键盘，“费劲，不如自己重新写一个！”
在《似水柔情》一书中，王小波骨子里那种执拗精神展露无遗：“我觉得我还是我，我要拥有一切――
今天要是不把那段C++程序调通，老子就不睡了.....
.”
王小波，程序员撩妹之楷模
赢得了一整个银河
 
读过《黄金时代》、《
红拂夜奔
》的人，就会发现，王小波笔下的每一段故事都关于一个天真得有点轴的姑娘陪一个不合时宜的男人，度过了那个鸡飞狗跳的年代。管他世外有多乱，天真的还是天真，不合时宜的依旧不合时宜，像极了两颗钉子拧巴起来，钉在洪流里。
两颗钉子我行我素，洪流里的人面面相觑。
这就是王小波，敢说、敢写，简单，率真，是荒唐的时间里真诚的存在。
这也是王小波和李银河爱情故事的缩影。管他世外有多乱，天真的还是天真，不合时宜的依旧不合时宜，天真得有点轴的银河陪王小波，度过了那个鸡飞狗跳的年代。
在第二次和李银河见面时，王小波就向提出交往的要求。李银河在多年之后坦言到，“被其表白后，感到有些难以接受，
他的长相……实在是种障碍，差一点就分手了。
”
王小波却浑然不在意，还能趁机调侃
“一想到你，我这张丑脸上就泛起微笑。”
 即使再排斥他长相的人，也不会给他难堪了吧。
有着
“整容般有趣灵魂”
的他，每每给
李银河
写信总是这样开头：
“你好哇，李银海“
，字里行间透出类似孩子般的对爱的渴望与无助。
《爱你如爱生命》一书，记录了王小波对李银河说过的情话：
咱们应当在一起，否则就太伤天害理啦。
你要是愿意，我就永远爱你 ；你要是不愿意，我就永远相思。
你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。
王小波给予银河的爱，是自由的，真诚的，率真的，像极了他自己。
王小波，IT届的一大“叛徒”
却找到了最好的路
纵观王小波的一生，他对于互联网的深度体验，与其在文学上面的尝试是可以等量齐观的。
玩硬件、写软件、上网写博客、用电脑写作、用软件卖钱……
王小波的互联网经历，几乎涵盖了今日程序员生活、工作的各个方面。
然而，混熟了互联网的他，对其已提不起兴趣。
“我对微机已无兴趣，因为发现写小说也可以赚到钱。”
或者说的可以更直白点，王小波学编程就是为了赚钱养活热爱写作的他。
没有人限定了谁的一生该怎么走，不妨问问自己：你想怎么走。
王小波选择了写作。
1992年从北京大学、中国人民大学辞职，王小波成为自由撰稿人，陆续出版了《黄金时代》《白银时代》《青铜时代》
《我的精神家园》
等知名作品。他的唯一一部电影剧本
《东宫・西宫》
获阿根廷国际电影节最佳编剧奖，并且荣膺1997年戛纳国际电影节入围作品，使王小波成为在国际电影节为
中国取得最佳编剧奖的第一人
。
高晓松曾评价王小波，“以我有限的阅读量，王小波在我读过的白话文作家中绝对排第一，并且甩开第二名非常远，
他在我心里是神一样的存在
……王小波是可以和
卡夫卡
媲美的。”
一个比高晓松还丑的男子，却被高晓松称之为
神一般的存在
，可见王小波在文学上的天赋与创作是惊艳世人的。
王小波的这次叛变，是极其正确的。
可就在1997年，4月11日，一个很平常的日子，王小波心脏病突发，一个人悄悄地离开了世界。
在他去世的1997年，也是中国的
互联网元年。
这一年，联想超越IBM成为中国个人电脑市场霸主，张朝阳创办了搜狐前身爱特信网站，丁磊在广州创办网易，
王志东
的四通在线拿到650万美金风投，四通利方体育沙龙上出现了一篇著名的帖子《
大连金州没有眼泪
》，当时的马化腾还蛰伏在深圳电信，腾讯还没有影子，马云还在思考中国黄页的出路，李彦宏还在加州的院子里种菜养花，日后统率中国互联网的BAT连一个萌芽都算不上。
或许我们可以打开脑洞，如果王小波不死，他除了文学创作，在互联网领域，可以去混论坛成为老榕、陈彤一般的人物，可以去创业成为
张朝阳
、丁磊，可以去布道成为
凯文凯利
……也可能在博客微博时代成为公知代表，也可能形象崩塌一败涂地，也可能成为自媒体达人每次打赏无数……
但这都不是王小波。
做极客的王小波与做知识分子的王小波，是一个硬币的两面，用编程的写作互证，才能找到一个血肉丰满的王小波。
一个有趣但笔力未到上限就消逝的中国卡夫卡作家。
一个比高晓松还丑却用封封情书撩到银河的痴汉。
一个成功混迹小说圈的程序员。                
这些都是王小波。
用丑丑微笑面对世界的王小波；
通过自己努力改变生活的王小波；
在热爱面前，愿意倾尽所有的王小波。","王小波在杂文集
《沉默的大多数》
中［科学的美好］这样写到：
“我现在既不是化学家，也不是数学家，更不是物理学家。我靠写文章为生，与科技绝缘――只是有时弄弄计算机。这个行当我会得不少，从最低等的
汇编语言
到最新潮的C++全会写，硬件知识也有一些。但从我自己的利益来看，我还不如一点都不会，省得整夜不睡，鼓捣我的电脑，删东加西，最后把整个系统弄垮，手头又没有软件备份。”
-------------------------------------------
不得不说，《沉默的大多数》这本书读起来真的是拍案叫绝：","计算机水平很高，恶搞水平更高，他不高兴的时候把命名都写成caonima1，caonima2，caonima3
……","补充
@王二
 ：
王小波是个神人，统计、计算机真不是白给的。 ? COS论坛
  王小波与他的好友间关于计算机和统计的一部分书信摘要。","《姚勇：现在的社会要钱不要王小波》
 转载自：
南方人物周刊
  
原文链接:
ò|ó?￡o???úμ?é?
       作为外甥，他眼里的王小波是什么样子呢？这个王小波对他有什么样的影响呢？或许，能告诉我们另一面的王小波。
       出事前不久，姚勇说，舅舅嘴唇的颜色已经变紫了，电话中也透露出不舒服的感觉。出事前两天半夜一点，姚勇接到姥姥的电话，老人仿佛有预感似地说，找不到王小波，可能是出事了。“当时我们都没当真，后来姥姥的弟弟出去寻找，在昌平的房子发现了尸体。”
        4月11日早晨7点，姚勇还在睡觉，父亲接到了电话。姚勇匆匆和父亲一起赶到姥姥家，帮忙给剑桥网站管理员写信找远在英国读书的舅妈
李银河
――当时email还不是那么普及
人物・姚勇
       “被王小波教育过的外甥”――在王《
我怎样做青年的思想工作
》一文中提到“天资聪明，虽然不甚用功，也考进了清华大学”
        “这孩子爱好摇滚音乐，白天上课，晚上弹吉它唱歌，还聚了几个同好，自称是在‘排演’，但使邻居感到悲愤；这主要是因为他的吉它上有一种名为噪声发生器的设备，可以弹出砸碎铁锅的声音。每逢考期临近，他就要熬夜突击准备功课；这样一来就找不着时间睡觉。几个学期下来，眼见得尖嘴猴腮，两眼乌青，瘦得可以飘起来。他还想毕业后以摇滚音乐为生。”
        临近下班的姚勇疲态尽显，不时摘下眼镜狠狠地揉搓眼眶；尽管如此，面对镜头的眼神还是有些失去焦点。每天精神高度集中地工作以及经常熬夜写代码，让“疲惫”成了这个32岁IT青年的常态，一如其他所有努力拼搏、处于创业阶段的IT人士。
        姚勇留着长发，这可能是他“IT青年”形象的唯一“破绽”。若干年前，他曾甩动长发，用吉它弹出令人兴奋的音符，引发台下阵阵尖叫。后来他一度成为国内著名演唱组合“水木年华”的主唱，他的形象出现在“
水木年华
”“新歌+精选3”专辑的封面上，这是该乐队唯一一次以三人形式出现。
        姚勇的又一重身份是王小波的外甥，或者按照他朋友的说法，是“被王小波教育过的外甥”――在王《我怎样做青年的思想工作》（以下简称《思想工作》）一文中提到的“天资聪明，虽然不甚用功，也考进了清华大学”的那个外甥，就是姚勇。在王小波生前的最后几年里，姚勇是和他关系最密切的亲人之一；也正是因为王小波，促成了姚勇从手捧吉它到手握鼠标的转变。
思想工作者王小波
        24岁前，姚勇的简历基本按照音乐人的标准写就――小学开始学习小提琴；初中进入军乐团、交响乐团；高中喜欢摇滚，苦练吉它；大学成立了自己的乐队“泡沫”，担任主唱和主音吉它。
“这孩子爱好摇滚音乐，白天上课，晚上弹吉它唱歌，还聚了几个同好，自称是在‘排演’，但使邻居感到悲愤；这主要是因为他的吉它上有一种名为噪声发生器的设备，可以弹出砸碎铁锅的声音。”王小波在《思想工作》中这样写道，“每逢考期临近，他就要熬夜突击准备功课；这样一来就找不着时间睡觉。几个学期下来，眼见得尖嘴猴腮，两眼乌青，瘦得可以飘起来。他还想毕业后以摇滚音乐为生。”最后一句话，令姚勇的父母大为头痛。
        当时姚勇的家人在国外，每周他都要去姥姥家，也就经常能遇到侍奉老人的王小波。而高中阶段就读过《
黄金时代
》并颇以为“爽”的姚勇，和这位和蔼可亲的舅舅很有共同语言。于是，王小波在《思想工作》里说，“不管我愿意不愿意，我都要负起责任，劝我外甥别做摇滚乐手，按他所学的专业去做电气工程师。” 
        时隔十多年，姚勇已不记得舅舅当时确切说了什么话来说服他，大意是“人在什么阶段应该做什么事情”、“要花多少精力去学习”、“不必非得那么辛苦搞艺术”、“走上社会的起点要高，不能大学毕不了业”等等，都是些亲人之间常见的教诲。但姚勇说他听得进去，因为舅舅把他当朋友，平等、平和地对待他。
        王小波去世后，姚勇才读到《思想工作》，兼之当时他觉得自己艺术天分不够高、音乐之路也很难走，又重新回想起舅舅劝服他时说的话，品出另一些深意。在《我的舅舅》一文中，他说：“作品的灵感只能是来自于作者本身对于痛苦的体验。当我察觉到这一点时，我的舅舅感到了身上的责任。他不希望自己的经历在下一辈中重演。”
        于是24岁后，姚勇的重心从20年来一以贯之的音乐，转向他同样喜欢且看上去更有前景的IT。
编程高手
王小波
       说到IT，在姚勇看来，舅舅可是个编程高手。在他刚进入清华电机系，对编程还不熟悉的情况下，舅舅已在用C＋＋写自己的中文输入系统、中文编辑器和多媒体系统。姚勇说，生前，舅舅一直在做自己的电子书――他希望他的书为更多人了解。
       姚勇和舅舅几乎没有代沟，很多时候他觉察不出舅舅有长辈的样子。对姚勇来说，王小波更多的是一位可以热烈讨论技术、科技触角灵敏的和蔼长辈，而非一位作家――印象中，王小波几乎不在家中讨论他的书稿，姚勇笑称，可能是因为他的第一部小说《唐人秘传故事》并不入文学功底同样深厚的家里人的“法眼”，认为它不是商业小说，无法糊口；而他的小说、杂文，大多都是在他去世后出版，家人才得以看见。
        姚勇说，舅舅在家里不太说话，本身也不是健谈的人，可能只有在和他聊起电脑技术的时候，话匣子才被打开。
        姚勇回忆，他常常周末去姥姥家，舅甥两人就坐在计算机前，讨论电子小说和编程细节。有时候王小波会向他展示编程的进展，“敲完键盘，歪过头来冲边上的我嘿嘿一乐”，有时“和我一道痛骂微软公司的险恶――在他们发明的Windows操作系统下编程犹如噩梦。”
        一次，姚勇在舅舅面前抱怨父亲不给他买计算机，舅舅表示理解，并当即决定去买一台奔腾，把自己的电脑送给姚勇。“我乐得不行，简直可以说是欢天喜地。”王小波还亲自把这些自己用了好多年的家当抱下来，给姚勇打了辆面的，“在关上车门时，我冲他招手，心中充满感激之情。看到他微笑着站立在马路边上缓缓向后退去的身影，心中闪过一阵阵温暖之意。”
突然的死亡
        1997年，王小波去世前的最后一个春节，是和姚勇、姚勇的姥姥一同度过的。和往年一样，舅甥二人在院里放了鞭炮，迎接崭新的一年。
之后，从小身体不好的姚勇受长期扁桃体化脓的困扰，打了一个月点滴，还与父亲因学业的事情闹僵，正躺在床上无人照料时，王小波打来电话安慰，让姚勇好好照顾自己，还担心着他的学业问题，“怎么样也得拿到毕业证呀”。
        出事前不久，姚勇说，舅舅嘴唇的颜色已经变紫了，电话中也透露出不舒服的感觉。出事前两天半夜一点，姚勇接到姥姥的电话，老人仿佛有预感似地说，找不到王小波，可能是出事了。“当时我们都没当真，后来姥姥的弟弟出去寻找，在昌平的房子发现了尸体。”
         4月11日早晨7点，姚勇还在睡觉，父亲接到了电话。姚勇匆匆和父亲一起赶到姥姥家，帮忙给剑桥网站管理员写信找远在英国读书的舅妈李银河――当时email还不是那么普及。
在打开电脑的时候，姚勇哭了，那里有舅舅未竟的《
黑铁时代
》和未出版的杂文，然而这位高大的骑士却再也不回头了。
         那年秋天，姚勇制作了一个网站，把舅舅的一部分作品放在上面，纪念这个教育他人生道理、和他讨论程序、带领他进入网络世界、影响他之后人生观价值观的人。
没有舅舅的日子
         1998年，姚勇留校做了程序员；2000年，跟朋友一起开发网络游戏3D引擎；到了2002年，姚勇用“潦倒”来形容自己的状态，身边的钱刚够吃饭；与此同时，“水木年华”的一名成员离开，清华校友
卢庚戌
想邀请气质和音乐上都“摇滚”的他参与进来，姚勇犹豫再三，终于舍不了做音乐人的夙愿，点头同意，但又放心不下他的3D引擎，就买了个笔记本，在演出等候的时间段，继续做他的技术。“当时真的累坏了，几乎每天都要飞行、演出，别人不演出时还有空余的时间，我得写代码，一个脑子永远分成两半，一边完了忙另一边，永远没有休息的时候，因为两边都是自己的兴趣。”
        2003年，
姚勇
的心脏出现了早搏现象。他决定退出，重回网游领域。
        也就是在2003年，某天晚上十点多，
丁磊
把姚勇叫去，希望他来做3D客户端。姚勇说，当时不知道也不认识丁磊，觉得还是希望自己创业，就没搭理这事。2005年12月31日，姚勇在博客上写道：“前段飞机上翻某本精英杂志，几年富润榜，似乎就03年他是中国首富。我心说行，也就我当时还
摇滚青年
的范儿，傻逼嗬嗬还真拒了个首富。要知道后来想做的这白日梦会给我带来那么多技术之外的破事儿，我早上赶着颠儿颠儿给人写3D引擎去了。”
        几年间，姚勇胃病频发，事业也有过不顺利。“现在的社会不需要舅舅说的智慧、趣味，要的是钱。舅舅的思想曾经在我脑中存在，现在也一直都在，但你面临的责任、处境、解决问题的方法等现实，逼迫你不能用这些思想解决问题。但经历了那么多，我的信仰仍然是我的兴趣，是我坚持的动力所在。”
        还是在2005年12月31日这篇博客中，姚勇写下如此一段：“身边所有被资本支撑的产品，都呼啸而过。伴随着几十亿几十亿滚滚而来之后又滚滚而去。只有我，依旧在原地，抱着最初的那些童真不放。青春逝去， 再不复返。有时醒来想，为兴趣而活，真这么错么？想实现一点梦想，真这么难么？”","GitHub - plutoid/wangxiaobo: 王小波作品搜罗
Fork without any hesitation.","高中时候泡图书馆，偶然翻到了他的杂文集。 一口气全部看完，发现他理科很好，又写书，会编程，留过学，想法之类的符合我的取向，当时就感觉打开了新世界的大门。当时高中做化学实验，想起他吸氨水我就想笑。看了看书的封面，还特别年轻，心想，这人不错啊。
结果翻到了最后一页，发现97年就走了。。。。。。。当时心里一万句我操。。。有些难过，觉得他的文章什么时候都不过时。后来看完了全集，看了书信，难过，唉，我心中的
王二
。",具体怎么好我不知道，但是20年前就能写出《从internet说起》，就知道他比好多人高到不知道哪里去了。。。,Programming language 也是一种语言，语言功底好的人，写程序也很有天赋，很庆幸王小波没有选择去写代码,1996年发表,"Show me the code, 有强烈的想看王小波代码的冲动，想来这些代码在计算机圈中比他的文字还珍贵，还能""人肉""到这些代码吗？",不值一提的长处罢了,王小波的技术到底够不够牛，我是无从了解的，因为那个时代也许已经与比他更牛的人存在的，但是他的精神是现在依旧可以在IT民工身上看到的，我们是技术流，只为了技术，一个纯粹的技术疯子他不懂得他的创举能带来多少利润他只知道可以更方便自己的使用，他追求更高层面的技术，永不停歇!,“我现在软件写得出神入化，大概8088上能做到的一切，我都做到了。自己觉得该告一段落，去写小说了。”,"我一直都以为王小波只会天马行空，装深沉。。没想到他还会
计算机编程
这一套。。真牛逼。。","今天读《爱你就像爱生命》  看到这页我实在是看不下去了 我是来看情书的啊 前面各种爱 各种信任 各种撒娇啊 怎么画风不太对了……然后开始怀疑人生……毕竟我一个交互设计的研究生，一直赖着不学编程……所以，今晚我去图书馆借了一本编程入门的书……
大一的时候，偶然在图书馆找到了小波老师的一本书，当时我对小波老师的认知就是：一个我还没读过他作品的作家，所以我就找了一本读。忘了是《青铜时代》还是《
白银时代
》了，在教室里读，刚好那天开会，教室都是人，真的，看的脸红了。。。
然后这么多年，再也不看小波老师的书（心里阴影太大），最近是因为关注
李银河
老师，（2017年以前，我以前真不知道他们是夫妻）所以觉得还是想再看看小波老师的书，结果……
然后又查了一下，1978年高考，考上人大，这最起码说明还是有碾压当年的同龄人能力的吧……
美国匹兹堡大学……
然后大部分人的知道的身份是作家……
反正这两页 我也看不懂……
最后：完全0基础、文科编程小白，求好心的大神指点入门（数理化生一个比一个差）
谢谢","他是
对外经济贸易大学
的C++老师
毕业于北大数学系
深藏功与名。",总之人家是觉得写书和写程序都能挣钱，不如写书去了。
,,,,,,,,,,,,,,,,,,,,,
怎样评价《数码宝贝》第一部中的泉光子郎的编程水平？,None,"受到 
@夜路川
 答主勇于用python进化自己室友的激励，我顺便深挖了一下《数码宝贝》第一部第五集中光子郎在电脑上敲出的代码，终于把
原始代码
跑了出来，视频在最后。
《数码宝贝》第一部第五集截图
虽然这段代码会自己乱动并让甲虫兽进化，显得狂拽酷炫吊炸天，但其实和第十集出现的代码是一模一样的（而动画里表现出的效果明显不同）。第十集里的代码反而看得更清楚一点。
《数码宝贝》第一部第十集截图
根据这张图抽出文本如下：
100
 
/* func sample. coast creation */


110
 
float
 
s


120
 
while
 
s
<
1
 
or
 
s
>=
2


130
     
input
 
""ratio 1 to 2""
;
s


140
 
endwhile


150
 
s
 
=
 
(
s
-1
)
/
10
+
1


160
 
screen
 
1
,
2
,
1
,
1


170
 
s
=
sqr
(
s
*
s
-1
)


180
 
float
 
x0
=
100
,
 
x1
=
412
,
 
y0
=
0
,
 
y1
=
0


190
 
fractal
(
x0
,
x1
,
y0
,
y1
,
1
)


200
 
line
(
100
,
 
50
,
 
412
,
 
50
,
 
255
,
 
65535
)


210
 
end


220
 
func
 
fractal
(
x0
;
float
,
x1
;
float
,
y0
;
float
,
y1
;
float
,
sp
;
int
)


230
     
float
 
l
,
 
r
,
 
x2
,
 
y2


240
     
l
=
sqr
((
x1
-
x0
)
*
(
x1
-
x0
)+(
y1
-
y0
)
*
(
y1
-
y0
))


250
     
if
 
l
<
2
 
or
 
sp
>=
9
 
then
 {


260
         
line
(
x0
,
y0
/3+50,x1,y1/
3
+
50
,
255
,
65535
)
 : 
return
()


270
     }


280
     
r
=
rnd
()+
rnd
()+
rnd
()
-2


290
     
x2
=(
x0
+
x1
)
/
2
+
s
*
(
y1
-
y0
)
*
r


300
     
y2
=(
y0
+
y1
)
/
2
+
s
*
(
x0
-
x1
)
*
r


310
     
sp
 
=
 
sp
 
+
 
1


320
     
fractal
(
x0
,
x2
,
y0
,
y2
,
sp
)


330
     
fractal
(
x2
,
x1
,
y2
,
y1
,
sp
)


340
 
endfunc
如果想重新原汁原味地运行这段代码，首先要明确它的语言和版本。注意到注释和变量定义的语法更接近C系语言，但还有endwhile、func、endfunc等关键字，可以确定这不是VB或者其他主流的
BASIC系语言
。但是代码行号的格式暴露了这货肯定是个远古产物，我本来想看看光子郎电脑上这个文件的后缀名是什么，瞅了半天发现是“名称未设定 3”（见上图），失去线索的我只能开始疯狂的google……
在资料检索过程中主要发现两个问题。一是和这段代码语法相近的语言太多，比如
VFP
（Visual FoxPro，知道它的人肯定都老了）、VimScript、SAP采用的
ABAP
、早期PHP、伪代码的某个版本
[1]
、乃至德仪计算器的自创
脚本语言
等等。经过一个个的尝试，发现这些语言都是形似神不似，并不是真正的答案。
Google Books里找到的一本TI计算器手册
第二个问题是，如果仔细看光子郎的代码，你一定会陷入困惑，因为这段代码根本不像是有一个统一的语法规则。这里举两个栗子：
流程控制语法不统一。120-140行的
while-endwhile
结构，或许让你觉得和BASIC有一点点类似，而且顺便猜测
if语句
肯定也会有个endif结尾。但是250-270行的if语句居然用了大括号，更丧心病狂的是在then后面接大括号！
变量声明格式不统一。110行是类C的声明格式，而220行的函数参数却用了类似ECMAScript的声明方式，但用的不是冒号是分号。这让我一度以为这段代码就是导演魔改的，是一种不存在的噩梦般的语言。
然而，在我就要放弃之际，一位国外先行者的博文给了我曙光（尽管文章里有一些错误）
[2]
。这个语言最终还是被查出来了……
事情要追溯到1987年，夏普发布了一款型号为X68000的PC。作为那个年代的电脑，搭载了10MHz的
摩托罗拉68000CPU
，1MB的内存，没有硬盘，且只在日本发售
[3]
。其操作系统是
夏普
为这一系列电脑专门设计的Human68k，《数码宝贝》中的那段代码，就属于这个操作系统专有的编程语言
X-BASIC
[4]
。
Sharp X68000ACE-HD
X-BASIC手册
日本维基上X-BASIC的一段例程
这个系列的最后一款电脑在1993年发布（配置有所增强），而《数码宝贝》第一部是在1999年放映的，可见在动画制作时期，光子郎的代码也不算特别陈旧。
为了实际地跑一下这段代码，又经过一番艰辛的努力，我搞到了X68000的模拟器，还有操作系统Human68k（version 3.02）的磁盘映像，现在还能找到这些东西，真的要感谢极客阿宅们的默默奉献。
在模拟器里一开机，感觉就成功了一半：
为了能使代码顺利运行，还需加载SX-WINDOW映像。最后终于找到X-BASIC，一字不差地键入了光子郎的代码：
执行run命令，按代码要求输入一个1到2之间的浮点数值，下面就是见证奇迹的时刻了！
视频资源加载失败
我不禁望向窗外的那只放屁虫，它仍在很悠闲地晒太阳，很遗憾我的甲虫兽并没有进化……原因很简单，这真的只是一段随机生成「coast」轮廓的代码。初始输入是一个阈值，从视频里看，显然阈值越高「海岸」越险峻，阈值越低「海岸」越平滑，很有可能是摘取了当时哪个游戏里地图生成器的一段源码。所以，导演又糊弄事呢？
为了跑这段代码，我查到了一些资料和工具，在此罗列一下，有兴趣可以看看。
X-BASIC文档（日文）：
http://
ww3.enjoy.ne.jp/~zoomar
k/ip/xb/xb_frm.html
X68000 Emulator in Java：
https://
stdkmd.net/xeij/
Human68k磁盘映像（日文）：
http://
retropc.net/x68000/soft
ware/sharp/human302/
X68000相关资料（日文）：
http://
retropc.net/x68000/book
/x68book.htm
Programming Languages Database：
http://www.
epocalc.net/php/liste_l
angue.php
最后话说回光子郎的编程水平，这段代码的难点主要在于用递归实现了分形图形的绘制，虽然没什么特别神秘的地方，但还是需要一定程度的编程技能和数学知识。原理上很像我之前绘制谢尔宾斯基三角形的代码：
但是光子郎当时好像上小学四年级？
而且在动画里，这段程序的输出是这样的，光子郎最后靠这个成功还原了他和美美所在的迷宫。
嘛，单从这里看，感觉能进科大少年班就是了……
彩蛋：当年
X68000系列
的电脑还随附一个名为060turbo
[5]
的软件，单独装在一个磁盘。这个软件的唯一功能是在屏幕上随机打印一张复杂的
分形图形
（疑似
Mandelbrot
图像？并不是很确定）。我用模拟器试了一下，效果确实惊艳，感觉光子郎在成为分形大师的路上还需努力23333。
参考
^
Pseudocode Examples
?
https://www.unf.edu/~broggio/cop3530/3530pseu.htm
^
Running Izzy's ""Digivolving"" code
?
https://digitalworldproblems.tumblr.com/post/76036641581/while-im-looking-at-that-moviecode-post-he
^
X68000
?
https://en.wikipedia.org/wiki/X68000
^
X-BASIC
?
https://ja.wikipedia.org/wiki/X-BASIC
^
060turbo の添付ディスク
?
http://retropc.net/x68000/software/hardware/060turbo/disk060t/","2020年，光子郎用Python打开了数码宝贝世界的大门，也象征着我们的青春结束了。
不说别的，就看他写了什么。
坐标是数码宝贝第一部的第五集
这是和 
黑安杜鲁兽
 战斗时 
光子郎用来进化甲虫兽的代码
发现这大概像一段VB代码。不敢确定。
根据诸位大佬的研究，光子郎的代码是X-Basic
破千了！！ 十分感谢各位大佬的抬爱。在各位大佬的指正下，把这个看不清楚写错的文本修正一下。
转文本如下：
100
 
/*
 
func
 
sample
.
coast
 
creation
 
*/


110
 
float
 
s


120
 
while
 
s
<
1
 
or
 
s
>=
2


130
		
input
 
""ratio 1 to 2""
;
s


140
	
endwhile


150
 
s
 
=
 
(
s
-
1
)
/
10
+
1


160
 
screen
 
1
,
2
,
1
,
1


170
 
s
=
sqr
(
s
*
s
-
1
)


180
 
float
 
x0
=
100
,
 
x1
=
412
,
 
y0
=
0
,
 
y1
=
0


190
 
fractal
(
x0
,
x1
,
y0
,
y1
,
1
)


200
 
line
(
100
,
50
,
412
,
50
,
255
,
65535
)


210
 
end


220
 
func
 
fractal
(
x0
;
float
,
x1
;
float
,
y0
;
float
,
y1
;
float
,
sp
;
int
)


230
 	
float
 
l
,
r
,
x2
,
y2


240
 	
l
=
sqr
((
x1
-
x0
)
*
(
x1
-
x0
)
+
(
y1
-
y0
)
*
(
y1
-
y0
))


250
 	
if
 
l
<
2
 
or
 
sp
>=
9
 
then
 
(


260
 		
line
(
x0
,
y0
/
3
+
50
,
x1
,
y1
/
3
+
50
,
255
,
65535
)
 
:
return
()


270
 	
)


280
 	
r
=
rnd
()
+
rnd
()
+
rnd
()
-
2


290
 	
x2
=
(
x0
+
x1
)
/
2
+
s
*
(
y1
-
y0
)
*
r


300
 	
y2
=
(
y0
+
y1
)
/
2
+
s
*
(
x0
-
x1
)
*
r


310
 	
sp
 
=
 
sp
 
+
 
1


320
 	
fractal
(
x0
,
x2
,
y0
,
y2
,
sp
)


330
 	
fractal
(
x2
,
x1
,
y2
,
y1
,
sp
)


340
 
endfunc
对这段代码的个人理解如下：
定义一个
浮点数
 s
当 s<1 或 s>=2
	s = input(""ratio 1 to 2"")
s = (s-1)/10+1
screen 估计是一个类？不知道有什么用
大佬指出 这是一个屏幕控制命令
sqr 估计是
开方函数
 s = s^2-1
定义四个浮点数
调用
fractal函数
 他给这个自定函数叫 分形
调用又一个自定函数 line 接受6个参数最后程序建了模所以估计是一个
画线函数
这里声明前面的fractal函数 这还是一个
递归函数
前面不知道变量s是啥所以这个代码从这里开始可读
经过大佬指出，s变量是x2,y2值的一个参数
四个浮点数
这是求两点距离的公式 l 是两点距离
如果这个距离小于2 或者 sp>=9
画条线后返回？
rnd 应该是随机数函数
递归调用
在这里根据编程语言的通性，笔者用python大概重构了一下这份代码。希望能够进化我的舍友。
基于前辈和大佬，对这份代码进一步修改：
import
 
matplotlib.pyplot
 
as
 
plt


import
 
numpy
 
as
 
np


import
 
math


import
 
random


x_r
 
=
 
[]


y_r
 
=
 
[]


def
 
fractal
(
x0
,
x1
,
y0
,
y1
,
sp
):

    
l
 
=
 
math
.
sqrt
((
x1
-
x0
)
*
(
x1
-
x0
)
+
(
y1
-
y0
)
*
(
y1
-
y0
))

    
if
 
l
<
2
 
or
 
sp
>=
9
 
:

        
x_r
.
append
(
x0
)

        
x_r
.
append
(
x1
)

        
y_r
.
append
(
y0
)

        
y_r
.
append
(
y1
)

        
return

    
r
 
=
 
random
.
random
()
+
random
.
random
()
+
random
.
random
()
-
2

    
x2
=
(
x0
+
x1
)
/
2
+
float
(
s
)
*
(
y1
-
y0
)
*
r

    
y2
=
(
y0
+
y1
)
/
2
+
float
(
s
)
*
(
x0
-
x1
)
*
r

    
sp
 
=
 
sp
+
1
 
    
fractal
(
x0
,
x2
,
y0
,
y2
,
sp
)

    
fractal
(
x2
,
x1
,
y2
,
y1
,
sp
)



s
 
=
 
0


while
 
True
:

    
if
 
float
(
s
)
 
<
 
1
 
or
 
float
(
s
)
 
>=
2
:

        
s
 
=
 
input
(
""ratio 1 to 2
\n
""
)

    
else
:

        
break


fractal
(
100
,
412
,
0
,
0
,
1
)


plt
.
plot
(
x_r
,
y_r
)


plt
.
show
()
运行结果如下：
s = 1.1
s = 1.2
光子郎
的结果：
好吧只是抽了两张比较像的
甲虫兽表示身体发烫。充满力量。
愿伟大的祖国繁荣富强，国庆节快乐。","前方多图，流量预警
――――――――――――――――――――――――
友情提示，本文配合此音乐服用效果更佳：
07 - Digital Scratch! ~～光子郎のテ`マ～#2 [-] Digital Scratch! ~Koushirou no Theme~ #2
有句话叫做不看广告看疗效，我们就直接来看看光子郎都有过哪些优秀操作吧。
光子郎的成就不完全统计
：
1.成功分析出了动力室的程序，并且用程序手动进化了甲虫兽（技术宅威武）。
2.成功获取遗迹的地图，并且还建立了语音通讯来指导美美如何走出这个迷宫一样的地方。
3.分析了发现希望徽章后出现的那个山洞里面的程序，直接得出了数码世界是建立在现实世界之上的结论。（我觉得这段是光子郎最神的一幕。）
4.发现了
分子兽
在金字塔之下的密道。
5.基本上找出了石盘上卡牌摆放的内在规律。（之前在水底，玄内说的那些东西也基本上只有他才能完全理解，最后干脆单独和他说。）
6.成功设置好了
玄内
传给他的“数码结界”程序，正是靠着这个程序才保护了他一家人的安全。
（你看不见我~你看不见我~你看不见我……）
7.连接了巨鲸兽的视觉系统可以看见巨鲸兽所看见的，并且还配合
嘉儿
的哨声完成了一个“声纳系统”。
8.通过查询玄内老人给他的数码宝贝图鉴，光子郎发现了
战斗暴龙兽
的杀手锏“恐龙克星”，给了孩子们一针强心剂。
9.虽然一开始由于使用电脑造成暴露目标，但是光子郎很快就把他和太一的方位变成了”禁忌的多重存在“让敌人一头雾水。
10.没错，重头戏来了。在剧场版《
我们的战争游戏
》里，光子郎开始疯狂地秀起了操作(值得一提的是，在另一部同为
细田守
指导的电影《
夏日大作战
》里，主角也是一个技术宅)：
(1).
看一个人的技术水平，可以看和他交流的都是些什么水平的人（光子郎自己也说过，在数码世界里最希望的事就是回到家上网发邮件给他的朋友）：
当然了，更diao的在后面，这水是有多深…
(2).
小试牛刀，几下子就成功连上ISDN网络。
(3).
在由于地狱使者兽入侵导致掉线以后，通过卫星电话连接上了外国节点再次进入了网络。
(4).
最后的关头，光子郎意识到BOSS的速度太快导致无法锁定，直接快速把巨量的邮件全转发到BOSS的邮箱，于是，BOSS卡机了……，被
奥米加兽
成功击杀。
10.剧场版里的夏天过去了，在第二部的故事里光子郎依然风头强劲，多次发挥重要作用。
(1).
仅靠一张杂志照片就大概分析出了一乘寺贤家所在的大体位置（细思极恐）。
(2).
提出只要有D3
暴龙机
（顺便说一下这个名字也是他给取的），任何一台上网的电脑都可以打开数码世界大门的假设并且应验。
整个第二部里的光子郎，基本上分析与联络玄内的事情大部分都是他在做，作为一代二代补充性质的广播剧
《两年半的休假》
里也提到光子郎一直就联系着玄内并且早就知道了被选召的孩子们不止他们几个了。
给第二部主角做知识辅导也是经常的事情。比如解释数码宝贝的合体进化（他还专门为此新做了一个词：“Joint + Progress=Jogress”），又比如下图里向
一乘寺贤
解释为什么新的被选召的孩子们的神圣计划会变形。
11.而在第二部的剧场版《超恶魔兽的反击》里一开始，光子郎就充当了一个召集者的角色（毕竟网络世界要是出了什么异常肯定是他最先知道的）。
在
太一阿和
都要把最重要的戏份让给新主角，阿助差不多永远在考试or复习的情况之下，光子郎在技术支援方面的戏份还是那么吃重，真是让人不禁有些唏嘘――
好了关于他的事绩基本上说得差不多了，不得不提的是他还有一个非常可贵的品质：
对计算机的专注
。
第一集开始就在自己一个人摆弄电脑。
太一觉得“电脑敲一下就好”，被光子郎赶紧拦下了。
还是
素娜
最能了解别人的感受啊。
唉…并且作为一个光美党，我要先去哭会儿…：
由于只注意遗迹里的文字，不理会美美，结果人家都气哭了，说他是个笨蛋。（一声叹息）
不过也就是在这个岛上，美美明白了光子郎研究文字的意义，光子郎也明白了不能单纯靠电脑的运算。于是到了第二部的剧场版里大家就玩得很开心了…
总之不管别的了，反正技术宅你今年一定要把美美给追到手啊听到了吗！加油！QAQ
新PV出了，美美早已看穿了一切，哈哈。
――――――――――――――――――――――――――――――――
11月新剧场版上映更新！
《
数码宝贝大冒险
Tri.》的第一章「再会」已经上线了。
我们的光子郎依旧是操作犀利,意识超前,输出恐怖。
距离第二部已经又过了3年，人类世界再度出现迷之怪物。
八个孩子们再度聚首，不得不说光子郎还是那个最能透彻地分析情况的人啊（这时要是能再响起技术宅专属BGM就好啦）：
第二，
神圣计划
发生故障（被阿武先说了）
（不过在这里还是要小小吐槽一下，你们倒是好好听光子郎讲的啊…果然光子郎的水平已经进化到了大家都不明觉厉的程度了吗？……诶诶，太一跟阿和怎么又吵起来啦。扶额）
（还有阿助啊……你其实是专程来虐狗的吧！~我也想问，对方是人类吗…【喂！）
(把光子郎都惊呆了…)
（哈哈哈此刻大家的表情都神同步了）
好了，接下来光子郎开始蓄能了，大家赶紧做好心理准备。
先是和阿武聊天的时候，表示自己早已是买买买的一员了（按照剧场版的设定那还是在05年啊）。
（其实光子郎你的小心思啊，其实大家都明白的啦…）
接下来就又是光子郎的秀操作时间了，为了挑选好看的衣服，他开发了一款“光子郎环游世界”（大雾）软件。即使宅在家里也可以各种衣服换着穿啦。
（哈哈，甲虫兽你真是为光子郎操碎了心啊）
好啦，镜头一转，我们又来到了……
嗯，看来美国网友真的是没白交啊。
前方核能预警！
看到这儿的时候我已经不由自主地献上了膝盖…
一个电脑制作的虚拟空间可以快速地了存入和取出数码宝贝，简直就像是自己造了一个“数码世界”一样啊。这时光子郎的帅气程度我感觉已经超越分析出数码世界奥秘那集了。
终于，就在光子郎的办公室里，数码宝贝总算是有了媲美隔壁棚
精灵球
一样的黑科技了（虽说六代好像也有类似的技术，不过对于大冒险系列来说这还是首次吧）。虽然端口携带不是很方便，但是也可以用数量来弥补嘛。
相信不少人会有一个疑问，太一明明把护目镜送给了大辅，为什么在Tri.又戴上护目镜了呢？
嘿嘿，答案就是光子郎熬夜只睡了三个小时给太一做了新的护目镜！
技术宅亲手制作的护目镜当然不止是用来耍帅的。
戴上以后才发现另有玄机（谷歌赶紧开发这样的应用吧，哪怕只是模拟的也好啊）
而太一也正是通过这个在摩天轮上发现了巨大的数据错位。
故弄玄虚装神秘的阿尔法兽出现了。光子郎马上动用电脑里的图鉴（肯定也是优化过的了，还带扫描分析的）。只可惜相关数据还是太少了。
是的，第一章里光子郎的表现就是这么抢眼。
但我还是要说！光子郎你就不要再各种迷之脸红啦，赶紧就从了美美吧！你看看连阿助都有女朋友了（喂！），你到底还在等什么呢？
众人：有情况
加油啊光子郎！明年再见！
――――――――――――――――――――――――――――――――
《数码宝贝大冒险Tri.》的第二章「决意」
上映更新！
光子郎依旧充当着的技术核心作用。总是能第一个知道有突发情况出现并且及时地通知给大家。
并且一直在根据最新情况分析这次危机的原因：
说到这个感染的问题啊…
喂！数码兽你们又在乘机卖萌了！萌死我算了…
哈哈不过他们也不用太担心，因为光子郎也不是毫无准备的啊：
在收到一封神秘电子邮件后，他进行了解析，果然又是与数码世界有关的信息。不过答案真正揭晓，又是在之后的事情了。
在扭曲消失以后光子郎及时地打开了观测数码世界的窗口（虽然不能够进入，但是在数码世界的数码兽能听到电脑那头孩子们的声音）：
呐呐呐，至于光子郎和美美的事情呢…
怎么说呢…光子郎说了句“美美太以自我为中心了”。美美的心里明显是很不好受的（当时第一反应：？？？我去，官方你不要这样…）
嘛。不过乐天的美美还是在大家（特别是
望月芽心
）的鼓励下调整好了状态。光子郎更是看到她的照片立马就跑过来了。
哈哈一副要面试了的表情：
哈哈哈光子郎你还是蛮帅的。不过不要老是害羞啦勇敢一点吧！你看美美多大方啊。
――――――――――――――――――――――――――――――――
《数码宝贝大冒险Tri.》的第三章「告白」上映更新
这章，光子郎也陷入困难了，虽然他可能已经算是孩子们里面知道的最多了。
数码兽们，还是被感染了……而且还不止一只，甚至光子郎也清理不出头绪……
光子郎开始没日没夜地钻研，几近崩溃的状态。没办法，这集他是主角，真正的考验来了。
当然光子郎毕竟是光子郎。从这句话里就能够看出来。
感觉甲虫兽的话是互文，“希望”对应的是光子郎的“知识”。
终于，光子郎调查清楚了！错位的发生是因为原本的二进制被篡改成了一个数码数据无法处理的计数法。
而光子郎很快也通过数据分析知道了感染发生的根源
最后关头，光子郎还在错位空间里创建了一个备份场，不单能使数码宝贝不被重启，还能剔除感染。可惜最后一个都没有留住，哭瞎了QAQ
调整好了数码世界的坐标（之前也是他一直在联系众人再回去）
图鉴再度发挥了作用
就这样，被选召的孩子们又一次前往数码世界展开了冒险……
光子郎的故事，未完待续。","我来歪个楼吧，我不是学编程的，但是我懂一点日语，也是数码宝贝的铁杆粉丝。
偶然一我看到了这张图，所以想要吧墙上的文字解出来，看一看究竟是什么意思。于是想要翻译墙上的文字。
视频资源加载失败
墙上的文字是五十音平假名符号化了。（这在日漫中不算不常见，在《
信蜂
》、《家庭教师》、都有这样的字体出现。
不过
墙上的图并不是按照50音家名完全对应的，存在着大约百分之10比例的
干扰图形
。
（视频里我空出的部分就是在deji文字对照表里从未出现的图形，而红色的部分是与对照表图形有像的地方但是不完全一样靠猜测大致翻译的文字）
也就是说有几个图形并不在五十音里面。这大概就是光子郎一直敲键盘的原因吧。
这些李鬼们严重的吸引到了光子郎小朋友的注意力导致他连他的小女朋友都不顾。（笑
这种感觉就好比一部分文字里大部分的字都认识但是因为有几个字不认识影响理解
众所周知（也许不见得）日语中纯假名表述属于表音符号，相当于我们把拼音拆开了写这样的情况，那么就导致中间缺少的音非常影响理解整段话的意思。
我认为，制作方的用意应该是把这个数码宝贝的世界线说明，dejimoji化之后贴在动画的遗迹墙上了，所以光子郎才会说，只要读懂墙上的文字，就可以知道数码世界的意义了。
嗯，上道。四年级的小孩子居然这么上道。
然后，从结果上看，后期光子郎能够推出数码世界是与现实世界重叠的另一个世界这一点看，光子郎的进展应该是比我快。因为我解出来的密码只是一首糟糕的诗。
（当然，也许因为我日语不是母语，在缺少大量音之后根本无法达意，而光子郎小朋友通过一系列的方式最终破解了全部的密码，并顺利读懂。）
大家知道一段话，中间缺东西是什么感觉吗？
（大家做过完形填空吗？）
从其他答案那些程序员们运行程序过程中出现的情况来看，动画的文字部分应该也并未特别考究，所以光子郎背景墙上的文字应该是随机写的。
只是设定上说墙上写着
数码宝贝世界
的运行法则。
不过，既然这么想要知道这句话什么意思，那么我们有百度翻译啊。
百度翻译上人家这么说：
（嗯好吧，还挺应景的啊）","（是因为我强调“玩Python”，所以把
宠物小精灵
也推给我了么 ^_^  ）
前面 
夜路川
 的考据十分专业，赞一个先。其中回帖里很多网友提到这是老Basic或GwBasic，不过各位只知其一不知其二。这个屏幕截图确实是Basic的大量变种之一，但却是一个非常非常小众的分支，恐怕国内真没有几个人用过 ―― 它是 1987 年 日本
夏普
为其 Sharp 68000 机器设计的 X-Basic 语言（别问我怎么知道的）。
典型的X-Basic程序代码
其实从截屏中也可以看出它和其他basic变种之间的显著区别，比如：
使用 /* ... */ 这种C风格的块注释，而不是 basic 标准的REM或引号；
使用 func ... endfunc 定义函数而不是 basic 标准的 DEF ；
直接用 float s 定义
浮点数变量
，而不是使用 basic 标准的 DIM As；
if then 后面居然用花括号包装语句，而且还出现了 return() ！
一方面使用古老的行号，另一方面却有大量的缩进结构。要知道当时即使权威的Basic教材里，语句一般也都是全部顶格书写的。
所以可以推断，这个语言的设计师当时受了很多C语言的影响。回想当年有很多改进Basic语言的努力，比如加入面向对象特征等等，所以这个语法确实是那个年代的风格。
最后跟这个帖炸出来的老程序员们握个手！看到 screen 1,2,1,1 这一句时，感觉眼泪都要出来了，真的是30年前的回忆啊！当时使用的显示器是显像管那种，有CGA、EGA等不同型号，支持的颜色和分辨率都不同。screen这个命令就是用来指示显示器切换到哪一种模式。不过 X-BASIC 里面的screen参数含义与国内熟悉的 GW-BASIC 不太一样（可能当时日本的显示器指标普遍更高）：其中第一个参数 1 代表的是让显示器切换到512*512分辨率（我记得GWBasic里是320*320）、第二个参数2代表的是让显示器进入16色状态（可以显示16种颜色、不是16位颜色！），第三个参数1代表高分辨率模式，第四个好像是代表内存缓存开关（记不清了）。
这几天好像特别喜欢怀旧，昨天刚考证了 
1991年爱国者导弹那次事故
 ，今天直接飞回1987年了。我大概真的是老了吧 ……
（还好头发还在，请各位CS同学安心学习、勇敢从业）","引用：
为什么电影中的黑客几乎绝不用鼠标？ - 黑客 (Hacker)
我觉得题主应该去看下
秒速五厘米
，男主会。。。。结果。。。。语法是php，左边的文件目录结构是
jsp
。","前面高赞回答的各位大佬们已经扒过光子郎的代码了，我就不再扒了。
当时光子郎才小学四年级，能用X-Basic写代码还原迷宫，说中科大少年班水平都不为过。
光子郎代码运行结果
但是其实大家不必太过讶异，光子郎还真不是编剧给开挂了，因为在很多发达国家，许多小学生都具备一定的编程能力。
在光子郎的家乡日本，孩子们5岁就可以学编程了。
是的你没看错……5岁……
 在欧美国家，编程甚至早已成为中小学必修科目。
不过动画归动画，现实是现实。
动画里光子郎是用编程语言写代码，但现实中，这些中小学生基本都是用MIT（麻省理工学院）的LLK团队开发的
Scratch编程工具
进行编程学习，主要学习的是运算思维。
不过，靠它完成一个迷宫程序还是轻而易举的：
▲10岁小学生用
Scratch编程工具
做出的迷宫游戏
综上，小学四年级的光子郎会编程不奇怪，牛逼的是他是用真编程语言写代码，而别的小学生需要借助编程工具来实现整个程序操作。
现实点说，现在很多计算机专业的大学生恐怕都比不上动画中的光子郎，因为真的从小接触编程语言的人真的很少。光子郎是妥妥的赢在起跑线上。不过也有例外，
BT之父的Bram Cohen（布莱姆?科恩）就是五岁的时候开始学习C语言，到十六岁，他已经学会了三种编程语言了。
但这样的天才是真的屈指可数，动画中的光子郎可能就是Bram Cohen这种水平吧，谁看了不说一句牛逼呢！","最近，了解到迷宫可以多种算法实现，也注意到《数码宝贝》中
光子郎
曾用计算机确定迷宫。因此，我尝试用Prim算法实现迷宫。
我复制了网络上比较流行的一个Prim算法迷宫之Python实现，作出了一些改进，增加了大量有益的注释。
注释以英文写出，保持了同原注释语言的统一。
对此算法及其实现，我个人认为，应该注意指出以下几点：
 应了解Prim算法的一般原理，从而能够理解：Prim算法实现的迷宫，从算法上看，是实现了一种生成树。这个树从入口处，不断生长出若干条枝，这些枝串起了特定区域内所有的单元格。在这个生长的过程中，总有一个枝会串起作为出口的那个单元格。不过，这个单元格不一定是那个枝的最后一叶。
 
 矩阵M中保存了大量的数据，它们代表着特定区域内的全部单元格。每个单元格包含一组5个数据，分别代表：左、上、右、下、是否已访问。从这个排列顺序，可知这个Python的具体实现应该是西方人写出来的。
 
 特定一个单元格被访问后，检查其周边的四个方位上的单元格。如果某个单元格已被访问，则可以作为连接的可能选项。如果某个单元格未被访问，则可将之加入一个列表，表示它之后可能会被选出来访问。但这里要特别注意：这时，这个单元格的是否已访问的数据被赋值为2。2不能代表已访问，也不能代表未访问。所以这个单元格不能被某个以及若干个被访问的单元格当作接连的可能性，因而不能被多条枝重复串起来。这个保证了出迷宫的通路的唯一性。
大家可以依据算法的代码，来理解相关的原理。其中相应的具体注释，应该能帮到大家。
代码如下：
#!/usr/bin/env python3


# -*- coding: utf-8 -*-


""""""

Created on Tue Jan 25 19:20:53 2022



@author: wst

""""""



import
 
random


import
 
numpy
 
as
 
np


from
 
matplotlib
 
import
 
pyplot
 
as
 
plt


import
 
matplotlib.cm
 
as
 
cm




# num_rows = int(input(""Rows: ""))  # number of rows


# num_cols = int(input(""Columns: ""))  # number of columns


num_rows
,
 
num_cols
 
=
 
15
,
 
15



# The array M is going to hold the array information for each cell.


# The first four coordinates tell if walls exist on those sides


# and the fifth indicates if the cell has been visited in the search.


# M(LEFT, UP, RIGHT, DOWN, CHECK_IF_VISITED)


M
 
=
 
np
.
zeros
((
num_rows
,
 
num_cols
,
 
5
),
 
dtype
=
np
.
uint8
)



# Break the walls of enter and exit


M
[
0
,
 
0
,
 
0
]
 
=
 
1


M
[
num_rows
 
-
 
1
,
 
num_cols
 
-
 
1
,
 
2
]
 
=
 
1



# Set starting row and column.


# The possibility is the stack of visited locations.


possibility
 
=
 
[(
0
,
 
0
)]



# Trace a path though the cells of the maze and open walls along the path.


# We do this with a while loop, repeating the loop until there is no possibility,


# which would mean we backtracked to the initial start.



# Imagination(wst):


# Image that there is a tree which has many branches,


# and all cells in the array will be connected by special branches.


# Now there is a special branch, growing strongly and getting the exit cell.



# Attention(wst):


# The nearby cell which have not been visited is added to `possibility`,


# but can not be connected by other cell either connect to them,


# (by the visited status value `2`) unless it is choiced from `check`.


# Then it can connect to other cell(s) which have been visited.


# This function ensures that a cell can only connected by one branch.



while
 
possibility
:

    
# random choose a candidate cell from the cell set histroy

    
r
,
 
c
 
=
 
random
.
choice
(
possibility
)

    
M
[
r
,
 
c
,
 
4
]
 
=
 
1
  
# designate this location as visited


    
possibility
.
remove
((
r
,
 
c
))

    
check
 
=
 
[]

    
# If the randomly chosen cell has multiple edges

    
# that connect it to the existing maze.

    
if
 
c
 
>
 
0
:
  
# the visit state of left cell (for example)

        
if
 
M
[
r
,
 
c
 
-
 
1
,
 
4
]
 
==
 
1
:
  
# If this cell was visited,

            
check
.
append
(
""L""
)
  
# it can be choiced as direction.

        
elif
 
M
[
r
,
 
c
 
-
 
1
,
 
4
]
 
==
 
0
:
  
# else if it has not been visited...

            
possibility
.
append
((
r
,
 
c
 
-
 
1
))

            
M
[
r
,
 
c
 
-
 
1
,
 
4
]
 
=
 
2

    
if
 
r
 
>
 
0
:
  
# the visit state of up cell

        
if
 
M
[
r
 
-
 
1
,
 
c
,
 
4
]
 
==
 
1
:

            
check
.
append
(
""U""
)

        
elif
 
M
[
r
 
-
 
1
,
 
c
,
 
4
]
 
==
 
0
:

            
possibility
.
append
((
r
 
-
 
1
,
 
c
))

            
M
[
r
 
-
 
1
,
 
c
,
 
4
]
 
=
 
2

    
if
 
c
 
<
 
num_cols
 
-
 
1
:
  
# the visit state of right cell

        
if
 
M
[
r
,
 
c
 
+
 
1
,
 
4
]
 
==
 
1
:

            
check
.
append
(
""R""
)

        
elif
 
M
[
r
,
 
c
 
+
 
1
,
 
4
]
 
==
 
0
:

            
possibility
.
append
((
r
,
 
c
 
+
 
1
))

            
M
[
r
,
 
c
 
+
 
1
,
 
4
]
 
=
 
2

    
if
 
r
 
<
 
num_rows
 
-
 
1
:
  
# the visit state of down cell

        
if
 
M
[
r
 
+
 
1
,
 
c
,
 
4
]
 
==
 
1
:

            
check
.
append
(
""D""
)

        
elif
 
M
[
r
 
+
 
1
,
 
c
,
 
4
]
 
==
 
0
:

            
possibility
.
append
((
r
 
+
 
1
,
 
c
))

            
M
[
r
 
+
 
1
,
 
c
,
 
4
]
 
=
 
2


    
# Select one of these edges as direction at random,

    
# and break the walls between these two cells.

    
if
 
len
(
check
):

        
move_direction
 
=
 
random
.
choice
(
check
)
  
# Select a direction

        
# Break the walls.

        
if
 
move_direction
 
==
 
""L""
:

            
M
[
r
,
 
c
,
 
0
]
 
=
 
1

            
c
 
=
 
c
 
-
 
1

            
M
[
r
,
 
c
,
 
2
]
 
=
 
1

        
if
 
move_direction
 
==
 
""U""
:

            
M
[
r
,
 
c
,
 
1
]
 
=
 
1

            
r
 
=
 
r
 
-
 
1

            
M
[
r
,
 
c
,
 
3
]
 
=
 
1

        
if
 
move_direction
 
==
 
""R""
:

            
M
[
r
,
 
c
,
 
2
]
 
=
 
1

            
c
 
=
 
c
 
+
 
1

            
M
[
r
,
 
c
,
 
0
]
 
=
 
1

        
if
 
move_direction
 
==
 
""D""
:

            
M
[
r
,
 
c
,
 
3
]
 
=
 
1

            
r
 
=
 
r
 
+
 
1

            
M
[
r
,
 
c
,
 
1
]
 
=
 
1



# The array image is going to be the output image to display


image
 
=
 
np
.
zeros
((
num_rows
 
*
 
10
,
 
num_cols
 
*
 
10
),
 
dtype
=
np
.
uint8
)



# Generate the image for display


for
 
row
 
in
 
range
(
0
,
 
num_rows
):

    
for
 
col
 
in
 
range
(
0
,
 
num_cols
):

        
cell_data
 
=
 
M
[
row
,
 
col
]

        
for
 
i
 
in
 
range
(
10
 
*
 
row
 
+
 
2
,
 
10
 
*
 
row
 
+
 
8
):

            
image
[
i
,
 
range
(
10
 
*
 
col
 
+
 
2
,
 
10
 
*
 
col
 
+
 
8
)]
 
=
 
255

        
if
 
cell_data
[
0
]
 
==
 
1
:

            
image
[
range
(
10
 
*
 
row
 
+
 
2
,
 
10
 
*
 
row
 
+
 
8
),
 
10
 
*
 
col
]
 
=
 
255

            
image
[
range
(
10
 
*
 
row
 
+
 
2
,
 
10
 
*
 
row
 
+
 
8
),
 
10
 
*
 
col
 
+
 
1
]
 
=
 
255

        
if
 
cell_data
[
1
]
 
==
 
1
:

            
image
[
10
 
*
 
row
,
 
range
(
10
 
*
 
col
 
+
 
2
,
 
10
 
*
 
col
 
+
 
8
)]
 
=
 
255

            
image
[
10
 
*
 
row
 
+
 
1
,
 
range
(
10
 
*
 
col
 
+
 
2
,
 
10
 
*
 
col
 
+
 
8
)]
 
=
 
255

        
if
 
cell_data
[
2
]
 
==
 
1
:

            
image
[
range
(
10
 
*
 
row
 
+
 
2
,
 
10
 
*
 
row
 
+
 
8
),
 
10
 
*
 
col
 
+
 
9
]
 
=
 
255

            
image
[
range
(
10
 
*
 
row
 
+
 
2
,
 
10
 
*
 
row
 
+
 
8
),
 
10
 
*
 
col
 
+
 
8
]
 
=
 
255

        
if
 
cell_data
[
3
]
 
==
 
1
:

            
image
[
10
 
*
 
row
 
+
 
9
,
 
range
(
10
 
*
 
col
 
+
 
2
,
 
10
 
*
 
col
 
+
 
8
)]
 
=
 
255

            
image
[
10
 
*
 
row
 
+
 
8
,
 
range
(
10
 
*
 
col
 
+
 
2
,
 
10
 
*
 
col
 
+
 
8
)]
 
=
 
255


        
# Display the image

        
plt
.
imshow
(
image
,
 
cmap
=
cm
.
Greys_r
,
 
interpolation
=
""none""
)

        
plt
.
pause
(
0.01
)

        
plt
.
clf
()


plt
.
show
()


我的代码，更改了matplotlib显示图形的逻辑，使之能动态地扫描出整个迷宫，在视觉效果上会惊艳一些。如果不需要，可以改成一步生成。
扫描出迷宫图片的视频如下：
视频资源加载失败
我生成的一些迷宫如下：","不请自来！
我一直觉得
四年级的时候就可以码程序比起现在真实的四年级小学生已经优越非常非常多了！
毕竟现在有的计算机专业的大学生都达不到光子郎这种水平！！","我不是程序员啦，不过
光子郎
在游戏进程中就破解了游戏内部世界观、设定和基本的升级原理，野怪没开打就知道属性技能，这……貌似最神的破解大神也是要退出游戏才行吧。",日本普通高中生水平。没错，就是日本动漫里的普通高中生水平，一般坐在倒数第二排靠窗的转校生那种。,"东京湾
埋藏的那批小学生的入门级水平","世界第一梯度吧
毕竟带着那么厚的手套敲键盘还敲得那么快的人，技术也肯定是顶尖级别的。","不如
司波达也","这部经典动漫告诉我们:
小学生赛高。",有点像工控机的屏幕脚本控制程序，而且是很原始的工控机屏幕……,冒号里的光一郎就是世界第一程序员，编程拯救世界,,,
,,,,,,,,,,,,,,,,,,,,,
为什么祖传代码被称为「屎山」？,None,"一个有趣的事情，
一个哥们上班时忽然怒气冲天，大声质问这TM谁写的代码，这么明显的bug都能出，还不写注释，当时项目组的码农们都心惊胆战，不敢说话，害怕把自己揪出来示众。
项目经理听到发话了：XX，你查一下
SVN
记录，查出来全公司通报，扣他年终奖。
这哥们：我已经在查了....
过了几分钟......
这哥们：不可能吧，这怎么可能呢？
大家都凑了过去，发现这段代码是这哥们一年前自己提交的。
为了避免过度尴尬，大家都没再提这个事情。
---------------------------------------------------
回到问题，是的，都是一堆臭屎，不做记号的话，还真分不出来是不是自己拉的。","最近公司的电梯出了问题，平常从1层到8层都畅通无阻的电梯，偏偏在经过4楼时神秘的跳过了这一层。
原本负责修理电梯的老程序员已经被扔进电梯井了，所以老板决定由你全盘负责电梯的修理和维护。
你简单研究了下这部电梯，似乎初步找出了问题的关键所在。
这部电梯的1层到4层是一个老程序员修建的，而后面的5到8层则来自于另一位跟你水平相仿的程序员。
这也就是说，问题很大可能正是来自于4层到5层的接缝处，随着公司大楼的不断加高，原本生效的程序发生了某些错误的吻合，才导致4层被神秘的“跳过”。
了解了问题所在，你立刻开始针对性的开展工作，在你的妙手回春下，你和你的老板一起眼睁睁的看着电梯不可逆转的上升，向上、向上，甚至还顶破了8层的天花板，在一众员工的众目睽睽下消失在了高空之中……
显然，问题从来不会这么简单的解决，你决定研究下那些延伸进钢筋混凝土深处的钢索，刚研究没多久，公司的女同事就过来对你破口大骂――因为电梯的钢索会影响厕所换气扇和电灯的开关，让整个厕所像极了三流鬼片的拍摄现场。
你开始意识到问题可能稍稍超出了你的想象，面对老板的不断催促，你只能赶鸭子上架般拿出了你的最终方案:
1.要求前往4楼的人站在电梯的后半部分。
2.在电梯下方安装滑梯。
3.将电梯后半部分的地板换成活版门，当检测到有人按4楼时，在5楼开启活版门。
4.最重要的一步，关闭电梯内部的光源，将电梯变成后来人看不明白的黑箱，也就没人会来找你的麻烦了。
虽然有些员工抱怨前往4楼时会遇到匪夷所思的失重感，但这无伤大雅的问题跟4楼的恢复使用又能算得上什么呢？
你唯一需要知道的就是，你成功的解决了公司的问题，你的薪水翻了三番，而且你因为业务能力出色被调到了跟程序毫无关系的领导岗位，甚至还跟前一任修理电梯的员工当上了同事( )
至于你问那个电梯？要相信后人的智慧。
而“去4楼只能站在电梯的后半部分”则变成了一个公司的都市怪谈，没人知道这古怪的规定是如何生效的。
但它正在客观实在的发生，不是吗？","有一天，有几条虫子，干扰了老板赚钱，老板希望你能抓住它们。
你带着年轻的锐气，青春的活力，学艺多年积累的程序设计艺术，打开了公司的代码仓库。
远看，似乎一个运转的机器，巨大的代码堆积在一起形成了大致的轮廓，蠕动着前进。
凑近了一看，在不净的框架中，乱码般的语句在运转，像生了麻风病的
蛞蝓
一样在喷吐，粘稠的水在流动，而穿着格子衫的人群则在焰柱旁围成了一个半圆，这就是码农的仪式。他们环绕着那不可名状植物，不断的伸手进去拨弄，又不断的掏出一些东西填上去，使他堆的更高，为了防止倒塌，又掏出黏糊糊的糊糊，用力的涂抹，试图把它们黏在一起。
这是一个前人留下的屎堆起来的一个
克苏鲁缝合怪
，看起来摇摇欲坠，有无数的虫子爬来爬去。但勉强堆起了山一样的形体，蠕动着为老板赚钱。
你满心热血，要对这座山进行清理，使它成为一个鲁棒的钢铁巨兽，可以随时更换最新的部件，奔腾如飞，坚固异常，带着兄弟们走向人生巅峰。
你经过缜密的分析，顺着虫子留下的痕迹，终于找到了问题的源头，发现一坨很多年前某码农因为时代局限或者水平有限拉的陈年旧屎，你觉得只要对它改良一下，梳理清楚结构，加强判断与容错，就可以变化成一个钢铁部件，让这坨怪物离巨兽更近一步。
你用力的挖掘其中的信息，却发现，事情没有那么简单，这一坨实际上不是孤立的一坨，而是和整个山体融合在一起。或者说，这座山实际上是一坨坨粘稠滑腻的克苏鲁，通过无数的触角和粘液连接在了一起，这些克苏鲁伸出无数的触角，伸进这座山体中未知的角落。
有看起来结构相同，但是出现了几十上百次的重复逻辑。有无数道不知道伸向何处的判断分支。有七零八落到处都是又无法解释的神秘数字。有从表面直接伸向最底层的神秘调用。还有猜不出，看不懂，无法预计什么时候会触发，什么时候会爆发的无数定时器。还有无数神秘的线程在独立的挂在那里，猜不出哪个什么时候会忽然启动，什么时候会忽然挂起，什么时候会忽然互相抢资源而死锁，哪些资源会莫名其妙的被改动。神秘的链接，神秘的任务队列，神秘的池，神秘的环形缓存，神秘的堆栈。
他们
耦合
在一起，互相支撑，构成了一坨更大的克苏鲁屎怪，缓慢的蠕动。
你极其困难的清理和修改了其中的一点点内容，让这一点点的内容脱离出耦合态，看起来清晰一点。结果，忽然屎山对面十万八千行外，你永远意想不到的一块功能，忽然挂了。一个你完全在工作上没接触过的同事，通过他的盘查，发现是他维护的一个函数/方法、类、线程、内存块，池，和你改动的部分是深度耦合的，你的解耦导致了难以理解的错误使他们的部分产生了错误。于是你被骂了，你只能再退一步，在一个更小的范围内进行调整，但是发现，虫子不止是由这一块构成的，于是你追踪者虫子的足迹，去改良一个一个的模块。
在经历了一轮又一轮的批评，几乎结识了全公司所有模块的负责人之后，你终于抓住了一条虫子。但是在这个漫长的过程中，你早已忘却初心。在无数次的赶工加班熬夜的迷糊中，被同事老板挨骂后的愤懑中，表白失败/和女朋友吵架/发现自己头顶有点绿的低落中；无数次当做临时代码写下，计划单元测试完成后就重写却忘记的过程中，因为偷懒或者不舍得打断思路而而懒得抽出轮子而产生的超大代码块中。
留下了无数看起来结构相同，但是出现了几十上百次的重复逻辑。无数道不知道伸向何处的判断分支。大量的无法解释的神秘数字。从表面直接伸向最底层的神秘调用。猜不出，看不懂，无法预计什么时候会触发，什么时候会爆发的无数定时器。无数猜不出哪个什么时候会忽然启动，什么时候会忽然挂起，什么时候会忽然互相抢资源而死锁，莫名其妙改动资源的神秘线程。神秘的链接，神秘的任务队列，神秘的池，神秘的环形缓存，神秘的堆栈。
你要抓的哪条虫子确实抓出来了。然而，在你没看到的地方，随着运转，更多的新的虫子正在茁壮的成长。
这时，你突然发现你的脚抽不出来了，几条触手顺着你的腿向上攀延，你的手被深深地吸入泥沼一样的屎山，你使尽全力想要抽出胳膊，但越是挣扎，陷得越深，仿佛屎山中心有一个冰冷的黑洞，要将所有接近的物体吞噬殆尽。你的精气在一点点流失，一种极度的疲惫，但是又释然的感觉涌了上来。此刻，你觉得舒适又满足，渐渐地闭上了双眼，你甘愿奉献头发与生命，将自己化作一块补丁，维系着系统的苟延残喘。它再也没法离开你了，你和你的头发，成了它的一部分。
不知道过了多久。终于又有一条虫子在运行中暴露，干扰了老板赚钱。
老板又安排了一个年轻人来抓住这条虫子。这个年轻人带着锐气，青春和活力来到这座山前。
看到这摇摇欲坠的克苏鲁大山，不仅倒吸一口冷气。
“oh shit ! shit mountain !”","直到改出了 bug，才知道原来某行代码是干这个用的
n天后，我擦，那行代码不止干了这个
又n天后，我擦，这种代码不止一行
又n天后，妈的，老子也搞上去了几行","屎山？小公司的祖传代码才可以叫做屎山。
大公司的祖传代码，那是屎海上漂浮的僵屎山。
你就在这屎海里面漂着，一旦进来了，就出不去了。
每天的工作，就是在粪泳前进。还有拉着部门的粪船前进。
各个部门的粪船每天继续产出新鲜的屎，投放到屎海里，它们不断聚集，成为新的屎山。
旧的屎山顺着洋流还相互亲热着，迸发出岩浆般热情的屎，掉落在你头上和身边。
你不得不一边拼命地游以自保、一边还想尽办法地不沾太多屎到身上。
系在你身后的是部门的大船，部门领导坐在船上，用伞和棍子推着避免撞上屎山。
偶尔有个负责的领导，还会愿意让你上上船休息。
可惜一旦你沾着太多的屎了，或者让船沾着太多的屎了，就等着被踢下船去吧。
偶尔有那心有抱负的人，尝试着改变这一切。
他们以为找到了一些仿佛可以容易对付的屎山，想着要重构，说他们看到了一条干净的出路。
但是，他们还是太年轻了。
因为，他们看到的，只是屎山的一角。
他们带着部门的船从旁边划过，却不知这就是昨日的泰坦尼克。","第0天，你发现电灯开关离床很远，每次睡觉关灯都很麻烦，于是把电灯开关封锁起来，从里面拉了一条连杆到床头，用机械传动的方法缩短了睡眠区域和开关操作区域之间的距离。
第1天，你觉得这样还是太远，打算再把它改造成遥控的，于是你做好了自动按按钮的装置和遥控器。此时你面临三种选择:
0.直接把装置装在新按钮上
1.把连杆拆了，把装置装在旧按钮上
2.把旧按钮拆了，换成传感器
你想了想，好不容易做好了，不用多可惜，于是选择了0。
第2天，遥控器不见了，你找了老半天才找着，心想这遥控器好是好，就是容易丢，于是一气之下用强力胶把它粘在了地上。
你冷静下来一想，不对啊，直接在床上合适的位置搭个小桌板，把遥控器固定在那上面不就行了？
真聪明，可惜现在遥控器死死黏在了地上，要想扒下来就得把整个地板拆掉。
好巧不巧，你在某宝上发现一个电动伸缩器，一接到信号，就会像一根手指一样伸出来，然后缩回去。
你大喜过望，赶快买来了伸缩器，吊在旧遥控器正上方，再量好了自己睡眠时手的位置，在那里搭了个小桌板，把伸缩器的遥控器粘在上面。这样，你睡觉之前只需要按一下小桌板上的遥控器的按钮，伸缩器就会按一下地板上的遥控器的按钮，旋转器就会挤压连杆末端的元件，连杆就会移动，按下电灯开关，电灯就会关掉。
第3天，你感觉这小桌板硌得慌，于是把床平移了一段距离，清空空中空间。但这样，按钮又太远了。于是你去某宝买了个声控灯和一块黑色的幕布，罩在小桌板上遮住新遥控器，又给伸缩器装了温度传感器。睡觉前只需拍拍手，声控灯就会亮起，幕布内的空间就会升温，温度传感器就会监测到升温,伸缩器就会按下地板上的遥控器的按钮，旋转器就会挤压连杆末端的元件，连杆就会移动，按下电灯开关，电灯就会关掉。
第4天,你发现最近气温变化迅速,温度传感器总是误报。于是你接了一台电脑、一个机械臂、一个视频识别仪,每隔一秒,机械臂就会操作电脑刷新显示实时的外界温度的网页,再由识别仪扫描电脑屏幕,读出温度数字,由此刷新温度基准值。于是现在,睡觉前只需拍拍手,声控灯就会亮起，幕布内的空间就会升温，温度传感器就会监测到幕布内和外界温度的差值超过了阈值,伸缩器就会按下地板上的遥控器的按钮，旋转器就会挤压连杆末端的元件，连杆就会移动，按下电灯开关，电灯就会关掉。
第5天，你发现声控灯时常因为环境噪音误启动，但又没有说明书，不知道怎样把它拆开来调整启动的分贝阈值，于是又买了一个语音识别信号器，把它的输出口和声控灯的输入口封在一个密闭的隔音空间里。只要你说“关灯”，语音器就会收到信号，在隔音空间里发出声波，声控灯就会亮起，幕布内的空间就会升温，温度传感器就会监测到幕布内和外界温度的差值超过了阈值,伸缩器就会按下地板上的遥控器的按钮，旋转器就会挤压连杆末端的元件，连杆就会移动，按下电灯开关，电灯就会关掉。
第6天，你嫌每次睡觉前都要说话太麻烦，于是在床下装了一个压力板，连接一个录音机。只要你躺下，压力板就会启动，录音机就会说“关灯”，语音器就会收到信号，在隔音空间里发出声波，声控灯就会亮起，幕布内的空间就会升温，伸缩器就会受热膨胀按下地板上的遥控器的按钮，旋转器就会挤压连杆末端的元件，连杆就会移动，按下电灯开关，电灯就会关掉。
第7天，你感觉自己还是很怀念点按按钮的快感，于是你买来一个机器人，在床下压力板四周装上了复合杠杆和摇杆，把床顶起来，减轻压力板收到的力。只要你按下按钮，机器人就会摇动摇杆，床就会下降，压到压力板，压力板就会启动，录音机就会说“关灯”，语音器就会收到信号，在隔音空间里发出声波，声控灯就会亮起，幕布内的空间就会升温，温度传感器就会监测到幕布内和外界温度的差值超过了阈值,伸缩器就会按下地板上的遥控器的按钮，旋转器就会挤压连杆末端的元件，连杆就会移动，按下电灯开关，电灯就会关掉。
第8天，你发现你的装置失灵了，起初以为是机器人坏了，于是拆开了机器人，发现没有坏。无奈之下你只能把机器人和摇杆强行报废断开，自己摇动摇杆，发现摇杆也没坏。于是你只能把复合杠杆再拆成一节节钢棍去调查压力板，发现压力板也没坏。你只好把录音机的电路剪开，发现也没坏。只能破开小桌板看隔音空间的外壁，也没坏。于是撬开隔音空间看声控灯的接收器，发现也没坏。于是撕破幕布看声控灯的灯泡，没坏。伸缩器的手指，没坏。地上的遥控器，没坏。你一不做二不休把地板穿了个大洞把遥控器取出来，没坏。旋转器，没坏。连杆，没坏。敲开封装的盒子，原来是大灯的一颗螺丝松了。
你把它拧了回去。
第9天，你还是像9天前那样从床上跳起来，关灯，跳回床上，睡觉。","说到祖传代码不得不提当年在移动的一段经历。
我刚入职第一天，旁边的妹纸告诉我，你是今年第五个负责这个模块的，心里凉了半截，这TMD才七月份啊，听她说最长的干了两个月。
我就不信那个邪，页面交互一般，后端不也就增删改查？能难到哪里去。看了代码才知道，too young，too simple。里面最老的代码是09年那会的，直到现在一直在维护，今刚好十周年庆典，我光荣接盘，这大概就是代码届的接盘侠吧，现在用的还是jdk1.6，不分什么前端后端，页面都是用Java写的，最坑的是里面的js，有四五个公用的js文件，大概几万行代码，注释掉的代码占三分之二，大概是我这么多年见过最多的注释了，是谁说注释多的代码质量高的？出来，我不打死他。
说来也怪，两个月了还没给我安排需求，就是来的那个礼拜说了句让我看代码，每天早上一杯咖啡，页面点一点，心情好就看看代码，日子过得很是惬意，这大概就是程序的春天吧！真不知道前面那四个哥们放着这大好的日子不过，咋跑了呢？
一天中午，项目经理喊我，问我代码看得怎么样了？从项目架构说到业务逻辑，其实有个屁的架构，随便扯了五六分钟，项目经理笑了笑，点了点头，很是满意的样子。
“小李，这有有个bug，你去修一下“
“嗯嗯，没问题“意料之中，毕竟也快两个月了。
“下个月初，你争取弄完哈“说话的时候十七八号的样子。
“没问题。“
开始写代码了，带着一丝激动，毕竟两个多月没操练了，也带着一丝胆怯，因为是个人都能看出来这是是否能顺利转正的关键一战。
两个多月来，最认真的看了一天代码，我在哪里？我是谁？我在干什么？是哪个智障写的函数，十几个行参，变量命名汉语拼音占了一大半，我严重怀疑这是小学生写的代码，还智障一样的不分前后鼻音，小学语文老师怕是后勤老师教的（真不是看不起后勤老师），函数内部无止境的递归调用，本以为快结束了又来个
回掉函数
，一个函数有800多行。果然出来混还是要还的，过了两个月的春天，一下子跌进了冰窖。
这样的日子浑浑噩噩的过了七八天，招我进去的那个技术老鸟实在不忍心，过来指点我。
“小伙子，你这样看代码，估计明年春天也搞不定，你这个bug，是第三个人上线的时候写出来的，你重点看下他提交代码的部分“
一语惊醒梦中人，只能用这最白痴的办法了。
看了三天，终于找到问题所在，花了十分钟，搞定。然后技术经理核查了我两个小时代码才放心让我上线。
后面有一次和项目经理吃饭，“小李，前面四个人都跑路了，我就看好你，你知道为什么当初你刚来那两个月，我啥也没让你干？我是怕你一开始就做需求，扛不住跑路。”
“经理，那代码那么老了，怎么不重构一下“
“上一次重构代码的项目经理已经被大老板开了“
你有哪些终生难忘的扎心瞬间？
353 赞同 ・ 26 评论
回答","几年的代码也好意思叫shit山？这种东西得在微软/电信公司这种toB地方才恐怖。
我司有些代码我正好要升级gcc版本，要试试转docker踢到云上去，然而这批代码写于2000年前，那个酸爽哦。最早的部分可能写于1980年代bell实验室，第一批维护升级做需求的人早就退休了，第二批也退休了，每一行代码动起来都胆战心惊。
这会出现什么结果呢，重构花费时间极长，但是b端客户对稳定性和可升级性的需求不是普通客户能比，所以历代开发在这个坑上只能采取坑上盖板子这样的方式继续开发，坑传个10年20年，从底子上来看问题多太正常了。质量全是靠工程手段维持。框架稀里哗啦，代码风格迥异，逻辑不知道干什么，早期代码没有注释，指针到处乱来，文档有一本砖头一样厚的90年代开发指南，那感觉，嘿嘿嘿。","公司代码已经40年了，最早写代码的人不知道是否活着，要命的是文档没留下。
你们几千几万代码算什么，这个比微软系统还大。项目代码堆在一起有90多G，目测过千万行。
像int2 int4 int8 uint12345678这种类型定义上千种。无意中，翻出了一个用于定义的头文件，24万行的#define，我不知道这是不是人类写的。
我们有个古老的更新记录，当然，没有汉化版，像读一本流水账样的历史书。代码被美国人、印度人、中国人、澳洲人都更新过。
时代在发展。
像文本格式的数据库早就不用了，而我们却在用它包装n层并转换成sql。
你问我们怎么添加一列数据库字段，嘿，用手写数据库，用祖传的文本工具把它转换成代码，再添加进各个工程配置中，再一个个的编译，别忘了在sql中添加这一列，对了，你用多大的数据要写清楚，32字节，不要写多也不要写少，中间空4个空格你知道吗？写错了整个工程会出现莫名奇妙的错误。这些做完了。一天结束了。
像MFC已经不美了，我们却用托管C++强行封装并中转成WPF，然后，引用WCF是作为中间桥梁进行通信的。
托管C++你们知道吗？那可是编译器都看不懂的东西。能编译通过，只是在编写的时候一直是上万个报错的，你要自己用脑子想这东西能不能编译，不能依赖VS自动检查功能。
由于底层各种封装，封成迷宫了，VS经常解读到崩溃，编译到死机，自己去看的时候，几百层的调用栈中又有几百种重构函数。
工程之间的逻辑好复杂，主要是几千个工程太多了，dll与lib已经傻傻的分不清楚了，哪些有哪些的依赖，先编译这几十个工程，然后才能编译那几十个工程，要按照一定顺序来，不然依赖会报错。想哭。
哦。。我在里面添加个helloworld是多么不容易，要写一天，模块上千个，结构体万万不能动，任何一个结构体的修改会导致整个项目的瘫痪并要重新编译一整天（也许到最后是失败的）。
看代码就像走迷宫，对着一个函数按下F12之后，等着转圈圈，然后就会出现几百个定义索引，不是老玩家谁知道应该去哪个定义索引。
迷宫都比它简单，起码只有一条完美的出路。
真是大粪堆。
吐槽完了。继续搞这坨屎。
匿了，怕公司看。
过去一年了。感官上不一样了，再搞两年成熟练工就不再痛苦了，只是英语还需要更高的水平，听印度人讲英语还是听不懂。","驾驭屎山的唯一方法，不是重构，而是
不重构
。
为什么有人可以在屎山里加功能？
很简单：把屎山扒拉开，每块闻一闻，找出和你要改的功能对应的那坨屎，把这坨屎包起来（封装），你就可以假装它不是屎，是巧克力。然后，在旁边拉一泡新的屎，等它风干成型（测试通过）就可以收工了。
当然，怎样优雅地在一座屎山里闪转腾挪，做到“百屎丛中过，片屎不沾身”，还是需要很多经验和技巧的。不过说白了，就算失误了摔个嘴啃屎，臭也只臭你程序员一个，老板还觉得你很努力，客户还觉得真香。
很多愣头青觉得自己是天才，可以把屎山重构了。他们中的大部分人引发了屎崩，永远埋在了几千米高的屎山之下。
极少数人活了下来。他们真的做到了，他们真的重构了整座屎山！
重构之后的那个东西，被后人称为――屎山2.0。
当一个系统复杂度增加的时候，它的熵也会增加，这是宇宙规律。而某些有洁癖的码农，他们非要强行降低这个
复杂系统
的熵――不是做不到，但需要巨大的能量，也就是成本。
你想让谁来付这个成本？老板还是客户？
屎山不是一天拉成的。每一代屎山的建设者，都是非常聪明的人。他们非常清楚继续堆高屎山，未来将产生的代价。他们理性中立客观地评估了推翻屎山重建的成本，然后做出了一个充满智慧的决定：
在屎山上继续拉屎。
这个决定对于每一个人都是最优解，因为每一个人只需要对他当下的目标负责。每一次“继续拉屎”的决定都是正确的，不这样做才令人匪夷所思。如果重构屎山，客户很生气，因为交付时间更长了，还会冒出许多以前没有的bug。老板很生气，因为成本大增，而客户毫无多付钱的意思。就连重构屎山的人自己也很生气：天天钻在屎山里996，搞得浑身屎味，工资却一分钱没涨。
尿海不择细流，故能成其大；屎山不拒细壤，方能就其高。屎山就这样一天天长大，终于令最后接手的码农感叹：高山仰止，
景行行止
。
其实，屎山，是任何复杂系统的终极归宿。
无论你使用何种语言，师从什么流派，哪怕23种
设计模式
样样精通，最终还是会踏上前往屎山的道路。因为，条条大路通屎山。
就连微软、谷歌、Oracle这样的大公司，他们的产品也都是屎山。Oracle每改一个功能，全公司的服务器需要全速测试几个月。chromium浏览器的源码有十几个G，虽然是开源的，但没有人敢在如此险峻的屎峰上提交自己微不足道的屎坷垃，高处不胜寒。
至于微软，呵呵……从win8到win11，10年了，控制面板还是有两种口味：一种是古早味的，一种是苹果味的。office从2016到2021，5年了，不拿放大镜都看不出有什么区别。
这段话可能会让你误以为，微软、谷歌都是垃圾。但实际上，他们是地球上最强的软件公司。世界上最高的屎山，都是最聪明的屁股拉出来的。换了一般的程序员，屎山还没垒出一个小屎包，就屎崩了，就这点水平还天天嚷嚷着要重构屎山。
乔布斯曾说：死亡是最好的创新。
所有代码的最终归宿都是坟墓，而绝大多数代码早已死无葬身之地。屎山是不可能重构的，这辈子都不可能重构的。打败屎山的唯一方法，唯有另起炉灶，建一座新的屎山。这就是为什么在巨头们巍峨连绵的屎山脚下，总能有新的小屎包崛起。
当然，对于血气方刚的少年，我知道，你很可能觉得我在扯淡，屎山有什么好怕的，重构就是了。
明知山有屎，偏向屎山行。来，壮士，干了这碗屎，我绝不会拦着你。
我只会献上一本秘籍，祝你早日成功：
作为一名有理想的程序猿，我也在努力建造自己的屎山。
我想做一个能直接翻译英文pdf的工具，不是
划词翻译
那种，而是一次性翻译整个文件，英文pdf进，中文pdf出。这样看论文就可以偷懒了~
链接如下，感兴趣的同学可以试试。目前只有PC版，APP的坑一直没填：
大中华区
Rust语言代言人 
@张汉东
 老师在试吃之后，只评论了两个字：
神器
。
他翻译的pdf是这样的：
说实话，得到这样的评价实在出乎我的意料，因为我还从没试过翻译编程领域的文章，初看貌似效果还行。不过，我在受宠若惊的同时，也暗暗感到惭愧。因为只有我自己知道，屎山里还有多少坑没填……
不说了，我要进屎山填坑了……
如果你喜欢我这种用脱口秀style把道理讲通透的风格，可以尝尝我最近出版的两本科普书。这两本书都入选了2021年度CCF“科普阅读推荐图书”榜单。CCF是什么，对于程序员就不需要介绍了吧……
一本既不吹捧科学家的伟大、也不纠结历史细节、只想让你无废话看懂量子、还吭哧吭哧手绘100多张彩色漫画实验图解的硬核科普：
广告
猫、爱因斯坦和密码学：我也能看懂的量子通信
京东
￥68.00
去购买
?
一本不屑于教Python和调参、只想和你探讨人类命运和智能本质的AI科普：
还有不赚钱、只求交个朋友的套装：","之所以被成为屎山，因为你一碰，就会屎山爆发，那画面……不忍直视！
当你看到祖传代码时：
当你尝试改动时，只删了一行代码时，可能会发生下面这种情况
有句话，说的非常好：
祖传代码就像一座很大的屎山，你见过的最大的山，每次你想修正一个bug，你的工作就是爬到屎山的正中心去！","你管理着一个动物园
为了创收，你在动物园里修建了一个海洋馆，门票另收，吸引小孩子
结果上面下来一个工作组，说这是违规的，你一个动物园搞海洋馆另收门票和旅游局搞杜绝宰客、吸引游客的精神相悖
于是你决定钻个空子，把海洋馆“外包”出去，实际上从自己的左手转到右手。为了做得更像一点，你在地图上把海洋馆抹掉了，但为了让游客知道有海洋馆的存在，你在游客守则里此地无银三百两地加了一句“本园没有海洋馆，如果有工作人员向你售卖海洋馆的票，拒绝他们”
但你一个为了创收而建起来的动物园哪来的经费搞海洋馆？
于是你在海洋馆和大象区之间造了个
异次元通道
，让大象掉进海洋馆里，然后立一块牌子，说这是鲸鱼，过几天换一头大象
为什么大象这么多？你也不知道你前任跑了个什么程序，能以固定的频率转化出几头大象来
你不想知道这个，是因为上次探究为什么动物园有那么多跑来跑去的兔子的经历太具有灾难性了。你造了一个坚实的围栏，让兔子再也跑不出来，结果因为动物园空空荡荡，别的动物以为这都是它们可以获得的领地，都想跑出来。你想了想还是兔子攻击性小，于是在兔子园区底下挖了个坑道，让兔子能跑出来
兔子那么多怎么办？（其实你也不知道为什么会有那么多兔子，按理兔子园区也没几只兔子啊）于是你雇了一批员工捕杀兔子，维持兔子的正常数量
结果你发现员工杀完兔子之后处理现场时会把兔子肉和兔子血先分包扔在架子上，等都处理好了再一起丢，于是有的游客不明所以就把兔子血和兔子肉当商品买走了。没办法，你只好在游客守则里写上“动物园的饮料店不提供‘兔子血’”
过了几个月领导又下来检查了。领导看到那海洋馆里的大象的时候都被你气笑了，他问你，你告诉我这是鲸鱼？领导还发现海洋馆和动物园的员工就是同一批人。于是领导又责令你进行整改
动物园又没钱，你还能怎样？你只好在鲸鱼区贴上“大象是3D投影”的告示，然后让员工分成两批，穿不同颜色的衣服，还告诫海洋馆里的员工不要回答任何与动物园有关的问题，问就说没有动物园。为了避免下次检查的时候发现你在动物园里搞捕兔运动（毕竟兔友挺正确的），你决定给兔子肉打上“山羊肉”的标签，让人不明所以
年末的时候你发现海洋馆亏损了，原因是有人偷偷摸摸溜进海洋馆投宿（是的你开了个酒店），却不付钱。于是你给游客发放不同颜色的衣服以供辨别，叮嘱海洋馆员工把入园的时候没买住宿的人赶出去，而且1：00以后把所有灯都关了，让那些想投宿的人摸黑去吧！
你还发觉员工离职率有点高。你想了想，让员工干捕兔子这回事确实不太容易留住人。于是你把动物园员工也分为了两批，其中老员工穿黑衣服，负责干捕兔子之类的活，还有就是撕掉游客地图上的虚线――鬼知道为什么印刷厂送来的地图会有虚线！总有好事的游客沿虚线撕下一部分地图去喂动物，把动物喂死了
你的动物园终于开始盈利了――的确，它特别奇怪，压根就不是什么正常的动物园，但它能跑起来啊！发现你的动物园很奇怪的人认为你的动物园里有污染认知的东西，还写出了几张告示来保护人们。其实哪有什么“它”，就是一群秃头的程序员罢了！程序员又有什么错？","曾经在visa工作过，感觉什么10年20年的代码简直naive，你见过1965年的代码吗？第一次看到简直惊呆了，这半个世纪的代码现在还在用还跑的好好的？
机器是大型主机，语言是COBOL，估计这一辈的攻城师都没见过吧，90年代c和java都没什么气候的时候行业50%的人都在写COBOL，现在连这个语言的名字都没法出现在教科书里了吧。
能跑就接着让它跑吧，换的话成本太高。","我大二的时候在学校实验室有过一次失败的打工经历，大概就是学校一个实验室需要重写一部分代码，从FORTRAN到Java，我开始觉得还好，和两个朋友应聘都通过了，毕竟整个学校愿意为了打工专门学一下FORTRAN的人也是屈指可数。
拿到代码以后我们就懵逼了，这部分代码比我们所有人年纪都大，从197几年一直更新到1989年，以后再也没有人更新过，加起来有上万行，曾经有过文档但是丢失了，几乎没有注释，变量命名乱七八糟，为了让这坨代码在进入Windows时代后能跑起来，90年中期又有人专门给这坨代码用FORTRAN + C写了一个编译器，随着系统升级，编译器也不能用了，然后在2001年还是2003年又有人用 C 重写了编译器，得到了一个在当时Window版本可以用的二进制程序。但是因为系统升级以后，这个二进制程序不能用了，而且编译器也不能用了，就决定直接把最早的那堆FORTRAN代码重写。
原始代码为数不多的注释里，还有一些特别可怕的内容，类似“我也不知道这里为什么能运行，但是得到了正确的结果，千万不要改”。
我当时不知道屎山这个词，现在看到以后回想起来，简直是层峦叠嶂的屎山。
……
反正。
最后也没有重写成，解决方案是把电脑系统降级回去了。","从前 有个函数佳佳
type add(type a, type b);
它爸希望它返回a+b。
有一天佳佳被诊断出
先天过敏性疾病
，给它吃666和28,它居然拉肚子了（回答了250）。
//add(666,28) ――― 250
它爸的兄弟也就是它的舅舅们想了一个办法，在给他吃东西之前看看这东西它会不会过敏。
if(a!=666&&b!=28)
return add(a,b);
else return 694;
大家发现这种方法简单粗暴。于是每一次佳佳被诊断出先天性疾病的时候都在前面加上一句if else。
N年后，大家每次要去跟佳佳吃饭的时候，都得小心翼翼的检查食物。
if((a!=666&&b!=33628)||(a!=666&&b!=28)||(a!=3666&&b!=446628)||(a!=38666&&b!=65328)||(a!=4666&&b!=528)||(a!=4666&&b!=6667328)||(a!=7666&&b!=7628)||(a!=28666&&b!=399228)||(a!=2666&&b!=428)||(a!=375666&&b!=3928)||(a!=9666&&b!=328)||(a!=6636&&b!=48528)||.....||||(a!=66976&&b!=728))
    return add(a,b)
然后开始处理佳佳的过敏物
else if (a!=66976&&b!=728) return 67704;
else if (a!=375666&&b!=3928) return 379594;
else if (...) return ...;
............
else ............;
又过了N年，大家发现佳佳还可以被用来检测它亲兄妹健健的先天性疾病，于是有了
if(add(a,b)!=把上面那一坨东西写成
三元操作符
?:的形式，你懂的反正就是一坨)
sub(a,b)
else if (a!=66976&&b!=728) return ...;
else if (a!=375666&&b!=3928) return ...;
else if (...) return ...;
............
else ............;
后来医生对佳佳和它的近亲程程以楚楚芳芳等及其他拥有相同病症的人给出的治疗方案。
有一天，有个人发现了楚楚有一个特性，每当给它的第二个食物是0的时候它都会发脾气把家给烧了。这和它的远门祖宗球球表现的一模一样
exit(0)
可是佳佳的上司请不起球球，因为球球太贵了。
于是上司门决定给楚楚的第二道菜是0来让楚楚烧家。
exit(0) 被替代为 div(0,0);
1万年后，科技的进步，时代的前行。医生们考古发现了佳佳的先天性疾病，想对它进行治疗（debug）。
功夫不负有心人，佳佳的病被治好了。这个时候医生们发现，佳佳的病治好了，可是依赖佳佳的健健和程程们都因为佳佳的大病初愈而而疯狂。
医生们想着，既然佳佳都能被治好，那就顺便治一下健健和
程程
吧。
当医生们完成手速之后，发现楚楚，芳芳，开开，萍萍好像也因为他们被治好后而疯狂。 疯狂的不仅仅是他们，还有他们的孩子们（所有使用这些函数的人）。
于是医生们日复一日，年复一年的治疗啊，发现这治下去没完没了了。终于医生们放弃了，把治好的病人们又恢复了原状。（放弃debug）
终于世界又恢复了宁静。
10万年后，有个叫灭爸的人，它发现这样下去会有大量的资源被这些疾病缠身的人们给消耗殆尽。于是它打响了一个响指，所有
和佳佳
有关的人都被消灭了。灭爸和它的火帮负愁着年门开始了世界的修缮（重构）
终于在他们的执着努力下，所有被他们消灭的人的岗位都得到了新的替代。他们终于消灭了所有的已知疾病。
不知又过了多久，一个叫嘉佳的年前函数，被确诊为拥有了某先天性疾病。
................","看着难受，又不能改它，只要一动，山就塌了，将自己深埋屎下，臭不可闻。
就像你有几栋楼，几百个房间，手上拿着一串没有备注的钥匙，一个一个房间试，你以为你打开了，却没想，门后还有一道门。
当你费劲心思解决了所有门，你又发现，钥匙断了。
你完全不明白为什么要这样设计，那么愚蠢，当你有了个新想法，忙碌之后，又发现自己写的更蠢。
不要试图去理解它，改变它。
这是神圣的传火，让你的下一任有点事情做。","先给你看一下一坨屎一样的代码
这坨屎，忍忍，你有足够的时间还可以修复的。
花了我一天追根溯源了解需求；
花了一天修改代码；
花了两天对比自测，以及尽可能遍历所有异常场景，测试会怎么样，以及询问前开发，leader，产品，各个相关人士，这些问题得意见；
然后上线预防环境clone请求并行跑1天，对比两边结果是否一致，研究不一致的原因，并解决；
最后才正式上线…
300行代码终于变成30行..
如果这样的狗屎增加100倍，并随机遍布到其他100w行的正常代码中。
你试一下去解决一个bug？
你就会体会到攀爬一座屎山，并在上面采摘一个可以食用得部分的那种独特快感..
你除了骂一句 谢特shit，别无他法。
2021年6月1日
给大家介绍一下比上面更牛逼的狗屎代码。
先说最大的一个问题，增加一个字段需要同时修改10多个子项目，提交10多次github，build这些模块之前先instal一轮，模块之间编译安装的还有依赖先后..
这完美分布式单体应用，成功锁死所有修改，牵一发而动全身，这句话我算是懂了。
还有分支用来区分客户的。比如分支名huawei，就是客户华为，分支名weiruan。就是微软..….其他人无权利创建分支。
方便他自己管理项目呗
因此任意修改代码都需要“架构师”亲子处理，无其他人可以搞定。
另外公司离不开他了，整个团队中中他永远是受益者，不管招聘多少人开发效率还是太低了….一直加人…全体996也不行..然后他拥有了80多个下属….离职率百分80（能呆着超过2年的员工只有3人..）.…@可他已经升级成公司技术vp..
评论区的说kpi的同学，这就是你们想要的真实故事。
哈哈哈哈哈哈
那个代码我感觉挺多人说挺好的，没问题。
怎么说呢，确实没问题。
直男癌和撩妹高手的差别吧。
举个例子：
直男：我想和你嘿嘿嘿
撩妹高手： 我想和你一起看日出的
绝大多数人对于屎山是痛恨的，但是自己写的时候又还是写成了狗屎（包括我自己..）
这是人性，能偷懒不香。孔鲆恍┛床坏窖矍袄益得事情，没动力呀。
所以才有重构，重构就是为了解决这个问题。
大概思路：
1写最直觉无脑版本代码
2优化变量名称，函数结构，提取方法，类。抽象
3刷代码规范，
魔法值
呀，变量eqs常量 反过来呀，bean copy用工具类，
4面向对象的优化，函数式优化
5优化过多if
6性能优化
7更好的中间件选行替代
8容错，高可靠，高可用优化
每次一点点的来，没几个人能一步写到位。
2022年2月25日
那个架构师，升级成副总之后，半年不到，巅峰结束..…他被降级成为了team leader ，管10个人…
――――――
2022年11月5日
他被开除了，花了很长时间最长才找到工作。。。","有网友觉得我们技术总监水平太差，搞个脚本都要好几天，是什么野鸡总监……
这就不得不提到屎山里的另一个大坑，最初大家想的很简单，从生产上拿一份数据放到本地库里，再修改一下代码逻辑循环生成合同……但尴尬的是我们svn上的合同模板和生产上的不一样！
进操作间动生产数据不是吗那么容易的……大量的时间都浪费在和甲方勾心斗角上，留给写脚本、测试脚本的时间并不多……
说一个亲身经历的一座「屎山」，曾入职一家成立15年的软件公司，我当时应聘的是中级程序员，但在入职几个月后，我的岗级和薪资调整到了高级程序员，这并不是因为我在这几个月中技术水平跨越式提升，而是因为这三个月中发生了以下事情：
前任组员一号和我完成交接之后
跑路了
！
前任组长和新招来的组长交接之后
跑路了
！
前任组员二号和新招来的初级程序员交接之后
跑路了
！
新任组长和我交接之后
跑路了
！
新人组员（女）在工位掩面痛哭之后，
换组了！
（捂着脸掉眼泪不发出声音的那种哭）
组内人手严重不足，我白天解决生产bug，晚上写新需求！
这是一座年轻的「屎山」，我是第三批接手者，历时几个月后我成了项目组中，资历最老的员工！实习生和初级程序员写出来的bug和低级错误我就忍了，都是从菜鸟过来的，勉强可以理解。
但是框架因为“高程”、“架构组”、“大手子”等人的填填补补，已经到了严重影响用户体验的程度！！！
For example！
当时项目的工作流很奇葩，不论出现什么错误，都会统一提示“发生未知错误”。哪怕我照着“公司祖传框架使用手册”，在配置中填写「核算系统接口调用失败」、「当前时间不允许操作」、「xxx号风险
模型校验
失败」等提示信息，但客户用的时候还是统一提示“发生未知错误”！
起初因为运维人员每天都在帮客户解决这种问题，客户倒是没有多大的怨气。某一天，因为很复杂的原因，客户为了此事大发雷霆，我被要求解决这个问题。
在一顿忙碌之后，问题定位到了一个公司自己封装的
jar包
，反编译后发现里面的逻辑有问题。我就联系外地的架构组，让他们给我一个新的jar包，第二天我收到了回复：“这个框架很早就重构了，公司新框架不兼容老框架，使用老框架的项目都交给项目组自己维护了，你们项目组的框架应该是xxx在维护。”
xxx是一个很陌生的名字，几番打听之后才知道，xxx是我们组的第一任组长，离职两年多了！我只能在svn上继续摸索，愣是没有找到jar包的源码。几经波折之后才知道，svn之前是几个外包厂商共用的，后来因为外包厂商多了，就给每个厂商重新配置了一个
svn
，迁移的时候这个jar包的源码因为没有厂商认领，就被丢到了公用的svn上。
然而故事并没有结束，从公用svn找到的源码，和我通过反编译出来的代码，很多地方对不上！源码里的注释在我眼中都变成了「年轻人，千万不要动这坨屎！」
最后我只能在工作流外面，又封装了一套组件，专门用于代替工作流提示信息，并且留下了一行注释「
如果你不幸看到了这行注释，不要怪我，我也不想的！
」
以上只是「屎山」一角，「屎」是因为祖传代码里面有很多问题是真的臭，「山」是因为屎太多了。最讽刺的是，你可能为了治理「屎山」，也在里面拉了几次「屎」......
昨天答完问题，晚上做梦梦到了当时做项目填坑的苦逼生活，
气醒了！！！
今天再跟大家分享一个关于这座「屎山」的一角。
项目组负责的几个系统中，有一个负责放款的系统（
前置业务系统，并不涉及记账和转款
），放款是甲方爸爸非常核心的功能之一，上线之前肯定是重点测试的，所以我接手的时候已经平稳运行了数年。接手之后也没有出什么问题，整个放款业务也没有什么新需求，我也就没有深入研究，直到那一天......
背景是甲方爸爸接了个一个大单，但是因为量太大，其中几笔合同的合同号录差了，导致纸质合同和线上合同对不上，甲方爸爸就找到了我们组的一个组员去做数据处理。处理了一下午，线上合同的合同号还是没有变，组员来找我的时候已经满头大汗，我心中隐隐猜到，又要踩屎了。
我发现组员按照数据库文档修改了合同号，但是系统上还是显示旧合同号。因为已经踩了几次屎，我就直接去翻代码了。然后大量“中文拼音”命名的变量和无数意义不明的注释，看的我太阳穴一跳一跳的。
原来生成电子合同功能跟我们
想象
的不太一样，在完成放款操作时系统会生成一个以合同信息主键（36位UUID）命名的PDF存在
本地，
每一次点击下载合同其实就是根据主键ID下载这个文件，所以数据库里不论怎么修改对电子合同都没有影响，当时捋明白这个逻辑的时候我惊出了一身冷汗，但并不是因为这个设计多么的反人类......
前方高能！！！前方高能！！！前方高能！！！
前任运维人员交接的时候，说放款系统上线一年没啥问题，唯一要注意的就是因为与外部系统交互产生的交易文件很多，所以要定时
清理
，还当着我的面，删掉了一批日期比较早的文件。操作生产环境有指定的电脑，那台电脑上看pdf文件是没有后缀的，图标也是一张白纸，加上当时在场的人也都没有太在意，根本没有发现这些“交易文件”不太对劲。看着大概就长下面这样，谁也没有好奇的去看看里面是什么。
所以新任运维人员会定期去删除老旧文件，也就是以前的电子合同！！！
我当时就给技术总监和项目经理打电话，三个大老爷们大半夜跑到单位附近的肯德基研究对策。好在数据都在数据库里，技术总监捅咕了几天，写出来个脚本把所有被删的文件重新生成了一遍。但是服务器空间不够又传不上去，就跟甲方爸爸说电子合同这块设计不够完善（
前任技术总监背锅
），我们想要优化一下，不要钱的那种。
“事故”尘埃落定之后，项目经理想要追责却发现这锅只能他自己背，除了他全都是后来的......
在那个公司干了一年多，工资涨了三次，但我还是离职了，毕竟「屎」是真的难吃......当我把项目交接出去的时候，我就想起我在项目里留下的注释（屎），露出了和（幸）蔼（灾）亲（乐）切（祸）的笑容。
知乎第一个过百的评论，心情十分复杂[捂脸哭]
评论区很多朋友提出重构或重写系统，关于这一点本苦逼打工人又要吐槽了！
曾经在某一个外包项目上苦苦挣扎了一年半，除了春节基本没完整休过节假日，精神和肉体都处在崩溃的边缘，一度准备离职。项目经理苦口婆心地挽留我，发生了如下对话：
“小孙啊，这个项目明年就要重写了，到时候你就是这个业务条线的leader，其他公司哪有这个机会。”
（别走啊，现在这个摊子磨走了多少人，就你钱要得最少还干得最长）
“我敲代码还行，我这年纪轻轻的当不了领导，而且重写项目这事说了一年了，也没看到动静。”
（当时参与系统原始需求的甲方，要么高升要么跳槽了，重写个鸡儿，那就是新做个系统！别以为我不知道，就是因为价钱没谈拢，重写的事儿才一直没开工，不要给我画大饼！）
“那你再等半年，年底往上申报调薪的时候，我给你多涨点，你要是不满意再走也不迟，现在这时间段工作也不好找。”
（年底先给你涨500，现在这时间段人不好招，等年后招来人了，谁还管你走不走。）
“现在工作还挺好找的吧，已经谈好两个下家了，薪资都比现在高不少。”
（别跟我画饼！）
“你这是早就准备好了啊？不再考虑考虑？”
（年轻人不讲武德！再给你最后一次机会，耗子尾汁！）
“也考虑挺长时间了，可能是我不适合这份工作吧，希望公司能越做越好。”
（绿水青山，永不相见！垃圾公司，赶紧倒闭！）
很多系统是不具备重构、重写条件的，原始需求早就没有影了，能找到操作手册都算是不错了。总不能让程序员根据屎山倒推需求吧，那得推出个啥来？！
最后脱离苦海，摆脱了一座屎山！后来找工作的时候，就尽量避免外包了，外包公司的屎山是最高最臭的，因为上面拉屎的人来自天南海北！","你面对一个巨大的屎山。
有的块都发黑变硬了，也有的还新鲜带虾仁的。
不要试图了解都是谁拉的他们吃了什么。
新需求就撇条新的垛上去。
旧bug就试试自己拉泡稀的把旧的粘起来拍打拍打能用就行。
不要试图去
refactor
什么，敲开硬壳子可能溢出旁边那坨的芯，窟窿越捅越大。
什么
设计模式
代码风格也不用多在意，山上什么样的都有。
不行就上手捏出需要的形状
hardcode
。","屎山通常由一开始的沟通不畅或学艺不精引发，这是人类工作中几乎不可避免的，尤其在当下，很多领域的程序员门槛越来越低的大环境下，上述问题更是难以避免。此时随着新需求的引入，或者已有需求与条件的变动而产生的大量编写与重构工作中，由于周期短，工作量大，可能存在人员交接等情况，上述问题将会在工作中产生极大的影响；而“祖传”只是将这种影响累计起来，最终可能就会走向一发不可收的局面，所以通常就会把各种祖传代码称为“屎山”。当然这么说感觉很空中楼阁，不如我给你个形象的比喻吧：
现在，甲方给你了一个很简单的需求：提供给他纯净的乙酸乙酯，你现在要实现他的这个需求。
首先，你可能会想到最简单的实现：就像蒸馏后的污水会变成纯净的水一样，你也可以去工厂回收废旧的乙酸乙酯，然后搭建一个蒸馏器，这样把蒸馏出来的纯净乙酸乙酯提供给甲方，任务就完成了。
但很快问题出现了：工厂送来的废旧乙酸乙酯开始混有乙醚了，这玩意沸点比乙酸乙酯还低，一蒸馏会跟着乙酸乙酯一起出来，纯度满足不了客户的要求了。好在学过高中化学的你很快给出了解决方案：既然已经花大精力搭了蒸馏装置了，不如直接把原料换成乙醇，乙酸和浓硫酸，直接制取乙酸乙酯，这样收集的地方加个饱和碳酸钠溶液，把出来的乙醇和乙酸吸收掉就好了，客户的要求还是可以满足。你对这个想法很满意，于是改造完交给手下的小A管理了。
但可惜你忘记交代小A装置被你改过的事情了，他还以为你在用上一套蒸馏废旧乙酸乙酯的那套装置，于是他望着收集装置处出了神――这出来的不就已经是纯净的乙酸乙酯了嘛，为什么还要用碳酸钠洗一遍，上一任维护者真是不懂得节约。于是小A自以为聪明的去掉了收集装置处的碳酸钠溶液。
结果这一去，甲方大大暴怒了：你这送过来的乙酸乙酯咋出口处显示的pH值还是4呢，这肯定纯度不行，以后再这样咱合作取消。小A一听这也不是个事，于是紧急连夜拆拆探探地检查了整个蒸馏器，但是不论怎么检查，都没发现蒸馏器的什么问题。“那既然蒸馏器没问题，肯定是出口处那个pH监测器坏了”，小A如是想到。于是在小A的一番调整下，显示的数值调整到比实际的数值大3，这样看起来就是7了，完美。甲方大大看过后也点头，这件事就这么结束了。
直到小A的接班人小B到来了，小A临走前告诉他，那个pH检测仪是坏的不要随便乱动，蒸馏器加的原料是废旧乙酸乙酯，你只要看好蒸馏器就行。但是这个小B可是个人才，他一番折腾后发现pH检测仪可是太正常了，就是被小A人为调大了3，这小B可是气不打一处来，好嘛，小A你自己瞎调赖机器有问题，看我给你调回去。
结果调回去后小B傻眼了，咋蒸出来的东西pH值都是4，但好在小B没那么傻，发现加料的地方可不止一个孔，还有一个孔加的是浓硫酸，小B想了想，既然另一个孔小A说是加的废旧乙酸乙酯，那这个浓硫酸估计就是干燥废旧乙酸乙酯用的。“虽然硫酸难挥发，但谁知道这蒸馏温度有没有人动过，没准是少量硫酸也被蒸出来了呢”，这样想着，小B把浓硫酸换成了中性的无水氯化钙。
结果这下好了，问题更大了，不但蒸出来的产物pH值比4还低，而且居然还能溶在水里(乙酸乙酯几乎不溶于水，
这里应大家要求额外写一些注解:浓硫酸，无水氯化钙和下文的无水硫酸钠都可以用来除去乙酸乙酯中的水；但是浓硫酸在这里还有一个作用:帮助乙醇和乙酸反应生成乙酸乙酯。小B在这里擅自去掉了浓硫酸，那蒸出来的基本上就是乙醇和乙酸的混合物，自然pH值不对劲
)，小B赶快换了同样是中性的无水硫酸钠，但依然是这样。结果就是，在停工了整整一天后，小B也没能解释清楚这股子无名之酸是哪里来的。
伴随着甲方大大的反复催促，这工不能再停了，但是问题又确实查不出来。没办法，小B只好在产物里加一些生石灰，然后额外加一套过滤装置把多余的生石灰过滤走，最后把测定出pH值合格的产物交给甲方。
从此，本来一套简单的蒸馏器，在收集处不但多了一个生石灰添加装置，还多了一套过滤装置，不仅如此，还有小B留下的温馨小提示：“不要动加料口处的浓硫酸和收集处的任何装置，本生产车间严格依靠这些装置运行，任何的操作都可能会导致生产无法进行”。
屎山就是这样炼成的；这下你是不是就懂得，为啥很多祖传几代的代码，就会不可避免地变成“屎山”"
,,,,,,,,,,,,,,,,,,,,,
学 Python 都用来干嘛的？,我最近学python，不过不知道怎么练习，不知道用来写什么。大家都用来干嘛的？都说说python可以用来写什么好玩的东东。,"python能做太多有趣的事了，看看我是怎么玩的
先动动小手关注一下呀 
@朱卫军
 ，已经写了几百篇原创技术回答和文章，后续会继续努力！
自动发邮件
自动化操作excel
最近做了个Python办公自动化的Live讲座，里面对技术讲得更加详细
广告
如何利用python进行自动化办公？
作者 朱卫军
会员专享
￥9.99
去查看
?
大家有什么编程或者求职的问题可以在值乎向我提问哈
朱卫军
52 次咨询
4.9
Python优秀回答者
190573 次赞同
去咨询
定制酷炫二维码
下载视频、MP3
爬虫
HTML\网页自动生成PDF
从PDf中抽取图表
制作可视化图表
地理空间分析
数据分析
连接数据库
机器学习
正则表达式
文本转音频
淘宝抢购
OCR识别
如果你不知道如何学习python，入门困难
如果你想从事数据分析，学习分析技术
如果你想学习sql
如果你想学习tableau
如果你想选择一些好的python技术书
广告
Python编程  从入门到实践 第3版（图灵出品）
京东
￥69.80
去购买
?
广告
利用Python进行数据分析 原书第3版
京东
￥96.90
去购买
?
Python基础知识小技巧
看到这里，大家不要忘了关注
朱卫军
哦，还写了好多好多好多~","能写的东西可太多了，
日常生活的有这么些有趣的教程
：
比如哄哄女朋友：
Python导出微信聊天记录并生成词云
，备用地址：
向手机发送通知：
教你如何使用Python向手机发送通知(IFTTT)
，备用地址：
文献搜索工具：
你不得不知道的python超级文献搜索工具
，备用地址:
制作日历：
Excel+Python=精美壁纸日历 任意DIY
检测人脸是否佩戴口罩：
20行代码检测人脸是否佩戴口罩
，备用地址：
打水印：
超简单Python安全批量打水印教程！
提取音乐高潮：
Python 制作音乐高潮副歌提取器
，备用地址：
如果你想成为超级极客，可以看看这些文章：
树莓派+智能音箱：
Python声控普通风扇
、
Python声控开机
树莓派
+摄像头：
Python人脸识别开机
Python 深度学习图像风格迁移
想看更多
更多有趣的Python教程欢迎关注公众号：Python实用宝典
或者访问网站：
Python实用宝典","熊孩子浏览器
我们家娃喜欢看电视，一看就没够，为了让她在看电视的时候做点儿有意义的事情，我用python做了一个小程序，叫bear_kids_player. 说起来也简单，就是在播放视频的时候每隔一段时间弹出一个对话框，里面有一个问题，让孩子输入。答对了对话框就销毁，然后视频就接着播放；答不对，对话框就一直在那里，视频停止。
最初的设定只是让孩子输入字母或者做做加法，后来加了一点改进，目前可以显示图片，并且自动朗读显示的单词。
具体安装只要用pip install bear_kids_player 就可以。
安装结束以后，用如下命令可以启动：
import bear_kids_player
import run_bear_kids_player
run_bear_kids_player.run_bear_kids_player()
ctrl+o 可以打开视频
ctrl +F2 可以关闭视频
在 .../bear_kids_player 文件加下有一个config.csv 文件，可以对一些参数进行设定
比如：Intervals(间隔时间)， 打开文件的快捷方式，关闭文件的快捷方式，题库筛选的阈值，题库筛选所需的类型
另外还有一个questions.csv 文件，这是一个题库。这个题库可以自己输入题目，答案，类型，以及想要显示在对话框里的图片链接，可以依据个人的情况自己添加题目。
下面是一个简单的演示
当然由于朗读功能使用的是gtts实际上链接google获取音频的，所以在国内可能朗读功能会不那么好用。不过本来也就给自己娃写的程序，倒是也没指望推广。
python的主程序用的
pyqt5
，总共用了我大概一周业余时间完成，由于对一些库以及发布python包不是很熟悉所以浪费了很多时间。
此外，视频解码程序是K-Lite_Codec_Pack_1526_Basic（17MB），可以从
K-Lite Codec Pack
?
downloads.ddigest-dl.com/software/download.php?sid=1089&ssid=0&did=374
下载到，需要安装解码程序才能对常见的视频格式进行支持。
家里的娃娃三岁半，原本小写字母认不熟，许多字母会搞混譬如p，q，g，d，b，还有一些小写字母认不出，教了无数遍都不上心学。自从使用了这个程序大概三天左右，小写字母都差不多认识了。增加了单词输入题目以后，娃娃只用了两天就可以不依赖我的帮助，自己把我事先设定的10个单词准确输入了。我们家娃从来没接触过键盘，有这个成绩我还比较满意。
后面可能会做些升级，比如要求娃朗读，然后用pyttsx库做语音识别输入；或者去掉她输入熟练的单词的显示，让她依据读音输入单词。或者换些加减法等数学问题。总之慢慢添加新功能。
程序没有很认真地注释，距离工业级水平相差甚远，目前就是东拼西凑 能用就行的状态，不喜勿喷。","学习了Python其实可做很多事情，首先你可以找一份好工作！！
来看看这份职业规划书
学了Python我们选的工作：
web开发工程师
人工智能工程师
数据分析师
爬虫工程师
自动化运维工程师
自动化测试工程师
当然，如果你想自己做一些事情，比如爬一下喜欢的图片，爬某个网站，或者是抢火车票都可以，下面我们就来说说具体的！
想聊私密话题，就用Python来做个聊天器
配套资料：
https://
pan.baidu.com/s/12mlxhK
w1tFPSDuAZkkBLKQ
 
提取码
：i1or 
节假日抢不到火车票，不用怕，用Python全自动抢票
配套资料：
https://
pan.baidu.com/s/1E3O-gF
BbzaUcjtvSBROBtg
   提取码：9epq
想去吃饭游玩不知道哪好，用Python实现实时比较
配套资料：
https://
pan.baidu.com/s/1FcO28D
BQIrFqZ1_dTyRitw
  提取码：yem6 
想换工作，可以利用Python爬取适合你的职位信息哦！
配套资料：
https://
pan.baidu.com/s/1_Jankx
PLCvwqpD8MR7ZoqQ
 提取码：edrg 
用Python搭建你想搭建的系统
配套资料：
https://
pan.baidu.com/s/1jHMLUT
4H-Bf1EYKlDZjwIQ
  提取码：6arw 
用Python搭建聊天机器人
配套资料：
https://
pan.baidu.com/s/11hUdZj
rmjI91vk-hF61uug
  提取码：quha 
更多Python用途（想学习哪个可以直接私信我获取哦）：
关于Python的学习，可以看Python入门教程完整版，600集让你轻松入门Python！
Python入门教程完整版（懂中文就能学会）
配套资料：
https://
pan.baidu.com/s/12-dymJ
8FjWzh6b5NKJuP3Q
 提取码：gqly","2020年03月29日-更新：
有不少小伙伴私信我学习python的方法。我简单回复一下。
入门推荐：
1、
廖雪峰
的python网站。讲的很基础，很适合初学者入手。
2、有了基础后推荐做一些小项目。使用python做个表格，自动处理数据。或者参考我这篇文章做个爬虫。在这个过程中肯定会遇到很多的问题，这也正是提升自己的最好方式。
3、假如你是程序yuan或者科班学生，那么更推荐你刷LeetCode。选择python答题。双管齐下，效果更佳。
4、最后的最后，推荐一款我最近在用的学习辅助工具。
百词斩――夜曲编程。
它的优势在于：
    复杂+理论――生动+理解+样例+练习+纠错。主要专门对计算机考试，但是并非是刷题，而是重在理解
    零基础――深入进阶，对小白友好，对基础不好比较友好～。有学习群、助教全程陪伴学习，疑问可以在线解答，可以反复与大师沟通经验。
    感兴趣的同学可以关注【夜曲编程】，后台回复【免费教程】开启白嫖之路。
夜曲编程
    有什么python下载问题，和库的安装、删除的问题都可以找夜曲编程的人员问问，就不用花精力捣鼓下载python，学习python的过程会更加方便。
-------------------------------------------- 我是分割线 -------------------------------------------
我来更新一波，最近又学了些骚操作，那就是查阅网上的图片，更进一步来说可以瞻仰漂亮小姐姐的图片。
有时候当你浏览这么一个话题时。
想要一次性全部下载图片，作为珍藏，但是总不能手动一张张保存吧，这时候就要祭出时代的翘楚，乱世之英雄了。
好了，话不多说，先上代码，你们拿去运行，收获了喜悦之后，再来体验知识的曼妙！
此代码，直接在cmd中能跑起来，自动在当前目录创建一个文件夹存放图片。
# -*- coding: utf-8 -*-

import requests
import json
import time
import re
import os
import datetime
import pandas as pd
from urllib import parse
from lxml import html

UrlDataCnt = 1
SaveImageCnt = 1
ObjectUrlPage = 0
LastImage = 0

QuestionId = 1
DefaultFolder = ""download-zhihu-image""
DownloadFolder = ""NewFolder""

def SelectModel():
    DownloadMode = input(""please input download model(default model is 0, ID model is 1):"")
    #print(""DownloadMode is "",DownloadMode)
    return DownloadMode

def DefualtMode():
    global DownloadFolder
    global QuestionId
    DownloadFolder = DefaultFolder      # default save folder
    QuestionId = 297715922              # default id

def InputMessage():
    global QuestionId
    global DownloadFolder

    QuestionId = input(""please input id:"")
    DownloadFolder = input(""please input folder name:"")

    # print(""Id:"", QuestionId)
    # print(""folder name:"", DownloadFolder)

def MakeDir():
    if not os.path.exists(DownloadFolder):
        print(""create the path successful"")
        os.mkdir(DownloadFolder)
    else:
        print(""the path is exist"")
 
def GetHtmlData(url):
    headers = {
        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36',
    }
 
    try:
        r = requests.get(url, headers=headers)
        r.raise_for_status()
        return r.text
    
    except requests.HTTPError as e:
        print(e)
        print(""HTTPError"")
    except requests.RequestException as e:
        print(e)
    except:
        print(""Unknown Error !"")
        
def ParseHtmlData(html):
    JsonData = json.loads(html)['data']
    #print(""JsonData:"", JsonData)
    UrlData = []
    
    try:
        for item in JsonData:
            #print(""item:"",item)
            Formula = ""(ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?"" 

            Content = item['content']          
            print(""Content"", Content)

            p = re.compile(Formula)
            iterator = p.finditer(Content)
            for match in iterator:
                #print(match.span())
                #print(match.group())
                UrlData.append(match.group())
                print(""match:"",match.group())

        return UrlData
    
    except Exception as e:
        print(""error"")
        
def SaveImage(Image):
    global SaveImageCnt
    ImageName = str(SaveImageCnt) + "".jpg""
    SaveImageCnt = SaveImageCnt + 1

    ImagePath = os.path.join(DownloadFolder, ImageName)
    with open(ImagePath, 'wb') as  f:
        #print('Output:', ImagePath)
        f.write(Image)

def ParseImageData(ImageUrl):
    resp = requests.get(ImageUrl)
    Image = resp.content
    #print(""Image:"",Image)
    # remove the same picture
    global LastImage
    if LastImage != Image:
        SaveImage(Image)
    LastImage = Image
    
def ParseImageUrlData(UrlData):
    global UrlDataCnt
    for Url in UrlData:
        print(""Url:"", Url)
        ParseImageData(Url)
        # if UrlDataCnt % 4 == 0:
        #     #print(""Url:"", Url)
        #     #ParseImageData(Url)
        # UrlDataCnt += 1     

def GetObjectUrl():
    # print(""ObjectUrlPage:"", ObjectUrlPage)
    # print(""QuestionId:"", QuestionId)

    ObjectUrl = ""https://www.zhihu.com/api/v4/questions/""+str(QuestionId)+""/answers?include=data%5B%2A%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crelevant_info%2Cquestion%2Cexcerpt%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%2Cis_labeled%2Cis_recognized%2Cpaid_info%2Cpaid_info_content%3Bdata%5B%2A%5D.mark_infos%5B%2A%5D.url%3Bdata%5B%2A%5D.author.follower_count%2Cbadge%5B%2A%5D.topics&limit=5&offset=""+str(ObjectUrlPage)+""&platform=desktop&sort_by=default""

    return ObjectUrl
 
def DataProcessing():
    global ObjectUrlPage

    # get object-url
    ObjectUrl = GetObjectUrl()

    # get totals number
    Html = GetHtmlData(ObjectUrl)
    UrlTotals = json.loads(Html)['paging']['totals']
    print(""UrlTotals:"",UrlTotals)
    print('---'*10)
      
    # Traverse all URLs
    while(ObjectUrlPage < UrlTotals):
        # get data from object-url
        Html = GetHtmlData(ObjectUrl)
        ImageUrlData = ParseHtmlData(Html)
        ParseImageUrlData(ImageUrlData)

        # get object-url
        ObjectUrlPage += 5
        ObjectUrl = GetObjectUrl()
        
    
if __name__ == '__main__':
    Model = SelectModel()       # select download model
    if Model == '1':
        InputMessage()          # input message from you
    else:
        DefualtMode()  

    MakeDir()           # create folder 
    
    DataProcessing()    # data processing 

    print(""finish"")
现在，我们来开始讲解具体的实现原理，实现步骤，实现方法。
    这部分下次更新，我要去睡觉了。
看了各位dalao的回答，又增长不少知识。心中不禁感叹！
我当初学习Python的目的很简单，
为了解决工作中的问题，提高工作的效率
。我的工种是嵌入式软件，按理说与Python八竿子打不着，但实际恰恰相反。
我学习的背景为，我负责开发的设备每天都会产生大量的日志，而通过日志数据可分析bug。以前都是人工统计，就是一个一个的数，看的头昏眼胀，数据量小的时候勉勉强强还行。但数据量大了之后就凉凉。所以我学习的目标就非常明确了。所以我建议题主带有目标的学习，就不会出现不知道该如何练习这类型的困惑了。
好了，嗦嗦又讲了一大堆。
总而言之一句话，可以分析数据，解决bug。
那么问题抽象出来，如何从大量的数据文件中寻找制定的内容呢？
一、实现思路：
读取文件
选中指定的内容段
在新路径下保存内容段并命名为之前的文件名、
二、代码实现。（为了更有说服力，那就贴一下我的代码，仅供参考）
#!/usr/bin/env python3


# -*- coding: utf-8 -*- 


import
 
os


import
 
re


regtxt
 
=
 
r
'.+?\.txt'
 
#扫描对象为txt文件.


regcontenthead
 
=
 
r
'<!-- ========== METHOD SUMMARY =========== -->'
  
#找出指定的开头


regcontentend
 
=
 
r
'</table>'
                 
#找到指定的结尾


class
 
FileException
(
Exception
):

    
pass


def
 
getdirlist
(
filepath
):

    
""""""获取目录下所有的文件.""""""

    
txtlist
 
=
 
[]
 
#文件集合.

    
txtre
 
=
 
re
.
compile
(
regtxt
)

    
needfile
 
=
 
[]
 
#存放结果.

    
for
 
parent
,
 
listdir
,
 
listfile
 
in
 
os
.
walk
(
filepath
):

        
for
 
files
 
in
 
listfile
:

            
#获取所有文件.

            
istxt
 
=
 
re
.
findall
(
txtre
,
 
files
)

            
filecontext
 
=
 
os
.
path
.
join
(
parent
,
 
files
)

            
#获取非空的文件.

            
if
 
istxt
 
:

                
txtlist
.
append
(
filecontext
)
                
                
#将所有的数据存放到needfile中.

                
needfile
.
append
(
readfile
(
filecontext
))
 
                
#print('needflie:', needfile)

    
if
 
needfile
 
==
 
[]:

        
raise
 
FileException
(
""no file can be find!""
)

    
else
:

        
#print('needfile:',needfile)

        
validatedata
 
=
 
getvalidata
(
needfile
)

        
#print ('validatedata', validatedata)

        
print
 
(
'total file 
%s
 , validate file 
%s
.'
 
%
(
len
(
txtlist
),
len
(
validatedata
)))


def
 
getvalidata
(
filelist
=
[]):

    
""""""过滤集合中空的元素.""""""

    
valifile
 
=
 
[]

    
for
 
fp
 
in
 
filelist
:

        
if
 
fp
 
!=
 
None
:

            
valifile
.
append
(
fp
)

    
return
 
valifile


def
 
readfile
(
filepath
):

    
""""""通过正则匹配文本中内容，并返回文本.""""""

    
flag
 
=
 
False

    
contentrehead
 
=
 
re
.
compile
(
regcontenthead
)
          
#regcontenthead = r'<!-- ========== METHOD SUMMARY =========== -->' 

    
contentrend
 
=
 
re
.
compile
(
regcontentend
)

    
fp
 
=
 
open
(
filepath
,
 
'r'
,
 
encoding
=
'UTF-8'
)

    
str1
 
=
 
""LCP_Read""

    
str2
 
=
 
""LCP_Write""
 
    
Newfilepath
 
=
 
filepath
.
replace
(
str1
,
 
str2
)
        
#保存到新的路径

    
fpWrite
 
=
 
open
(
Newfilepath
,
 
""a+""
)

    
lines
 
=
 
fp
.
readlines
()

    
#print('lines:', lines)

    
flines
 
=
 
len
(
lines
)

    
#print('flines:', flines)

    
#逐行匹配数据.

    
for
 
i
 
in
 
range
(
flines
):
 
        
iscontenthead
 
=
 
re
.
findall
(
contentrehead
,
 
lines
[
i
])
 
        
j
 
=
 
i

        
if
 
iscontenthead
:

            
for
 
j
 
in
 
range
(
flines
):

                
if
 
j
 
<
 
i
:

                    
continue

                
else
:

                    
iscontentend
 
=
 
re
.
findall
(
contentrend
,
 
lines
[
j
])

                    
fpWrite
.
write
(
lines
[
j
])
     
#把指定的内容写入文件

                    
if
 
iscontentend
:

                        
fp
.
close
()

                        
fpWrite
.
close
()

                        
#print('filepath', filepath)

                        
return
 
filepath
                       

if
 
__name__
 
==
 
""__main__""
:

    
getdirlist
(
'C:
\\
Users
\\
Dandelion
\\
Desktop
\\
LCP_Read'
)
  
# 注意此处是绝对路径
以上为代码实现！（话说知乎的编辑为什么没有代码类型文本的编辑呢）","如果你还没有开始使用Python，答应我，把这个回答看完，如果你真的学习并深入使用过Python，我想你一定会爱上他，并且对于Python的未来充满期待。
对于Python而言，不光是简洁的语法，它广泛的应用场景，完善的语言生态，丰富的库，都吸引着我不断地探索，接下来，我分两个方向和大家聊一聊 Python在各个领域中的
降龙伏虎
之能，不要走开，我们一起探索一下。
首先来说一下极其推荐的方向：
1、数据分析
可能几年之前，说到数据分析，你并不会想到Python，但不知从什么时候开始，数据分析师的简历上，Python已经成了最亮眼的加分项。各种数据分析框架的出现，让Python这种本就极其简单的语言更加方便易用，让数据分析师可以将更多的经历放在数据本身。而后随之而来的各种数据可视化框架，也让数据分析工作不再需要切换不同的语言不同的软件，将所有的工作集中交给Python，他都可以用最简单便捷的方式帮你完成。
话说数据分析是当下一个非常热门的方向，如果你想学习的话，可以学习知乎
知学堂
推出的官方课程，
学习3天，只需要1毛钱。知乎数据分析大V猴子老师讲课，近距离跟大佬学习。
学习数据分析方法，通过方法拆解任务问题，思维+方法双重进阶，告别数据小白。
快来报名吧！
数据分析 3 天实战训练营
￥0.10
已失效
2、科学计算
曾几何时，讲到科学计算，我们想到的就是几个头发花白的老教授在实验室里不停的计算，但如今，我们每个人都可以站在巨人的肩膀上进行科学计算，这个巨人就是丰富的科学计算库，我们只需要几行或者十几行代码就可以做到数据的预测，评估，图像的判别，修复，路线的规划，修改等，随着近几年Facebook，Google，百度等大厂的加入，Python在科学计算方向的地位水涨创高，现在已经成为数据挖掘，机器学习，人工智能等的第一编程语言，相信过不了多久，可能我们人人都是数据科学家吧。
3、大数据框架
大数据现在可是风口，不亚于10年左右的移动互联，怎么能少了Python的身影呢！近几年Python你在大数据领域的发展也是风生水起，虽然无论是实时还是离线计算，Python你的性能都是远不如Scala与Java的，但是Python的易用性，以及丰富的库，大大提高了大数据开发者的工作效率，同时，Python能够更好的兼容各种
科学计算库
，让大数据的开发从根本上规避了各种复杂的技术问题，摆在我们面签的更多是业务，程序员的个人能力被各种框架无限放大，知道项目上线前的一刻，你可能还不知道自己原来如此优秀。
4、
脚本开发
通常，脚本编写是指编写小程序以让简单任务自动化。从简单的定时开机关机，批量修改删除文件，到复杂的游戏外挂，自动抢票，整点自动秒杀，再到企业级的定时任务脚本，自动化运维，自动化测试等等都是脚本的应用，简单的开发过程，以及强大的功能，让Python可以在脚本编写领域和Shell有一较高下之力。
5、爬虫
说道Python就不得不说说爬虫，很多人了解Python都是从爬虫开始的， 至于为什么，我只能说，贴近生活，简单高效，既可以解决工作，生活中的数据需求，又可以做些私活赚点外快，何乐而不为呢？
6、Web框架
很多人都认为Web方向是Java的赛道，没错，现在市场上90%的web服务还是java实现的，但是由于Python服务的简单高效以及完美的扩展性，让技术门槛变得非常低，几行代码就可以制作一个简易的Web服务器，现在有多少大学生的第一个博客项目就是Python编写的呢？
再说一下可以做，但不推荐的方向：
1、
嵌入式应用
对于嵌入式应用，我不在行，但是我知道Python可以配合Rasberry Pi工作。它在那些硬件发烧友中非常流行。
2、游戏
您可以用
PyGame库
来开发游戏，但是，它不是最流行的游戏引擎。如果把游戏作为兴趣爱好，您可以用它来构建项目，但是，如果您真的要做游戏开发，我个人不建议选择它。
相反，我推荐您用Unity的C#脚本，它是最流行的游戏引擎之一。它允许您在很多平台上构建游戏，这些平台包括：Mac、Windows、iOS和安卓。
3、桌面应用
您可以用Python的Tkinter来开发，但是它似乎不是最流行的选择。相反，用Java、C#和C++等语言开发桌面应用看起来更流行。最近，一些公司也已经开始使用JavaScript来创建桌面应用程序了。比如，Slack的桌面应用程序是用Electron来构建的。它允许您用JavaScript来构建桌面应用。
就我个人来说，如果我要构建一个桌面应用，我会用JavaScript。它允许您复用Web版本的某些代码（如果有的话）。
当然，Python的能量不仅仅如此！！！我们一起期待Python带给我们的其他震撼吧。
希望我的解答可以对大家有所帮助，也欢迎大家随时补充交流。","“学 Python 都用来干嘛的？”看了一些小伙伴们的回答，已经列举了很多应用。那么这里再为大家补充一款同样免费、好用，而且更加灵活的 Python 应用工具，那就是：
SeaTable
 表格，它同时结合了协同表格的易用性和数据库强大的数据处理能力，支持“文件”、“图片”、“单/多选”、“协作人”、“公式”等丰富的数据类型，能帮我们用表格的形式来方便地组织和管理各类信息，和专门的软件系统一样强大。它还可以按照需要进行扩展，实现数据处理的自动化和业务流程的自动化。它自带数据收集表、 Python 脚本、JavaScript、API 、可视化插件、数据处理、BI高级统计分析、自动化规则等功能。其中在 Python 方面，就提供了完善的 Python API，我们用它可以快速地开发出自定义数据处理流程，可以基于表格快速实现各种 IT 小应用、工作流程，甚至业务系统等。
再具体点来说，在 SeaTable 表格中，我们可以上传 Python 脚本到到平台，可以把脚本和数据放在一个地方进行管理，不需要再单独找一个服务器。同时，可以在表格中根据不同的需要存储多个 Python 脚本文件， 一键点击运行或通过设置自动运行就可以达到我们想要的效果。而且，相比于传统的 Excel 表格， SeaTable 表格支持单表千万级数据，同时提供 SQL 查询接口等。为 Python 应用提供了完善的功能支撑。
另外，它支持免费私有化部署，可以用 Docker 方式，简单易维护。
下面，我们就来看 Python 结合 SeaTable 表格的一些应用。实操举例：
1.
用 Python 从维基百科抓取冬奥会城市信息到 SeaTable 表格并自动生成地图
用 Python 从维基百科中抓取往届举办冬奥会的城市数据， 然后自动填入到 SeaTable 表格中，并用 SeaTable 表格的可视化插件自动生成城市地图、城市图库。
表格数据
自动生成地图
自动生成图库
2.自动化更新网站证书过期时间，自动化监控和提醒网站证书过期时间。
比如我们团队平时管理的站点就有20多个，全部使用的是免费的 Lets' encrypt 证书，并通过脚本在证书过期前自动更新证书。偶尔会出现脚本没有配置对或其他的原因导致证书没有正常更新，尤其是对新部署的站点。这就需要制作一个应用来解决这类的问题。
使用案例如下：
3.用 SeaTable 表格整理股票的零散信息，用脚本自动更新股票价格等数据。
比如用 SeaTable 表格做了一个股票池，将股票名称、代码、相关文件资料等信息都记录到了一起，并且增加了一个“股价更新”脚本，通过代码调用网上的股价数据，一键点击就可以自动更新股价，甚至还可以设置每天自动更新等。这样，查询和管理自己的股票信息就变得更简单方便了，而不用每次必须登录证券交易软件来查询。
股票池
00:23
使用案例如下：
4.用 SeaTable 的表单、Python 脚本、统计功能，快速实现打卡小应用，轻松完成打卡活动。再也不用麻烦程序员耗时耗力地去开发应用，更不需要花钱购买软件了（本案例中的脚本代码，修改下字段名称即可使用）。
比如在本案例中，本活动的打卡规则是：参与者须连续9天，每天打卡一次，并且打卡时间是在16点至22点前。如符合规则，那么活动结束后，我们会如数返还之前缴纳的费用。因此，我们会按打卡规则编写脚本代码。利用编写好的脚本筛选掉不符合打卡时间的打卡者。
下方这个视图中的“标记”列，就是用来自动标记通过脚本筛选出的不符合打卡时间的打卡者。
完成上一步后，我们在下方的视图表上，点击右上角的“脚本”，将编写好的脚本代码粘贴或者导入进去。然后就可以点击运行脚本了。
脚本会对「标记筛选视图」 里的汇总数据自动进行如下处理：
打卡时间不在16点至22点前的则被判定为无效，会自动在“标记”列显示为“无效”；
打卡时间在16点至22点前的，在“标记”列会显示为空，并且打卡者如果在一天内打卡多次，也只会取16点至22点前的第一次打卡时间作为有效记录。也就是说，即使有打卡者每天都打卡了，且每天有多个16点至22点前的打卡时间，那么该打卡者每天也只会有一次有效记录。
运行脚本后，如下图：
脚本地址：
https://github.com/seatable/seatable-scripts-cn/blob/master/examples/python/verify_records.py
后面一步更简单，用统计功能统计出连续打卡9天及以上者即可。本案例如下：
5.用脚本快速实现考勤数据的自定义处理。
比如，从考勤机中导出来的打卡记录，存在每人每天的具体上下班打卡时间都在一列里，也存在着每人每天有多次打卡时间的记录。那么我们用脚本就可以从表中获取每人每天的最早打卡时间作为上班打卡时间，获取最晚打卡时间作为下班时间。并且把每人每天的最早打卡时间、最晚打卡时间统计到一行，这样就十分清楚了。
案例如下：
6.用 SeaTable 的“表单”做问卷调查，然后通过表格右上角的“脚本”，写一个简单的脚本从参与问卷调查的用户中抽出几个中奖用户。轻松完成一个从数据收集到数据处理的完整的小型应用。
案例如下：
7.SeaTable 表格的“按钮”列也支持运行自定义脚本。方便在表格中实现交互自动化操作。
“按钮”是 SeaTable 表格的一种交互式字段类型，在用了“按钮”列类型的单元格中，通过点击按钮或自动化触发，就可以执行指定的动作，自动完成一些数据处理和工作流程。这些动作包括但不限于：运行脚本、发送邮件、发送企业微信消息、将行复制到另一个表、修改行等。
8.SeaTable 表格的“自动化规则”功能支持设置多种触发条件，来自动运行自定义脚本，让自动化应用更加简单、便捷。
限于篇幅，本回答就介绍这么多，SeaTable 表格功能丰富，使用灵活，我们可以配合使用，快速打造出自己的应用。
推荐阅读
SeaTable：Python + SeaTable | 计算两个日期间的工作日天数
42 赞同 ・ 11 评论
文章
SeaTable：Python + SeaTable | 从启信宝网站获取公司融资等信息至 SeaTable 表格
41 赞同 ・ 11 评论
文章
SeaTable：Python + SeaTable | 用 Python 从维基百科抓取冬奥会城市信息并制作地图
673 赞同 ・ 23 评论
文章
SeaTable：同步服务器日志到 SeaTable，让日志更好的可视化和协同处理
166 赞同 ・ 18 评论
文章
SeaTable：教程 | 无需编程或数据库，用 SeaTable 零代码制作数据查询应用
134 赞同 ・ 26 评论
文章
SeaTable：SeaTable 工作流案例 | 零代码搭建费用报销、客户服务、内容运营等流程
343 赞同 ・ 22 评论
文章","先来看看，大佬都用Python干啥。
还有人用 Python 来买房。
程序员的选房神技，GitHub上的房源爬虫
210 赞同 ・ 5 评论
文章
实验楼上面好多 Python 项目，真的是可以做很多事情，下面一起来看看！
训练营项目
1. Python 数据分析入门与进阶（数据分析方向）
通过 Python 数据分析和算法，实现【苹果公司股票分析、实验楼课程数据统计、用户情绪分析、潜在客户分析】等项目：
Python 数据分析入门与进阶
?
www.shiyanlou.com/courses/764
2. Flask + VueJS 全栈 Web 开发实战（Web开发方向）
使用 Python 的 Flask 框架和 VueJS，通过两个实战项目留言板项目和论坛应用的练习，掌握 Flask + VueJS 进行 Web 开发的能力。
3. Python 实现搜索引擎（爬虫+Web框架）
利用 Python 异步特性实现
异步爬虫
系统，一步一步地将构建索引、索引压缩、排名算法等环节编码实现，最后利用异步 web 框架 sanic 构建后端实现一个完整的
垂直搜索引擎
站点。
4. 基于 Python 实现微信公众号管理 Redis 服务器（公众号后台管理）
实现一个 Redis 服务器监控工具，第一部分实现了 Redis 服务器管理和监控信息获取的 API ；第二部分创建一个用户系统接入微信公众号平台。借助这个项目我们可以进一步学习 Web 开发中的一些知识。
5. Python 使用机器学习玩转 Flappy Bird 游戏（机器学习）
6. 
Python 新手入门课
7. 
Python 异步网络编程实战
8. 
基于 Ansible + Celery 的运维开发平台
9. 
采用微服务架构基于 Flask 实现电商网站“淘贝网”
10. 
基于 Django + React 实现电商平台
11. 
基于 Django 实现问答社区
12. 
使用 Python 实现一个轻量型数据库
13. 
Python 实现类似 Redis 的 NoSQL 数据库
14. 
基于 Django 实现 Upwork 众包网站
15. 
基于 React + Flask 打造私人专属网盘
16. 
异步 Web 框架 Sanic 设计与实现
17. 
Python 异步网络编程实战
练手小项目：
Python 实现密码强度检测器
Python 3 实现图片转彩色字符
基于 TCP 的 Python 聊天程序
Python实现简易局域网视频聊天工具
Python 实现简单画板
Python 应用马尔可夫链算法实现随机文本生成
使用 Python3 编写系列实用脚本
使用 Python3 生成分形图片
Flask 实现简单聊天室
Python3 实现可控制肉鸡的反向Shell
Python 实现 FTP 弱口令扫描器
Python3 实现命令行动态进度条
基于 Flask 与 MySQL 实现番剧推荐系统
Python3 & OpenCV 视频转字符动画
基于PyQt5 实现地图中定位相片拍摄位置
Python3基于Scapy实现DDos
Python3 实现火车票查询工具
基于 Python 的简易 Shell 实现
使用 Github Pages 和 Hexo 搭建独立博客
Python 实现简单滤镜
川普撞脸希拉里(基于 OpenCV 的面部特征交换)
Python3 智能裁切图片
Python3 图片隐写术
Python从零实现图像形态学处理
Python 实现将 Excel 数据绘制成精美图像
Python3 实现图片拼接与混合
Python 实现 Redis 异步客户端
仿 StackOverflow 开发在线问答系统
基于Pygame开发贪吃蛇和俄罗斯方块
Python 实现简单计算器
Python 实现推箱子游戏
Python 实现康威生命游戏
Python 解决哲学家就餐问题
使用 Python 定制词云
人机对战初体验：Python 实现四子棋游戏
Python 实现英文新闻摘要自动提取
Python实现Huffman编码解压缩文件
Python3 实现 Markdown 解析器
Python3实现简单的FTP认证服务器
使用 Python 解数学方程
数独游戏的 Python 实现与破解","可以拿来了解女朋友情绪变化，顺道自动回复。
还能一键扣图，让开淘宝店的设计师下岗，在一旁痛哭流涕……
提示：关注微信公众号 【七月在线实验室】，让自己变得更强！在公众号内发“ZH”。即可获得BAT面试题100道和课程代金坏染美好礼哦！
一
虽然程序员不会有女朋友，但是这个也可以用在同性朋友身上哦。
再也不用担心工作忙，没法经常和她/他/它聊天了。
可以实时知道女友的情感情绪指数，再也不用担心女友莫名其妙生气了。
还能顺道教女朋友学英语（女朋友一定很惊喜）
为了方便快速开发，我们使用python中的wxpy模块完成微信的基本操作。
首先，我们设置一个config.ini配置文件，并从这个配置文件开始读取信息。这些参数一看就懂，所以无需多言。
# 读取配置文件
cf = configparser.ConfigParser()
cf.read(""./config.ini"",encoding='UTF-8')

# 设置女友的微信名称，记住，不是微信ID也不是微信备注
# 你女友的微信名称，记住，不是微信ID也不是微信备注
my_lady_wechat_name = cf.get(""configuration"", ""my_lady_wechat_name"")

# 设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间
say_good_morning = cf.get(""configuration"", ""say_good_morning"")
say_good_lunch = cf.get(""configuration"", ""say_good_lunch"")
say_good_dinner = cf.get(""configuration"", ""say_good_dinner"")
say_good_dream = cf.get(""configuration"", ""say_good_dream"")

# 设置女友生日信息
# 几月，注意补全数字，为两位数，比如6月必须写成06
birthday_month = cf.get(""configuration"", ""birthday_month"")
# 几号，注意补全数字，为两位数，比如6号必须写成08
birthday_day = cf.get(""configuration"", ""birthday_day"")

# 读取早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间的随机提示语
# 一般这里的代码不要改动，需要增加提示语可以自己打开对应的文件修改
#早上起床问候语列表，数据来源于新浪微博
str_list_good_morning = ''
with open(""./remind_sentence/sentence_good_morning.txt"", ""r"",encoding='UTF-8') as f:
    str_list_good_morning = f.readlines()
print(str_list_good_morning)

#中午吃饭问候语列表，数据来源于新浪微博
str_list_good_lunch = ''
with open(""./remind_sentence/sentence_good_lunch.txt"", ""r"",encoding='UTF-8') as f:
    str_list_good_lunch = f.readlines()
print(str_list_good_lunch)

#晚上吃饭问候语列表，数据来源于新浪微博
str_list_good_dinner = ''
with open(""./remind_sentence/sentence_good_dinner.txt"", ""r"",encoding='UTF-8') as f:
    str_list_good_dinner = f.readlines()
print(str_list_good_dinner)

#晚上睡觉问候语列表，数据来源于新浪微博
str_list_good_dream = ''
with open(""./remind_sentence/sentence_good_dream.txt"", ""r"",encoding='UTF-8') as f:
    str_list_good_dream = f.readlines()
print(str_list_good_dream)

# 设置晚上睡觉问候语是否在原来的基础上再加上每日学英语精句
# False表示否 True表示是
if((cf.get(""configuration"", ""flag_learn_english"")) == '1'):
    flag_learn_english = True
else:
    flag_learn_english = False
print(flag_learn_english)
# 设置所有问候语结束是否加上表情符号
# False表示否 True表示是
str_emoj = ""(?￣??￣??)??°----(?′ `?)----(?ˉ?ε ˉ??)----(??? ? ???)----( ?? .? ?? )----(?? ??)----(●′ω`●)----(●?????●)----?_?----_(:qf∠)----(′；ω；`)----( `)3')----Σ((( つ??ω??)つ----t(*′`*)s----( ′′??′?` )----(′∩｀。)----( ?? ?)----(??_?)----( ?? _ ?? )----c(*??????F *)----( ? 3?)----(; ′_f`)----(*ˉ辍)----(?'?`?)??----(?????)----(? .?.? ?)----(′???`)----(。?ˇェˇ??)----(???)----(｀???′+)----( _ )----( ?????)----ㄟ(??? )ㄏ----(●'?'●)??----(??ˇ?ˇ?）----( ?   ? )----( ′? ??`)----(?n?)----(????)----?(???? )----(???????)""
str_list_emoj = str_emoj.split('----')
if ((cf.get(""configuration"", ""flag_wx_emoj"")) == '1'):
    flag_wx_emoj = True
else:
    flag_wx_emoj = False
print(str_list_emoj)

# 设置节日祝福语
# 情人节祝福语
str_Valentine = cf.get(""configuration"", ""str_Valentine"")
print(str_Valentine)

# 三八妇女节祝福语
str_Women = cf.get(""configuration"", ""str_Women"")
print(str_Women)

# 平安夜祝福语
str_Christmas_Eve = cf.get(""configuration"", ""str_Christmas_Eve"")
print(str_Christmas_Eve)
# 圣诞节祝福语
str_Christmas = cf.get(""configuration"", ""str_Christmas"")
print(str_Christmas)

# 她生日的时候的祝福语
str_birthday = cf.get(""configuration"", ""str_birthday"")
print(str_birthday)
设置完相关参数以后，我们再来学习一下，如何每天教女友学英语：
# 获取每日励志精句
def get_message():
    r = requests.get(""http://open.iciba.com/dsapi/"")
    note = r.json()['note']
    content = r.json()['content']
    return note,content
如果你愿意，可以在上面对时间的判断中，加入一些其他你想要的，这样你女友就更开心啦！后期如果有时间，我将会加上以上节日问候功能。
接着，开启微信机器人，为了程序的健壮性，自动判断一下操作系统，根据不同操作系统执行不同指令：
# 启动
微信机器人
，自动根据操作系统执行不同的指令
# windows系统或macOS Sierra系统使用bot = Bot()
# linux系统或macOS Terminal系统使用bot = Bot(console_qr=2)
if('Windows' in platform.system()):
    # Windows
    bot = Bot()
elif('Darwin' in platform.system()):
    # MacOSX
    bot = Bot()
elif('Linux' in platform.system()):
    # Linux
    bot = Bot(console_qr=2,cache_path=True)
else:
    # 自行确定
    print(""无法识别你的操作系统类型，请自己设置"")
只有每天的问候和节日问候是仅仅不够的，我们必须时刻知道她的情绪指数，这里可以使用snowNlp或者jieba来做分析，但是为了能够在打包成exe可执行文件时使得程序尽可能小，我们采取直接调用接口的方式来做。代码如下：
# 接收女友消息监听器
# 女友微信名
my_girl_friend = bot.friends().search(my_lady_wechat_name)[0]
# chats=my_girl_friend 表示接收消息的对象，也就是女友
# except_self=False 表示同时也接收自己发的消息，不需要接收自己消息的可以去掉
@bot.register(chats=my_girl_friend, except_self=False)
def print_others(msg):
    # 输出聊天内容
    print(msg.text)

    # 做极其简单的情感分析
    # 结果仅供参考，请勿完全相信
    postData = {'data':msg.text}
    response = post('https://bosonnlp.com/analysis/sentiment?analysisType=',data=postData)
    data = response.text

    # 情感评分指数(越接近1表示心情越好，越接近0表示心情越差)
    now_mod_rank = (data.split(',')[0]).replace('[[','')
    print(""来自女友的消息:%s\n当前情感得分:%s\n越接近1表示心情越好，越接近0表示心情越差，情感结果仅供参考，请勿完全相信！\n\n"" % (msg.text, now_mod_rank))

    # 发送信息到文件传输助手
    mood_message = u""来自女友的消息:"" + msg.text + ""\n当前情感得分:"" + now_mod_rank + ""\n越接近1表示心情越好，越接近0表示心情越差，情感结果仅供参考，请勿完全相信！\n\n""
    bot.file_helper.send(mood_message)
教完女友学英语后，开始把我们的关心语发给她。这里涉及到wxpy模块的相关操作，很简单，看我的例子就会了：
# 发送消息给她
def send_message(your_message):
    try:
        # 对方的微信名称
        my_friend = bot.friends().search(my_lady_wechat_name)[0]

        # 发送消息给对方
        my_friend.send(your_message)
    except:

        # 出问题时，发送信息到文件传输助手
        bot.file_helper.send(u""守护女友出问题了，赶紧去看看咋回事~"")
最后，就是如何每天定时发关心语给女友的问题了。
首先来个while循环，365天无限关心
# 来个死循环，24小时关心她
    while(True):

        # 提示
        print(""守护中，时间:%s""% time.ctime())

        # 每天定时问候，早上起床，中午吃饭，晚上吃饭，晚上睡觉
        # 获取时间，只获取时和分，对应的位置为倒数第13位到倒数第8位
        now_time = time.ctime()[-13:-8]
        if (now_time == say_good_morning):
            # 随机取一句问候语
            message = choice(str_list_good_morning)

            # 是否加上随机表情
            if(flag_wx_emoj):
                message = message + choice(str_list_emoj)

            send_message(message)
            print(""提醒女友早上起床:%s"" % time.ctime())

        …………这下面还有很多代码，我就不列出来了…………
   # 延时60秒
   time.sleep(60)
最后，输入以下代码开始守护女友模式吧~
# 开始守护女友
    t = Thread(target=start_care, name='start_care')
    t.start()
使用教程
pip
安装下列包：
[x] pip install wxpy
[x] pip install requests
设置以下内容：
[configuration]

# 设置女友的微信名称，记住，不是微信ID也不是微信备注
my_lady_wechat_name = 小强子

# 设置女友生日信息
# 若某一项月份或者日期不想设置，请输入99，不能留空
# 几月，注意补全数字，为两位数，比如6月必须写成06
birthday_month = 03
# 几号，注意补全数字，为两位数，比如6号必须写成08
birthday_day = 18

# 设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间
# 若某一项时间不想设置，请输入99:00，不能留空
say_good_morning = 03:09
say_good_lunch = 03:10
say_good_dinner = 03:11
say_good_dream = 03:12

# 设置晚上睡觉问候语是否在原来的基础上再加上每日学英语精句
# 1表示是，0表示否
flag_learn_english = 1

# 设置所有问候语结束是否加上表情符号
# 1表示是，0表示否
flag_wx_emoj = 1

# 设置节日祝福语
# 情人节祝福语
str_Valentine = 亲爱的，情人节快乐！我想和你一起分享生命中的每一天，直到永远。

# 三八妇女节祝福语
str_Women = 嘿，女神节到了，祝我的女神开心快乐！你每天都是那么好看^_^

# 平安夜祝福语
str_Christmas_Eve = 宝贝，平安夜快乐，你吃苹果了吗？n(*RQ*)n

# 圣诞节祝福语
str_Christmas = 小仙女，圣诞节快乐哦！（づ￣3￣）づq?～

# 她生日的时候的祝福语
str_birthday = 亲爱的，生日快乐，我已经给你准备好了礼物哦，明天你就能看到啦！(*@ο@*) 哇～
演示图片
原作者：云外孤岛 
http://www.
cnblogs.com/cloudbird/p
/10534658.html
至于没有女朋友的……
要不考虑一下它
二
本段转载自：高级农民工（ID：Mocun6）
这张逼死淘宝专业抠图店家的照片，用3行Python代码，花5秒就能超高精度抠图。
该图片有可能会引起不适
继续查看
这里的 API 接口来源于 Remove.bg 网站，一个邮箱账号可以申请一个免费接口，可处理 50 张照片，如果想处理更多或者生成高清照片，需要买套餐，算下来价格大概是 
1 元一张
。
上淘宝搜索「
证件照换底色
」的店铺，发现多数店铺收费是 
5 元
，觉得利用好价格差空间，应该有商机。
接着比较感兴趣淘宝店家是怎么抠图的，抠图的质量如何，于是选择了排名前两位的店家来做测试，跟掌柜开始了一段「
套路
」聊天。
先找了第一家店主，店主上来就说先发照片，抠图满意再付款，于是就发了文章开头那张比较难抠的一张，想看看他们水平怎么样：
没想到店主这一抠就是二十分钟。。。
满心期待地打开图片一看，头发丝抠的不好，照片色彩也变了：
跟第二家店掌柜聊了后，也是花了 16 分钟弄好，比第一家稍好一点：
把三幅图一对比，从头发丝抠的效果和照片的色彩还原度就可以看出还是 AI 效果最好，而且只需要 5 秒钟。
于是，大致可以总结
这款 AI 工具从效果和效率上基本碾压手动 PS 的淘宝店家。
心疼掌柜，花了 20 分钟还没有拿下我这一单……
这么难抠的图 AI 工具效果都好，那简单的证件照应该更没问题，基本确定有商机。
接下来用 Python 把上面的代码进行完善打包成 exe 文件执行。
轻松实现这样的功能：
只需要简单敲几下键盘，就可以随意批量更换照片的背景色
（常见的白、蓝、红三种颜色），
然后秒换背景出图
。
效果如下：
具体实现很简单，第一步输入 API，第二步输入图片所在文件夹，接着程序就会先抠图，生成带透明背景的 PNG 格式图形。  
接下来第三步利用 PIL 库来设置图片的背景颜色，键入一个字母就可以秒生成对应的背景色证件照。
b：blue 蓝色
r：red 红色
w：white 白色
这样就做成了一个简单的证件照更换工具，拿去开个淘宝店和抠图的设计师抢饭吃没有压力……
估计打死店主也都想不到让自己下岗的是几行代码……效率还是自己的N倍……
此工具可关注公众号“七月在线实验室”后，发“证件照”获取。
转载自公众号“
七月在线实验室
”
↓
↓↓
公号后台回复“666”。即可免费获得 七月在线【面试求职 第四期】课程+最新升级版《
名企AI面试100题
》电子书。
《名企AI?试100题》涵盖
计算机语?基础、算法和?数据、机器学习、深度学习、应??向 (CV NLP 推荐 ?融风控)等五?章节
，每?段代码、每?道题?的解析都经过了反复审查或review。
部分内容展示
（点击图片可查看大图）","Python 能写好玩的东西简直不要太多！赶紧都来看看都能怎么玩！！
内容不老少，好玩的事很多，记得先点赞收藏，再看不迷路呀~
分分钟画出个
系统架构图
我们在做技术方案的时候，系统架构图是必不可少的。
轻松用 Python 快速绘制出一份精美且清晰的架构图，省去拖拽调整连线的步骤，让你分分钟上手。
无聊的时候，做个聊天机器人陪玩
用 Python 做个陪着自己玩的聊天机器人，多有意思啊，想和它聊啥就聊啥，也不会烦。
爱动弹了，就再升升级，搞个群聊、私聊的~
假装自己经常写字
用 Python 模拟手写体汉字，基于 Python 的 PIL 就可开发实现。
# coding: utf-8
from PIL import Image, ImageFont

from handright import Template, handwrite

text = """"""
道可道也非恒道也
名可名也非恒名也
无名天地之始有名
万物之母故常无欲
""""""

template = Template(
    background=Image.new(mode=""1"", size=(900, 1000), color=1),
    font=ImageFont.truetype(""path/to/my/font.ttf"", size=100),
    line_spacing=150,
    fill=0,  # 字体“颜色”
    left_margin=100,
    top_margin=100,
    right_margin=100,
    bottom_margin=100,
    word_spacing=15,
    line_spacing_sigma=6,  # 行间距随机扰动
    font_size_sigma=20,  # 字体大小随机扰动
    word_spacing_sigma=3,  # 字间距随机扰动
    end_chars=""，。"",  # 防止特定字符因排版算法的自动换行而出现在行首
    perturb_x_sigma=4,  # 笔画横向偏移随机扰动
    perturb_y_sigma=4,  # 笔画纵向偏移随机扰动
    perturb_theta_sigma=0.05,  # 笔画旋转偏移随机扰动
)
images = handwrite(text, template)
for i, im in enumerate(images):
    assert isinstance(im, Image.Image)
    im.show()
    im.save(""path/to/my/output/{}.webp"".format(i))
马赛克风格图片转化，真有意思
将图片转化成各种较小图块拼接成的图像工具。
马赛克风格的图片转化工具，支持自定义拼接图案和符号。
工具实用方便、代码简单易懂，适合对图像感兴趣的小伙伴学习和上手。
自动化办公，这个不能少
Python 强大的模块系统，可以高效的完成办公自动化的操作，轻而易举实现 Excel 自动化、Word 自动化、PPT 自动化。
比如
文件自动分类
：
比如
一键删除重复文件
：
比如
批量格式转换：
比如
轻松进行图表操作
：
微博爬虫，谁也能爬
Python 写的微博爬虫，命令行直接启动。
可以连续爬取
一个
或
多个
新浪微博用户的数据，并将结果信息写入
文件
或
数据库
。写入信息几乎包括用户微博的所有数据，包括
用户信息
和
微博信息
两大类。
支持获取微博用户、内容字段丰富。
# 安装
$ git clone https://github.com/dataabc/weiboSpider.git
$ cd weiboSpider
$ pip install -r requirements.txt
# 启动
$ python3 -m weibo_spider
抠图这种事，以后就靠自己
以后去掉背景图，把自己从图片里抠出来，咱谁也不求，Python 就能办！
https://github.com/danielgatis/rembg
?
github.com/danielgatis/rembg
剪视频这种，也要靠自己
不光抠图，剪视频咱 Python 也行，不只是单个剪，批量处理也么的问题！
https://github.com/Zulko/moviepy
?
github.com/Zulko/moviepy
制作自己的专属二维码
只需两步，就能用 Python 做自己的专属二维码！
Rocky0429：只需一行代码，小白也能制作自己的专属二维码！
6 赞同 ・ 1 评论
文章
就先写这些内容吧，如果觉得好玩儿，记得动动小手帮我 
@Rocky0429
 点个赞呀，感谢支持~","哈哈哈哈哈，我来说我来说！！！（收藏的时候记得点个赞呀~）
python可以写很多好玩的东西呀，本回答包括：
写写小游戏，并且用一些算法来自动玩这些小游戏；
写写爬虫，例如下载音乐，表情包啥的~；
写一些有趣的小工具；
复现一些有趣的图像算法。
1. 写写小游戏
所有源代码都可以在这找到，里面现在有20多个小游戏：：
https://
github.com/CharlesPikac
hu/Games
随便举几个例子吧。
1.1 坦克大战
效果：
04:11
介绍：
震惊，博主终于更新了坦克大战小游戏！！！
?
mp.weixin.qq.com/s/1xXULpT36P7LTO5HDbjptg
1.2 支持联网对战的五子棋
效果：
03:55
介绍：
1.3 
推箱子
1.4 2048小游戏
1.5 炸弹人
等等。
这里还有个姊妹项目：
https://
github.com/CharlesPikac
hu/AIGames
主要是设计一些AI算法来自动玩小游戏的：
例如：
等等
2. 写写有趣的爬虫
2.1 模拟登录
因为爬很多网站都需要先对网站进行模拟登录，然后才能获取到数据，所以自己写了个简单的模拟登录库，名字叫DecryptLogin。
项目地址：
https://
github.com/CharlesPikac
hu/DecryptLogin
 （欢迎给个stars呀~）
项目开源文档：
DecryptLogin中文文档 - DecryptLogin 0.1.0 文档
你只需要pip安装这个库：
pip install DecryptLogin
然后就可以简单地实现很多网站的模拟登录操作啦，例如模拟登录知乎(需要手动输入验证码)：
from DecryptLogin import login
lg = login.Login()
infos_return, session = lg.zhihu(用户名, 密码, 'pc')
如果你不想手动输入验证码，可以自己写个验证码接口函数：
def crackvcFunc(imagepath):
    验证码识别
    return 识别结果
infos_return, session = lg.zhihu(用户名, 密码, 'pc', crackvcFunc)
(PS：楼主也正在筹备为这个库搞个hackcaptcha库，专门解决登录过程中的验证码问题，项目地址：
https://
github.com/CharlesPikac
hu/hackcaptcha
项目还在开发中，弄好了再详细介绍吧...)
言归正传，DecryptLogin库的项目地址里还有很多和模拟登录相关的有趣的爬虫小案例：
可以供新手学习爬虫使用，例如：
2.2 写个音乐下载器
项目地址：
https://
github.com/CharlesPikac
hu/musicdl
项目文档：
https://
musicdl.readthedocs.io/
zh/latest/
写这个包的主要动机是我想用
树莓派
做个声控音乐播放器。你只需要pip安装该库：
pip install musicdl
然后写几行代码就可以快速实现一个音乐下载器啦：
from musicdl import musicdl

config = {'logfilepath': 'musicdl.log', 'savedir': 'downloaded', 'search_size_per_source': 5, 'proxies': {}}
target_srcs = ['baiduFlac', 'kugou', 'kuwo', 'qq', 'qianqian', 'netease', 'migu', 'xiami', 'joox']
client = musicdl.musicdl(config=config)
client.run(target_srcs)
运行效果如下：
更详细的介绍你可以自己查看项目文档，各种接口调用起来还是很方便的。毕竟我自己也要拿来玩耍。(
禁止商用哦~用的公开的API，只能下载各个平台的免费音乐，侵歉删~
)
2.3 爬爬表情包
知乎上的表情包其实挺多的：
抓到的表情包还可以用来拼图玩T_T：
2.4 其他
等等。
3. 写一些简单实用的小工具
所有
源代码
都可以在这找到：
https://
github.com/CharlesPikac
hu/Tools
里面的内容包括：
举几个例子吧。
3.1 艺术签名生成器
效果截图：
介绍：
3.2 简单的翻译软件
效果截图：
介绍：
3.3 多肉数据查询系统
效果截图：
介绍：
等等。
4. 复现一些有趣的算法
4.1 DeepDream
效果：
介绍：
代码：
https://
github.com/CharlesPikac
hu/DeepDream
4.2 CNN模拟生命游戏
效果：
介绍：
代码：
https://
github.com/CharlesPikac
hu/CNNLifeGame
4.3 生成会跳舞的小姐姐
效果：
介绍：
代码：
https://
github.com/CharlesPikac
hu/DanceNet
4.4 颜值预测
效果：
介绍：
代码：
https://
github.com/CharlesPikac
hu/isBeauty
4.5 铅笔素描画自动生成
4.6 快速风格迁移
等等。
更多有趣好玩的python应用，欢迎关注我的微信公众号：
Charles的
皮卡丘
很多小伙伴反应Github里python发送邮件来控制电脑的案例使用起来不太方便，时间太久了，我也忘了当时怎么构思的，不过授人以鱼不如授人以渔，最近我看到一个不错的批量发送邮件的课程，十分不错：
是夜曲编程出品的“python入门课程”中的一个小案例，里面还有很多其他有趣的python实战小例子，可供新手学习完之后巩固自己的知识。
学习完之后你就可以根据自己的需求自己设计一个用邮件远程控制自己电脑的代码啦～
另外，为了帮助不自觉的小伙伴更加主动地学习相关的课程，夜曲编程还独家推出了课程奖励机制，完成学习挑战的小伙伴即可获得夜曲编程提供的一些奖品，例如蓝牙键盘和夜曲独家知识卡片等等。
感兴趣的小伙伴可以关注一下他家的公粽号“
夜曲编程
”，
后台咨询具体的课程细节。注意，他家的课程都是可以开课三天内无条件退的哦，担心课程设置不适合自己的小伙伴完全可以先入手尝试几天，看看课程是否真的适合自己。还有扎实的免费课可以拿，去咨询一回复下「免费课程」就行，虽然是免费的，但是也很扎实。","不知道别人，我最开始学Python纯粹是出于兴趣。
只有兴趣使然的Pythoner，才能真正付出足够的时间和精力，每天100行代码、100分钟视频、100页书，坚持锻炼自己的技能，最后成长。
动手实操 | 如何用 Python 实现人脸识别，证明这个杨幂是那个杨幂？
网红和明星越来越像，
脸盲症
发作了？
别怕，写个程序帮你认人就行了
充气玩玩什么感觉？Python告诉你
用Python来玩一把充气娃娃“云测评”。。。
提高驾驶技术：用GAN去除(爱情)动作片中的马赛克和衣服
没时间解释了，快上车！
Python Crawler - 网信贷黑名单数据爬取
借钱出去的时候，要不要先看一下借款人的信用？
去看一下信用黑名单吧，要是借款人名字高挂，这钱还是不借了吧
案例里是将结果输出到txt的，大家也可以尝试讲这些转成pdf或者输出到其他更方便查询的地方~
Python小工具: 发个周报邮件给老板
每周都要发周报，烦死了。
照着这个教程做一篇，以后统统全自动发送，爽不爽？
上面这些小项目能不能激发起你的兴趣？
如果你有了兴趣，那我们就要谈更深入的问题：
如果以Python为职业，会有哪些可能？
当以职业为目标的时候，所需要的技能深度比单纯的兴趣所致要高得多。
Python的方向太多，所需要的能力也太多，所以接下来我就简单给大家做一个罗列：
1.Web方向（后端及
全栈
）
Web一直是Python爱好者就业的一个大方向，学习资料也比较全，岗位数量相对来说比较多。Python的优势在于编程效率，这一点上强无敌。但是受限于
动态语言
特性和使用者的水平，面对一些比较大的工程可能就没有那么得心应手。
想要从事Web方向所需要的能力：
HTTP协议、HTML5&CSS、Web前端基础、jQueryWeb前端、 ES6Web前端高级、React-web框架、后台数据库开发、Python框架 Django、Python框架-Flask
2.爬虫&数据采集
这一方向目前来说是入行最快的方向，除了爬虫岗位多用的Requests、Scrapy还是比较简单的，也会涉及到分布式和数据库的一些基础知识。
想要从事爬虫方向所需要的能力：
浏览器调试、数据分析与性能调优、
消息中间件
、数据存储与redis数据库编程、
反爬技术
、Selenium与 PhantomJS开发、常用爬虫框架Scrapy与平台
3.数据分析&
数据挖掘
数据分析是一直是Python的强项，数据分析三大库放眼整个数据科学领域也是最优秀的存在。数据分析岗位目前是也比较火热，现在开始学习算是不错的时机。
从事数据方向需要从事的能力：
数值计算Numpy、数据可视化Matplotlib、数据分析Pandas、数据规整、数据清洗、数据合并、
文本分析
、数据挖掘、推荐系统
4.自动化、
DevOps
Python的自动化方向岗位也是比较多，但是这一领域的出彩更多是源于Python本身的学习难度低成本低。现在运维领域比较热的概念DevOps更多也要依托于Python。一般来说，DevOps一般会要求具备相应的运维基础能力，收入也会更高，所以如果有运维行业的同学可以考虑这个方向。
从事自动化需要具备的能力：
Python自动化、任务调度系统、任务流程系统、CMDB资产管理、web 可视化、JumpServer、k8s容器化、Go语言编程
5.
机器学习
、
人工智能
我个人非常不建议大家从事这个方向。AI岗位工资高的超出想象，但是从业门槛也超出想象，确实能年薪五十万，但要求是985甚至清北学历，有些甚至要博士学位。
[1]
希望大家不要被无良培训机构忽悠，花个几万块钱是小事，浪费掉的时间比那些钱更宝贵。
从事
AI方向
所需要的能力：
机器学习库scikit-learn,
特征工程
、常见机器学习算法kNN、SVM、决策树、随枳森林，
量化交易
、深度学习Tensorflow,
线性回归
，神经网络。
总结
我制作了一个表格，将以上提到的五种方向，从学习难度、入门门槛、回报系数三个方面来评分，当然其中有我的个人倾向，各位可以做个参考：
最后，如果你看完这篇文章也想成为一名Python使用者，不妨看一下我花一个月时间整理的Python入门教程：
参考
^
尽管可能有些企业对学历没那么严格，但对能力的要求一定不会低很多。","很多人跟你一样，只管闷头学，却不知道为什么去学，往往的理由是：“简单啊”、“收入高啊”、“人生苦短，我用Python”，好吧，那我这里简述下学了Python可以干嘛。当然是为了赚钱啊，哈哈！
Web应用开发
服务器端编程，具有丰富的Web开发框架，如Django和TurboGears，快速完成一个网站的开发和Web服务。典型如国内的豆瓣、
果壳网
等，国外的Google、Dropbox等。
系统
网络运维
在运维的工作中，有大量重复性工作的地方，并需要做管理系统、监控系统、发布系统等，将工作自动化起来，提高工作效率，这样的场景Python是一门非常合适的语言。
科学与数字计算
Python被广泛的运用于科学和数字计算中，例如生物信息学、物理、建筑、地理信息系统、图像可视化分析、生命科学等，常用numpy、SciPy、Biopython、SunPy等。
3D游戏开发
Python有很好的3D渲染库和游戏开发框架，有很多使用Python开发的游戏，如迪斯尼
卡通城
、黑暗之刃。
图形界面开发
Python可编写桌面
图形用户界面
，还可以扩展微软的Windows，常用Tk、GTK+、PyQt、win32等。
网络编程
除了网络和互联网的支持，Python还提供了对底层网络的支持，有易于使用的Socket接口和一个异步的网络编程框架Twisted Python。","用python爬取了“学python都用来干嘛”下的部分有趣回答来回答这个问题。（如有侵权，请告知我删掉= =）（为了爬虫而强行爬虫，其实根本就不用爬虫的= =）
小白一枚，我是真的菜。我抄别人代码用python做过的事情：1、抢课脚本（我尝试了非常久，卡在验证码登录长达几个月，最后成功了不过还是很简陋）2、做简易网站。3、爬图片。4、爬
百度文库
。5、批量修改后缀名。6、做小游戏，像飞机大战，坦克大战，塔防小游戏，主要用pygame模块。7、爬有道翻译。8、爬知乎
以下是爬取内容（手动狗头）：
1、 用 Python 实现人脸识别
2、去除爱情动作片中的
马赛克
和衣服
3、 网信贷黑名单数据爬取
4、自动发送周报邮件给老板
5、快速完成一个网站的开发和Web服务
6、3D游戏开发
7、预测交通事故
8、不要沉谜于写所谓的“爬虫“，还有法律风险，慎重！
9、哄哄女朋友，导出微信聊天记录并生成词云向手机发送通知
10、做（沙雕）聊天机器人
11、自动抓取所有好友的头像，最后拼成了一张大图
12、一键扣图
13、自动爬取海贼王漫画
14、京东/淘宝价格监控，每次关注的商品降到目标价以下就发个短信提醒
15、监控一个加油站的油价
16、用
树莓派
做了个小车，用python实现了基本的控制功能
17、实现二维码生成和识别
18、做了一个专门看电视的个人网站，不用担心什么VIP/平台/广告/找片/下载，跳过片头片尾
19、破解观看只面向校内IP开放的视频
20、获取研究生系统全部学生姓名、学号、选课信息
21、扫描研究生系统上的弱密码用户基于上面获得的选课学生学号，获得身份证号码等重要信息
22、模拟登录图书馆并自动续借
23、网易云音乐批量下载
24、批量下载读者杂志某一期的全部文章
25、爬取了当前比较火的游戏壁纸
26、爬取
美团网
餐饮商家的信息
27、爬当当网各分类所有五星图书
28、网页开发
29、实现了主播开播的全员提醒，以及直播画面截图并发进群里
30、批量解决数学作业
31、ROS系统
32、扒同行的文章来伪原创","分享一个很优秀且简短的自动化拼写检查器，用Python来完成的，个人觉得挺好玩的，也很有趣。
当然，不是由我来搞定的，是来自谷歌Norvig大神的杰作
当我们使用谷歌搜索内容的时候，如果你拼错一个单词，网页会提醒你可能的正确拼法，这就是所谓的""拼写检查""（spelling corrector）。谷歌使用的是基于
的统计学方法。这种方法的特点就是快，很短的时间内处理大量文本，并且有很高的精确度（90%以上）。
效果大概是下面这个样子：
当用户输入一个单词的时候，分为了两种情况：
拼写正确，记为 
c
c
 （correct）
拼写错误，记为 
w
w
 （wrong）
所谓的""拼写检查""，从概率论的角度看，就是已知 
w
w
 ，然后在若干个备选方案中，找出可能性最大的那个 
c
c
 ，也就是求式（1）的最大值。
P(c|w)   \quad(1)
P(c|w)   \quad(1)
 
根据
可得：
P(c|w) = P(w|c) * P(c) / P(w) \quad (2)
P(c|w) = P(w|c) * P(c) / P(w) \quad (2)
 
对于所有的备选项C来说，W都是相同的，因此可以将上式简化为：
　P(w|c) * P(c) \quad (3)
　P(w|c) * P(c) \quad (3)
 
所以，实际上可以看成是求式（3）的最大值
P(c) 
P(c) 
 的含义是，某个正确的词的出现""概率""，它可以用""频率""代替。如果我们有一个足够大的文本库，那么这个文本库中每个单词的出现频率，就相当于它的发生概率。某个词的出现频率越高， 
P(c) 
P(c) 
 就越大。
P(w|c) 
P(w|c) 
 的含义是，在试图拼写 
c
c
 的情况下，出现拼写错误 
w
w
 的概率。这需要统计数据的支持，但是为了简化问题，我们假设两个单词在字形上越接近，就有越可能拼错， 
P(w|C) 
P(w|C) 
 就越大。
举例来说，相差一个字母的拼法，就比相差两个字母的拼法，发生概率更高。
例如，如果你想拼写单词 Serendipity，那么错误拼成 Serendipitu（相差一个字母）的可能性，就比拼成 Serendipituu 要高（相差两个字母）。
所以，我们只要找到与输入单词在字形上最相近的那些词，再在其中挑出出现频率最高的一个，就能实现 
 P(w|c) * P(c) 
 P(w|c) * P(c) 
 的最大值。
实现代码如下：
import
 
re


from
 
collections
 
import
 
Counter


def
 
words
(
text
):
 
return
 
re
.
findall
(
r
'\w+'
,
 
text
.
lower
())



WORDS
 
=
 
Counter
(
words
(
open
(
'big.txt'
)
.
read
()))



def
 
P
(
word
,
 
N
=
sum
(
WORDS
.
values
())):
 
    
""Probability of `word`.""

    
return
 
WORDS
[
word
]
 
/
 
N



def
 
correction
(
word
):
 
    
""Most probable spelling correction for word.""

    
return
 
max
(
candidates
(
word
),
 
key
=
P
)



def
 
candidates
(
word
):
 
    
""Generate possible spelling corrections for word.""

    
return
 
(
known
([
word
])
 
or
 
known
(
edits1
(
word
))
 
or
 
known
(
edits2
(
word
))
 
or
 
[
word
])



def
 
known
(
words
):
 
    
""The subset of `words` that appear in the dictionary of WORDS.""

    
return
 
set
(
w
 
for
 
w
 
in
 
words
 
if
 
w
 
in
 
WORDS
)



def
 
edits1
(
word
):

    
""All edits that are one edit away from `word`.""

    
letters
    
=
 
'abcdefghijklmnopqrstuvwxyz'

    
splits
     
=
 
[(
word
[:
i
],
 
word
[
i
:])
    
for
 
i
 
in
 
range
(
len
(
word
)
 
+
 
1
)]

    
deletes
    
=
 
[
L
 
+
 
R
[
1
:]
               
for
 
L
,
 
R
 
in
 
splits
 
if
 
R
]

    
transposes
 
=
 
[
L
 
+
 
R
[
1
]
 
+
 
R
[
0
]
 
+
 
R
[
2
:]
 
for
 
L
,
 
R
 
in
 
splits
 
if
 
len
(
R
)
>
1
]

    
replaces
   
=
 
[
L
 
+
 
c
 
+
 
R
[
1
:]
           
for
 
L
,
 
R
 
in
 
splits
 
if
 
R
 
for
 
c
 
in
 
letters
]

    
inserts
    
=
 
[
L
 
+
 
c
 
+
 
R
               
for
 
L
,
 
R
 
in
 
splits
 
for
 
c
 
in
 
letters
]

    
return
 
set
(
deletes
 
+
 
transposes
 
+
 
replaces
 
+
 
inserts
)



def
 
edits2
(
word
):
 
    
""All edits that are two edits away from `word`.""

    
return
 
(
e2
 
for
 
e1
 
in
 
edits1
(
word
)
 
for
 
e2
 
in
 
edits1
(
e1
))
当然， 工业强度的拼写校正器的完整细节是非常复杂的，不过从这个玩具拼写校正器中，我们也可以学习到一些内容，而且其校正的准确率也是不错的。
更多内容可参考：
 ","这个我有经验，Python可以做的事情太多了！！！！
下面看我都有哪些操作！！！
上干货之前，先给大家安利一个python入门课程，这个课程真的非常适合像我一样对编程毫无基础的人
，从我个人经历来讲，我建议新手们先别收集那么多其余资料，收集不等于内化为你自己的知识，想当初我也是收藏一大堆但是最后还是留着吃灰还占内存，不如就别再给收藏夹添加垫底资料了，
新手小白直接领这个Python入门课程就好，课程内容包含4节Python实操课+4节人工智能认知课+班群学习：
广告
仅限100名！0.1元入门Python。游戏闯关式教学，小白也能轻松学会
一、多表格处理文件
用来做多表格处理，避免数据出错和审核数据投入的大量时间精力
用Python进行多表格处理
二、处理数据，让数据可视化
1.用Python进行数据处理，可以生成输出热点图和桑基图，直观看出数据来源以及趋势变化。
制作热力图和桑基图
2.Python可以获取数据，发现数据规律，帮我们深入洞察用户，让我们成为最先看透问题本质的人
实现精细化运营
三、用Pyhton爬取资料
1.你可以用十几行代码爬取大量有用资料做调研，通过用户对社会事件的关注度，更好地进行事件分析而撰写爆文
爬取的资料可视化
2.用Pyhton来精准掌握了当下的用户画像和兴趣偏好，提高你出方案的效率
分析用户画像
3.抢车票！用 Python3 自动抓取 12306 网站信息，轻轻松松在这个火车票查询工具买到票，过年回家再也不用跟黄牛讨价还价！！！
抢车票，不怕掉线
四、用Python读取/录入信息
用Python做一个小工具，唰唰几秒自动识别需要的栏目信息，生成新的表格
，辅助自己又快又好地完成读取和录入的工作。
读取信息
录入信息
五、自动回复消息
Python就可以用几行代码，自动回复用户的常见问题，不在做个回复信息的工具人！！！
避免成为工具人
六、一键P图+更换背景
不需要安装复杂的Photoshop 软件，用Python做的小工具分分钟能扣个高精度图，还能自动更换背景！！！简直是黑科技！！！
简单粗暴的抠图
当然，Python能做的还有太多太多了，
像什么抢优惠券、抢演唱会票、抢球鞋、监控股市的交易、量化投资、小游戏开挂、爬取电影资源、自动发送邮件等等
，骚操作真的太多了，但前提是你得学会爬虫去爬取这些信息！
下面答主分享一下爬虫的整个过程：
1、了解爬虫的工作原理
爬虫的工作原理即：
获取数据――解析数据――提取数据――存储数据。根据这个我们基本可以明确后面的学习步骤。
首先最基础的一步就是学习如何利用一个强大的库――
requests
来获取数据。
2、了解一下HTML基础知识
为什么要了解HTML呢？因为爬虫就是通过编程向网络服务器请求数据（HTML表单），然后解析HTML，提取出自己想要的数据。这部分只需要达到读懂和修改HTML文档的水平即可。
3、如何解析和提取数据？
学会安装并使用第三方工具（BeautifulSoup）来解析和提取网页中的数据。 
4、如何存储数据？
爬取到的信息要存储下来才能看，这里就要学习2种常用的数据存储方式：存储成csv格式文件、存储成Excel文件。
(到此，我们就学完了爬虫完整的四个步骤，掌握了最基本的爬虫技能啦。
如果想进阶的话，可以继续学习MySQL和MongoDB这两个库，它们一个是关系型数据库的典型代表，一个是非关系型数据库的典型代表，用于应对十分巨大的数据量 。不过这里需要去接触另一种语言SQL。)
5、如何更高效的爬虫？
通过Scrapy实现
分布式爬虫
，解决爬取效率问题。不过这相当于是一个打怪升级的过程，先把前面的掌握了后面用起来才能得心应手！
至此，你就完成了爬虫的简单入门。把大目标被拆分成小目标，循序渐进，由浅入深，按照上面这个学习路径学下来，你会发现Python的学习只要你坚持，还是比较非常顺利的，同时基础知识也会掌握的很扎实。
学编程最需要的就是耐心！
现在大家想学编程太方便了，跟着教程满天飞。刚开始入门的时候有高手带，往往能有事半功倍的效果，尤其是自己不知道怎么找资料，怎么去配置编程环境什么的时候。有人手把手教的话，
入门就高效很多了
。强烈推荐一下这节
0基础入门课程
哦~
广告
仅限100名！0.1元入门Python。游戏闯关式教学，小白也能轻松学会
最后，既然看到这里，在收藏的同时，也请不吝啬的点个赞！！！！（以下图片来源网络，侵删！！","用python自动爬取海贼王漫画推送kindle。嘿嘿
之前闲着无聊，想找个项目练练手，这时我看到正在 压着泡面的kindle，嘻嘻
就你了，之前一直想在kindle上看漫画，可是想到又得下载资源还得发送到kindle，好麻烦，所以一直没有实现这个愿望，说干就干吧，。
kindle推送
首先关于kindle推送的设置，可以参考下面链接设置。
kindle是支持 JPEG (.jpeg, .jpg)；PDF (.pdf)等图片格式的。这里不推荐使用图片格式，因为漫画有多页，如果用图片推送的话，你会看到kindle上散乱着一堆的图片。。
先整理下思路
1，把漫画下载到电脑。
2，将下载好的一话漫画（15-19页）转换为一张pdf格式文件
3，通过邮件推送到kindle
4，定时爬取网站发现漫画更新 立即推送漫画，
需要用到的模块挺多的，一共需要这几个模块
第一步就是从网上抓取漫画页，具体哪个网站就不说 了，低调
因为此网站为静态网页，结构较简单，所以爬取起来比较容易，。这个函数主要为抓取一话里海贼王的所有图片地址，放到pic_list列表里并返回。
然后定义一个函数用来下载图片（传入图片地址，文件保存地址）
这里是将下载好的图片转化为pdf文件。
PDF文件生成完毕后就可以通过smtplib邮件服务来推送漫画了，qq邮箱的服务器为
mail_host = ""
http://
smtp.qq.com
""
mail_user =  ""邮箱地址""
mail_pass = ""邮箱密码""   # qq邮箱一般需要授权码
receivers = [占位]      #  这里填上kindle的亚马逊邮箱地址吗，可填多个接收邮箱
红色标记的就是kindle邮箱地址，
下面贴上代码
到这里主要功能都已写完，
目前追到了最新最新951话，952话还没更新
需要源码的可到GitHub页面查看下载。
GitHub地址：
https://
github.com/shuaishuai01
08/PYTHON-CRAWL-ONEPIECE-COMICS","Python，大概就是飞一般的感觉。
随着
机器学习
的火爆，Python已经连续三年占据IEEE Spectrum2019年度编程语言排行榜榜首。
而GitHub上，也经常能看到Python写的非常有趣的个人项目。
比如这个曾一日千星的项目：
像文字云一样，用各种小图拼出大的图片，构建一个像素风的世界，就像《我的世界》里一样，一定非常有趣。
还可以拿来做拼贴画、十字绣等装饰。
在这个名为
tiler
的GitHub
开源项目
里你就可以自动实现这一切，它开源第一天，就涨到了1100星，增长速度肉眼可见。
Tiler，意味瓦工，也就是用各种小元素作为“瓦”，搭建出一张大图片。
项目预设了不少“瓦”：有乐高、加号、圆形、@符号、心形、乘号、波浪线、横竖条、《我的世界》中的各种格子，以及曲别针形：
另外还有一组万圣节主题icon，包括各种南瓜灯、小鬼头、蝙蝠、猫头鹰：
这些不同的“瓦”都可以设定大小颜色和角度，以适应不同的画面规格。
另外，你还可以设定整个画面中由多少种颜色构成和“瓦片”的大小，也就是马赛克的模糊程度。
你可以用不同材质的“瓦片”，拼接出各种图案。
比如梵高的《星空》，项目中展示了10×10、25×25、50×50三种圆形拼成的规格：
△
 10×10的《星空》
△
 25×25的《星空》
△
 50×50的《星空》
有没有在PS里拖动
高斯模糊
半径控制条的感觉？
你也可以设置让构成图片的“瓦片”大小不一
也可以试试拿乐高积木来拼：
放大看，斑斓的星空，是这样的：
一个个小砖块，布满了乐高积木表面特有的圆形凸起。
嗯，要是真有这么大一片乐高，想想就爽歪歪。
（此处冲去乐高门店下单，金币-1000）
还有乘号版：
如果放大，你就会发现，这就是十字绣的图样啊！
这么大一副十字绣，色彩艳丽，斑斓交错，一看就可以玩很久，退休老母亲看到两眼发光。
就是绣完挂在家里，也和你北欧风/极简风/莫兰迪风/自如风的房间非常搭配，成为全场最吸睛的装饰画。
要是木有耐心，可以考虑一个迷你版：
还可以做成《我的世界》的样子
星空的细节如下：
你们能认识这些砖块都是啥么……
运行指南
如果想在自己电脑上运行的话，除了Python 3和
pip
，你还需要装OpenCV、numpy和
tqdm
。
之后，靠命令行就可以解决了。
你需要设置几个参数：
在gen_tiles.py中设置：
DEPTH
：每个颜色通道中的分割数量(ex: DEPTH = 4 -> 4 4 4 = 64 colors);
ROTATIONS
：旋转列表，以度为单位，应用在原始图像上(ex: [0, 90])。
在tiler.py中设置：
COLOR_DEPTH
：每个颜色通道中的分割数量(ex: COLOR_DEPTH = 4 -> 4 4 4 = 64 colors)；
RESIZING_SCALES
：应用于每个图块的比例(ex: [1, 0.75, 0.5, 0.25])；
PIXEL_SHIFT
：移动以创建每个框的像素数(ex: (5,5)); if None, shift will be the same as the tile dimension);；
OVERLAP_TILES
：如果构成图像的“瓦片”可以重叠；
RENDER
：渲染图像；
POOL_SIZE
：多处理池大小；
IMAGE_TO_TILE
：图像到瓦片（如果作为第一个参数传递则忽略）；
TILES_FOLDER
：瓦片文件夹（如果作为第二个arg传递则忽略）；
OUT
：结果图像文件名。
脑洞丰富的作者
这个项目的作者ID叫nuno-faria，除了这个Tiler项目之外，他还开源过不少有趣的东西。
有一个用Java写的
推箱子
：
像素风满满的桌面足球：
还有俄罗斯方块、弹球等许多种，个个都还蛮有意思的~
传送门
https://
github.com/nuno-faria/t
iler
―完―
@量子位
 ・ 追踪AI技术和产品新动态
深有感触的朋友，欢迎赞同、关注、分享三连?'?' ? ?","虽然一直被贬低，但是不可否认，Python还是一门非常热门且用处广泛的编程语言，下面就介绍从github上精选的4款由Python开发等小工具。
1. explainshell
Star：7.5k
作为IT/互联网相关的工作人员，哪怕不是开发者，也有可能会和Linux打交道，我们可以用Linux进行开发、运维等，因此，Linux就成为了一项非常重要的个人技能。
使用Linux过程中主要打交道的对象就是繁多的Linux命令和选项(options)就成了令人头疼的事情，举一个最为简单的例子，
> ls -al
这个Linux命令包含两个部分，command和options，ls是查看命令，-a和-l分别代表：显示所有文件(包括以.开头的隐藏文件)、以列表形式显示。
这些常用的我们都知道，但是有很多使用频率较少的怎么办？我们可以借助explainshell。
它是一款利用Python开发的Linux命令行工具，通过解析帮助文档，逐个匹配一行Linux命令中不同字符的含义，让你对Linux命令能够一目了然，是一款非常棒的Linux学习工具。
2. glances
Star：14.9k
glances就如同它的汉语意思那样，“一眼”、“一瞥”，能够通过一个简单的命令对系统信息一目了然，了如指掌。
glances利用Python编写的一个跨平台的监视工具，旨在通过curses或基于Web的界面提供大量监视信息。
你不仅可以通过终端命令行使用该工具，还可以web界面、API接口等对服务器进行远程监控，可以将统计信息导出到文件或数据库。
3. GeneralNewsExtractor
Star：1.1k
根据论文
《基于文本及符号密度的网页正文提取方法》
实现的一款网络正文抽取工具。在今日头条、网易新闻、
游民星空
、观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻做了测试，发现提取效果非常出色，几乎能够达到100%的准确率。
4. you-get
一款用于从Web下载媒体内容(视频、音频、图像)Python命令行工具，使用便捷，支持Youtube、Twitter、TED、网易云音乐、
哔哩哔哩
、腾讯视频、优酷视频、
央视网
、抖音、爱奇艺、虾米、酷狗......等几十个音视频平台。而且，功能非常强大，别的工具无法下载的，它都可以。
干货
干货 | 2019年共享免费资源整理(上)：学习资源篇
?
mp.weixin.qq.com/s?__biz=MzI0NTM1MzA2Mw==&mid=2247484955&idx=1&sn=fa9827493c135096729fac6cd8b54fb2&chksm=e94e9913de391005dc83393528bef4530875108a2fc5fbe0e9de0da87a96a4b146621288f7f8&token=2086279066&lang=zh_CN#rd
干货 | 2019年共享免费资源整理(下)：实用工具篇
?
mp.weixin.qq.com/s?__biz=MzI0NTM1MzA2Mw==&mid=2247484959&idx=1&sn=628c532c9504cbdb17bcd75fee354292&chksm=e94e9917de391001c367b78cedc19276a398c8675e9c9b5c590d02e90efdd1fc5f2e3e816db9&token=2086279066&lang=zh_CN#rd
更多精彩内容
实用工具 | 2款播放器让你免费听遍全网无损音乐
大数据 | Spark机器学习工作流开发指南
实用工具 | 你距离PS大神只差这6款免费在线工具！
简易教程 | 分布式消息发布订阅系统Kafka从搭建到使用
教程 | 一文搭建你的第一个免费专属博客
办公效率 | 让你突飞猛进的10个Word技能
学习工具 | 推荐10款提升自己的优质APP
Google | Python编程规范指南","程序员工作繁忙，动不动来个996，没时间陪女朋友咋办？
没关系，这件小事是难不倒聪明智慧的程序员的，他们花式陪女朋友的方式，让我们眼前一亮。
在github上，有一位叫作云外孤岛的程序员，每天通过微信发消息来陪女朋友，就是用Python来做的。
这简直就是程序员脱单指南啊！
单身狗终于有救了！
1.项目简介
作者教我们用python给女友定时发提示消息，而且不会漏过每一个重要时间，每天早上起床、中午吃饭、晚上吃饭、晚上睡觉，都会按时发消息给她，而且还可以帮助她学习英语单词哦！
哪里不会学哪里，从此再也不用担心女朋友的学习啦！
在生日来临之时，自动给女朋友发祝福语。在重大节日来临之时，比如女神节、情人节、春节、圣诞节等，每个节日都会自动发贴心问候语。
满满的仪式感，从此再也不用担心女朋友说你不在乎她了。
最最最重要的事情，你可以通过女朋友的回复，可以实时了解女友的情感情绪指数。
慢慢的关爱，从此再也不用担心女友莫名其妙的生气了。
2.编写思路
采用python中的wxpy模块完成微信的基本操作。
2.1设置配置文件，读取配置信息
这些配置文件包括女友微信号；设置早上、中午、晚上等一些主要时间，以及对应的提示语；设置一些重要的节日时间，以及问候语。
# 读取配置文件


cf
 
=
 
configparser
.
ConfigParser
()


cf
.
read
(
""./config.ini""
,
encoding
=
'UTF-8'
)

    

# 设置女友的微信名称，记住，不是微信ID也不是微信备注


# 你女友的微信名称，记住，不是微信ID也不是微信备注


my_lady_wechat_name
 
=
 
cf
.
get
(
""configuration""
,
 
""my_lady_wechat_name""
)



# 设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间


say_good_morning
 
=
 
cf
.
get
(
""configuration""
,
 
""say_good_morning""
)


say_good_lunch
 
=
 
cf
.
get
(
""configuration""
,
 
""say_good_lunch""
)


say_good_dinner
 
=
 
cf
.
get
(
""configuration""
,
 
""say_good_dinner""
)


say_good_dream
 
=
 
cf
.
get
(
""configuration""
,
 
""say_good_dream""
)



# 设置女友生日信息


# 几月，注意补全数字，为两位数，比如6月必须写成06


birthday_month
 
=
 
cf
.
get
(
""configuration""
,
 
""birthday_month""
)


# 几号，注意补全数字，为两位数，比如6号必须写成08


birthday_day
 
=
 
cf
.
get
(
""configuration""
,
 
""birthday_day""
)



# 读取早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间的随机提示语


# 一般这里的代码不要改动，需要增加提示语可以自己打开对应的文件修改


#早上起床问候语列表，数据来源于新浪微博


str_list_good_morning
 
=
 
''


with
 
open
(
""./remind_sentence/sentence_good_morning.txt""
,
 
""r""
,
encoding
=
'UTF-8'
)
 
as
 
f
:

    
str_list_good_morning
 
=
 
f
.
readlines
()


print
(
str_list_good_morning
)



#中午吃饭问候语列表，数据来源于新浪微博


str_list_good_lunch
 
=
 
''


with
 
open
(
""./remind_sentence/sentence_good_lunch.txt""
,
 
""r""
,
encoding
=
'UTF-8'
)
 
as
 
f
:

    
str_list_good_lunch
 
=
 
f
.
readlines
()


print
(
str_list_good_lunch
)



#晚上吃饭问候语列表，数据来源于新浪微博


str_list_good_dinner
 
=
 
''


with
 
open
(
""./remind_sentence/sentence_good_dinner.txt""
,
 
""r""
,
encoding
=
'UTF-8'
)
 
as
 
f
:

    
str_list_good_dinner
 
=
 
f
.
readlines
()


print
(
str_list_good_dinner
)



#晚上睡觉问候语列表，数据来源于新浪微博


str_list_good_dream
 
=
 
''


with
 
open
(
""./remind_sentence/sentence_good_dream.txt""
,
 
""r""
,
encoding
=
'UTF-8'
)
 
as
 
f
:

    
str_list_good_dream
 
=
 
f
.
readlines
()


print
(
str_list_good_dream
)



# 设置晚上睡觉问候语是否在原来的基础上再加上每日学英语精句


# False表示否 True表示是


if
((
cf
.
get
(
""configuration""
,
 
""flag_learn_english""
))
 
==
 
'1'
):

	
flag_learn_english
 
=
 
True


else
:

	
flag_learn_english
 
=
 
False


print
(
flag_learn_english
)



# 设置所有问候语结束是否加上表情符号


# False表示否 True表示是


str_emoj
 
=
 
""(?￣??￣??)??°----(?′ `?)----(?ˉ?ε ˉ??)----(??? ? ???)----( ?? .? ?? )----(?? ??)----(●′ω`●)----(●?????●)----?_?----_(:qf∠)----(′；ω；`)----( `)3')----Σ((( つ??ω??)つ----t(*′`*)s----( ′′??′?` )----(′∩｀。)----( ?? ?)----(??_?)----( ?? _ ?? )----c(*??????F *)----( ? 3?)----(; ′_f`)----(*ˉ辍)----(?'?`?)??----(?????)----(? .?.? ?)----(′???`)----(。?ˇェˇ??)----(???)----(｀???′+)----( _ )----( ?????)----ㄟ(??? )ㄏ----(●'?'●)??----(??ˇ?ˇ?）----( ?   ? )----( ′? ??`)----(?n?)----(????)----?(???? )----(???????)""


str_list_emoj
 
=
 
str_emoj
.
split
(
'----'
)


if
 
((
cf
.
get
(
""configuration""
,
 
""flag_wx_emoj""
))
 
==
 
'1'
):

	
flag_wx_emoj
 
=
 
True


else
:

	
flag_wx_emoj
 
=
 
False


print
(
str_list_emoj
)



# 设置节日祝福语


# 情人节祝福语


str_Valentine
 
=
 
cf
.
get
(
""configuration""
,
 
""str_Valentine""
)


print
(
str_Valentine
)



# 三八妇女节祝福语


str_Women
 
=
 
cf
.
get
(
""configuration""
,
 
""str_Women""
)


print
(
str_Women
)



# 平安夜祝福语


str_Christmas_Eve
 
=
 
cf
.
get
(
""configuration""
,
 
""str_Christmas_Eve""
)


print
(
str_Christmas_Eve
)



# 圣诞节祝福语


str_Christmas
 
=
 
cf
.
get
(
""configuration""
,
 
""str_Christmas""
)


print
(
str_Christmas
)



# 她生日的时候的祝福语


str_birthday
 
=
 
cf
.
get
(
""configuration""
,
 
""str_birthday""
)


print
(
str_birthday
)
2.2开启微信机器人
自动判断所属操作系统，并且根据不同操作系统执行不同指令。
# 启动微信机器人，自动根据操作系统执行不同的指令


# windows系统或macOS Sierra系统使用bot = Bot()


# linux系统或macOS Terminal系统使用bot = Bot(console_qr=2)


if
(
'Windows'
 
in
 
platform
.
system
()):

    
# Windows

    
bot
 
=
 
Bot
()


elif
(
'Darwin'
 
in
 
platform
.
system
()):

    
# MacOSX

    
bot
 
=
 
Bot
()


elif
(
'Linux'
 
in
 
platform
.
system
()):

    
# Linux

    
bot
 
=
 
Bot
(
console_qr
=
2
,
cache_path
=
True
)


else
:

    
# 自行确定

    
print
(
""无法识别你的操作系统类型，请自己设置""
)
2.3每日发送励志精句，教女友学英语
# 获取每日励志精句
def get_message():
    r = requests.get(""http://open.iciba.com/dsapi/"")
    note = r.json()['note']
    content = r.json()['content']
    return note,content
2.4掌握女友的情绪指数
使用
jieba库
分析女友情绪。
# 接收女友消息监听器


# 女友微信名


my_girl_friend
 
=
 
bot
.
friends
()
.
search
(
my_lady_wechat_name
)[
0
]


# chats=my_girl_friend 表示接收消息的对象，也就是女友


# except_self=False 表示同时也接收自己发的消息，不需要接收自己消息的可以去掉


@bot
.
register
(
chats
=
my_girl_friend
,
 
except_self
=
False
)


def
 
print_others
(
msg
):

    
# 输出聊天内容

    
print
(
msg
.
text
)


    
# 做极其简单的情感分析

    
# 结果仅供参考，请勿完全相信

    
postData
 
=
 
{
'data'
:
msg
.
text
}

    
response
 
=
 
post
(
'https://bosonnlp.com/analysis/sentiment?analysisType='
,
data
=
postData
)

    
data
 
=
 
response
.
text


    
# 情感评分指数(越接近1表示心情越好，越接近0表示心情越差)

    
now_mod_rank
 
=
 
(
data
.
split
(
','
)[
0
])
.
replace
(
'[['
,
''
)

    
print
(
""来自女友的消息:
%s
\n
当前情感得分:
%s
\n
越接近1表示心情越好，越接近0表示心情越差，情感结果仅供参考，请勿完全相信！
\n\n
""
 
%
 
(
msg
.
text
,
 
now_mod_rank
))


    
# 发送信息到文件传输助手

    
mood_message
 
=
 
u
""来自女友的消息:""
 
+
 
msg
.
text
 
+
 
""
\n
当前情感得分:""
 
+
 
now_mod_rank
 
+
 
""
\n
越接近1表示心情越好，越接近0表示心情越差，情感结果仅供参考，请勿完全相信！
\n\n
""

    
bot
.
file_helper
.
send
(
mood_message
)
2.5每天定时发送关心语
# 来个死循环，24小时关心她

    
while
(
True
):


        
# 提示

        
print
(
""守护中，时间:
%s
""
%
 
time
.
ctime
())


        
# 每天定时问候，早上起床，中午吃饭，晚上吃饭，晚上睡觉

        
# 获取时间，只获取时和分，对应的位置为倒数第13位到倒数第8位

        
now_time
 
=
 
time
.
ctime
()[
-
13
:
-
8
]

        
if
 
(
now_time
 
==
 
say_good_morning
):

            
# 随机取一句问候语

            
message
 
=
 
choice
(
str_list_good_morning
)


            
# 是否加上随机表情

            
if
(
flag_wx_emoj
):

                
message
 
=
 
message
 
+
 
choice
(
str_list_emoj
)


            
send_message
(
message
)

            
print
(
""提醒女友早上起床:
%s
""
 
%
 
time
.
ctime
())


		
…………
这下面还有很多代码
，
我就不列出来了
…………


        
# 延时60秒

        
time
.
sleep
(
60
)
2.6守护女友出了Bug，启动人工干预
# 发送消息给她


def
 
send_message
(
your_message
):

    
try
:

        
# 对方的微信名称

        
my_friend
 
=
 
bot
.
friends
()
.
search
(
my_lady_wechat_name
)[
0
]


        
# 发送消息给对方

        
my_friend
.
send
(
your_message
)

    
except
:


        
# 出问题时，发送信息到文件传输助手

        
bot
.
file_helper
.
send
(
u
""守护女友出问题了，赶紧去看看咋回事~""
)
2.7大功告成
   
# 开始守护女友

    
t
 
=
 
Thread
(
target
=
start_care
,
 
name
=
'start_care'
)

    
t
.
start
()
3.结果展示
作为一只单身狗，和舔狗，我选择做一只有情调的舔狗。
今天你依旧高冷，给你发了好多信息，都没回我。可你越是这样，我越是喜欢你。在我不断的嘘寒问暖下，你终于不再矜持，回了一个sb。我查了下英语词典，终于明白了这两个字母的意思。
s是sweet，b是baby，我想你一定是在叫我sweet baby了，这让我很感动。
扩展阅读：
声明：本项目原作者云外孤岛，链接：
脱单狗福利!每天不同时间段给女友定时给女友发消息,不错过早上起床、中午吃饭、晚上吃饭、晚安时间! - 云外孤鸟 - 博客园 (cnblogs.com)"
,,,,,,,,,,,,,,,,,,,,,
既然有些人喜欢开挂，为啥不开发一款网游，提供编程接口，允许玩家自行用各种软件，同时允许计算机参与计算？,比如，敌方开枪，由玩家设定扫描区域及间隔，同时服务器返回扫描区域内的物质，由计算机运算区分出是否是子弹，及时提醒玩家，或者自动计算躲避路径，并及时躲避，可以扫描出敌方位置以及移动速度，计算弹道什么的，或者双方纯拼算力，参考超神学院，诸天降临(gay伦对饕餮王的那一段)，这样，大家都考虑着去优化算法了。也就没心思去搞挂了 ,"真有这种游戏啊。。。
《Screeps》
steam链接：
https://
store.steampowered.com/
app/464350/Screeps/
有想要挑战一下的可以看这个live demo，不需要注册就可以立刻试玩：
https://
screeps.com/a/#
!/sim
游戏的介绍：Screeps is an open source MMO RTS sandbox game for programming enthusiasts, wherein the core mechanic is programming your units AI. You control your colony by writing JavaScript which operates 24/7 in the single persistent world filled by other players on par with you.
介绍的翻译：Screeps是一个为代码变态(划掉)爱好者设计的开源的MMO RTS（大规模多人在线即时战略）游戏。这个游戏的核心机制就是来为你控制的单位写AI。你可以用JavaScript来控制你殖民地（里的一切），并且这些内容7*24小时运行的，并且充满其他玩家来与你对抗。
说白了就是给你提供一个JavaScript的接口，用来写一个“AI”来跟其他玩家对抗。可以简单的基于规则，也可以写
有限状态自动机
，也可以写增强学习之类的agent ai（但性能其实很受限）。
现在这个游戏已经变得巨复杂了。从能源到采集，从防御到进攻策略甚至还有贸易等等等等。。。
这个游戏有多复杂？首先想要入门，游戏是全英文的，除了写code要用纯英文，最重要的是所有的官方文档也都是英文的。你需要通过阅读文档来学习这个游戏的API：
https://
docs.screeps.com/archit
ecture.html
（这文档一看就是API Reference的风格）
文档中包括整个游戏系统的运行逻辑、写code的接口和一大堆内部机制。
当然，还有API References！来来来，请随意体验一下被代码支配的恐惧：
然后看看大佬开源出来的code：
https://
github.com/TooAngel/scr
eeps
（是的，放在了全球最大宅男/女交友社区）
这个游戏的收费是花钱买算力(subscription token)。。而游戏中你可以获得算力再出售。所以完全有可能通过写一个巨厉害的code来赚钱……
详细信息建议看steam页面中
Attack.On.Pika[AFK]
的评论。。。分析的已经很透彻了
更：附上
tutorial
里的第一段代码：
module
.
exports
.
loop
 
=
 
function
 
()
 
{

    
var
 
creep
 
=
 
Game
.
creeps
[
'Harvester1'
];

    
var
 
sources
 
=
 
creep
.
room
.
find
(
FIND_SOURCES
);

    
if
(
creep
.
harvest
(
sources
[
0
])
 
==
 
ERR_NOT_IN_RANGE
){

        
creep
.
moveTo
(
sources
[
0
]);

    
}


}


大致的意思是这样的：从场景中找到名为Harvester1的一个creep(既游戏种的一种基本单位)。然后寻找当前房间中的所有source。然后命令creep去harvest 所有source中的第1个source。但这个过程有可能返回值是“ERR_NOT_IN_RANGE”这个错误，说明creep距离source太远了。然后就命令creep moveTO那个source里。然后整个函数永不间断地执行下去。
如此，万里长征第一步搞定了！你得到了一个可以遍历采集资源的creep。但是抵御不了入侵者，也很难最优化效率等等。想要更高端的agent，还是要多烧脑了。
更：看了一下API，这玩意居然还支持Binary Module。就是说一些要求性能的地方，你可以写个C语言的code然后编译成二进制的library再在JavaScript脚本里调用。","哈哈哈，我玩过一款网游可能符合题主的意思。
预警：本文较长，注意流量。
既然是外挂，提供编程接口就没什么意思啦，允许玩家自行用各种软件这个才是问题的关键。
大概是2014年的时候吧，有时候上下班通勤时间或者厕所蹲坑时间，想找点游戏打发时间，不想玩单机，也不想爆肝玩一些容易耗时耗力的游戏。
然后我就发现了一款
很弱智很脑残很沙雕
但是又很魔性的网络游戏。我刷微博的时候看见一个同事在玩，我就跟着点进去开始玩了。我当时玩的是微博小游戏版，游戏名字叫“愚公移山”（PS：我玩的游戏版本目前已经倒闭停止运营了！因此此文所有配图都是在网上搜索，如有版权问题，请联系我删除。）
游戏开始界面
现在回想，这游戏仍可以排进我玩过的沙雕网游的top榜之首，游戏很简单，就是点这个茅屋，然后就会造一个小人，（还记得
《愚公移山》
的课文吗？“子又生孙，孙又生子。子子孙孙无穷匮也! 而山不加增，何苦而不平? ”）这个游戏就是要造小人，然后去移山！！
游戏里面的boss就是山，而且那些山不是叫王屋和太行，策划们给那些山取了一些很脑残的名字，诸如：
游戏boss之一
打boss就是，点击这个山，然后你的子孙数量就会减少一个数值，山的HP数量（血条）也会减少一个数字，然后根据你的子孙数量，和移山的数量，会在游戏里面有一个世界排名，然后里面也会有一个好友排名，会显示你和你的游戏好友的子孙数进行排名。
当然，作为一个网游，它不可避免的也有充值系统，当然沙雕游戏的商店也是很沙雕的，卖的就是一些莫名其妙毫无关联但是让你在游戏里更快生孩子的道具，或者是对好友使用可以给好友避孕的一些道具。
游戏中的商店
游戏中增加生产率的方法有很多，比如升级茅屋变成豪宅，茅屋点一次只能生一个，豪宅点一次可以生十几个；比如增加草丛或克隆人装置等自动生育场景（充值开通或者攻克boss之后的金币道具购买）
游戏内核就这么简单，接下来就是开始斗法。
=======简单分割线========
我开始玩的时候，我那个同事已经是图2那种级别了，子孙67亿，生产速度222万人每秒，击败全球60%的玩家。我想偷偷地超过他，于是悄悄咪咪地开始玩，由于这个游戏只有“点击生娃”这么一个简单的操作，于是我先用了最简单的外挂，
按键精灵
。
鼠标连点器
用按键精灵写了一个鼠标连点的软件，然后通过模拟器在闲置电脑上开启游戏，最开始通过大概十分钟的个人玩法，我已经把茅屋升级成了女娲，点一下可以生120个子孙，为了便于后期的统计，我设置成每秒点击100次，也就是一秒钟可以生12000个子孙。那么一分钟就是720000子孙，一小时就是43200000子孙，我挂8小时，就会有3.4亿的子孙。因为前期的boss都很弱鸡，大概几百万子孙就可以移掉那些山，那么一天时间，我就能推到一些boss然后获取金币开通自动生育区！同事的67亿子孙，估计也就几天我就能超越！
前期的boss
调试完成之后，我心满意足地上班去了，也不敢挤号，看着我同事一本正经地工作的时候，我总是莫名想笑，心想着过几天我的游戏排名就要超过你了！兀自暗爽！
然后我当天下班，飞一般的回家开电脑，打开一看，连点器仍在正常运作，但是我的子孙居然只有1.1亿！卧槽怎么回事，是我的数学不好还是游戏策划的数学不好？我又检查了一下连点器，依然是一秒一百次，一分钟72万，明明过了八小时，为什么只有1.1亿！
我不解地百度，崩溃的发现原来这个游戏还有随机事件，就是会出现一个叫做“智叟”的人物，一下子就按百分比屠掉你的子孙，比例高到15%-30%！！！估计就是官方为了平衡我这种无脑点击挂出的类似验证码事件。
然后这个游戏没有日志记录，被智叟屠了我也看不到是什么时间，也不知道他出现的规律和频率，除了网上搜到的图片，我都不知道他到底长什么样子，更不知道该怎么应对。但是我综合分析以往的游戏套路，应该是他出现之后点击他会触发一些事件，可以驱赶或者打败之类的。于是我守在电脑前大概2个小时，果然出现了智叟，只要在3秒钟之内点击他，就可以把他驱赶走，不然他就会屠杀很多的子孙，我不得不又在连点器原始代码里加上监测智叟出现的代码。
当天晚上，捣鼓了半天，开了几个自动生产场景，自动生育率在每秒四万个，加上连点器，一秒钟可以生52000个子孙，一小时就是1.8亿子孙！！！
睡觉之前再次确认了一下正常运行，明早起来，20亿妥妥的。
果然，第二天一早起来，我的子孙大军已经生到23亿了，然后又是解锁场景，又是升级女娲，自动生育弄成了80万每秒，点击生产也达到了每下1000个，开挂高达每秒10万，加起来也就是90万每秒，和昨天的速度简直不可同日而语，并且我的世界排名已经击败了30%的人！超过同事指日可待！！可能也就是这两天的功夫了！！
有了一天的游戏经验，除了智叟之外我还获得了一个信息：就是在游戏途中升级场景或者道具，会让产出比更高！于是我又下载了一个
向日葵远程控制软件
，手机控制电脑，在公司蹲坑或者喝水时，就打开看看够不够升级新的道具，然后就顺手升级一波。等到下班的时候，我已经每秒生产率达到了100多万，人口总数也快到了40亿，世界排名也从击败30%到了击败40%多。
同事的游戏似乎没怎么打理，每秒生产率还是两百多万，但是人口总数已然达到了3000亿的级别，这个时候让我不得不感慨计划生育的重要性。
想要超过他，不得不花点功夫，由于我有连点器这个大杀器存在，于是我开始讲究策略，我把点击就能生产的女娲升级升级再升级，虽然越到后面升级需要的道具金币就越多，我又不得不去移山，移山又死掉几亿的子孙，真的体会到愚公移山的精神。总之折腾了一个晚上，我的人口总数变成了只有一千多万，但是我点击一下女娲，可以用生产50000个子孙，然后又优化了一下连点器，让它每秒可以点击140次，这样光是点击的产出率就达到了700万每秒，加上生产场景每秒100多万的产出率，我的子孙以每秒800万的速度繁衍着。生产速度已经达到了我同事的四倍！预计一晚上我的子孙就可以突破3000亿的大关！明天上午，就可以全盘超过我同事！
时间很快就到了我玩这个游戏的第三天上午，我同事5500亿总人口的时候，我已经6000亿了！！我差点就忍不住跟他说了！！但是我压抑住激动的心，硬是等到了下班的点，我的人口数经过一顿操作已经达到了10000亿，也就是一兆！！而我的同事仍然只有6000多亿！！我的世界排名已经击败了70%的用户！！
下班时候我风淡云轻地叫住了他！
我打开手机上的游戏，故作轻松地说：“你是不是也在玩这个游戏？你看看你的排名。”我准备欣喜若狂地收获他大吃一惊的表情，但他并没有特别惊讶，看到之后只是笑着说：“你小子可以啊，我这两天没玩你一下子把我超越了。”
我们顺着聊了一会，然后我又得知他玩游戏的原因，因为他有一个同学，是一个网游重度氪金用户，玩这个沙雕游戏，居然也充值了一千多块钱！！同事为了证明技术比金钱牛逼（或者是证明他同学是个沙雕），就也开始玩这个沙雕游戏！也是想像我一样通过某种外挂手段干过他的同学。而且我同事仅仅只比我早玩两天！！这两天他下班忙着约会没有怎么玩游戏，所以一不小心被我超过了，我们坐电梯下楼越聊越起劲，干脆就去了公司附近的星巴克，他现场给我演示了一下骚操作！
他走的外挂路线是提升自动产出，他觉得连点器什么的太low了，而且效率不高，他说自己一直在攒道具金币买地狱之门，这几天没怎么管，刚好消耗掉一波子孙，可以换两个地狱之门！
地狱之门是一个可以一秒钟生产150万子孙的大杀器！！也是游戏里生产率最高的场景！！
他打开了他的ThinkPad，然后麻溜的开出模拟器，兑换两个地狱之门，然后打开了一个辅助软件――变速齿轮！
变速齿轮利用HOOK API修改游戏时间的倍速！他用的版本最高可以调速到256倍！也就是现实中每过1秒钟，他的游戏里已经过了256秒！！
他的两个地狱之门就已经可以达到300万人/秒，加上变速齿轮，每秒造人速度居然高达7.68亿！
然后我们喝咖啡聊天那一会儿功夫，他的人口数居然也突破了一兆！！
除了一脸震惊，我还能说什么呢？
然后我们正式踏入了一兆大军，世界排名也达到了击败70%玩家水平！
但是他给我看了一下他那个氪金的同学，让我知道什么叫金钱的力量！！他的同学居然有世界排名！世界排名只有100个人，他的同学就是在52位，击败全球98%的玩家！
据了解，他的同学不会软件，也不会外挂，纯粹是充钱玩，就玩到了这个地步！！
我百思不得其解，因为根据我的研究，正常打boss加自然生产（没有谁会沙雕到一直狂点手机生产吧？），想要到我们现在这个程度（击败70%），可能都需要玩1个月。然后同事告诉我一个令人伤心的真相：因为我们都没充过钱，所以我们看到的商店和充过钱的玩家看到的商店不一样，充过钱之后商店里是可以直接购买地狱之门的，15块钱一个，买了地狱之门之后还送金币，送的金币又可以升级地狱之门，所以我这种辛苦攒金币买的地狱之门一秒只能生150万个子孙，但是我同学氪金买的地狱之门是这样的↓
WTF！
果然免费玩家和收费玩家玩的不是一个游戏！原来我们看到的商店都不一样！！我的商店里还有很多的问号，我以为是到了某个级别才能解锁，原来是要充钱！！
最让人生气的是，氪金玩家还可以买几种道具，它们分别是：+10%，+20%，+50%
就是字面意思，你要有10亿人口，买一个+50%，瞬间变15亿！
可气的是，这些道具只要几块钱（1-3块钱左右）
然后充了会员还是月卡啥的玩家，每天还有一次6块钱子孙翻倍的机会！！5000亿瞬间变1兆！
而且没充钱的玩家只能遇到智叟来屠杀，充了钱的玩家随机事件居然是：天空突然经过
哈雷彗星
，你银行系以内的子孙数量翻倍！
同事的同学就这么无脑氪金，各种道具各种点各种付款，就这么硬生生氪了一千多，到了世界排行榜的前100！榜上有名！！
我们要给平民玩家涨个脸，我们也要进榜！我们要证明技术比金钱牛逼！我们结合了我俩的骚操作，研究出了后台双线程操作，一边疯狂连点，一边变速齿轮自然生产，就这种疯狂的生产速度，居然还是不及排行榜上大神的生产速度，top100的大神们人口基数太大了，计算单位都不是一个量级的，我们爬天梯爬得好辛苦。游戏第六天的时候，到了一个阶段，所有能获取金币的渠道都打完了，场景和女娲都没办法再升级，我们的产值变成固定的1秒220亿，世界排名变成了击败90%的玩家！
可以说是瓶颈期了，并且随着排名的提升，居然又多了一种玩法，就是你可以去掠夺其他玩家的人口，然后玩家会有闪电，可以打击前来掠夺的人，然后就会击落侵略者的一些人口数变成自己的人口数，但是闪电每一个都有冷却时间（用完了可以拿金币买），有时候掠夺的人来得多了，后面只能被掠走一些人口。
我和同事研究中发现，这个游戏的安全机制（反外挂机制）可以说几乎没有，这个闪电很快就会用完但是很慢才能冷却，于是我们又用了新的外挂手段：wpe封包。
我们设置了闪电的冷却时间，将数据包中的30分钟冷却设置成1秒，这样我们就一直有闪电，所有掠夺者，一个不留全部干倒！真正实现了朋友来了有好酒，敌人来了有猎枪！
然而一天劈死几百个侵略者，我们的战利品――那些增加的子孙们，居然只让我们的世界排名提升了1%。
但是这个契机我们灵机一动，可以刷CD时间，为什么我们不刷金币呢？
这里值得一提的是，到后期干掉一个boss会给几百个金币，在所有百分比道具里面，+10%的道具是可以花1500金币购买的！
但是我们目前范围内已经无boss可杀，没有获取金币的渠道，后来还是同事聪明，10金币买了商店里一个最便宜的道具，抓到数据包的数据之后，把金币数量的减法改成加法，然后封包发送，结果成功了！我们金币增加了10金币！
然后开始刷金之路，一路刷到999999999999个金币，到了游戏金币栏上限。
虽然免费玩家没有+20%，+50%和+100%(翻倍)
但这个+10% 对于开挂玩家来说，已经够用了！
然后我们的连点器变成了连点+10%，在我们已有的人口基数下，可以说是涨幅是一个天文数字了！全服第一指日可待！
玩这个游戏的第九天：
终于到了世界排行榜的第一，第二就是我的同事，我们人口数差不多，只要少抓一个智叟，就能轮流坐第一。
拿到排行榜第一之后，这个游戏开始变得索然无味。同事也赶紧抽了个时间去和他的氪金同学N瑟，结果氪金同学说了这么一段话：
像我这样的充钱玩家，不是为了充钱而充钱，其实就是想打赏一下做游戏的研发策划人员，其次才是图一个游戏里的便捷，像我这样的人才是一个游戏开发出来，生存下去的原动力！你们这些开外挂开辅助不择手段达到目的的人，简直是游戏败类！！！
他同学的一番话真的是震耳发聩如雷贯耳，我和同事都羞愧地低下了头。不过事后氪金同学从技术角度了解了一下我们的操作方式，然后抱着学习的目的刷到了世界第三。
最后坚决抵制外挂行为，呼吁大家用钱支持自己喜欢的游戏。
=====================
备注：本故事纯属虚构，如有雷同实属巧合。本人不为故事中行为和语言承担任何道德上的谴责或法律上的责任。","我们有个黑客游戏，岂止是允许写外挂？而是不会写代码没法玩。
黑客大逃杀
：一个服务器，每人一个root权限账号。然后写个程序运行，杀掉所有其他人的程序，同时保护自己的程序不死。活到最后的赢。
你们会想玩不…","有啊有啊。
有个游戏叫
robocode
，题主要不要试一试？这个就是你要的类型哦，包你满意。
2001年发布，最新版是2018年4月发布。
玩法很简单，用程序控制自己的坦克击毁对方坦克。
但实际上可没那么容易，开炮要算提前量，不过对方也不傻，会用随机移动来扰乱你的瞄准。当然你也要用有效的移动策略防止对方打中。
我随便贴个视频你体会一下
当然这是低段位的比试，双方的动作都有很多问题。高手对决可以用深不见底来形容。
虽然国内并不流行，但真的是很好的游戏。","虽然不是完全符合题主的要求，但这两款游戏，一定程度上形成了一个“开挂”的小圈子，各国作者都在研究如何更加优美，更加奔放的“开挂”。而且后者对于外挂的研究深度，一定程度诠释了外挂的最终形态。
第一款游戏是
暗黑破坏神2
。
无线电镇楼
暗黑破坏神2大家可能都玩过，一部分人的记忆停留在血乌都瑞尔上，硬核点的玩家可能还记得build各种char。但能觉得这款游戏能跟开挂扯上关系的，无非也就是
hackmap
，大箱子插件，深入点可能还研究过ATMA或者UdieToo。
但这个游戏有一种小众而独特的玩法，叫做
硬血
。
硬血就是修改暗黑2的人物存档，d2s文件，不涉及MPQ，dll文件的修改，使其可以进入任意暗黑2的战网房间内，两个人进行PVP。因为相比于正常存档，硬血人物是完全打不死的存在，所以起名硬血。
硬血玩法是硬血人物对抗硬血人物，不像传统单机游戏一样是外挂欺负AI，也不像传统网游一样是外挂欺负正常玩家。所以如何修改成一个好的硬血人物存档，有着非常深刻的讲究，其中运用了非常多的暗黑2基础游戏机制，需要大量时间去钻研。
硬血人物图片
硬血科普贴：
【图片】｛申精｝玩暗黑的这些年，玩硬血的这些年……【暗黑破坏神吧】_百度贴
浅谈对硬血的理解【暗黑破坏神吧】_百度贴吧
第二款游戏是mugen。
mugen是一个格斗游戏引擎，最经常拿来做同人格斗，详情请见我的科普
mugen到底是什么，怎么以最正确的姿势入门？
格斗游戏中，被讨论的最多的就是人物的强度，绝大部分格斗游戏，都被玩家严格的区分了人物等级，S-C不等。甚至更多的人还在跨作品比较人物强度，比如KOF97中的大蛇和KOF2001的伊格尼兹到底谁厉害，而mugen就为这种跨作品PK提供了平台。
再加上中期mugen的AI作者的崛起，本来傻傻的任人欺负的普通人物，被赋予了强大的AI，于是mugen玩家们不再去手操控制人物，而是观战让AI打AI，于是你在B站上看到了各种各样关公战秦琼的杯赛。
我的入门杯赛：强中-凶中略有节操大乱斗
https://www.
bilibili.com/video/av21
5112
开启拳皇时代的杯赛：拳皇世界
https://www.
bilibili.com/video/av78
0682
既然人物-AI都是各国作者制作的，那么mugen人物就免不了被加上各种私货，比如制作一个超高防御超高攻击时刻全屏攻击的大蛇，这样的人物应该就是mugen
凶恶
玩法的起点。
mugen中的凶恶技术，是各个时代中喜爱凶恶玩法的作者，对于制作高强度攻击面，和高强度防御面的汇总。由于喜欢凶恶的作者和观众非常多，甚至达到和普通玩家分庭抗礼的存在。即使到现在，mugen传播在外的名声最大的mugen角色，也是一个凶恶人物――祸灵梦。
mugen有着非常严格的分级制度，纸并强凶狂神，强上凶下的等级差不多就是一个格斗游戏的顶尖玩家操作非BOSS S级角色的水平，而到了狂中往往存在各种回血脱离，已经是人类手操正常角色战胜不了的存在。到了神下之后，格斗游戏的表现力都趋近于无，你来我往之间只是画面和音效的演出效果，更多的是后台代码之间的战斗，神级角色们搭载了各种各样的凶恶技术，这些凶恶技术积累于日本作者和中国作者，所以有着各种各样的中二名称。比如即死，OTHK，混线，超即死，永续毒，毒，死宣，强制死宣，即死返，贯通炮，邪眼杀手，亲变更，NOKO。每一种称呼，背后都有对应的一项技术，这些技术往往针对了mugen中各种判定和BUG，来让系统判定自己胜利。好的凶恶角色往往搭载了更多，更通用的凶恶技术，也有着针对某些角色钢板防御面的特殊对策。
凶恶技术：
即死 | 千寻Mugen
凶恶技术还分攻击面和防御面，凶恶作者更加追求攻击面，在神级的顶点神最上的战争中，打掉多少高防御面的靶子，就是攻击面的体现。
2018神最上评测 
https://www.
bilibili.com/video/av29
070493
然而神最上就是mugen的顶点了吗？并不是。随着mugen作者的深入研究，更加凶恶的技术出现了。那就是针对mugen内存地址，汇编代码，
栈溢出
的隔离技术，包括本体亲捏造，%n，%f，statedef溢出，def溢出，这些技术应用往往已经不局限于mugen中的胜负了，可以直接注入汇编代码，修改mugen源代码，调用dll，调用windows的API执行任意行为。这种人物之间的攻击，往往在游戏战斗之前就开始了，在选择人物甚至载入人物的时候就完成了攻击。所以出现了打开浏览器的人物，删除所有人物的人物，听歌的人物。所以有个mugen笑话就是病毒人物。
选择即关机或者重启的两个人物
选择之后按E，可以打开作者博客的人物（调用explorer.exe被360报毒了）
隔离技术：
截止目前各种隔离技术一览【mugen吧】_百度贴吧
这里必须要提到一个中国作者，ydccdy2010，通称遥远，几乎大部分的隔离新技术都是他提出来的，是mugen凶恶历史上最重要的作者。
这些新技术的出现，让mugen人物强度再次提升了一个档次，甚至让原本的神级人物不带他们玩了，神最上评测中不允许出现隔离技术。
论外・攻守对决：
https://www.
bilibili.com/video/av92
91548
看到上述两款游戏，你是不是对外挂又有了新的理解，其实不管是单机游戏的修改器，还是网游的挂，都没有太多深度。外挂的最终形态，就是变身成黑客，攻击游戏本身，攻击玩家电脑，攻击服务器。","我之前就想要做一个这种游戏来着，没有人机界面，全部API提供，后来被朋友阻止了，他们的理由非常说服人：
我不想下班了以后再上班。。。。
=====
没想到这么多人想要下班了以后再上班。。。。。有建设性意见的可以加我微信，备注：下班之后再上班，我拉你进讨论群。。。。","更新：感谢各位点赞，如想开私服，微信扫我头像。
――――――――――――――――――――――――――
这种游戏不要太多。
从最入门的  
到
到
The ICPC International Collegiate Programming Contest
?
icpc.baylor.edu/
到
Free Open Source Codes Forge and Sharing
?
www.codeforge.com/
到
Build software better, together
?
github.com/","不知道大家有没有听过
剧场效应
？
大家只想在有秩序的环境下做那个有特权的人，
而不是在一个混乱的环境下肆无忌惮得做任何事。
在一个混乱的环境下大多数人只能被按在地上摩擦，即使没有被按地上摩擦，那也远没有开挂带来的凌驾于秩序之上规则之外的感觉来得更爽。
什么是“剧场效应”？
在一个剧场里，大家都在看戏。每个人都有座位，大家都能看到演员的演出。忽然，有一个观众站起来看戏（可能是为了看的更清楚，也可能因为身高较矮），周围的人劝他坐下，他置若罔闻，求助剧场管理员，管理员却不在岗位。于是，周围的人为了看到演出，也被迫站起来看戏。最后全场的观众都从坐着看戏变成了站着看戏。
有什么区别吗？
先站起来看戏的人在短时间内看的更清楚了，等到大家都站起来了，所有人看的效果和原来几乎相同。
只是，所有人都成了站着看戏，所有人都更累了。
所有人，比原来付出了更多的体力成本，得到了和原来一样的（甚至更差）观剧效果。
更悲剧的是，虽然大家都更累了，但不会有任何人选择坐下来看戏。
因为，谁选择坐下来，谁就啥也看不到。
相反，还会有人开始站在椅子上看戏，引发更多的人也站在椅子上看戏。
于是，一种空前的奇观出现了，某处的椅子不是用来坐的，而是用来站的。
结果，破坏秩序的人没有得到持久的收益，而遵守秩序的人则是受害者。
表面上，要怪那个破坏秩序，先站起来的观众，是他，首先破坏了秩序。
实际上，真正的责任人，应该是剧场的管理员，毕竟，他是秩序维护者。","看到这个题目的一瞬间，我就想到了M.U.G.E.N。
------------------------------------------------
简单地说，mugen是个游戏引擎，从最开始的移植其它游戏角色供大家手控战斗，发展到了现在――角色作者制作性能超出天际的角色和AI，让AI们自己战斗（因为有些角色技能几十个，手操灾难，有些AI惨无人道）。角色作者采用各种匪夷所思的手段把角色的性能无限提升，包括并不限于利用bug、控制台命令、篡改程序等等。
2019.5.27添加
------------------------------------------------
虽然
mugen
并不是网游，但是其它方面完完全全体现了题目中的各种设定。
首先说一下mugen是什么：
mugen是一款免费的2D格斗游戏引擎。玩家可以自己制作游戏人物和AI。
绝大多数游戏，在给玩家提供了太过自由的环境后，往往都会发展出一些莫名其妙的东西出来。比如我的世界里有人造了一个游戏机，然后在我的世界里的游戏机里玩我的世界；中世纪背景的besiege，制作者原本想象中的投石机摧毁停车场变成了汽车人大战F22；war3原本一个RTS游戏，但是现在空战赛车射击消消乐连连看什么地图都有。mugen也是一个被“玩坏了”的典型。
这里引入一个概念：纸 并 强 凶 狂 神 论外，也许有些人听过这个东西，不过这里也大致不太严谨的解释一下：纸 并 强 凶 狂 神 论外是用来对游戏人物进行分级的，最弱者为纸，大概有星爷电影中眼镜仔的强度（或许更弱？）；
断水流大师兄
大概并级或者强凶级吧（不是一个系统，强行比较帮助理解，并不准确，大师兄不是游戏人物）；再往上就是狂神论外了。
mugen玩家制作的并、强、凶人物还比较正常，纸级太脆，作为游戏人物而言战斗力不足1鹅。并、强、凶级的人物就开始有意思起来，玩家创造出来的人物在自己制作的AI支配下互相战斗，各种花式连击和战斗脱离有声有色，状态爆发之下，一套连击带走对方也是有可能的，还出现了一个常用语“十割”，表示一套连招打掉整整一条血条，有十割当然也有五割、七割，一气（能量豆，用来施放超必杀技等）十割，三气十割等。
但是到了狂级，一些奇奇怪怪的东西就多了起来。比如死星或者叫做死兆星，源自
《北斗神拳》
，死兆星出现就意味着死亡的出现。狂级的很多人物在一定条件下就会触发死星，直接无视一切秒杀对方。也就是说你打对方打得正起劲呢，打到了对方就剩一丝血皮，突然对方瞬间脱离战斗，然后格斗游戏变成了一段花里胡哨的画面，等到画面散去，你就只能看到自己角色的尸体了。
普通mugen角色的作者（或者可以理解为mugen这个游戏的玩家）还在想办法用拳脚到肉的方式击败对方，还在尝试不断提升AI对于技能招式的判断，给自己游戏角色增加了死星的玩家已经脱离了正常的格斗概念。
类似的还有大伤害，脱离，无敌等等
mugen的画风从这里就开始奇怪了
像无限能量豆这种都是小case
先是有些作者作出的角色可以把对手打浮空一套连击到死，或者干脆就是自带无限连
然后就有作者给出了脱离――甭管你打的多开心，我都可以瞬间脱离被你打中浮空的不可控状态
紧接着有作者给自己的角色增加了大伤害技能，特定条件下的招式可以一击打掉一条血
那么对应的有些角色就出现了大伤害检测功能，一旦出现大伤害，则会令其无效
有些作者制作出了“我看了电视”这种无法格挡的赖皮技能
那另一些作者干脆搞出类似“自信”（白罗灭精）之类的全屏伤害、自身无敌的大招出来
所以狂凶级别的战斗通常最为精彩，大家往往看的眼花缭乱，B站随便搜狂级/凶级/mugen都可以看到很多。
（某不走心的随便举例）
继续讲神和论外
神是个什么概念呢？
大概就是“普通人不能理解”这种概念吧。
普通人战斗的目标还是消减对方的血条，让对方血条归零，或者低于自己拖到时间结束。
神已经不满足于这些了，像这种普通攻击模式，神级是不屑于做的，攻击最起码也要是全屏伤害，自身无敌等。
举几个例子：
时间暂停――游戏打一半，突然整个世界清静了，除了释放暂停神技的角色外，一切飞行道具、人物、时间包括背景人物统统被暂停了，然后等时间恢复后，瞬间脸上飞来无数拳脚黑粒子。
开场偷跑――游戏双方还在摆pose的阶段，一方就已经开始各种拳脚飞踹了，这时候甚至举着
round2
的小姐姐都还没走下场。
无敌――你打不到我的脸哟，“无耻”的作者们干脆去掉了自己的人物受击框，脱离了这个次元，比带土的写轮眼可要厉害多了。
回血/
锁血
/空血不死――我站着这里让你打，能打死我算你厉害。
秒杀――游戏一开始，ready go 刚刚喊完，屏幕上紧接着就出现了winner is XXX。游戏时间甚至都没有变，对方的血条就已经归零了。
神级角色
的这些操作已经不是在游戏设定的框架之内进行了，有的通过调取mugen系统自带的一些金手指，比如让自己瞬间满血，对方瞬间死亡等，有的利用游戏规则漏洞，比如无敌、暂停等不一而足。
所以神级人物有人也称之为灯光师。两个神级角色战斗时各种炫酷的技能四处飞射，但是两边要么无敌，要么脱离了这个次元，让对方这些平时能够秒杀纸并凶狂的技能只有一些动画效果，完全没有伤害或者干脆打不到人。
那么什么叫做论外呢？
论外，大概就是讨论的时候要排除在外的意思吧。
为什么要排除在外呢？因为能够驾驭mugen世界规则，乃至篡改规则的神级角色们，也都无法击破论外的防御。
论外采用的技术完全就是黑客手段。
比如直接消去对方PLAYER，架还没打，对手就从这个世界里消失了。
比如直接篡改规则，让游戏宣告自己胜利，或者宣告对方失败。
比如冻结对面，直接让对方无法读取数据，各种神级手段无法施展。
比如让数据溢出，导致对方无法正确读取自己的角色，己方无敌等等。
比如直接修改对方人物数据，把对方神级人物变成一个白板再来和自己单挑。像这种时候，谁能取得胜利已经不是看招式如何了，完全是看谁的程式加载更快，早一步把对方变成白板，就直接在游戏开始前取得了胜利。而且论外最强的地方其实不在于攻击，而是在于防御，论外最强者被拉下马，要么是出现了一位拥有原本“论外最强”都无法击破的防御的人物，要么是出现了一位攻击快过对方的新人物。
像这种修改角色数据、修改
mugen程序
的行为大家还感觉不过瘾的话。隔离作者们还提供卡死mugen、弹网页、篡改BGM、直接让mugen崩溃等选项，绝对能让你体验到一个游戏里的二次元小角色和三次元肥宅战斗的绝望感。
可以说这些游戏角色已经脱离了原有的框架，完全就是一段病毒，像那种借助金手指开挂的，在里面都是相当低端的存在。
贴个论外大佬们的战斗？视频
https://www.bilibili.com/video/av18198813/?spm_id_from=333.788.videocard.4
?
www.bilibili.com/video/av18198813/?spm_id_from=333.788.videocard.4
提问者说的“由计算机运算区分出是否是子弹，及时提醒玩家，或者自动计算躲避路径，并及时躲避，可以扫描出敌方位置以及移动速度，计算弹道什么的”在这些无节操的论外角色面前，可爱的像是一只小绵羊。
提问者的想法限于如何在游戏规则内取得胜利，mugen某些作者已经开始定义规则和掀桌子了。
最后说一点：由于mugen各种技术实在太过复杂，我也仅仅是个偶尔看看视频的爱好者，所以这篇答案里面对于
mugen技术
的说明和人物分析肯定有很多错误，望包涵和指正。","少年，你知道MUGEN神战吗？
为啥随便答一句就被顶起来了真正的圈内大佬的回答却没人看啊……
https://www.
zhihu.com/question/3201
55407/answer/670408638","有这样的游戏，只是没有做成对战类网络游戏。
在大学里，这个游戏叫航模大赛/机器人大赛/算法大赛。
在体育界，这个游戏叫F1。
在网络上，这个游戏叫网络安全。
在市场上，这个游戏叫
程序化交易
。
至于为什么没有面向普通玩家的游戏，这样的设定，与天斗，太容易，与人斗，太难了。","你要知道，这些人开挂，是因为他们太loser
只能在一个公平环境下去用不公平的工具满足于自身产生虚假成就感
真要真刀真枪干外挂服务器
csgo有外挂社区服务器
在那里面，什么锁头穿墙都是弟弟
小陀螺都是垃圾
那里大陀螺是起步，大陀螺不是你转的更快打的更快
大陀螺是能规避子弹的
就像题主说的，比拼算法优劣了
你觉得，公平环境下low到开挂的菜狗，他会编程吗？","那我干嘛不打
codeforces
？
全球同服，万人竞赛。
在线评分，一发入灰。
服务器位于俄罗斯，受俄罗斯法律保护。","要是喜欢编程pk，可以去玩玩Screeps
用JavaScript调教你的AI侵略别人的领土保护自己的领土的游戏
Steam上68，官网上有免费试玩版，没有中文
听说建议先玩玩试玩，因为太硬核了，很可能发现不对自己的胃口
我并没有玩过，因为没学过JS。。。",玩家开挂并不是因为喜欢自己动手做外挂，而是别人没有的超能力但我有，能通过最简单直接的方式大杀四方，享受的是那种高人一等的快感。,"有啊，
mugen
绝对符合你的描述：
mugen是一个格斗游戏引擎。
玩家自己开发角色参战。
最开初大家都尽量还原原作性能。
某一天一个人突发奇想的在某个招式下面加了个这个
[state -2]
type= nohitby
trigger1=1
time=15
这样这个招式就有15帧的无敌时间了。
然后陆陆续续的作者希望自己的角色更强
配合优秀的ai+人物性能
当时的神级，现在的狂级就诞生了。
狂下位的审核：黑鬼（又名
阿卡林
）
高速回血回气，各种广范围的无敌技能，一个秒杀技能。
手操一个强级人物和他打打就知道有多绝望了。
但这并不能满足作者们的欲望。
于是神级，诞生了。
神级的审核五位成员都是常时锁血，常时无敌。一般的技能对他们已经不起作用了。
这时候就必须要借助引擎本身的bug来扣他们的血。
然后各种代码之间的针对与反针对开始了。
某一天，一位作者发现了512内存溢出法可以让对手几乎无任何抵抗方式的被ok。
论外诞生了。
他们的生死和血条已经完全无关了。
他们的攻击手段也和扣血无关了，直接利用内存溢出的方式ok对手。
论外的技术由于过于凶恶，所以称之为“论外”。
发展了这么久，最凶恶的技术有目前四个：
1.极限
卢卡尔
为代表
阻止对面人物加载，替换对面人物文件，普通即死获得胜利
2.文本为代表
修改胜负判定法则，自杀判胜。
3，4，记不得
不过目前貌似还有更加凶恶的：混元魔女。
利用xp系统bug在打开mugen时就造成杀伤，不选人直接获得胜利。
https://www.bilibili.com/video/av2472535?from=search&seid=5169968421813808332
?
www.bilibili.com/video/av2472535?from=search&seid=5169968421813808332","额，据我所知，有人在去年组织了一场“神仙大乱斗”。
是的，绝地求生神仙大乱斗比赛，参赛选手带上各自的挂，看谁能活到最后，在斗鱼直播的好像……
然后比赛被叫停了。
…………………………………分割线…………………………
守望也出地图工坊了，你可以完全自定义除人物模型和地图模型外的任何细节，比如更改技能和触发动作，改变角色在某种地形上的移速，改变弹道速度和命中判定，传送角色，更改物品属性等等……
不知道会不会出一个挂房……","本末倒置了。
游戏的第一要素是好玩，不是防作弊。还是那句话：游戏不是为了防作弊而开发的。
开发者全部精力放在玩法上，也不能保证游戏好玩，怎么会更多关注防作弊呢？
而作弊者，不好玩的游戏他也不会去玩。因为他享受的是相对大部分人的优势。一个人玩作弊缺乏观众。
如果有人费尽心思开发防作弊机制，结果可能是不好玩儿没人玩，作弊机制无用武之地。而游戏好玩，大量玩家涌入，导致需求巨大，再好的防作弊机制也会被破解","这怎么能少了老牌fps游戏，大名鼎鼎的穿越挂线（cross f***，简称cf）呢？
正式服的外挂不能满足题意。基本处于不明显的挂（如透视）大号开着，明目张胆的挂基本是小号的状态。如果是大号明目张胆开挂100%是盗号/借号/租号
但是！
cf还有一个服务器，叫做体验服
当年体验服本意好像是比正式服早更新，用于玩家测试。然而体验服很快外挂横行，也不知官方怎么下了决心，就把体验服变成养挂场所了，在体验服开挂我好像没听说过有处罚。
反正体验服就是个神仙斗法的地方:
进入刀战地图，作为良民入场。刚进场对面就冲过来个玩家，他手上的拳套挥得凶猛，下下似猛虎扑食，却又快若轻鸟舞翅，大有金丹期气势，你就看见个无影爪刚碰到你就横尸了
然后我方一个队友突然大喝一声，震退金丹术士，掏出破天斩魔剑（PS，这武器最早设定名叫玩具大宝剑），然后挥得刀下生风！同时脚法神速，有若
神行太保
，定是元婴强者！
然后他就从我们家走到对面家一遍，把包括那个拳套哥在内的全干趴下了。
结果对面又进来个屠龙哥，他的术法依然是快刀。但恐怖的是他的刀只有起手没有落刀，我连挥刀距离都看不清，只要进入攻击范围就死。
这哥们跟我方元婴大宝剑战了几个来回，互有胜负，看来也是元婴大神。
这边正难舍难分，对面又突入一个身影。只是他一进来就开始翻滚（正常角色被
擎天
打死时的特效“再见兄弟”，会有一个大幅度翻滚，然后这玩家一进来就自己在那翻）
看起来相当厉害啊！完全不知道他的真实位置在哪。犹如轻功高手，身影不定。
结果我方大宝剑冷笑一声，高速再来了个绕场循环，连翻滚哥一并砍倒在地。
好吧，原来是个中看不中用的。
然后对面又进来个屠龙哥，只是……只是我看不到人物模型。恐怕已是出窍分神，实力深不可测！
至于为何我知道是屠龙？因为他站在原地，轻抬宝刀，就能以屠龙索命千里之外。（玩家对这个挂取的外号叫做“小李飞刀”）
不，这可能已经是合体期了！他轻轻松松把我方大宝剑摁在地上摩擦。元婴强者都被打得惨不忍睹。（话说我们这边就大宝剑一个修仙之人，所以其他人完全是任人鱼肉状态）
后来这位强者觉得太无趣，自己跳到地图底下（死亡隧道地图）划水去了。（我下去就看到一片轻刀打水激起的水花犹如水雾一样，他一抬头我就GG了）
这时，一个笑脸兵入场。刚瞥见他的级别（最低级别图标就是个笑脸）就两股战战，要知道，在正服仙家最强战力基本是笑脸兵。
还未等我缓过神来，只见他小刀在空中漫无目的地一划，我们这边全部人应声倒下！
倒在血泊中的我才忽然顿悟了，原来笑脸，是对凡人最大的鄙夷和嘲讽。
（问题是这把怎么挂基本都在对面？）
[以上除艺术加工外全都是我真的见过的外挂]
还有一次是生化模式。一个玩家拿着
生化手雷
无限投掷，而且还在天空飞。跟轰炸机似的，炸的全房都有点卡。
美中不足的是他的飞天挂需要不断按跳跃键，不然会下坠，显得不太美观。
也许这把无敌手，太无聊了，这玩家没有参与下一把。
结果新一轮开始，玩家中一架
空中炮艇
直接起飞，拿着巴雷特，把原本2-3秒一枪的大炮打出了半秒一枪的速度，还不用换子弹。
妥妥空中炮艇，我们所有人都变生化了他还在空中火力压制。而且他的飞天挂是固定高度的，不需要他连续操作。所以他可以专心开炮。
正当我以为又要望洋兴叹的时候，生化群里突然窜出一只刚才还平平无奇的小红，腾空而起，直奔炮艇。
我们麦都兴奋炸了:
“卧槽！神仙对决啊！”“抓他！抓他！”
这小红飞天就是上局那个轰炸机的连续跳跃飞天。虽然慢了点，但却恰恰对固定高度的飞天形成了威胁。
小红从下面一点点扑上去，炮艇的飞天挂改变高度似乎很不连续，所以他只能且战且退。
勉强打死小红一次，击退第一波攻击。
但很快小红复活，继续扑上来。炮艇不就就被贴身击毙了。
后来他两还搞出了飞天终结者对战空中炮艇，飞天终结者对决飞天复仇女神……
反正我们一帮凡人都在地上喊666","允许算法参赛，这种游戏很多啊。只不过，这种所谓提醒玩家的功能其实是完全没有必要的。
因为允许算法的话，所有的事情都可以由算法完成，玩家只需要看就行了。
本质上你想要的所谓掌控一切的感觉，然后却发现在AI面前人类的操作显得那么没有意义，实际上给不会编程的玩家不会带来多少乐趣。
因此这类游戏最终变成了程序员专属，或者至少是对算法感兴趣的玩家专属。也算是某种程度上的策略游戏吧。这对于某些只想要操作取胜，不想要极致策略的玩家来说并不友好。"
,,,,,,,,,,,,,,,,,,,,,
程序员必须掌握哪些算法？,None,"不 BB，直接上干货，非科班出生，毕业工作后才开始学算法，到目前学了 4 年 ！！！
为了让你对数据结构和算法能有个全面的认识，我画了一张图，里面几乎涵盖了所有数据结构和算法书籍中都会讲到的知识点。
这里面有10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
掌握了这些基础的数据结构和算法，再学更加复杂的数据结构和算法，就会非常容易、非常快。
这里也给大家推荐一个特别适合新手免费刷题的网站
算法相关内容非常全面，从基础入门到进阶提升，所有必备知识点都包含了，而且牛客不光是一个刷题网站，还是一个交流学习平台，发个问题总有热心的大佬帮助！
如果觉得不错，别忘了双击点个赞哦。
在这里也送大家一本帮助我拿到BAT 等一线大厂 offer 的算法笔记，是一位阿里大神写的，对于算法薄弱或者需要提高的同学都十分受用，算法一定是计算机学习的重中之重：
貌似手机端打开连接有的会出现问题，可以点击这个总结看看：
这里补充一下，无论是学习算法还是学习编程的任何一个技术点，想要得到提升，最好的一个方法就是去阅读，阅读优秀牛人的分享，目前主流的程序员习惯阅读的博客网站中，掘金社区属于质量不错的一个，内容包括前端、后端、Android、iOS、人工智能等等，各个方向，各个技术点都有，C++程序员需要的知识都能找到。
喜欢在掘金社区阅读的小伙伴可以通过下方链接了解。
1、复杂度分析
看动画轻松理解时间复杂度（一）
看动画轻松理解时间复杂度（二）
冰与火之歌：「时间」与「空间」复杂度
每个程序员都应该收藏的算法复杂度速查表
2、基本算法思想
五分钟了解一下什么是「贪心算法 」
有了四步解题法模板，再也不害怕动态规划！
（进阶版）有了四步解题法模板，再也不害怕动态规划！
（再进阶版）有了四步解题法模板，再也不害怕动态规划！
浅谈什么是分治算法
看动画轻松理解「递归」与「动态规划」
浅谈什么是动态规划以及相关的「股票」算法题
深度解析「正则表达式匹配」：从暴力解法到动态规划
3、排序算法
「多图警告」手撕排序算法 C iOS进阶必备
十大经典排序算法动画与解析，看我就够了！（配代码完全版）
这或许是东半球分析十大排序算法最好的一篇文章
4、搜索
几道和「广度优先搜索」有关的算法面试题
初识广度优先搜索与解题套路
从简单二叉树问题重新来看深度优先搜索
5、查找
二分查找算法详解
一网打尽！二分查找解题模版与题型全面解析
面试官，我会写二分查找法！对，没有 bug 的那种！
6、字符串匹配
动画：BM 算法中的坏字符规则与好后缀规则
动画：七分钟理解什么是KMP算法
动画：什么是 BF 算法 ？
动态规划之 KMP 算法详解（配代码版）
7、线性表
如何高效对有序数组/链表去重？
超详细！详解一道高频算法题：数组中的第 K 个最大元素
一道简单的数组遍历题，加上四个条件后感觉无从下手
数组特性的妙用！如何找到「缺失的第一个正数」
剑指 offer 第一题：二维数组中的查找
动画：什么是单调栈？
在数据结构中穿针引线：链表实现栈和队列
从简单的线性数据结构开始：栈与队列
五分钟学算法小知识：用栈实现队列/用队列实现栈
几道和「堆栈、队列」有关的面试算法题
超详细！图解「合并 K 个排序链表」
动画：面试如何轻松手写链表？
LeetCode 上最难的链表算法题，没有之一！
链表算法面试问题？看我就够了！
看动画轻松理解「链表」实现「LRU缓存淘汰算法」
从简单的线性数据结构开始：穿针引线的链表（一）
在数据结构中穿针引线：链表实现栈和队列
8、散列表
五分钟速读：什么是散列表（哈希表）？
什么是哈希洪水攻击（Hash-Flooding Attack）？
几道和散列（哈希）表有关的面试题
如何判断一个元素在亿级数据中是否存在？
9、树
面试前准备：二叉树高频面试题和答案
懵逼树上懵逼果：学习二分搜索树
LeetCode 二叉树问题小总结
从简单二叉树问题重新来看深度优先搜索
几道和「二叉树」有关的算法面试题
详解什么是平衡二叉树（AVL）（修订补充版）
【面试现场】为什么 MySQL 数据库要用B+树存储索引？
字典树概念与题型解析
面试官：为什么 MySQL 的索引要使用 B+ 树，而不是其它树？比如 B 树？
心里没点 B 树。。。
数据结构与算法――最小生成树
植树节，程序猿种的那些树
数据结构与算法――2-3-4树
数据结构与算法――2-3树
看动画轻松理解「Trie树」
10、图
浅谈什么是图拓扑排序
数据结构与算法――图论基础与图存储结构
数据结构与算法：三十张图弄懂「图的两种遍历方式」
数据结构与算法――图最短路径
总结
学习数据结构和算法的过程，是非常好的思维训练的过程，所以，千万不要被动地记忆，要多辩证地思考，多问为什么。
如果你一直这么坚持做，你会发现，等你学完之后，写代码的时候就会不由自主地考虑到很多性能方面的事情，时间复杂度、空间复杂度非常高的垃圾代码出现的次数就会越来越少。
你的编程内功就真正得到了修炼。
2020 年 01 月 13 日补充：
我再推荐一些算法书籍的选择给大家参考一下。
入门系列
入门的同学，我建议你不要过度追求上去就看经典书。
不要一来就拿着《
算法导论
》开始啃，初学就去啃这些书肯定会很费劲。你一旦啃不下来，挫败感就会很强。
然后就放弃学算法了。
所以，入门的同学，我建议你找一些比较容易看的书来看，比如《大话数据结构》和《
算法图解
》。
不要太在意书写得深浅，重要的是能不能坚持看完。
《大话数据结构》 这本书最大的特点是，它把理论讲得很有趣，不枯燥。而且每个数据结构和算法，作者都结合生活中的例子进行了讲解， 能让你有非常直观的感受。
虽然这本书有 400 多页，但是花两天时间读完，应该是没问题的。
如果你之前完全不懂数据结构和算法，可以先从这本书看起。
《算法图解》 跟《大话数据结构》走的是同样的路线，就像这本书副标题写的那样，“像小说一样有趣的算法入门书”，主打“图解”，通俗易懂。它只有不到 200 页，所以内容比较少。
作为入门，看看这本书，能让你对数据结构和算法有个大概的认识。
当然，这些入门书共同的问题是，缺少细节，不够系统，也不够严谨。
所以，如果你想要系统地学数据结构和算法，看这两本书肯定是不够的。
基础系列
通过基本入门算法书的调教，你已经逐渐体会到了算法的魅力，现在正是时候踏入基础系列算法的领域！！！
这些书籍需要你费点心思去阅读。
很多同学在学习的过程中，看到一篇算法科普文章经常会有这样的想法。
哎呀，要是文章的代码是 Java 语言就好了呀。
哎呀，要是文章的代码是 Python 语言就好了呀。
虽然代码并不会很严重影响阅读，但还是有很多强迫症的同学喜欢看到文章的解释代码是自己擅长的。
我这里推荐《数据结构和算法分析》，这本书非常系统、全面、严谨，而且又不是特别难，适合对数据结构和算法有些了解，并且掌握了至少一门编程语言的同学。而且，这个作者也很用心。
他用了三种语言，写了三个版本，分别是：《
数据结构与算法分析
 ：C 语言描述》《数据结构与算法分析：C++ 描述》《数据结构与算法分析：Java 语言描述》。
面试实战系列
大家都知道，对于程序员来说很大程度上算法就是为了应付面试的。
所以，推荐三本有益于面试的书籍，分别是：《剑指 offer》《
编程珠玑
》《编程之美》。
《剑指 offer》这本书的目的非常明确，就是为了面试。
这本书几乎包含了所有常见的、经典的面试题。如果能搞懂这本书里的内容，应付一般公司的面试应该不成问题。
面试之前也可以去牛客看看笔面经，知己知彼百战不殆！
我做了一个 图解《剑指 offer》的小程序，应该能帮助你学习，感兴趣的可以在微信搜索 图解剑指offer。
我也在 B 站录制了一些图解剑指 offer 的免费视频课程，感兴趣的也可以看看，每个视频控制在5分钟以内。
《编程珠玑》这本书的豆瓣评分非常高，有 9 分。
这本书最大的特色就是讲了很多针对海量数据的处理技巧。这个可能是其他算法书籍很少涉及的。面试的时候，海量数据处理的问题也是经常会问的，特别是校招面试。不管是开拓眼界，还是应付面试，这本书都很值得一看。
《编程之美》这本书有多位作者，其中绝大部分是微软的工程师，所以书的质量很有保证。不过，这里面的算法题目稍微有点难，也不是很系统，这也是我把它归到面试这一部分的原因。如果你有一定基础，也喜欢钻研些算法问题，或者要面试 Google、Facebook 这样的公司，可以拿这本书里的题，先来自测一下。
2020年05月31日补充：数据结构与算法在平时工作中的作用。
正如 
N.Wirth 教授
所说的： 
数据结构+ 算法＝程序
。
遇到一个实际问题，充分利用所学的数据结构，将数据及其之间的关系有效地存储在计算机中，然后选择合适的算法策略，并用程序高效实现。
这句话可能有点抽象，我举个例子给你们解释一下
。
在工作过程中，我们多多少少都接触过 OAuth2 ，在使用 OAuth2 授权的时候，通常应用会弹出一个类似这样的信息：
1) 获取用户基本信息接口
2) 获取用户列表接口
3) 用户分组管理接口
。。。
微信获取授权
思考一下，如果让你设计数据库，应该怎么设计信息存储权限？
如何你熟练掌握了各种数据结构的特点的话，那自然而然想到使用 
bitmap
 来存储权限。
我们把权限划分成最小粒度之后，每一个 bit 都它的含义， 例如我们把权限划分为以下几种：
获取你的头像、性别、昵称等基本用户信息
以你的身份发布微博
获取你的好友列表
获取你的朋友圈信息
每勾选一个选项，就代表着这个权限被授权，为了保证可扩展性，我们使用一个 
uint64
 来保存这些 bit ，也就是说，我们一共可以划分 64 种细分权限，然后对这些权限进行组合。
例如，第一个 bit 如果设置了，那么就代表可以获取你的昵称、头像、地区、性别等基本用户信息， 第二个 bit 如果设置了，就可以用你的身份发状态。
数据结构的实际作用还有挺多，感兴趣的可以搜索以下知识点：
二叉树搜索用于
中断处理
、
登记缓存查找
等
哈希表
，用于实现
索引节点
、
文件系统完整性检查
等
红黑树
用于
调度、虚拟内存管理、跟踪文件描述符和目录条目等
Radix树
，用于内存管理、NFS相关查找和网络相关的功能
......
上面这些例子是关于数据结构的，我再举一个算法的例子，如果有帮助，不妨点个赞收藏一下，好的内容值得肯定。
同样的也来思考一个问题：计算机的缓存容量无论再大，缓存满了还是要删除一些内容，给新内容腾位置。
那么删除哪些内容呢？我们肯定希望删掉哪些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为「有用的」的数据呢？
这个时候采取的策略就是 
LRU 缓存淘汰算法
。
LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。
具体的关于 
LRU 缓存淘汰算法
 的介绍可以看我之前写的一篇文章。
补充：
为了避免知乎大佬觉得我吹逼，先贴一下自己的 GitHub 地址，
目前 70，000 star，全球排名 51 名。
https://
github.com/MisterBooo
算法是一种技能，是可以通过科学合理的方式训练出来的能力。
在想刷题之前，得从心里认识到接受刷题很重要，才能坚持去刷题。
江湖有个传言：
国内刷 LeetCode，最多够你吃 1 年老本；湾区刷 LeetCode ，够你吃 10 年老本了。
为什么湾区的刷题性价比这么高呢？
你想想，电面考 4 道题，一道题值 5 万！单位是 Dollar ！
刷到就是赚到！！
想想是不是很刺激，有没有动力开始刷题了！可以提速刷题了！
就目前互联网的情况来说，无论是面国外大厂还是面国内大厂，如果想换工作都要去刷题，一面二面不丢你几道 Hard 题，都对不住你偷偷摸摸找个会议室假装开会实则面试的鸡贼。
同时，还得认识到一点，
面试能力和你平时的工作能力其实差别挺大的。
有些人技术挺厉害的，但没有刷题，一面二面都过不了，
而某些小镇刷题家，还真就靠刷题拿下了 Google、微软、脸书等大厂offer。
国内大厂也有这种趋势，比如字节，一大半都是面试题。
要不是他提前先看视频刷题，妥妥得凉凉。
所以，刷题很重要。
（PS：感谢大家耐心的阅读，算法是程序员的重中之重，必须攻克，大厂面试必考，顺便送一份阿里大佬刷Leetcode总结的算法笔记，如果你能吃透，那我相信80%的技术面试都会不在话下：
BAT大佬写的Leetcode刷题笔记，看完秒杀80%的算法题！
 这本书的目录，非常经典：
刷题大概可以分为 4 个阶段。
1、纯小白，
不知道怎么刷题，对很多概念都很陌生，各种数据结构和知识点几乎完全不懂，打开 LeetCode 第一题，满头问号。
有人相爱、有人夜里开车看海、有人 LeetCode 第一题都做不出来。
2、算法上基本已经入门，Easy 可以做出来，Medium 纠结半天也能有头绪，但基础不牢，比如字符转字符串还得 Google 一下。
3、刷了几百道题后，总结了自己的解题模板，参加周赛有时候甚至可以全部完成。
4、开始以 beat 100% 作为 AC 的目标了。
就目前的算法面试大环境来说，能达到第二阶段，中小公司可以应付过去了，到达第三阶段，字节、腾讯算法面试环节妥妥没问题了。
怎么样到达第三阶段？
给一下我的一些小建议吧。
1、如果目标是国内大厂，那么一定要刷足够的题，不需要把 LeetCode 上 2500 道算法题都刷完，但至少刷 200 道算法高频题，这些高频题我都写了题解同时也录制了视频，
在这个链接总结了：
https://www.
algomooc.com/1659.html
 
2、面试前一周以看题为主，因为刷题也刷不了几题，多看看自己总结或者别人总结的模板，比如回溯算法模板，掌握后，几十道回溯题都不在话下。
一些模板：
3、刷题过程需要注意难度要循序渐进，算法训练是一个系统工程，需要循序渐进，太过于急功近利，反而容易因做不出难题而产生挫败感，带来反效果。
如果你本身有基础，熟练度高，那你刷简单的 LeetCode 应该是几分钟一题，几分钟一题的，花不了你多少时间。
如果你刷简单都花费很长时间，说明熟练度不够，就更应该从简单开始，然后过度到中等，再过度到困难。
并且，目前国内大厂的算法考察，基本不会超过 LeetCode 中等难度，上限难度基本都是 LeetCode 中等题里面的中等难度，所以不要太去纠结难题怪题偏题。
把高频题掌握就行了：
https://www.
algomooc.com/1659.html
 
再退一步，如果你觉得 LeetCode 的题目太难，可以先从《剑指 Offer》上的算法题开始学起。
为了帮助大家更好的入门学习算法，经过半年的积累，我给大家
卷
了《剑指 Offer》系列的三十道题目，结合动画的形式录制了视频，相信能帮助你更好的刷题。
领取地址：
4、
按算法分类来选题，比如
一个时间段，只刷链表题，刷得差不多的时候，接下来再刷二叉树的题。
这样做有几个很明显的好处。
一、持续地刷同个类型的题目，可以不断地巩固和加深理解，可以总结出自己的思考路径或者解题模板。
比如链表题目，就会去思考虚拟头节点、双指针、快慢指针。
二、可以更全面地接触这个数据结构，算法的各个变种，这会促使你对这个数据结构，算法的理解更加全面和深刻，学习的效率会更高。
我一直认为读书是世界上性价比最高的成长方式，书很便宜但分量很重，是让我们摆脱平庸走向卓越的方式之一。
对于计算机专业的学生而言，读计算机经典书籍不光能让你快速提升知识和能力，更会让你在校招之际如虎添翼。
书籍下载：
计算机必看经典书籍（含下载方式）
最后，再给大家送上点干货！
下面这是一个
高赞回答合集
，建议大家
点赞&收藏
，Mark住别丢了，
大学期间绝对用得上
。
1、怎么学好数据结构，看下面这个回答，已经获得了 
21000+ 的赞和 50000+的收藏。
2、如何系统地学习算法，看下面这个回答，已经获得了 
11000+ 的赞和 26000+的收藏。
3、新手该如何使用 GitHub，看下面这个回答，如果在大学期间就知道使用 GitHub ，那么能力远超同龄人。
4、想成为一名优秀的程序员，那么这些程序员平时都喜欢逛的论坛怎么说你也得收藏一些吧。
5、无论别人怎么说，我都是坚定不移的选择计算机专业。
6、如何系统地学习 C++ ，这个回答能帮你找到路线。
7、想要准备 Java 面试，那么这些面试题必须掌握。
赶紧点赞和收藏吧~","程序员必须掌握的常用算法正如 
@力扣（LeetCode）
所讲，主要包括以下内容：
算法：
1、排序算法：
快速排序
、归并排序、计数排序
2、搜索算法：回溯、递归、剪枝
3、图论：最短路径、
最小生成树
、网络流建模
4、动态规划：
背包问题
、最长子序列、计数问题
5、基础技巧：分治、倍增、二分法、
贪心算法
数据结构：
1、数组和链表
2、栈与队列
3、树和图
4、哈希表
5、大/小跟堆，可并堆
6、字符串：
字典树
、后缀树
还可以在此基础上细分，例如单单排序算法就可以分为以下十种：
对于学习算法，我推荐在力扣上刷题：
此外，推荐一个用动画的形式演示 LeetCode 上的题目的项目：
例如基础的
冒泡排序法
演示如下：
选择排序法：
插入排序法：
希尔排序法
：
归并排序法：
快速排序法：
堆排序：
计数排序：
桶排序：
基数排序
：
该项目正在完善中，已经用动画的形式演示出了一下题目：
因为知乎排版没有表格，所以我就截图了，以上内容详见：
此外，再推荐一些免费的学习资源：
在学习的时候，要想为什么要这样设计，优点在哪里，有什么改进方法，逐步通过这样的方式提升逻辑思维能力。不懂就查，找学习资料和相关解答，坚持学习。
1. 算法学习 LintCode：
https://www.
lintcode.com/
算法学习网站，上去每天刷两道算法题，走遍天下都不怕。
2. 算法学习 LeetCode：
https://
leetcode.com/
也是算法题网站，同上。
3. 算法学习 LeetCode 中文站：
https://
leetcode-cn.com/
这个是上面算法题网站的中文站点，英文不好的可以刷这个，英文好的推荐去刷英文网站的题目，还能提升英语能力。
4. 中国大学MOOC网：
https://www.
icourse163.org/
中国大学MOOC是由网易与高教社携手推出的在线教育平台，承接教育部
国家精品开放课程
任务，向大众提供中国知名高校的MOOC课程。在这里，每一个有意愿提升自己的人都可以免费获得更优质的高等教育。
我是程序员客栈，中国领先的程序员自由工作平台，技术新人力解决方案
。","大学四年，算法是我非常注重学习的一门知识
。下面是我觉得值得学习的一些算法以及数据结构，当然，
并且我也整理一些看过不错的文章给大家，
大家也可以留言区补充。如果觉得不错，别忘了点个赞哦。先上图，后详细解说
----------------2021.9.1更新--------------
另外，这里有个可以白嫖的项目，推荐给大家
一、算法最最基础
1、时间复杂度
2、空间复杂度
一般最先接触的就是时间复杂度和空间复杂度的学习了，这两个概念以及如何计算，是必须学的，也是必须最先学的，主要有最大复杂度、平均复杂度等，直接通过博客搜索学习即可。
文章推荐：
算法分析神器―时间复杂度
二、基础数据结构
1、线性表
列表（必学）
链表（必学）
跳跃表（知道原理，应用，最后自己实现一遍）
并查集（建议结合刷题学习）
不用说，链表、列表必须，不过重点是链表。
三分钟基础数据结构：如何轻松手写链表？
以后有面试官问你「跳跃表」，你就把这篇文章扔给他
2、栈与队列
栈（必学）
队列（必学）
优先队列、堆（必学）
多级反馈队列（原理与应用）
特别是优先队列，再刷题的时候，还是经常用到的，队列与栈，是最基本的数据结构，必学。可以通过
博客来
学习。相关文章：
三分钟基础知识：什么是栈？
二叉堆是什么鬼？
【算法与数据结构】堆排序是什么鬼？
学习算法的过程中，有业余时间也可以学一学项目，毕竟很多算法最终都落地到项目上滴，这里给大家推荐一个
3、哈希表
（必学）
碰撞解决方法：开放定址法、
链地址法
、再次哈希法、建立公共溢出区（必学）
布隆过滤器
（原理与应用）
哈希表相关的，推荐通过博客来学习，推荐文章：
Hash冲突之开放地址法
4、树
二叉树：各种遍历（递归与非递归）（必学）
哈夫曼树
与编码（原理与应用）
AVL树（必学）
B 树
与 B+ 树（原理与应用）
前缀树
（原理与应用）
红黑树（原理与应用）
线段树
（原理与应用）
树相关是知识还是挺多的，建议看书，可以看《算法第四版》。相关文章：
高频面试题：什么是B树？为啥文件索引要用B树而不用二叉查找树？
【漫画】以后在有面试官问你AVL树，你就把这篇文章扔给他。
腾讯面试题：有了二叉查找树、平衡树为啥还需要红黑树？
【面试被虐】游戏中的敏感词过滤是如何实现的？
5、数组
树状数组
矩阵（必学）
树状数组其实我也没学过，，，，
这里给大家推荐一份刷题笔记，里面把各种算法题型以及经验都总结了，把这份笔记突击学习一下，很多算法考察，基本都稳了，给大家看一下目录
下载链接：
三、各种常见算法
1、十大排序算法
简单排序：插入排序、选择排序、冒泡排序（必学）
分治排序：
快速排序
、
归并排序
（必学，快速排序还要关注中轴的选取方式）
分配排序：
桶排序
、基数排序
树状排序：堆排序（必学）
其他：计数排序（必学）、
希尔排序
对于十大算法的学习，假如你不大懂的话，那么我还是挺推荐你去看书的，因为看了书，你可能不仅仅知道这个算法怎么写，还能知道他是怎么来的。推荐书籍是《算法第四版》，这本书讲的很详细，而且配了很多图演示，还是挺好懂的。
推荐文章：
必学十大经典排序算法，看这篇就够了(附完整代码/动图/优质文章)(修订版)
2、
图论算法
图的表示：邻接矩阵和邻接表
遍历算法
：深度搜索和广度搜索(必学)
最短路径算法
：Floyd，Dijkstra（必学）
最小生成树
算法：Prim，Kruskal（必学）
实际常用算法：关键路径、
拓扑排序
（原理与应用）
二分图匹配：配对、匈牙利算法（原理与应用）
拓展：中心性算法、
社区发现算法
（原理与应用）
图还是比较难的，不过我觉得图涉及到的挺多算法都是挺实用的，例如最短路径的计算等，图相关的，我这里还是建议看书的，可以看《
算法第四版
》。
漫画：什么是 “图”？（修订版）
漫画：深度优先遍历 和 广度优先遍历
漫画：图的 “最短路径” 问题
漫画：Dijkstra 算法的优化
漫画：图的 “多源” 最短路径
3、搜索与回溯算法
贪心算法（必学）
启发式搜索算法
：A*寻路算法（了解）
地图着色算法
、N 皇后问题、最优加工顺序
旅行商问题
这方便的只是都是一些算法相关的，我觉得如果可以，都学一下。像贪心算法的思想，就必须学的了。建议通过刷题来学习，leetcode 直接专题刷。
4、动态规划
树形DP：01背包问题
线性DP：
最长公共子序列
、最长公共子串
区间DP：矩阵最大值（和以及积）
数位DP：数字游戏
状态压缩DP：旅行商
我觉得动态规划是最难的一个算法思想了，记得当初第一次接触动态规划的时候，是看01背包问题的，看了好久都不大懂，懵懵懂懂，后面懂了基本思想，可是做题下不了手，但是看的懂答案。一气之下，再leetcdoe专题连续刷了几十道，才掌握了动态规划的
套路
，也有了自己的一套模板。不过说实话，动态规划，是考的真他妈多，学习算法、刷题，一定要掌握。这里建议先了解动态规划是什么，之后 leetcode 专题刷，反正就一般上面这几种题型。后面有时间，我也写一下我学到的
套路
，有点类似于我之前写的递归那样，算是一种经验。也就是我做题时的模板，不过感觉得写七八个小时，，，，，有时间就写。之前写的递归文章：
为什么你学不会递归？告别递归，谈谈我的一些经验
5、字符匹配算法
正则表达式
模式匹配：KMP、Boyer-Moore
我写过两篇字符串匹配的文章，感觉还不错，看了这两篇文章，我觉得你就差不多懂 
kmp
 和 Boyer-Moore 了。
字符串匹配Boyer-Moore算法：文本编辑器中的查找功能是如何实现的？
6、流相关算法
最大流：最短增广路、
Dinic 算法
最大流
最小割
：最大收益问题、方格取数问题
最小费用最大流
：最小费用路、消遣
这方面的一些算法，我也只了解过一些，感兴趣的可以学习下。
最后，给大家推挤个项目，以防不备之需
总结
对于上面设计到的算法，我都提供了感觉还不错的文章，建议大家收藏，然后可以利用零碎的时间进行阅读，有些人可能会觉得上面的算法太多，说实话，我觉得不多，特别是对于在校生的，上面涉及到的算法可以不用很懂，但至少得了解。至于书籍的话，如果你连基本数据结构都还不懂的，建议看《
数据结构与算法
》相关书籍，例如《大话数据结构》、《
数据结构与算法分析
》。如果你有一定的基础，例如知道链表，栈，队列，那么可以看《算法第四版》，不过这本书是用 Java 实现的，不过我觉得你只要学过 C，那么可以看的懂。
这些算法的学习，虽然你觉得学了没有什么用，但还是那些话，它对你的影响是潜意识的，它可以给你打下很深厚的基础内功，如果你想走的更远，那么我推荐学习，标注
必学
的，那么我觉得，你是真的需要抽时间来学习下，标注
原理与应用
的，代表你可以不知道怎么用代码实现，但是必得知道它的实现原理以及应用。
算法的学习没有太多捷径，离不开刷题，刷多了就会有感觉了，这里再给大家推荐一份某大佬的 leetcode 刷题笔记，汇聚了上千道 leetcode 题解，并且代码都是 beat 100%：下载链接：
cookbook.zip - 蓝奏云
?
wws.lanzoui.com/irsUMk93i1g
----------------2021.9.1更新--------------
这里有个可以白嫖的项目，推荐给大家","更新：
有很多朋友私信问我Python学习有没有什么好的资料，我给大家找了几门不错的免费课，想学的可以看看。
《Python入门教程》
《Python初级入门精讲》
《Python爬虫开发》
《Python实战编程》
《1小时掌握Python爬虫+高效学习法则》
原回答：
【收藏是点赞的4倍，你们是要闹哪样！】
程序员必须要掌握的十大经典算法
算法一：
快速排序算法
快速排序是由东尼・霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。
快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。
算法步骤：
1 从数列中挑出一个元素，称为 “基准”（pivot），
2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
算法二：堆排序算法
堆排序
（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似
完全二叉树
的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
堆排序的平均时间复杂度为Ο(nlogn) 。
算法步骤：
创建一个堆H[0..n-1]
把堆首（最大值）和堆尾互换
3. 把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置
4. 重复步骤2，直到堆的尺寸为1
算法三：
归并排序
归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
算法步骤：
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针达到序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾
算法四：
二分查找算法
二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。
搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜 素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组 为空，则代表找不到。
这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。
算法五：BFPRT(线性查找算法)
BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分 析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂 度，五位算法作者做了精妙的处理。
算法步骤：
1. 将n个元素每5个一组，分成n/5(上界)组。
2. 取出每一组的中位数，任意排序方法，比如插入排序。
3. 递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。
4. 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。
5. 若i==k，返回x；若i<k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k小的元素。
终止条件：n=1时，返回的即是i小元素。
算法六：DFS（深度优先搜索）
深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分 支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发 现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。
深度优先搜索是图论中的经典算法，利用
深度优先搜索
算法可以产生目标图的相应
拓扑排序
表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。
深度优先遍历图算法步骤：
1. 访问顶点v；
2. 依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；
3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。
上述描述可能比较抽象，举个实例：
DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。
接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。
算法七：BFS(广度优先搜索)
广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。
算法步骤：
1. 首先将根节点放入队列中。
2. 从队列中取出第一个节点，并检验它是否为目标。
如果找到目标，则结束搜寻并回传结果。
否则将它所有尚未检验过的直接子节点加入队列中。
3. 若队列为空，表示整张图都检查过了――亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。
4. 重复步骤2。
算法八：Dijkstra算法
戴克斯特拉算法
（Dijkstra’s algorithm）是由荷兰计算机科学家
艾兹赫尔・戴克斯特拉
提出。
迪科斯彻
算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。
该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra算法是目前已知的最快的单源
最短路径算法
。
算法步骤：
1. 初始时令 S={V0},T={其余顶点}，T中顶点对应的距离值
若存在<v0,vi>，d(V0,Vi)为<v0,vi>弧上的权值
若不存在<v0,vi>，d(V0,Vi)为∞
2. 从T中选取一个其距离值为最小的顶点W且不在S中，加入S
3. 对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值
重复上述步骤2、3，直到S中包含所有顶点，即W=Vi为止
算法九：动态规划算法
动态规划（Dynamic programming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。
动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多 子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个 子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。
关于动态规划最经典的问题当属
背包问题
。
算法步骤：
1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
2. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。 动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是 在表格中简单地查看一下结果，从而获得较高的效率。
算法十：朴素贝叶斯分类算法
朴素贝叶斯分类算法
是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下， 如何完成推理和决策任务。概率推理是与确定性推理相对应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其他特征都不相关。
朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获取得非常好的分类效果。在许多实际应用中，朴素贝叶斯模型参数估计使用
最大似然估计
方法，换言之
朴素贝叶斯模型
能工作并没有用到贝叶斯概率或者任何贝叶斯模型。
_________________________________________________________________________________________
公号：聊聊Python，感兴趣的可以来找我玩，一起来聊聊Python这点事~
作者：lxlmycsdnfree
链接：
https://
blog.csdn.net/lxlmycsdn
free/article/details/78881146
希望能对你有用","我来缅怀一下当年OI和ACM的日子……题目都在 
Welcome To PKU JudgeOnline
 上。
初期（校赛及省赛水题难度）:
一.基本算法:

枚举. (poj1753,poj2965)

贪心(poj1328,poj2109,poj2586)

递归和分治法.

递推.

构造法.(poj3295)

模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)

二.
图算法
:
图的深度优先遍历和广度优先遍历.

最短路径算法
(dijkstra,bellman-ford,floyd,heap+dijkstra) 
(poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)
最小生成树
算法(prim,kruskal) 
(poj1789,poj2485,poj1258,poj3026)
拓扑排序
 (poj1094)

二分图的最大匹配 (
匈牙利算法
) (poj3041,poj3020)

最大流的增广路算法(KM算法). (poj1459,poj3436)

三.数据结构.
串 (poj1035,poj3080,poj1936)

排序(快排、归并排(与
逆序数
有关)、堆排) (poj2388,poj2299)

简单
并查集
的应用.

哈希表和二分查找等高效查找法(数的Hash,串的Hash) 
(poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)
哈夫曼树
(poj3253)

堆

trie树
(静态建树、动态建树) (poj2513)

四.简单搜索
深度优先搜索
 (poj2488,poj3083,poj3009,poj1321,poj2251)

广度优先搜索
(poj3278,poj1426,poj3126,poj3087.poj3414)

简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)

五.动态规划
背包问题
. (poj1837,poj1276)

型如下表的简单DP(可参考lrj的书 page149):
E[j]=opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533)
E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (
最长公共子序列
) (poj3176,poj1080,poj1159)
C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)
六.数学
组合数学:
1.
加法原理
和乘法原理.
2.排列组合.
3.递推关系.
(POJ3252,poj1850,poj1019,poj1942)
数论.
1.素数与整除问题
2.进制位.
3.同余模运算.
(poj2635, poj3292,poj1845,poj2115)
计算方法.
1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)
七.计算几何学.
几何公式.

叉积
和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)

多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)
(poj1408,poj1584)
凸包. (poj2187,poj1113)

中级（校赛压轴及省赛中等难度）:

一.基本算法:

C++的标准模版库的应用. (poj3096,poj3007)

较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)

二.图算法:
差分约束系统的建立和求解. (poj1201,poj2983)

最小费用最大流
(poj2516,poj2516,poj2195)

双连通分量
(poj2942)

强连通分支及其缩点.(poj2186)

图的
割边
和割点(poj3352)

最小割
模型、网络流规约(poj3308)

三.数据结构.
线段树
. (poj2528,poj2828,poj2777,poj2886,poj2750)

静态二叉检索树. (poj2482,poj2352)

树状树组(poj1195,poj3321)

RMQ. (poj3264,poj3368)

并查集的高级应用. (poj1703,2492)

KMP算法. (poj1961,poj2406)

四.搜索
最优化剪枝和可行性剪枝

搜索的技巧和优化 (poj3411,poj1724)

记忆化搜索
(poj3373,poj1691)

五.动态规划
较为复杂的动态规划(如动态规划解特别的旅行商TSP问题等)
(poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)
记录状态的动态规划. (POJ3254,poj2411,poj1185)

树型动态规划(poj2057,poj1947,poj2486,poj3140)

六.数学
组合数学:
1.容斥原理.
2.
抽屉原理
.
3.
置换群
与Polya定理(poj1286,poj2409,poj3270,poj1026).
4.递推关系和母函数.
数学.
1.
高斯消元法
(poj2947,poj1487, poj2065,poj1166,poj1222)
2.概率问题. (poj3071,poj3440)
3.GCD、扩展的欧几里德(
中国剩余定理
) (poj3101)
计算方法.
1.0/1分数规划. (poj2976)
2.三分法求解单峰(单谷)的极值.
3.矩阵法(poj3150,poj3422,poj3070)
4.迭代逼近(poj3301)
随机化算法(poj3318,poj2454)
杂题(poj1870,poj3296,poj3286,poj1095)
七.计算几何学.
坐标离散化.

扫描线算法
(例如求矩形的面积和周长并,常和线段树或堆一起使用)
(poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)
多边形的内核(半平面交)(poj3130,poj3335)

几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429)

高级（regional中等难度）:

一.基本算法要求: 

代码快速写成,精简但不失风格 

(poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)

保证正确性和高效性. poj3434

二.图算法:
度限制最小生成树和第K最短路. (poj1639)

最短路,最小生成树,二分图,
最大流问题
的相关理论(主要是模型建立和求解)
(poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446
最优比率生成树. (poj2728)

最小树形图
(poj3164)

次小生成树.

无向图、有向图的最小环 

三.数据结构. 
trie图的建立和应用. (poj2778)

LCA和RMQ问题(LCA(
最近公共祖先
问题) 有离线算法(并查集+dfs) 和 
在线算法
(RMQ+dfs)).(poj1330)
双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的目的). (poj2823)
左偏树(可合并堆). 

后缀树(非常有用的数据结构,也是赛区考题的热点).(poj3415,poj3294)
四.搜索 
较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)

广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A*算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)

深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA*算法. (poj3131,poj2870,poj2286)

五.动态规划 
需要用数据结构优化的动态规划.(poj2754,poj3378,poj3017)
四边形不等式理论.

较难的状态DP(poj3133)

六.数学 
组合数学.
1.MoBius反演(poj2888,poj2154)
2.偏序关系理论.
博奕论.
1.极大极小过程(poj3317,poj1085)
2.Nim问题.
七.计算几何学. 
半平面求交(poj3384,poj2540)

可视图的建立(poj2966)

点集
最小圆覆盖
.

对踵点(poj2079)

八.综合题.
      (poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263)
=====================================================================
扯点建议：
如果你不是要死磕acm搞出成绩来的话，多放点心思在数据结构上对以后的帮助会比较大，比如字符串相关的
字典树
、哈希、自动机、后缀树等等，而对脑力要求较高的比如博弈论和各种花式动态规划（树型DP、集合DP、插头DP等等）就不用太关心了。
btw这些算法和数据结构如果能精通的话，对你以后做数据挖掘和机器学习是有极大帮助的。
广告时间：如果你对以上学习路径有什么困惑，或者你对以下问题感兴趣：

＊ 为什么面试官都喜欢考程序员基础算法？

＊ 如何高效、系统性地学习算法和数据结构？

＊ 为什么大家普遍觉得动态规划较难理解？

＊ 学算法是否有必要参加 OI / ACM 等算法编程竞赛？

＊ 如何平衡自己在算法、竞赛上和其它方面学习的精力投入？

＊ 学习传统算法对日后工作的帮助具体有多大？

＊ 学习传统算法对学习机器学习的帮助具体有多大？

那么欢迎来到我的知乎 Live：
SimonS 的知乎 Live - 如何快速攻克传统算法和数据结构
SimonS 的知乎 Live - 如何成为当下合格的算法工程师
SimonS 的知乎 Live - 机器学习入门需要哪些数学基础","刷了小400道Leetcode，总结了如下知识点（文末可下载笔记）：
上述都是程序员面试的高频考点，想要彻底掌握的话，
一定要有体系地去刷
，以
深度优先遍历
的方法循序渐进的实战，让自己把每个知识点彻底挖透记牢。推荐大家用Leetcode官方出品的免费教程 
Leetbook
，按照各个知识点循序渐进地罗列了算法题。
推荐的学习顺序：
复杂度分析、数组、栈、队列、链表、
哈希表
、二叉树、堆、Trie树、并查集、图
递归
、查找、排序、查、字符串匹配、动态规划
Leetbook的好处是把算法归类为各个章节，而且大部分章节都是免费的。如上图，在入门的时候就不要刷那种高频面试题了，先把数据结构和算法的各个基础打好。每个 book 里都是先教学、再由易到难地实战，一个知识点大概有十几道题，刷完基本上就能掌握一些套路，到medium的水平了。
然后才是去看各种
面经
和高频题，给自己查漏补缺，并且
要稍微记录一下，几行代码或者解题思路，方便自己快速复习
。
这里再给大家分享一些资料，都是刷题福音：
下面是我总结的一些必刷算法（字母是难度），部分解法在文末的脑图中，可以直接下载。
栈
155. 最小栈 E
85. 最大矩形 H
链表
206. 反转链表 E
160. 相交链表 E
876. 链表的中间结点 E
21. 合并两个有序链表 E
, 
23. 合并K个升序链表 H
141. 环形链表 E
, 
142. 环形链表 II M
19. 删除链表的倒数第 N 个结点 M
287. 寻找重复数 M
146. LRU 缓存机制 M
并查集
200. 岛屿数量 M
字节跳动大闯关
树
二叉树
二叉树前序/中序/
后序遍历
112. 路径总和 E
, 
113. 路径总和 II M
, 
437. 路径总和 III M
236. 二叉树的最近公共祖先 M
958. 二叉树的完全性检验 M
124. 二叉树中的最大路径和 H
平衡二叉树
基本原理和操作
为什么有了BST和AVL还需要
红黑树
完全二叉树
完全二叉树的插入
222. 完全二叉树的节点个数 M
哈希表
剑指 Offer 48. 最长不含重复字符的子字符串 M
前缀和+哈希表
560. 和为K的子数组 M
523. 连续的子数组和 M
查找
二分查找
bug-free写法：左闭右开，先写排除中位数的逻辑
189. 旋转数组 M
, 
153. 寻找旋转排序数组中的最小值 M
, 
154. 寻找旋转排序数组中的最小值 II H
162. 寻找峰值 M
287. 寻找重复数 M
4. 寻找两个正序数组的中位数 H
668. 乘法表中第k小的数 H
719. 找出第 k 小的距离对 H
793. 阶乘函数后K个零 H
BFS
抖音红人
1293. 网格中的最短路径 H
854. 相似度为 K 的字符串 H
DFS
抖音红人
200. 岛屿数量 M
面试题 08.12. 八皇后 H
46. 全排列 M
, 
47. 全排列 II M
93. 复原IP地址 M
双指针
1. 两数之和 E
数组中两数相减的最大值
滑动窗口
560. 和为K的子数组 M
713. 乘积小于K的子数组 M
76. 最小覆盖子串 H
排序
插入：插入排序, 
选择排序
选择：选择排序, 堆排
交换：
冒泡排序
, 
快速排序
, 快排优化
归并排序
, 原地归并, 
剑指 Offer 51. 数组中的逆序对 H
, 
327. 区间和的个数 H
基数排序
148. 排序链表 M
拓扑排序
字典序
31. 下一个排列 M
386. 字典序排数 M
440. 字典序的第K小数字 H
1163. 按字典序排在最后的子串 H
TopK问题
剑指 Offer 40. 最小的k个数 E
347. 前 K 个高频元素 M
373. 查找和最小的K对数字 M
402. 移掉K位数字 M
动态规划
72. 编辑距离 H
516. 最长回文子序列 M
, 
5. 最长回文子串 M
1143. 最长公共子序列 M
300. 最长递增子序列 M
53. 最大子序和 E
背包问题
最短路径：Dijkstra, Floyd, Bellmanford, Johnson
121. 买卖股票的最佳时机 E
, 
122. 买卖股票的最佳时机 II E
, 
123. 买卖股票的最佳时机 III H
, 
188. 买卖股票的最佳时机 IV H
模式匹配
单模式单匹配：KMP
多模式单匹配：Trie
多模式多匹配：AC自动机
大数据
蓄水池抽样法
---
当然，
除了勤奋地刷题之外，一定要多学习大佬们的思路，掌握最优的解法
。这里离不开一些开源笔记的帮助：
一位CMU硕士整理的101道经典题型，按体系归好类了，初学者可以先跟着走一遍（文末下载）：
还有LeetCode Cookbook对1479道题都给了思路和解法、复杂度分析（文末下载）：
上面的资料都帮大家整理好啦，记得帮 
@李rumor
 
点个赞再去下载呀～","力扣 (LeetCode)
 作为全球极客挚爱的技术成长平台，致力于为同学们面试、求职提供帮助。
 向下阅读的同学一定要注意，下方 
图片可能会带来不适
，有
密集恐惧症
的小伙伴们请建议迅速划过。
在这里，力扣君也为大家整理了一些程序员在 
面试中
 需要掌握的算法，熟练掌握它们可以帮你在面试中如虎添翼，百战百胜。
现在 ChatGPT 风靡全球，AI 的概念离不开算法，学习算法更为重要
算法 - Algorithms
排序算法：
快速排序
、归并排序、计数排序
搜索算法：回溯、递归、剪枝技巧
图论：最短路、
最小生成树
、
网络流
建模
动态规划：
背包问题
、最长子序列、计数问题
基础技巧：分治、倍增、二分、贪心
数据结构 - Data Structures
数组与链表：单 / 
双向链表
、跳舞链
栈与队列
树与图：
最近公共祖先
、并查集
哈希表
堆：大 / 小根堆、可并堆
字符串：
字典树
、
后缀树
在 
互联网公司最常见的面试算法题有哪些？
 问题下的回答中，力扣君更加详细地整理了一些面试常见的算法并且对每种算法罗列了很多题目，在此就不赘述了，感兴趣的同学可以点击链接了解更多内容。
如果不谈面试的需求，对于程序员来说上面提到的那些算法依然非常重要，可以说上述内容都是
作为一个程序员必须掌握的算法
。
有人可能会觉得，这些基础的算法在工作中完全用不到，安安静静地做一个 
CRUD Boy
 多好。
其实不然，虽然同是程序员，程序员之间也是可以分出个三六九等的。
一名出色的程序员一定是熟练掌握各种算法的。
扎实地理解与掌握这些基础算法，能帮助你收获更强的竞争力，在自己的岗位上快速晋升。
那熟练掌握这些算法，到底可以为身为程序员的我们带来什么呢？
提升代码效率
比如，现在让你实现这样一个功能：给你一些有序的数字，动态地查找目标数字。实现这一功能的方法有很多种，当面临不同情况的时候，我们需要使用不同的方法。
查找频率很低时，对于每一次查询，暴力从前向后遍历，每次查询的复杂度为 
O(N)
，能解决问题。
当查找频率很高时，对有序数字使用
二分查找
，每次查询复杂度为 
O(logN)
。或者使用哈希表，每次查询的复杂度为 
O(1)
。
如果数字非常多存不进内存里，可以使用 
B树
 的思路来优化查询。
当引入密集的插入操作，查询不太密集的时候，可以使用 
LSM树
 的思想完成这一功能。
如果你熟知各种基础算法，那么你就可以很容易地针对不同的场景找到合适的解决方案，并且将它们变成代码，以提升程序的效率。而不是遇事不决，先上暴力，虽然解决了问题，但是在时间与空间上还有很多不足。
提升能力、借鉴思路、获得启发
通过学习这些算法，可以提升我们在计算机方面的能力：抽象建模能力、逻辑思维能力等，并且积累一些解决问题的基本思路：折半、倍增、贪心、分治等。
现实中的问题都大相径庭，但是我们通过将其抽象并建模之后，会发现问题的本质是相似的，我们往往可能从某一个基础算法中获得启发，从而高效地解决问题。而达到这一境界，就要求我们首先对基础算法能非常了解，并达到熟练运用，融会贯通的地步。
所以，即使过了公司面试这一关，算法对于程序员来说依然是非常重要的。熟练掌握算法，将是你职场晋升路上的一把利刃。还是那句话，奔着求职、面试、晋升的小伙伴，刷 
力扣
 拿到你的 Dream Offer，走向人生巅峰！
下面给大家推荐几个算法学习的网站：
对于算法的学习的平台，只要关注以下三个维度来进行选择：
第一、能够学习算法的原理，在动态规划之后的很多算法，都需要花时间去理解，需要有一个学习的过程。所以，学习算法的过程无论是边学边做还是简单的学习，最好可以附带一定的教学功能。
第二、可以对算法进行练习的在线测评系统 (OnlineJudge)。如何选择一个适合自己的 OJ 去练习？力扣君认为首先要看其支持的语言种类与检索功能，另外是否有定期的原创题目，原创比赛。是的，原创非常重要！（敲小黑板咯！）
第三、针对第二点，明确进行算法练习的目的，单纯为了提升算法能力还是在提升的同时也想为自己的技术面试做准备。
一、
力扣 (LeetCode)
集教学与和练习与一体
力扣的 
探索卡片
 针对每一种算法都有详细的教学和习题，非常适合初学者来进行练习。
技术面试必备刷题平台
拥有上千道原创算法题的 
力扣题库
，国内外不少知名 IT 公司技术面试时的首选题库。如果你正在准备技术面试，来力扣刷题肯定没错。
活跃的社区
在力扣 
题解
 版块发起对一道题的讨论，如果你没有好的解题思路，可以和其他小伙伴一起学习交流。
每周一次的原创竞赛题
参加每周一次的 
力扣周赛
，你可以通过周赛来赢取力扣积分兑换相应奖励，如果时间没有那么充裕，也可以参加力扣的虚拟竞赛。力扣的竞赛题更偏求职风格，比赛过程中错误的数据会显示出来以方便选手调式，对多数程序员来说可以说相当友好啦！
二、Github （
https://github.com
)
Github 除了
开源项目
以外，也有一些大型的学习算法的项目。比如：
著名的算法可视化项目
https://
github.com/algorithm-vi
sualizer/algorithm-visualizer
其中将许多著名的算法都做了可编辑的动画，对于后期理解图论等相关算法有很大帮助。
基于 Python 的算法合集
https://
github.com/qiwsir/algor
ithm
亮点是这个项目是中文的，算法由浅入深，相对适合从零开始学算法的。
三、Topcoder（
http://topcoder.com
)
想挑战自我？可以试下 TopCoder 
参加过 TopCoder 比赛的童鞋可能会对它印象深刻，它有它独特的魅力。TopCoder 没有测试用例，在比赛中，完成代码后可以去直接阅读别人的算法，并构造错误用例来为对方扣分。
可以说 TopCoder 很适合学有所成的人去寻找下刺激，不过建议有一定的刷题基础再进行尝试。
四、Coursera（
Coursera | Online Courses & Credentials by Top Educators. Join for Free
）
Coursera 上有各所大学的算法课程。有很多都是世界顶尖的算法课，有兴趣学习的程序员也可以不妨前去一试。
关注力扣官方微信公众号：「
LeetCode力扣
」，更多关于程序员面试、技术干货的内容等你来啃！","十大经典排序算法最强总结（含Java代码实现）
0、排序算法说明
0.1 排序的定义
对一序列对象根据某个关键字进行排序。
0.2 术语说明
稳定
：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
不稳定
：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
内排序
：所有排序操作都在内存中完成；
外排序
：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
时间复杂度：
 一个算法执行所耗费的时间。
空间复杂度
：运行完一个程序所需内存的大小。
0.3 算法总结
图片名词解释：
n: 数据规模
k: “桶”的个数
In-place: 占用常数内存，不占用额外内存
Out-place: 占用额外内存
0.4 算法分类
0.5 比较和非比较的区别
常见的
快速排序、归并排序、
堆排序
、冒泡排序
等属于
比较排序
。
在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。
在
冒泡排序
之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n2)。在
归并排序、快速排序
之类的排序中，问题规模通过
分治法
消减为logN次，所以时间复杂度平均
O(nlogn)
。
比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，
比较排序适用于一切需要排序的情况。
计数排序、基数排序、桶排序
则属于
非比较排序
。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。
非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度
O(n)
。
非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。
1、冒泡排序（Bubble Sort）
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 
1.1 算法描述
比较相邻的元素。如果第一个比第二个大，就交换它们两个；
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
针对所有的元素重复以上的步骤，除了最后一个；
重复步骤1~3，直到排序完成。
1.2 动图演示
1.3 代码实现
/**

     * 冒泡排序

     *

     * @param array

     * @return

     */

    
public
 
static
 
int
[]
 
bubbleSort
(
int
[]
 
array
)
 
{

        
if
 
(
array
.
length
 
==
 
0
)

            
return
 
array
;

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
array
.
length
;
 
i
++)

            
for
 
(
int
 
j
 
=
 
0
;
 
j
 
<
 
array
.
length
 
-
 
1
 
-
 
i
;
 
j
++)

                
if
 
(
array
[
j
 
+
 
1
]
 
<
 
array
[
j
])
 
{

                    
int
 
temp
 
=
 
array
[
j
 
+
 
1
];

                    
array
[
j
 
+
 
1
]
 
=
 
array
[
j
];

                    
array
[
j
]
 
=
 
temp
;

                
}

        
return
 
array
;

    
}
1.4 算法分析
最佳情况：T(n) = O(n)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(n2)
2、选择排序（Selection Sort）
表现
最稳定的排序算法之一
，因为
无论什么数据进去都是O(n2)的时间复杂度
，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。
选择排序
(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 
2.1 算法描述
n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：
初始状态：无序区为R[1..n]，有序区为空；
第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
n-1趟结束，数组有序化了。
2.2 动图演示
2.3 代码实现
/**

     * 选择排序

     * @param array

     * @return

     */

    
public
 
static
 
int
[]
 
selectionSort
(
int
[]
 
array
)
 
{

        
if
 
(
array
.
length
 
==
 
0
)

            
return
 
array
;

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
array
.
length
;
 
i
++)
 
{

            
int
 
minIndex
 
=
 
i
;

            
for
 
(
int
 
j
 
=
 
i
;
 
j
 
<
 
array
.
length
;
 
j
++)
 
{

                
if
 
(
array
[
j
]
 
<
 
array
[
minIndex
])
 
//找到最小的数

                    
minIndex
 
=
 
j
;
 
//将最小数的索引保存

            
}

            
int
 
temp
 
=
 
array
[
minIndex
];

            
array
[
minIndex
]
 
=
 
array
[
i
];

            
array
[
i
]
 
=
 
temp
;

        
}

        
return
 
array
;

    
}
2.4 算法分析
最佳情况：T(n) = O(n2)  最差情况：T(n) = O(n2)  平均情况：T(n) = O(n2)
3、插入排序（Insertion Sort）
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
3.1 算法描述
一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：
从第一个元素开始，该元素可以认为已经被排序；
取出下一个元素，在已经排序的元素序列中从后向前扫描；
如果该元素（已排序）大于新元素，将该元素移到下一位置；
重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
将新元素插入到该位置后；
重复步骤2~5。
3.2 动图演示
3.3 代码实现
/**

     * 插入排序

     * @param array

     * @return

     */

    
public
 
static
 
int
[]
 
insertionSort
(
int
[]
 
array
)
 
{

        
if
 
(
array
.
length
 
==
 
0
)

            
return
 
array
;

        
int
 
current
;

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
array
.
length
 
-
 
1
;
 
i
++)
 
{

            
current
 
=
 
array
[
i
 
+
 
1
];

            
int
 
preIndex
 
=
 
i
;

            
while
 
(
preIndex
 
>=
 
0
 
&&
 
current
 
<
 
array
[
preIndex
])
 
{

                
array
[
preIndex
 
+
 
1
]
 
=
 
array
[
preIndex
];

                
preIndex
--;

            
}

            
array
[
preIndex
 
+
 
1
]
 
=
 
current
;

        
}

        
return
 
array
;

    
}
3.4 算法分析
最佳情况：T(n) = O(n)   最坏情况：T(n) = O(n2)   平均情况：T(n) = O(n2)
4、希尔排序（Shell Sort）
希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。
希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。
4.1 算法描述
我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，
{n/2,(n/2)/2...1}
，称为
增量序列
。
希尔排序
的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：
选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
按增量序列个数k，对序列进行k 趟排序；
每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
4.2 过程演示
4.3 代码实现
/**

     * 希尔排序

     *

     * @param array

     * @return

     */

    
public
 
static
 
int
[]
 
ShellSort
(
int
[]
 
array
)
 
{

        
int
 
len
 
=
 
array
.
length
;

        
int
 
temp
,
 
gap
 
=
 
len
 
/
 
2
;

        
while
 
(
gap
 
>
 
0
)
 
{

            
for
 
(
int
 
i
 
=
 
gap
;
 
i
 
<
 
len
;
 
i
++)
 
{

                
temp
 
=
 
array
[
i
];

                
int
 
preIndex
 
=
 
i
 
-
 
gap
;

                
while
 
(
preIndex
 
>=
 
0
 
&&
 
array
[
preIndex
]
 
>
 
temp
)
 
{

                    
array
[
preIndex
 
+
 
gap
]
 
=
 
array
[
preIndex
];

                    
preIndex
 
-=
 
gap
;

                
}

                
array
[
preIndex
 
+
 
gap
]
 
=
 
temp
;

            
}

            
gap
 
/=
 
2
;

        
}

        
return
 
array
;

    
}
4.4 算法分析
最佳情况：T(n) = O(nlog2
 
n)  最坏情况：T(n) = O(nlog2
 
n)  平均情况：T(n) =O(nlog2n)　
5、归并排序（Merge Sort）
和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 
5.1 算法描述
把长度为n的输入序列分成两个长度为n/2的子序列；
对这两个子序列分别采用
归并排序
；
将两个排序好的子序列合并成一个最终的排序序列。
5.2 动图演示
5.3 代码实现
/**

     * 归并排序

     *

     * @param array

     * @return

     */

    
public
 
static
 
int
[]
 
MergeSort
(
int
[]
 
array
)
 
{

        
if
 
(
array
.
length
 
<
 
2
)
 
return
 
array
;

        
int
 
mid
 
=
 
array
.
length
 
/
 
2
;

        
int
[]
 
left
 
=
 
Arrays
.
copyOfRange
(
array
,
 
0
,
 
mid
);

        
int
[]
 
right
 
=
 
Arrays
.
copyOfRange
(
array
,
 
mid
,
 
array
.
length
);

        
return
 
merge
(
MergeSort
(
left
),
 
MergeSort
(
right
));

    
}

    
/**

     * 归并排序――将两段排序好的数组结合成一个排序数组

     *

     * @param left

     * @param right

     * @return

     */

    
public
 
static
 
int
[]
 
merge
(
int
[]
 
left
,
 
int
[]
 
right
)
 
{

        
int
[]
 
result
 
=
 
new
 
int
[
left
.
length
 
+
 
right
.
length
];

        
for
 
(
int
 
index
 
=
 
0
,
 
i
 
=
 
0
,
 
j
 
=
 
0
;
 
index
 
<
 
result
.
length
;
 
index
++)
 
{

            
if
 
(
i
 
>=
 
left
.
length
)

                
result
[
index
]
 
=
 
right
[
j
++];

            
else
 
if
 
(
j
 
>=
 
right
.
length
)

                
result
[
index
]
 
=
 
left
[
i
++];

            
else
 
if
 
(
left
[
i
]
 
>
 
right
[
j
])

                
result
[
index
]
 
=
 
right
[
j
++];

            
else

                
result
[
index
]
 
=
 
left
[
i
++];

        
}

        
return
 
result
;

    
}
5. 4 算法分析
最佳情况：T(n) = O(n)  最差情况：T(n) = O(nlogn)  平均情况：T(n) = O(nlogn)
6、快速排序（Quick Sort）
快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
6.1 算法描述
快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：
从数列中挑出一个元素，称为 “基准”（
pivot
）；
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
6.2 动图演示
6.3 代码实现
/**

     * 快速排序方法

     * @param array

     * @param start

     * @param end

     * @return

     */

    
public
 
static
 
int
[]
 
QuickSort
(
int
[]
 
array
,
 
int
 
start
,
 
int
 
end
)
 
{

        
if
 
(
array
.
length
 
<
 
1
 
||
 
start
 
<
 
0
 
||
 
end
 
>=
 
array
.
length
 
||
 
start
 
>
 
end
)
 
return
 
null
;

        
int
 
smallIndex
 
=
 
partition
(
array
,
 
start
,
 
end
);

        
if
 
(
smallIndex
 
>
 
start
)

            
QuickSort
(
array
,
 
start
,
 
smallIndex
 
-
 
1
);

        
if
 
(
smallIndex
 
<
 
end
)

            
QuickSort
(
array
,
 
smallIndex
 
+
 
1
,
 
end
);

        
return
 
array
;

    
}

    
/**

     * 
快速排序算法
――partition

     * @param array

     * @param start

     * @param end

     * @return

     */

    
public
 
static
 
int
 
partition
(
int
[]
 
array
,
 
int
 
start
,
 
int
 
end
)
 
{

        
int
 
pivot
 
=
 
(
int
)
 
(
start
 
+
 
Math
.
random
()
 
*
 
(
end
 
-
 
start
 
+
 
1
));

        
int
 
smallIndex
 
=
 
start
 
-
 
1
;

        
swap
(
array
,
 
pivot
,
 
end
);

        
for
 
(
int
 
i
 
=
 
start
;
 
i
 
<=
 
end
;
 
i
++)

            
if
 
(
array
[
i
]
 
<=
 
array
[
end
])
 
{

                
smallIndex
++;

                
if
 
(
i
 
>
 
smallIndex
)

                    
swap
(
array
,
 
i
,
 
smallIndex
);

            
}

        
return
 
smallIndex
;

    
}


    
/**

     * 交换数组内两个元素

     * @param array

     * @param i

     * @param j

     */

    
public
 
static
 
void
 
swap
(
int
[]
 
array
,
 
int
 
i
,
 
int
 
j
)
 
{

        
int
 
temp
 
=
 
array
[
i
];

        
array
[
i
]
 
=
 
array
[
j
];

        
array
[
j
]
 
=
 
temp
;

    
}
6.4 算法分析
最佳情况：T(n) = O(nlogn)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(nlogn)　
7、堆排序（Heap Sort）
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似
完全二叉树
的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
7.1 算法描述
将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
7.2 动图演示
7.3 代码实现
注意：这里用到了完全二叉树的部分性质：详情见
《数据结构二叉树知识点总结》
//声明全局变量，用于记录数组array的长度；

static
 
int
 
len
;

    
/**

     * 
堆排序算法


     *

     * @param array

     * @return

     */

    
public
 
static
 
int
[]
 
HeapSort
(
int
[]
 
array
)
 
{

        
len
 
=
 
array
.
length
;

        
if
 
(
len
 
<
 
1
)
 
return
 
array
;

        
//1.构建一个最大堆

        
buildMaxHeap
(
array
);

        
//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆

        
while
 
(
len
 
>
 
0
)
 
{

            
swap
(
array
,
 
0
,
 
len
 
-
 
1
);

            
len
--;

            
adjustHeap
(
array
,
 
0
);

        
}

        
return
 
array
;

    
}

    
/**

     * 建立最大堆

     *

     * @param array

     */

    
public
 
static
 
void
 
buildMaxHeap
(
int
[]
 
array
)
 
{

        
//从最后一个非叶子节点开始向上构造最大堆

        
for
 
(
int
 
i
 
=
 
(
len
/
2
 
-
 
1
);
 
i
 
>=
 
0
;
 
i
--)
 
{
 
//感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) 

            
adjustHeap
(
array
,
 
i
);

        
}

    
}

    
/**

     * 调整使之成为最大堆

     *

     * @param array

     * @param i

     */

    
public
 
static
 
void
 
adjustHeap
(
int
[]
 
array
,
 
int
 
i
)
 
{

        
int
 
maxIndex
 
=
 
i
;

        
//如果有左子树，且左子树大于父节点，则将最大指针指向左子树

        
if
 
(
i
 
*
 
2
 
<
 
len
 
&&
 
array
[
i
 
*
 
2
]
 
>
 
array
[
maxIndex
])

            
maxIndex
 
=
 
i
 
*
 
2
;

        
//如果有右子树，且右子树大于父节点，则将最大指针指向右子树

        
if
 
(
i
 
*
 
2
 
+
 
1
 
<
 
len
 
&&
 
array
[
i
 
*
 
2
 
+
 
1
]
 
>
 
array
[
maxIndex
])

            
maxIndex
 
=
 
i
 
*
 
2
 
+
 
1
;

        
//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。

        
if
 
(
maxIndex
 
!=
 
i
)
 
{

            
swap
(
array
,
 
maxIndex
,
 
i
);

            
adjustHeap
(
array
,
 
maxIndex
);

        
}

    
}
7.4 算法分析
最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)
8、计数排序（Counting Sort）
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。
8.1 算法描述
找出待排序的数组中最大和最小的元素；
统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。
8.2 动图演示
8.3 代码实现
/**

     * 计数排序

     *

     * @param array

     * @return

     */

    
public
 
static
 
int
[]
 
CountingSort
(
int
[]
 
array
)
 
{

        
if
 
(
array
.
length
 
==
 
0
)
 
return
 
array
;

        
int
 
bias
,
 
min
 
=
 
array
[
0
],
 
max
 
=
 
array
[
0
];

        
for
 
(
int
 
i
 
=
 
1
;
 
i
 
<
 
array
.
length
;
 
i
++)
 
{

            
if
 
(
array
[
i
]
 
>
 
max
)

                
max
 
=
 
array
[
i
];

            
if
 
(
array
[
i
]
 
<
 
min
)

                
min
 
=
 
array
[
i
];

        
}

        
bias
 
=
 
0
 
-
 
min
;

        
int
[]
 
bucket
 
=
 
new
 
int
[
max
 
-
 
min
 
+
 
1
];

        
Arrays
.
fill
(
bucket
,
 
0
);

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
array
.
length
;
 
i
++)
 
{

            
bucket
[
array
[
i
]
 
+
 
bias
]++;

        
}

        
int
 
index
 
=
 
0
,
 
i
 
=
 
0
;

        
while
 
(
index
 
<
 
array
.
length
)
 
{

            
if
 
(
bucket
[
i
]
 
!=
 
0
)
 
{

                
array
[
index
]
 
=
 
i
 
-
 
bias
;

                
bucket
[
i
]--;

                
index
++;

            
}
 
else

                
i
++;

        
}

        
return
 
array
;

    
}
8.4 算法分析
当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。
最佳情况：T(n) = O(n+k)  最差情况：T(n) = O(n+k)  平均情况：T(n) = O(n+k)
9、桶排序（Bucket Sort）
桶排序是
计数排序
的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
桶排序
 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的
排序算法
或是以递归方式继续使用桶排序进行排
9.1 算法描述
人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；
遍历输入数据，并且把数据一个一个放到对应的桶里去；
对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；
从不是空的桶里把排好序的数据拼接起来。 
注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。
9.2 图片演示
9.3 代码实现
/**

     * 桶排序

     * 

     * @param array

     * @param bucketSize

     * @return

     */

    
public
 
static
 
ArrayList
<
Integer
>
 
BucketSort
(
ArrayList
<
Integer
>
 
array
,
 
int
 
bucketSize
)
 
{

        
if
 
(
array
 
==
 
null
 
||
 
array
.
size
()
 
<
 
2
)

            
return
 
array
;

        
int
 
max
 
=
 
array
.
get
(
0
),
 
min
 
=
 
array
.
get
(
0
);

        
// 找到最大值最小值

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
array
.
size
();
 
i
++)
 
{

            
if
 
(
array
.
get
(
i
)
 
>
 
max
)

                
max
 
=
 
array
.
get
(
i
);

            
if
 
(
array
.
get
(
i
)
 
<
 
min
)

                
min
 
=
 
array
.
get
(
i
);

        
}

        
int
 
bucketCount
 
=
 
(
max
 
-
 
min
)
 
/
 
bucketSize
 
+
 
1
;

        
ArrayList
<
ArrayList
<
Integer
>>
 
bucketArr
 
=
 
new
 
ArrayList
<>(
bucketCount
);

        
ArrayList
<
Integer
>
 
resultArr
 
=
 
new
 
ArrayList
<>();

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
bucketCount
;
 
i
++)
 
{

            
bucketArr
.
add
(
new
 
ArrayList
<
Integer
>());

        
}

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
array
.
size
();
 
i
++)
 
{

            
bucketArr
.
get
((
array
.
get
(
i
)
 
-
 
min
)
 
/
 
bucketSize
).
add
(
array
.
get
(
i
));

        
}

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
bucketCount
;
 
i
++)
 
{

            
if
 
(
bucketSize
 
==
 
1
)
 
{
 
// 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误

                
for
 
(
int
 
j
 
=
 
0
;
 
j
 
<
 
bucketArr
.
get
(
i
).
size
();
 
j
++)

                    
resultArr
.
add
(
bucketArr
.
get
(
i
).
get
(
j
));

            
}
 
else
 
{

                
if
 
(
bucketCount
 
==
 
1
)

                    
bucketSize
--;

                
ArrayList
<
Integer
>
 
temp
 
=
 
BucketSort
(
bucketArr
.
get
(
i
),
 
bucketSize
);

                
for
 
(
int
 
j
 
=
 
0
;
 
j
 
<
 
temp
.
size
();
 
j
++)

                    
resultArr
.
add
(
temp
.
get
(
j
));

            
}

        
}

        
return
 
resultArr
;

    
}
9.4 算法分析
桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 
最佳情况：T(n) = O(n+k)   最差情况：T(n) = O(n+k)   平均情况：T(n) = O(n2)　　
10、基数排序（Radix Sort）
基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；
基数排序
是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。
10.1 算法描述
取得数组中的最大数，并取得位数；
arr为原始数组，从最低位开始取每个位组成radix数组；
对radix进行计数排序（利用计数排序适用于小范围数的特点）；
10.2 动图演示
10.3 代码实现
/**

     * 基数排序

     * @param array

     * @return

     */

    
public
 
static
 
int
[]
 
RadixSort
(
int
[]
 
array
)
 
{

        
if
 
(
array
 
==
 
null
 
||
 
array
.
length
 
<
 
2
)

            
return
 
array
;

        
// 1.先算出最大数的位数；

        
int
 
max
 
=
 
array
[
0
];

        
for
 
(
int
 
i
 
=
 
1
;
 
i
 
<
 
array
.
length
;
 
i
++)
 
{

            
max
 
=
 
Math
.
max
(
max
,
 
array
[
i
]);

        
}

        
int
 
maxDigit
 
=
 
0
;

        
while
 
(
max
 
!=
 
0
)
 
{

            
max
 
/=
 
10
;

            
maxDigit
++;

        
}

        
int
 
mod
 
=
 
10
,
 
div
 
=
 
1
;

        
ArrayList
<
ArrayList
<
Integer
>>
 
bucketList
 
=
 
new
 
ArrayList
<
ArrayList
<
Integer
>>();

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
10
;
 
i
++)

            
bucketList
.
add
(
new
 
ArrayList
<
Integer
>());

        
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
maxDigit
;
 
i
++,
 
mod
 
*=
 
10
,
 
div
 
*=
 
10
)
 
{

            
for
 
(
int
 
j
 
=
 
0
;
 
j
 
<
 
array
.
length
;
 
j
++)
 
{

                
int
 
num
 
=
 
(
array
[
j
]
 
%
 
mod
)
 
/
 
div
;

                
bucketList
.
get
(
num
).
add
(
array
[
j
]);

            
}

            
int
 
index
 
=
 
0
;

            
for
 
(
int
 
j
 
=
 
0
;
 
j
 
<
 
bucketList
.
size
();
 
j
++)
 
{

                
for
 
(
int
 
k
 
=
 
0
;
 
k
 
<
 
bucketList
.
get
(
j
).
size
();
 
k
++)

                    
array
[
index
++]
 
=
 
bucketList
.
get
(
j
).
get
(
k
);

                
bucketList
.
get
(
j
).
clear
();

            
}

        
}

        
return
 
array
;

    
}
10.4 算法分析
最佳情况：T(n) = O(n * k)   最差情况：T(n) = O(n * k)   平均情况：T(n) = O(n * k)
基数排序有两种方法：
MSD 从高位开始进行排序 LSD 从低位开始进行排序 
基数排序 vs 计数排序 vs 桶排序
这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：
基数排序：根据键值的每位数字来分配桶
计数排序：每个桶只存储单一键值
桶排序：每个桶存储一定范围的数值
我有一个
微信公众号
，经常会分享一些Java技术相关的干货；如果你喜欢我的分享，可以用微信搜索“Java团长”或者“javatuanzhang”关注。
作者：
郭耀华
链接：
https://www.
cnblogs.com/guoyaohua/p
/8600214.html
来源：
博客园","的答案说的好极了，我也发挥下：
第一个算法是计算终身年薪
终生范围的年薪。以下数字都是假的，只是说明算法，无实际意义。
比如26岁可以开始工作，如果40岁就下岗，实际上一年100万，也只有1400万，要除以整个工作年龄（65-26 = 39），平均年薪大概只有30多万。而且累积税率下，高收入年份集中在26-40岁非常吃亏。
但，这没有考虑到房价上涨因素，因为房价上涨时期，前14年的收入会因为房产而大量增值，使得算法更加复杂。
还有比如假设能做到50岁，那么晚工作5年（比如多读个火坑博士）损失的钱是多少呢？假设起薪是100万，50岁下岗时是200万一年，实际上损失的是最后5年的收入，大概200X5 = 1000万。所以写码要趁早。
其次要算地点年薪。比如工作30年同样年薪，在一个房价上涨的地区，会在退休时能提出更多的钱，尤其是50多岁把一线城市或是加州的房子一卖回乡下养老或是环游世界，美滋滋。
第三要算成长年薪，同样100万的工作，有些技能会保证10年后不仅不失业，反而会上涨到150万，而有些技能会在衰退中，10年后可能只有50万甚至失业。
第二个算法是
一道题的价格
我当年做过粗略计算，很多LeetCode题做一道可以提升年薪300-500美元。假设400道Medium、Hard题可以拿到大厂Offer，那么很可能不刷题的人上限也就是不到20万，而大厂senior上限可以轻松35-40万。差不多20万的差距，除以400 等于 500美元。
所以一道Medium或是Hard题的价值大概是500美元年薪每年。而且这个可怕在于是累积的，每年500, 20年下来就是1万块一道题。这还不算大厂背景对个人的加分、对失业的强抵抗力等，只是单单年薪上的收入（当然，税后会少很多）。
这个“算法”掌握了，你才有动力去学习LeetCode的算法，你就不会觉得它折磨人了。LeetCode这么一看，简直跟金山一样，还不去挖？
第三个算法是算时薪和效率
Google和微软的时薪就比较高，
亚麻就相对低。这种时薪不光是用hours计算，还用体力计算。比如微软上班干两个小时活，扯六个小时蛋，然后回家精神抖擞，可以去卖房子、创业、炒股票等，相当于一天多出来4个小时有效时间；FB上班干七个小时活，被扯两个小时蛋，通勤再耗去一个半小时，回家就瘫痪了。
千万别看什么华为他们996效率高。我算过，他们效率很低：中午吃饭吃一个小时，还要午休一个小时，加上重新进入状态的时间，中国的12小时一天，实际上也就相当于美国的9小时一天左右，因为我们这里9小时是真的9个小时。
第四个算福利
公司免费三餐大概省多少钱？早饭就算0（因为可以不吃），午饭算10美元，晚饭算15美元，一年工作220天，25X220 = 5500美元。但这是税后的，所以5500 要乘以1.5（税率按33%近似） = 8250美元税前。
还要算时间账：午餐和晚餐大概各省半个小时的话（不需要开车出去或是下楼吃等），一年会省220小时，相当于多出来220/8 = 27天。
还要算健康账：因为公司有大量的蔬菜水果等。食物种类多变更有利于身体。
还要算士气账：免费三餐大概能提升10%-30%的员工士气（我是吃货，所以+30%）。
结论：三餐免费每年带来很大的收益，无论公司还是员工。
第五个算面试大厂的成功概率
假设一个人面一家大厂的成功率是25%，大厂有8家，冷冻期均是一年，连续坚持不懈面5年，一个offer都拿不到的概率是：
（1-0.25）^ (8*5) = 0.75 ^ 40 = 0.00001 = 0.001%
假设这人只有5%的成功率，且一年只面了4家，连续面5年，一个offer都拿不到的概率是：
（1-0.05）^ (4*5) = 0.95 ^ 20 = 0.3584 = 35.84%
可见，一个只有5%成功率的人，坚持面5年也有大概2/3的概率能进大厂。
第二个假设跟我在现实中的观察很相似，也解释了为什么很多看似不强的人也进了大厂。","心率算法
：
 标准心率（RHR）：正常60-100次/分，平均75次/分
最大心率
（MHR）：220－你的年龄
最低心率：早上静止时测量的
安静心率
：安静状态下测量的
保留心率：最大心率-最低心率
心率储备=最大心率-安静心率
最佳加班最适宜心率（EHR）：最大心率×（60%～80%）
防脱发加班心率：
晨脉
×（1.8～1.4）（在早上加班Y束后的 5 秒龋量脉搏 10 秒，然后将搏动次数乘以 6；或者量脉搏 15 秒，然后将Y果乘以 4）
有氧加班最适宜心率：最大心率（60～80%）（最大心率－安静心率）×（60～80%）+安静心率
加班减肥心率：最低心率+保留心率×（50%～70%）
加班耐力心率：最低心率+保留心率× （60%～70%）
目标心率：
心率储备
（60%～80%）60%~70%主要用于减脂；70%~80%主要用于提高心肺功能
注意：由于最大加班心率是一个基于生理条件的心跳极限的估算值，故实际强度要因人而宜，对于初习者通常可保持在60～65%MHR即可。如果不顾自己的身体条件一味追求高强度加班，则将不利于健康。
视频资源加载失败
代码诚可贵，生命价更高！程序员同行们一定要注意身体，我们一定要熬到国家“
1024程序员节
”法定节假日那一天呀！！！！！！
正经算法：
2020版数据结构与算法
2020版数据结构与算法（资料网盘）
  提取码：jkg9 
让数据结构不再难懂，让算法不再难写
让数据结构不再难懂，让算法不再难写（资料网盘）
 提取码：qca8
C语言数据结构 培养架构师思维
C语言数据结构 培养架构师思维（资料网盘）
   密码：4wi6
互联网巨头公司面试题目之二叉树数据结构与算法
互联网巨头公司面试题目之二叉树数据结构与算法（资料网盘）
   提取码：j8i0 ","计算机科学家投票选出最重要的算法（按照英文名称字母顺序排序）：
1、A* 搜索算法――图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A*搜索算法是最佳优先搜索的范例。
2、集束搜索（又名定向搜索，Beam Search）――最佳优先搜索算法的优化。使用
启发式函数
评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字――集束的宽度。
3、二分查找（Binary Search）――在线性数组中找特定值的算法，每个步骤去掉一半不符合要求的数据。
4、分支界定算法（Branch and Bound）――在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。
5、Buchberger算法――一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中
高斯消元法
的泛化。
6、数据压缩――采取特定编码方案，使用更少的字节数（或是其他信息承载单元）对信息编码的过程，又叫来源编码。
7、Diffie-Hellman密钥交换算法――一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。
8、Dijkstra算法――针对没有负值权重边的有向图，计算其中的单一起点最短算法。
9、离散微分算法（Discrete differentiation）
10、
动态规划算法
（Dynamic Programming）――展示互相覆盖的子问题和最优子架构算法
11、
欧几里得算法
（Euclidean algorithm）――计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。
12、期望-最大算法（Expectation-maximization algorithm，又名EM-Training）――在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。
13、
快速傅里叶变换
（Fast Fourier transform，FFT）――计算离散的傅里叶变换（DFT）及其反转。该算法应用范围很广，从数字信号处理到解决偏微分方程，到快速计算大整数乘积。
14、梯度下降（Gradient descent）――一种数学上的最优化算法。
15、
哈希算法
（Hashing）
16、
堆排序
（Heaps）
17、Karatsuba乘法――需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。
18、LLL算法（Lenstra-Lenstra-Lovasz lattice reduction）――以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的
RSA加密
等等。
19、最大流量算法（Maximum flow）――该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。
20、合并排序（Merge Sort）
21、
牛顿法
（Newton's method）――求非线性方程（组）零点的一种重要的迭代法。
22、Q-learning学习算法――这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。
23、两次筛法（Quadratic Sieve）――现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。
24、RANSAC――是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。
25、RSA――公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。
26、Sch?nhage-Strassen算法――在数学中，Sch?nhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。
27、单纯型算法（Simplex Algorithm）――在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。
28、
奇异值分解
（Singular value decomposition，简称SVD）――在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解
最小二乘法
问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。
29、求解线性方程组（Solving a system of linear equations）――线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯―约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。
30、Strukturtensor算法――应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。
31、合并查找算法（Union-find）――给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作：
查找：判断某特定元素属于哪个组。
合并：联合或合并两个组为一个组。
32、
维特比算法
（Viterbi algorithm）――寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。","从程序员面试角度，说说面试时需要掌握的算法有哪些。
具体的请看下面列表。不过，如果是准备面试的话，我建议你通过做题来巩固这些算法知识。这里推荐你到 
http://www.
lintcode.com
 上面进行 Online Judge，以下类别的面试题目都有覆盖到。
准备之前可以试听
《如何在一个月内攻破算法面试》
，
帮你节省65%准备时间。
算法部分 
二分搜索 Binary Search 
分治 Divide Conquer 
宽度优先搜索 Breadth First Search 

深度优先搜索
 Depth First Search

回溯法
 Backtracking 

双指针
 Two Pointers 
动态规划 Dynamic Programming 
扫描线 Scan-line algorithm
快排 Quick Sort
数据结构部分 
栈 Stack
队列 Queue

链表
 Linked List 
数组 Array 

哈希表
 Hash Table
二叉树 Binary Tree  
堆 Heap

并查集
 Union Find

字典树
 Trie
----------3.31更新---------
有朋友留言说这些算法覆盖得太少，他都“基本掌握”了。需要做以下几点补充说明。
1. 我在这里总结的是程序面试必须掌握的算法知识。所以选择的是最常面试到的算法内容。面试与做研究不同，不会要求那些极少用到而又及其高深的算法。
2. 有的人觉得自己“基本掌握”了，但如果真的让他来做两道题，他也许花很长的时间都写不出来完整的答案。甚至即使做出来了，还会有非常多的bug。在面试中，一个题目一般只有30-45分钟的时间可以让你作答，而且要求
bug free
。如果你做不到这样，那就不可以说自己“基本掌握”。
3. 以上的算法知识点，看起来很少，真正掌握、吃透，是要花很长时间的。个人觉得与其泛泛地了解一些算法知识的皮毛，不如深入地把以上面试、工作中最常用到的算法知识吃透。
九章算法，硅谷一线工程师在线直播授课，已经帮助30000+人成功拿到心仪offer。
九章算法班
，硅谷求职必备，你的面试官也曾上过这门课，点击立即报名试听
更多课程信息请访问：
九章算法","每种程序员的需求很不一样，与其谈具体的算法，不如说最基本应掌握复杂度、穷举、分治、回溯、贪心、
动态规划
等算法基础理论。
P.S. 如果我当面试官问 
游戏编程里面有哪些经典或者很酷的算法？ - Milo Yip 的回答
 里类似的算法，估计很难请人。实际工作需要不断学习（甚至研究）领域相关的算法去解决问题，没有什么必须掌握的。","前面一些回答，尤其那个3k多赞的，算是知识点罗列吗？找两本书：初等算法+算法设计，把目录贴出来，大概就是这个样子了。
我对此类回答不太满意。我来换一个角度解读下吧。
其实程序员员掌握多少算法并不关键，关键的是能不能理解算法背后深层的理论，以及修练出解题的思路。
就好像排序中的
堆排序
，本质就是二叉树的应用。
快速排序、
希尔排序
等本质都是分治法的思路。
等等
见的多了就会发现，很多算法面向解决的问题明明相差很大，但底层实现都是非常类似；而又有些算法面向的问题很类似，而底层实现又相差巨大。
现实世界的需求是千变万化的，即使你掌握再多的算法也不可能直接照搬某个算法去解决你面对的问题。
关键的是要通过学习算法过程中整理出解决问题的思路。例如面对高性能的需求附带一些个性化的情况时，是用
hash表
解决，还是用二叉树，选择哪种具体的实现以及一些细节处的处理。
因此在现实环境中，严格按照某种算法定义使用算法的情况很少见，大多都是变种。甚至多种算法拼凑组合。
而为什么能产生这么多算法，这么多变种算法的原因，其实也是因为很多人在面对自己的需求时照搬经典算法解决不了问题，所以修改或优化了算法，才产生了变种算法甚至新算法。
所以，学习算法不要单纯去记忆算法的定义和实现代码，关键是要学会其中的思路。
这个跟写代码学习
设计模式
、架构模式等的情况是一样的。真正严格匹配某种模式的情况很少，都是杂合。
关键是掌握其中的本质。就好像武功中的，看山还是山，看水还是水。无招胜有着的境界。
欢迎点赞和评论。","算法是程序的灵魂――编程从本质上来说就是算法加数据结构，而算法是编程思想的核心部分。
当前程序员的岗位划分逐渐细化。对于
研发级程序员
来说，掌握算法是完成岗位开发任务的基础，而对于
应用级程序员
来说，掌握算法是进行岗位升级的重要基础。
小编建议程序猿们从以下几个方面审视或提升或入门算法知识结构――
基础部分
基础编程模型， 包括Java
程序的基本结构
、原始数据类型与表达式、语句、数组、
静态方法
、API、字符串、二分查找、输入输出等
数据抽象　
背包、队列和栈：API/集合类数据类型的实现
关于排序　
初级
排序算法
的游戏规则，比如选择排序、插入排序，参考
希尔排序
　
归并排序，包括原地归并的抽象方法、自顶向下的归并排序、自底向上的归并排
快速排序
优先队列
（API和堆）
关于查找
符号表，包括有序符号表、无序链表中的顺序查找、有序数组中的二分查找、对二分查找的分析等
二叉查找树
　　
平衡查找树，常见的2-3查找树、红黑二叉查找树
散列表，包括散列函数、基于拉链法/
线性探测法
的散列表
在应用中可以重点学习：字典类用例、索引类用例和稀疏向量
关于图
无向图，需要重点关注表示无向图的数据模型、符号图、连通分量、广度/
深度优先搜索
有向图，需要重点关注有向图的数据类型和可达性，以及环和有向无环图、有向图中的强连通性
最小生成树，如Prim算法、Kruskal算法
最短路径
，在了解加权有向图的数据结构和最短路径算法的理论基础后关注Dijkstra算法，以及无环加权有向图中的
最短路径算法
关于字符串
字符串排序：键索引计数法、低位优先的字符串排序、高位优先的字符串排序、三向字符串快速排序、字符串排序算法的选择
单词查找树：三向单词查找树
子字符串查找：暴力子字符串查找算法、Knuth-Morris-Pratt子字符串查找算法、Boyer-Moore字符串查找算法、Rabin-Karp指纹字符串查找算法
正则表达式
数据压缩　
以下从在线题库、在线提交程序源代码等维度推荐一些优秀的网站，希望能对题主有所帮助。
一、在线题库
算法学习，本质上是学习一门语言。学习语言的要领在于看、听、说、练。对于新手、进阶的信息安全工作者来说，刷题能够让算法能力得到一个质的飞跃。
1、hackerrank - 
https://www.
hackerrank.com/
面向程序员、Hacker们的社交网络，在算法、数学、SQL、
函数式编程
、AI等众多不同领域为挑战者们提供了相应的编程题目，用户可直接在线完成挑战。
2、Topcoder - 
https://www.
topcoder.com/
成立于2001年，最早的
在线编程
竞技平台之一，网站提供了一系列的算法挑战，参赛者可使用代码编辑器直接进行在线作答，比拼获胜者可获得竞赛赞助方提供的奖励。
3、Geeksforgeeks - 
https://www.
geeksforgeeks.org/
Geeksforgeeks涵盖文章、解释和代码解决方案等内容，除了提供基础的编程、算法学习资源外，在“算法和数据结构”主题中，提供测试项目，解题者可以在在线编辑器中进行挑战。
4、codeforces - 
http://
codeforces.com/
此网站是由来自萨拉托夫州立大学Mike Mirzayanov领导的一个团队创立和维护，是一个举办比赛、做题和交流的平台，网站自带blog功能，可以求助/发布题解。
5、lintcode - 
https://www.
lintcode.com/
支持中英双语，汇集了算法、数据结构，人工智能，系统设计等众多领域的题目，网站还会举办编程比赛，很多算法爱好者在这里切磋技艺。
此外：
1、Codewars - 
https://www.
codewars.com/
2、Leetcode（
https://
leetcode.com/
）
3、Github （
https://
github.com
)
4、codehs - 
https://
codehs.com/
5、visualgo - 
https://
visualgo.net/
6、CoderPro - 
http://
coderpro.com.cn/
7、codesignal - 
https://
codesignal.com/
8、CodinGame - 
https://www.
codingame.com/
9、codechef - 
https://www.
codechef.com/
10、v2ex - 
https://www.
v2ex.com/
11、Online Judge - 
https://
acm.sjtu.edu.cn/OnlineJ
udge/
12、codecademy - 
https://www.
codecademy.com/
13、programmingpraxis - 
https://
programmingpraxis.com/
二、在线提交
程序源代码
Online Judge系统最初使用于ACM-ICPC
国际大学生程序设计竞赛
和OI信息学奥林匹克竞赛中的自动判题和排名，现广泛应用于世界各地高校学生程序设计的训练、参赛队员的训练和选拔、各种程序设计竞赛以及数据结构和算法的学习和作业的自动提交判断中。
1、北大POJ - 
http://
poj.org/
免费的公益性网上程序设计题库，包含3000多道饶有趣味的程序设计题，是个提供编程、算法题目的网站，兼容Pascal、C、C++、Java、Fortran等多种语言。
2、杭电HDU - 
http://
acm.hdu.edu.cn/
杭州电子科技大学的
在线评测系统
，中国最受欢迎OJ之一，题目数量多，来源广，有很多优质好题。
3、浙大ZOJ - 
http://
acm.zju.edu.cn/onlineju
dge/
浙江大学的在线评测系统，国内起步最早的几个OJ之一，题目数量约2000道，打开速度较快。
4、
洛谷
 - 
https://www.
luogu.org/
创办于2013年，是基于网页形式的信息学在线评测系统，它不仅仅是一个在线测题系统，还拥有强大的社区、在线学习功能。
5、RQNOJ - 
http://www.
rqnoj.cn/
RenqingNet Online Judge，2007年8月上线，集成了题库、测评、讨论、团队、比赛等主体的网络平台，是国内OJ(信息学在线测评)开放平台开发和运行的先导。
其它：
1、大视野在线测评BZOJ - 
http://www.
lydsy.com/JudgeOnline/
2、UOJ - 
http://
uoj.ac/
3、福州大学 - 
http://
acm.fzu.edu.cn/
4、上海交大OJ - 
http://
acm.sjtu.edu.cn/OnlineJ
udge/
5、中科大OJ - 
http://
acm.ustc.edu.cn/ustcoj/
6、
宁波工程学院
 - 
https://
ac.2333.moe/
7、波兰SPOJ - 
http://www.
spoj.com/
8、日本JOI - 
http://www.
ioi-jp.org/index.html
9、LIGHTOJ - 
http://www.
lightoj.com/
10、浙江工业大学OJ - 
http://
acm.zjut.edu.cn/
以上，一股脑推荐很多网站，但并不意味着所有的都需要花大量的时间和精力去研究。在算法学习中，首先自己要找出自己的问题总是出在哪里？最薄弱的环节是哪一个？只有发现自身问题，知道如何学习去提升技能，最终才会学以致用。","好问题。非常同意大佬 
@温酒
 的观点。
第一个算法是：怎么算时薪。
这里我的经验是不要按照 8 小时的工作制来计算，而是按照每个工作日
实际的工作时间
来计算时薪。要不然在那些 w/l balance 好著称的公司工作计算会有偏差。
举个例子，湾区某大厂小张年薪税前 240k。一年 52 周，平均每周 $4.6k。每周按照规定工作 40 小时，实际上在美国一般真正用于工作的时间有 30 小时/周就已经很忙了。
4.6k / 30 = 153
所以小张的最低时薪应该至少为 $153。注意，还不包括公司给 match 的 401k 以及各种保险。所以综合考虑应该还要更多一点。
第二个算法我认为程序员应该掌握的是
确定做一件事的止损点
，即在沉没成本大于多少时果断放弃做这件事？
考虑以下几个场景
1）”追“一个妹子，追多久如果还不答应就果断换人？
2）刷题进 
dream company
，刷到什么程度就去面试自己的 dream company，如果失败立马换其他公司？
3）在当前公司划水到什么时候应当考虑跳槽？
4）房价降/涨到什么时候则考虑买房？
这些都是我们生活中息息相关的事情，我认为掌握这些算法更重要，优先级更高。","注：本篇回答主要针对程序员校招求职。
常考面试算法题类型总结
结合2019春招和秋招真题，以下几类算法题最常考，汇总了一下：
一、暴力枚举
好多鱼！
DNA合成
连续整数
序列和
01翻转
最长公共连续子串
组装三角形
最小的矩形
字符串分类
优美的回文串
赶去公司
调整队形
集合
涂棋盘
小易记单词
分饼干
买帽子
度度熊回家
寻找三角形
有趣的排序
神奇数
添加字符
数组变换
二、
动态规划
页码统计
创造新世界
双核处理
堆砖块
不等式数列
牛牛的数列
暗黑的字符串
数字和为sum的方法数
三、DFS/BFS
推箱子
工作安排
幸运的袋子
饥饿的小易
跳石板
地下迷宫
四、数学
超级素数幂
找整除
魔力手环
混合颜料
最大的奇约数
末尾0的个数
五、模拟实现
平衡数
消除重复元素
奇怪的表达式求值
变换次数
六、
贪心算法
排序子序列
组队竞赛
训练部队
七、字符串算法
循环单词
练习题库推荐
推荐两个题库，面试算法题基本上都是从里面出的或者变形而来：
1、
剑指Offer
2、
leetcode在线编程
算法视频推荐
1、
如何学习算法：十年算法刷题大牛手把手传授算法学习经验
2、
算法基础入门
3、
算法基础提升
4、
求职算法真题精讲-中级
5、
求职算法真题精讲-高级
6、
直通BAT算法精讲
算法专栏推荐
《程序员代码面试指南》左程云
更多名企笔试真题解析、面试经验交流、招聘信息内推，尽在牛客！
求职之前，先上牛客！快快下载拿offer！
互联网名企面经精选
因为每家公司的侧重点不同，所以他们面试时考的题目类型也不同。如果能提前知道每家公司考题的风格，临到自己上考场就会轻松很多。整理了一些前辈们的面试经验分享给大家：
最后，祝大家都能拿到自己最想要的那份offer，加油~","2017年我还是个萌新，那时和爱打呼噜的2b室友讨论了一个晚上的结构体
，探讨空洞中的数据。当初笑话别人写的2b代码，终于自己写到了，windows下的vs真的是最优秀的debug工具，clion党不哭，羡慕那些java程序员之间讨论的，都是丰富的乱七八糟名字的高大上的东东。linux c程序员可能就一个
内存泄漏
。
任何一个行业都是一个江湖，有江湖就有故事，追名逐利的人喜欢被写入故事，踏实做事的人却希望被隐匿。久而久之，江湖上的故事越来越虚名浮利，听故事的人也越来越坐井观天。且不见无数江湖武侠小说，开篇的人物总是让我们误以为是江湖大侠，看着看着才发现一山更比一山高，到最后才发现开篇人物简直是不入流的小。而真正的高手，反而隐匿成传说。互联网行业，也是如此。
一眨眼自己要找工作了，开始天天刷算法题了。一天夜里梦到老师了，被算法支配的恐惧。同学们都在抄作业，我也拿着后排的大神作业在抄，抄的是题目是1.4和4.2，大神只写了一题，我越抄越觉得在抄天书，知识它就是不进脑袋。还了作业，道了一声谢谢。回过头，看到老师在黑板上留下2个字，遗憾。
我信息安全专业出生，研究生时期光顾着做安全全栈实验了，并没有写过正儿八经的开发项目，导致编程水平一直很菜，匆匆一刷《剑指OFFER》，就开始关注校招宣讲，笔试了趋势科技、
的C++安全开发，都没有过，最后在新华三C++安全开发岗上岸了。如果算法你比我还菜，千万不要投安全开发岗，信息安全和软件设计是2个完全不同的职业方向，老老实实去做渗透测试～
广告
互联网研发求职者必会算法从入门到放肆
作者 ailx10
会员专享
￥25.00
去查看
?
下面是我当时一刷的80道算法题：
ailx10：最大子数组问题
 
ailx10：主方法求解递归式
 
ailx10：生日悖论
 
ailx10：二叉堆
 
ailx10：优先队列
 
ailx10：快速排序
 
ailx10：计数排序
 
ailx10：基数排序
 
ailx10：桶排序
 
ailx10：插入排序
 
ailx10：期望为线性时间的选择算法
 
ailx10：最高分是多少
 
ailx10：栈和队列
 
ailx10：双向链表
 
ailx10：数组中重复的数字
 
ailx10：二维数组中的查找
 
ailx10：替换空格
 
ailx10：从尾到头打印链表
 
ailx10：重建二叉树
 
ailx10：二叉树的下一个节点
 
ailx10：用2个栈模拟一个队列
 
ailx10：fibo数列第n项
 
ailx10：旋转数组的最小数字
 
ailx10：矩阵中的路径
 
ailx10：剪绳子
 
ailx10：机器人的运动范围
 
ailx10：二进制中1的个数
 
ailx10：数值的整数次方
 
ailx10：打印1到最大的n位数
 
ailx10：删除链表的节点
 
ailx10：正则表达式匹配
 
ailx10：表示数值的字符串
 
ailx10：调整数组顺序使奇数位于偶数前面
 
ailx10：链表中倒数第k个节点
 
ailx10：链表中环的入口节点
 
ailx10：反转链表
 
ailx10：合并两个排序的链表
 
ailx10：树的子结构
 
ailx10：二叉树的镜像
 
ailx10：对称的二叉树
 
ailx10：顺时针打印矩阵
 
ailx10：包含min函数的栈
 
ailx10：栈的压入、弹出
 
ailx10：从上到下打印二叉树
 
ailx10：二叉搜索树的后序遍历序列
 
ailx10：二叉树中和为某一值的路径
 
ailx10：复杂链表的复制
 
ailx10：二叉搜索树和双向链表
 
ailx10：序列化二叉树
 
ailx10：字符串的排序
 
ailx10：数组中出现次数超过一半的数字
 
ailx10：最小的k个数
 
ailx10：连续子数组的最大和
 
ailx10：1~n整数中1出现的次数
 
ailx10：数字序列中某一位的数字
 
ailx10：把数字翻译成字符串
 
ailx10：礼物的最大价值
 
ailx10：最长不含重复字符的字符串
 
ailx10：丑数
 
ailx10：Linux下求绝对路径
 
ailx10：最大乘积
 
ailx10：大数乘法
 
ailx10：六一儿童节
 
ailx10：迷宫寻路
 
ailx10：彩色的砖块
 
ailx10：等差数列
 
ailx10：第一个只出现一次的字符
 
ailx10：数组中的逆序对
 
ailx10：两个链表的第一个公共节点
 
ailx10：在排序数组中查找数字
 
ailx10：二叉搜索树的第k小节点
 
ailx10：二叉树的深度
 
ailx10：数组中数字出现的次数
 
ailx10：和为s的数字
 
ailx10：翻转字符串
 
ailx10：队列的最大值
 
ailx10：n个骰子的点数
 
ailx10：扑克牌中的顺子
 
ailx10：圆圈中最后剩下的数字
 
ailx10：股票的最大利润
 
ailx10：求1+2+3...+n
 
ailx10：不用加减乘除法做加法
 
ailx10：构建乘积数组
 
ailx10：无序数组的中第k小的数字
 
ailx10：大数加法
 
ailx10：C语言指针从入门到放肆
 
ailx10：gdb代码跟踪从入门到放肆
 
春风又绿江南岸，碧莲芳草酒连天。戈壁不识花间味，狂风劲草马蹄边。又是一个校招季，祝学弟学妹都能找到一个好工作～
本篇完～","上大学的时候，老师一直跟我们强调：“
算法才是编程的灵魂
”，由此可见算法到底有多重要，那么程序员应该要掌握哪些算法呢？
为了让大家有一个清晰的认识，我画了一张脑图，罗列出了个人觉得比较重要的且需要掌握的算法和数据结构，同时还整理对应的学习文章和书籍分享给大家，如果看完觉得有用的话记得双击点个赞哦，下面开始上干货：
1、数据结构
数据结构研究的内容就是如何按一定的逻辑结构，把数据组织起来，一般学习算法都是先从数据结构开始学习，先根据实际问题确定数据结构，然后在数据结构的基础上进行算法设计。
常见的数据结构有：常见的数据结构有：栈（Stack）、队列（Queue）、数组（Array）、链表（Linked List）、树（Tree）、图（Graph）、堆（Heap）、
散列表
（Hash table）。
2、常用基础算法
常用的基础算法包括：分治算法、贪心算法、动态规划算法、二分查找算法和分支界限算法等，下面列举每个算法的详细教程：
五大常用算法之：分治算法
五大常用算法之：贪心算法
五大常用算法之：动态规划算法
五大常用算法之：二分查找算法
五大常用算法之：分支限界法
3、排序算法
排序算法最经典的莫过于八大排序算法了，分别是：插入排序、冒泡排序、选择排序、
希尔排序
、堆排序、归并排序、
快速排序
、桶式排序。
排序算法很重要，考试和面试都会考察，而且是必考，我把八大排序算法的原理和代码都整理出来了，看下面这篇文章就够：
4、搜索算法
搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题解的一种方法。 现阶段常用的搜索算法有：枚举算法、深度优先搜索、广度优先搜索、剪枝算法、回溯算法等，以下是详细教程：
搜索算法之：枚举算法
DFS（深度优先搜索）和BFS(广度优先搜索)
搜索算法之：剪枝算法
搜索算法之：回溯算法
5、树与图
树与图相关是知识还是挺多的，而且很重要，想全面了解可以看书，推荐看《图解算法》，后面有下载链接。下面也整理了一些相关文章：
数据结构与算法――图最短路径
数据结构与算法：三十张图弄懂「图的两种遍历方式」
数据结构与算法――最小生成树
几道和「二叉树」有关的算法面试题
关键路径算法详解
大话数据结构-多路查找树（B树）_小地盘的诺克萨斯-CSDN博客_多路查找树
6、优秀的算法书
在这里我也整理了一份
由易到难的算法学习书单（附下载链接）
，希望能对大家在学习算法和找工作有所帮助！
1、《我的第一本算法书》
这本书是京都大学一个计算机教授和朋友联合出品的动画讲解算法的App 所衍生出来的书籍，非常适合新手朋友们。里面没有枯燥的理论和复杂的公式，而是通过大量的步骤图帮助读者加深对数据结构原理和算法执行过程的理解，便于学习和记忆。将本书作为算法入门的第一步，是非常不错的选择。
链接：
https://
pan.baidu.com/s/1r_lxqz
fg7YTHvAEQhNJwnQ
提取码：en9j
2、《趣学算法》
本书从算法之美娓娓道来，
没有高深的原理，也没有枯燥的公式，
通过趣味故事引出算法问题，包含50多个实例及完美图解，结合学生提问，分析算法本质，并
给出代码实现的详细过程和运行结果
。本书可
作为程序员的学习用书，也适合从未有过编程经验但又对算法有强烈兴趣的初学者使用
，同时也可作为高等院校计算机、数学及相关专业的师生用书和培训学校的教材。
链接：
https://
pan.baidu.com/s/1gg4TXO
at08UK-ZziBvCuWw
提取码：l55p
3、《啊哈！算法》
《啊哈！算法》一切以实际应用为出发点，
通过幽默的语言配以可爱的插图来讲解算法
。其中涉及的
数据结构
有栈、队列、链表、树、
并查集
、堆和图等；涉及的
算法
有排序、枚举、深度和广度优先搜索、图的遍历，当然还有
图论
中不可以缺少的四种
最短路径算法
、两种最小生成树算法、割点与割边算法、二分图的
最大匹配算法
等。
链接：
https://
pan.baidu.com/s/1PLMxdb
qLcUmCUs0Ueb6ckA
提取码：9yyz
4、《
图解算法
》
这是一本像小说一样有趣的算法入门书，示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。书中的
前三章将帮助你打下基础
，带你学习二分查找、大O表示法、两种基本的数据结构以及递归等。
余下的篇幅将主要介绍应用广泛的算法。
链接：
https://
pan.baidu.com/s/1GZEp8K
I1Fm0U4Uek7BOWAw
提取码：am4o
5、《
剑指offer
》
这本书大家一定如雷贯耳吧，基本上只要你是程序员就一定会用到这本书，书里面剖析了50个典型的程序员面试题，从基础知识、代码质量、解题思路、优化效率和综合能力五个方面系统整理了影响面试的5个要点，
是程序员找工作必备的一本算法书。
链接：
https://
pan.baidu.com/s/1GD9yTg
lFZkn5n__965dKjA
提取码：mas8
6、《
算法导论
》
这本书真的称得上是算法领域的“圣书”了，如果把它从头到尾看完并且搞明白了，那么恭喜你，年入百万不是梦！
链接：
https://
pan.baidu.com/s/1Y1kXAy
QsZO3MA_kgfa5Jog
提取码：tl3x
最后
学习算法的过程，是非常好的训练机器程序思维的过程，所以，千万不要被动地记忆，要多辩证地思考，而且一定一定要在看懂之后自己用自己喜欢的编程语言实现一遍，一定要亲自实现一遍呀！！！
这一点太重要了。
如果你一直这么坚持做，你会发现，你的编程水平会越来越高，写的代码会越来越艺术，你会不由自主地考虑到很多性能方面的事情，时间复杂度、空间复杂度非常高的垃圾代码出现的次数也就会越来越少。
加油！！！","高赞把数据结构到基础算法都总结得很清楚啦~
想要在学习的过程中加深的对算法的记忆和理解，还是要理论实践两手抓。
这里就介绍几个田纳西大学助理教授
奥斯汀
・亨利（Austin Z. Henley）推荐的练手项目，其中涉及的算法、要点，下文会
加粗
。
文本编辑器
不使用GUI框架中内置的文本框组件，要如何搭建支持光标移动、选择、插入和删除操作的文本框？
这个项目中，存在两个主要挑战：
如何将文本文档存储在内存中
学习文本光标在流行的编辑器中的行为
不要小看这些基础的功能，其中有许多细节值得注意。比如当光标位于文本当中，按下向上箭头，光标会移动到何处？
△图源：Austin Z. Henley
如果你觉得这太简单，还有进阶测试：
撤销/重做
自动换行
最后总结一下知识要点：
用于存储文本的数据结构：数组，rope，gap buffer，piece table
文本光标的行为和实现
撤销/重做的
设计模式
：记忆，命令
分离文本视觉和记忆的抽象
别忘了还有拓展阅读哟：
2D游戏-
太空侵略者
即使是最简单的游戏也需要考虑数据结构和设计模式。
在这个项目中，你的任务是从头到尾实现一个定义明确的游戏。最好使用SDL，SFML，PyGame这样的2D图形库。
△图源：Austin Z. Henley
第一步，创建对象移动的效果。
第二步，了解有关游戏循环的所有信息。游戏实际上是在绘图、获取用户输入和处理游戏逻辑之间循环。
第三步，处理用户输入。
第四步，学习如何创建和管理所有游戏对象及其状态。比如如何生成动态数量的敌人。
第五步，学习如何应用游戏的逻辑。子弹头位置何时更新？什么时候会有更多敌人出现在屏幕上？怎么判定敌人被干掉了？游戏何时结束？
甚至，在进阶阶段，你还可以考虑引入AI，来制造更加“智能”的敌人。
编译器-Tiny BASIC
从头开始编写一种非常小的类似于BASIC的语言编译器，然后将其编译为任何其他语言。比如，用Python编写可以输出C#代码的Tiny BASIC编译器。
△图源：Austin Z. Henley
知识点：
词法分析
句法分析
递归下降解析
抽象语法树
语义分析
优化passes
代码生成
迷你操作系统
从这个项目开始，难度就加大了。
操作系统依赖于硬件，因此入门门槛比较高。但这个项目可以帮助你更好地理解计算机底层都发生了什么。
作者亨利推荐了一本免费电子书《使用Rust构建RISC-V操作系统》作为入门教材（地址见文末）。
△图源：Austin Z. Henley
知识点：
交叉编译
Bootloading
BIOS中断
x86模式
内存管理和分页
排程（Scheduling）
文件系统
如果以上四个项目，你都觉得so easy，那么就来尝试一下最后这两个高难度项目吧。
电子表格
电子表格应用程序（如Excel）将文本编辑器和编译器的挑战结合在了一起。
在这个项目中，你需要学会如何在内存中表示单元格内容，并实现用于方程式的编程语言解释器。
电子游戏机模拟器
这是一个操作系统+编译器的二合一挑战项目。
挑战内容是，编写一个虚拟机，让虚拟机可以像真实的CPU和其他硬件组件一样运行。
亨利
的建议，是从简单的虚拟控制台入手，比如CHIP-8。
网友建言献策
博客一出，在Hacker News、Reddit上受到了广大码农们的欢迎。
有网友说：
这些项目能让我接触到完全不同的领域和问题，比我日常的工作更能激励我。
并且，网友们纷纷建言献策，又推举出好几个优质上手项目：
从零搭建数据库
光线追踪
器
矢量图形编辑器
图像解码器
网页聊天室
pi计算器的位数
通用终端实用程序（如grep）
FTP客户端和服务器
所以，这些项目是否激发了你的灵感？
Talk is cheap. Show me the code. 快动手练起来吧~
传送门
博客地址：
http://
web.eecs.utk.edu/~azh/b
log/challengingprojects.html
Hacker News讨论（内含更多项目推荐）：
https://
news.ycombinator.com/it
em?id=21790779
《使用Rust构建RISC-V操作系统》：
http://
osblog.stephenmarz.com/
index.html
―完―
@量子位
 ・ 追踪AI技术和产品新动态
深有感触的朋友，欢迎赞同、关注、分享三连?'?' ? ??"
,,,,,,,,,,,,,,,,,,,,,
为什么美国程序员工作比中国程序员工作轻松、加班少？,"工作效率区别大吗？
感觉美国程序员工作时间灵活、加班少，相比与国内程序员工作，似乎压力小很多。但是美国程序员的产出却非常牛逼（如google、fb等）。难道是因为他们效率更高吗？如果是，国内程序员是否能提高效率减少加班和压力呢？","不是因为外国公司效率高，也不是因为他们开会多。同类的app，不论是电商还是视频，国内的app远比国外的复杂，变化更快，功能更多。三天一小改，五天一大改，过个节都要出一套ui，新功能层出不穷，做活动此起彼伏。
国内程序员的工作量，就是比国外的同行多，同样多的功能，国外程序员做，照样加班。
关键是，这些功能，真的有用吗？
知乎可以提问，可以回答，因为它是个问答社区。但它还能直播，能视频，能充值，能交易，能借书，能开课，还能众裁。正中间的按钮，有时是想法，有时是会员，是创作，是发现，但没人在乎，大家只是看看首页的时间线罢了。这么多的功能，对用户来说，体验不一定有几年前的版本好。
大量的加班时间，花在了一些可有可无的需求上。
微观上看，是kpi焦虑，宏观上看，是违法成本低。有多低呢？大概像水电费那么低。
多开几小时的灯，就能出个新功能，成本近乎于零，没人用也不亏，何乐而不为？没有法律层面的支持，劳动者就像在
囚徒困境
中，谁都不想加班，谁都不敢先走。
随着时间的推移，加班成为新常态，向各行各业蔓延。生活越来越单调，越来越重复，人从生产者，转化为生产资料。","你自己随便拿出一个app看看吧
淘宝，支付宝：要喂小鸡？要建农场？
拼多多：要各种小游戏，要砍一刀，要各种抽奖抽红包（100%最大奖但就不行，你就得花几秒钟去看一个抽奖动画）
微信：直播，视频，小程序
美团：也是各种小游戏，稍不留神就点进去了
中国的KPI啊，明明是个购物app，明明是个支付app，明明是个外卖app，明明是个即时通讯app
为什么要增加那么多各种各样花里胡哨的小游戏？
亚马逊有小游戏吗？
PayPal
有小游戏吗？Google有小游戏吗？
说白了，不就是骗老板骗投资人的钱吗？
无法增加用户时长，咱们就小游戏走起，甚至送钱让你玩各种app内置的垃圾游戏，说白了，就是花公司的钱，花用户的时长，增加自己的绩效。
往上，骗得是投资人和老板，一看数据，全都增长
往下，坑的是用户，版本三天一小更，五天一大更，让你每天多花十来分钟挣那几分一毛钱
往内，写代码的不堪其扰，一会这需求，一会那需求，天天996，把自己的app跟摊大饼似的，约摊约大。","嗯，被经理举报了：
现在我切换到表扬模式。
是的，他们效率更高。
但是，国内程序员不可能通过提高效率减少加班和压力。因为这事的决定权不在你而在公司。
之前“开发和产品经理因为识别手机外壳颜色而打架”的传闻之所以能引起广泛共鸣，就是因为这类事实在太普遍了，太多人感同身受。
因为中高层
聪明
。
太聪明了。聪明绝顶、英明神武、别具慧眼、大巧若拙、福慧双修、
绝圣弃智
、兰芷蕙心、七行俱下、上智下愚、秀外慧中、足智多谋、聪明绝世、聪明睿智、聪明正直、精明能干、才清智高
――
人家喜欢听好话，咱得多说。尤其像这个水平的，起码值一千个关于聪明的形容词，对吧
。
可惜俺才疏学浅，实在凑不够数。只能列出八百个――不信您数数，足斤足两，一个不少！
啊？别看评论区。那都是不识数的。数到八百太难了，也就您这么聪明的能数清。不信您点点，八百！少一个俺再赔你一千个！
怎么样？满意了吧？
满意了我们继续。
所以，当你花大力气设计了一个精简高效的架构，把一个很难的问题干净漂亮解决掉时，绝不会有人击节赞叹――恰恰相反，他们觉得你捣鼓了个把月才产出几百行代码，反而会犯嘀咕：这人是磨洋工呢，还是不会？
你面向搜索引擎编程，乱七八糟拷一大堆东西到代码里，用到用不到都留着，KPI表现反而会特别亮眼。
一天几千行代码当然亮眼。
一群外行，怎么会知道这几千行里面就两行有效呢。
类似的，你兢兢业业，一个bug都不让出，人家就把你忘了；反之，你大大咧咧，一个功能你能写出800个bug――经理看起来就很忙很努力，因为他得不停的和你交流；你也很忙很努力，不停跑经理那里讨论问题：全公司你最忙你经理最敬业，不奖励你俩还有天理吗？！
你看，你好我好大家好，身为聪明人，你为什么不多写点bug呢。
当然了，这是极端情况。大多数公司还是没这么极端的――他们的中高层还不是那种
聪明绝顶、英明神武、别具慧眼、大巧若拙、福慧双修、绝圣弃智、兰芷蕙心、七行俱下、上智下愚、秀外慧中、足智多谋、聪明绝世、聪明睿智、聪明正直、精明能干、才清智高的
。
即便如此，他们中的绝大多数――包括多数程序员――仍然不懂软件工程。
他们并不知道，或者说并没有想过，今天你写的每一行代码，都会是明天的新代码的地基。
即使你知道，也没办法让中高层明白。
如果你今天写的太过随意，明天就很难在这个基础上扩展它；如果你着急完成任务，今天不先把昨天的设计缺陷修改掉，而是想一个办法绕开……那么明天你就不得不绕着圈子躲开更多问题。
越往后，就越难改；越难改，就越容易出bug。
但是，如果你想改昨天的代码，你就得先解决前天的问题；想解决前天的问题，大前天乃至大半年前的设计缺陷你就得逐一解决掉。然后，这大半年里，你就完不成任何新提的需求。
反正至多做三两年我就要换工作了。随他去吧，完成眼前的工作要紧。
因此，为了急功近利的眼前效率，中国程序员的长远效率自然变得极低――越往后越低。
我曾经接过一个任务。
因为高层设计的严重问题，我们不得不在
网络通信层
去
更新用户登录状态
（稍微懂点的都知道这需求有多奇葩：打个比方的话，这就好像让发动机制造商在活塞上做一个阀门以便随时泄压一样怪异。原因是我们的整车商忘了装启动机也没有离合器，所以需要减轻发动机阻力方便人家把车推起来）。
项目经理不懂。他觉得一条SQL语句也就是0.0x秒的事，我们的流程耽误1秒问题应该不大，所以就答应了。
我说每个用户都可能卡这么0.0x秒，人多了咱这模块吞吐量就没法看了。这个咱不能接。真要接也行，得改成多线程架构，得多安排时间。
经理说没事，直接加就行。做出事了他们负责就是（言外之意，一旦接了这个，将来我们自己的锅也有办法拉他们一起来背）。
既然都这么说了，我就动手做。
做完，内部测试没有任何问题；但一上线，整个系统死了。
原因是，那个库负荷特别大，一条数据库更新语句能卡几秒甚至几十秒。将来人多了还会更卡。
经理说，算了，你改多线程吧。
我思考了三天，决定不动我们这边的架构；而是设计个thread_call接口。任何传给thread_call的函数都会在另外的线程里执行――为了避免读写到调用函数的局部变量、然后在线程执行时调用函数已退出，thread_call内部会自动申请内存，把转交给工作函数的字符串等通过指针引用的参数统统复制过去；当线程执行结束，函数返回值也会保存在某地等待查询（超时或查询后自动删除），同时释放用到的资源。
为了实现这个，需要一个全局单例类负责管理线程、及时清理用到的资源；同时最好有一个线程池和一个内存池，免得频繁申请/释放。不然长时间运行下去，把内存弄的千疮百孔，程序就更容易出问题了。
内存池我已经写过一个泛型版本，直接拿来用就行。剩下的线程池、资源自动申请/释放（基于RAII和泛型，不支持原始指针因为无法确认空间大小、也无法确保复制成功，玩过泛型的都懂），加起来一百来行代码解决。最终代码量300多点，其中一大半是注释。
这个东西轻松的一次编译通过；然后挺过了各种测试，没发现任何问题。
这东西差不多相当于给C做了个简易协程框架（当时协程概念还没流行起来，不然我就把
yield
也实现进去了），今后遇到任何类似的“需要并行工作、但又不涉及数据竞争”的需求，直接写个处理函数然后丢给thread_call执行就好。
你看，如果程序都照这样写，是不是就会越写越快？
因为你昨天写的东西，今天可以拿来就用。写的越多，积累越多，实现新功能时需要重新实现的东西就越少，效率自然越高。
但是这个东西让项目经理作了难。
这是因为，如果算KPI的话，等于我花一周写了300行代码；然后又测了一周……两周300行代码的产出，这实在太少了。
反观别人，一个用户注册，人家一个字段一个字段一个字节一个字节的用代码检查、复制，轻轻松松搞出来500行。很水的几个功能轻松灌水上万行代码，然后部门KPI也有了，个人重要性也体现了――而且修不完的bug：你看，离了我们这个部门，公司真不能过啊！
可我傻乎乎的300行代码搞出这么复杂个东西，竟然还测不出bug……项目经理是知道这里面功能多，但上面觉得你忽悠他。300行代码你还能吹出花来不成？
而且，既然没有bug，以后人家还需要你这个部门吗？问题都解决了，我们这些人……还有继续雇佣的必要吗？
总之，他希望以后再写程序，尽量写长一些……而且，为什么要复用呢？其实每一个类似的需求，都是可以给他整个几万行代码出来的嘛。
没错。人家的预期是：这是个挺复杂挺难的任务，你应该加班加点忙上几个星期，提交几千上万行代码，到时部门KPI有了个人业绩也好看――将来每个类似任务都应照此办理。
而我呢，轻轻松松300行代码，杜绝了类似任务的出现――什么都不用管，加一行thread_call，全都妥妥贴贴了。
一个任务对应一行，这KPI还能看吗？
你看，面向目标的不同，面向KPI编码就必然使得实现臃肿、问题频发、每天996过劳死……但做起来其实轻松愉快，因为你完全可以磨上仨月洋工，然后吹嘘“多线程有多难”；然后还能让高层不断找你、解决诸如野指针、数据脏读脏写、死锁、内存碎片导致长时间运行后大块内存分配失败等等等等疑难问题――既让你显得重要，又能轻轻松松“骗”来大量的KPI，最后还不需要去学鬼画符一样、难的不要不要的泛型技术……
而面向问题编码呢，借助泛型，自动识别、复制函数参数（它们可能来自调用者的栈，随时可能失效），再加上用池来加速资源回收/分配效率、提前杜绝内存碎片问题――这完全是个简单轻松解决的小模块。而且只需解决一次，我们自己的“类协程库”都出来了，以后写程序会越来越快、越来越好：你甭管我怎么做完的、耗了多少时间，功能点我给你实现了、上线后
bug free
，是不是对双方都有利？
但是，后者在这个公司行不通。
代码量少没KPI你气不气？
bug写的少没人找你显得你不重要，倒霉不倒霉？
将来项目失败抓人背锅时，别人说我天天加班996007态度端正；而你呢，955一分钟班不加，这态度是不是很能说明问题？
从上到下都不懂你能怎么的？
别说这家公司的管理者了，他们的技术人员自己都不懂。我两个关系比较好的同事，还真以为我们是公司里干活最少、最不重要的几个呢。
因为别人忙忙碌碌总有干不完的活、修不完的bug，高层中层领导天天围着转，求爷爷告奶奶但任务就是做不完，重要的不得了。而我们几个公司公认的技术专家呢，每天到时间就走；座位上冷冷清清，从无领导过问；经常上班时间闲极无聊于是借“学新技术”的名义逛论坛……
时间久了，他们自己都心虚：为啥别人总是有干不完的活、见不完的领导？为什么我们经常整周整周的没有任务、闲坐着发呆？人家是不是比我们干的多、任务难啊？不对啊，每次分配任务，分给我们的，都是别人接不了、不敢接的啊？
直到有一天，午饭后散步聊天打屁谈到这事，我才觉得不对，提议回去看看工作日志/提交记录之类东西。
那天我们大概照例聊到了下午三点吧――没错，因为事少，因为要都要不来工作，一个月至多也就忙一周，955都大块大块的空闲时间。别说加班了，平常上班我们都经常偷空出去散步。
悠哉游哉回到公司之后，我们就去翻看所有同事的提交记录和bug报告数据。这才惊讶的发现，我们比其他同事完成的功能点数量高出5~10倍、难度也普遍更高，bug率却近乎为0――别人一个功能点能有密密麻麻几十个bug，而且上线几年bug都抓不完；而在我们看来，这些都是压根就不应该发生的低级错误，而且我们提交的代码的确不包含这类错误。
所以，别人一年只做三四个功能点，每个功能点都要出十几、几十个bug；而我们呢，一年起码几十个功能点，加起来不过3~5个bug（我更是一年只有1个bug，而且bug原因还是需求没写清：某个字段让返回字符串，我按照C惯例后面加了个‘\0’；对方用的java，不能识别这个\0）。
问题是，“我们接的任务最多最难”，这事我们项目经理知道，中高层领导不知道。
中高层领导知道什么呢？他们只知道，这个任务总是在别人那里卡住；他们只知道，系统出了问题，该找的人肯定不是我们几个（从不出bug自然不需要找）――所以你猜，在他们心里，谁更重要？
于是我决定辞职。
这是我第一次进这种公司，也是最后一次。
因为这种公司完全是“逆淘汰”。水平越差越吊儿郎当越吃香，水平越高越兢兢业业越被边缘化。","先说结论：跟国外公司比，国内公司最大的问题就是管理者素质不高，对问题的边界定义不清楚。提需求的人没有成本，无止境地提不靠谱的需求。码农自己开发时也追求快糙猛，提高了系统的风险。总的来说，经理很忙，产品很忙，码农很忙，测试很忙，运维也受不了。。就是这样的结局。
我在血汗工厂，大亚麻。整个大部门有80号码工。想知道大家工作有多轻松。。。我先上图为敬。
这位是最忙的。。这Commit记录你们看着办。。。 我们部门是前两年重组出来的，做了七八个全新的项目，按血汗工厂的风格，SDE是要full stack的，还要讲政治，写个类都要摆出个设计文档。跟自己组，隔壁组过完设计，大家blibli一通留言，然后针对几个service的API划分和命名再掰扯个一周。最后谁都说服不了谁，摆出一句”求赐名“这时高级经理或者SDE会猥琐地从希腊神话里找一个神的名字出来命名service，再随机指定几个比较顺眼的命名，会议就结束了。
除了内部Tech的会议，偶尔也会参与业务方的会议。在这里也是要讲政治的，你参会了就必须要多说，无论说什么，一定要存在感巨强。当小透明是行不通的，为什么，小透明就说明你这个人没想法，能力不行啊。某种意义上，声音大就是impact，就是能力！！有没有！！
接着说对SDE full stack的要求。你以为我们有前端，有测试，有运维？想多了，新开的service，如果涉及前端页面。是要自己写的。。。。没错，别管你是前端工程师还是后端工程师还是算法工程师，首先你得是个工程师，工程师就没有解决不了的问题。。。我们做前端时也要开很多会啊，跟业务方沟通进展和Demo时，业务方可以提意见，一旦提了意见是要sign off的。不是随意说说那么简单。这样有个好处，很多东西定下来了就不随意改变。提需求的人是面临很大的成本，你老提了需求又改，又sign off，不出两月大家就觉得你这人不靠谱，会给你很差的反馈。
谈完了前端，该到开发阶段了吧，开发时50%的时间在也业务代码，50%的时间在写测试代码。如果没有测试代码，code review是说啥也过不去的。写完代码之后，内部有很完整的自动部署工具，把你的单元测试，集成测试都跑完，然后部署测试环境，
gamma
环境等等。包括日志监控，都是要自己上手的，也是前文反复说的
full stack
的概念。SDE真的是
Someone Does Everything
啊。。。
这么一说确实挺忙的，实际上50%的时间都在会议，20%时间写代码，20%时间写测试代码，10%时间捣鼓一下配置，监控。但从来没有人加班，整天在家办公，这公司怎么还没黄。。怎么还没凉。
我来总结一下，会议是生产力。讨论得越清楚，返工就越少。比如系统设计，几个组的人一起讨论清楚系统的边界，上下游系统的关系，你的问题边界和需求是很清晰的。码工自己嗦嗦地对全流程服务。测试，运维等看似工作量繁重，实际上有效地降低了风险，极大地提高了软件的质量。
跟国外公司比，国内公司最大的问题就是管理者素质不高，对问题的边界定义不清楚。提需求的人没有成本，无止境地提不靠谱的需求。码农自己开发时也追求快糙猛，提高了系统的风险。总的来说，经理很忙，产品很忙，码农很忙，测试很忙，运维也受不了。。就是这样的结局。
我说得这么清楚，应该大家都了解了吧。求赞。。比心。。
最后
如果对您有帮助，点赞让更多人看到
关注 
@凯威讲堂
 关于学习、升学和就业的问题都可以私信我
关注公众号「凯威讲堂带你上岸」，第一时间了解内容更新","其实科学的规划和合理的安排可以令每个人的工作量减少的同时令结果质量更高。
然而有些人就是不信，怎么办呢(摊手
国内很多公司的领导自己都没有想清楚就交代任务。自己多做1%，就可以让好几个手下减轻一半的工作量，稍微动脑子优化一下流程更是不得了。其实这就是领导能力差的表现，他们还不自知。真正的领导能力不是令人服从，而是让大家用正确高效的方法完成任务。","先问是不是，再问为什么。
难道美国的程序员就不加班吗？他们就一天八小时工作，还想来就来，想走就走？非工作时间完全找不到人？还有什么食物饮料都免费提供？
让我来告诉你真实的情况吧，还...真是这样的。
加班文化应该是中美两地最明显的不同了，形成这种差异的原因不是一两句可以讲清楚的。我在两个国家都工作过，也在不同岗位工作过，所以就尽量从不同角度来简要说一下。
国内程序员加班严重，首先问题不在程序员这个群体。
产品层面拍脑袋决策多
产品层面，拍脑袋决策多，美其名曰：互联网思维、小步快跑、试错思维，其实是没想清楚，反正我就需求一提，技术团队来做，上线后成功了我是产品天才，失败了也没啥坏处，找个借口说什么“互联网市场变化太快”也能搪塞过去，或者找个新项目，继续画大饼。
国内的产品经理实在是太多了，很多还是刚毕业的小鲜肉，没有一点经验积累，凭借天马行空的想象力，提一个需求，就能让一帮技术专家为之操劳好几个月去实现，这简直是不可思议的。即使产品经理很厉害，但人数一多，每个人都要业绩，都拼命想点子、提需求，技术团队怎么能招架得住那么多需求呢。于是就会这些现象：
    节假日来了，我们上一个活动，或者节日小彩蛋功能。
    竞品上了一个 xx 功能，看起来不错，我们也抓紧上一个。
    10个产品经理同时跟你说：这个需求我跟老板对过了，xx 之前必须上线。
产品经理没有想清楚某个功能的价值，或者带来的收益不痛不痒，而技术团队则需要为此付出巨大的心血，也就是加班。当然这也不一定是产品经理的错，国内公司，老板的指令太多了，不说了，你懂的。
在美国这边，产品经理大多是行业经验非常丰富的人，要么是从工程师转过来，要么是从多年的商业领域经历然后读个 MBA转过来。上线一个功能，经过严谨的理论推演、多轮前期调研、科学的 AB test，从提出 idea 到最终用户看到更新，经常耗时半年或一年。很多不成功的 idea 还没面市，就因为数据不好而“胎死腹中”。这样一方面提高了产品需求的质量，另一方面也给技术团队足够多的时间来设计和实现一个可持续发展的架构。
技术团队话语权低
管理层在做决策时，往往更重视产品更新迭代，而忽视技术的建设。
比如说技术团队有100个小时，老板可能会把90小时都投入到实现产品功能，给技术优化、修补技术债务。于是就会出现技术实现非常粗糙的情况，举个栗子，给你一周时间，实现一个 IM 功能，你还会考虑什么模块化、可维护性、性能优化之类的吗？当然是怎么快怎么来，百度一下有没有别人实现过的代码，ctrl+v / ctrl+c，一点运行，诶，跑通了，上线。
所以国内很多程序员看别人的代码，感觉都是一团 shit，完全没法维护，干脆自己重写一个。
技术老大能跑到老板面前说“我们先把产品需求停一停，让我们的技术团队好好地优化一下基础设施吧。”吗？只要他不是傻子，都不会这样说。
话语权低还体现在，对产品几乎没有决策权，甚至不能质疑产品决策，提反对意见，总会被产品经理各种理由挡回来，产品经理有一句话终结争论的尚方宝剑：这是老板要做的。
久而久之，技术债务越堆越高，bug 越来越多，程序员不加班，谁加班？
而美国公司的现象是，技术话语权非常高，一个没想清楚的产品需求，能被技术团队直接打回去。同时，技术团队可以自主地花很多时间在技术优化上面。产品不能按时上线？经理说：没关系，延后，按照最优的技术方案来推进。有时候你想赶紧上线，提交一段粗制滥造的代码，会被同事鄙视死，被老板骂死。
每个季度最后一个月，专门抽出精力，来弥补技术债务，产品需求放一边先。
在这样的环境下，短期看起来效率低，但长期是最高效的。国内是“欲速则不达”，美国是“慢工出细活”。
技术基础设施差
知乎上有一个比较热门的讨论：腾讯的技术建设是否落后？
这不但是腾讯的问题，实际上绝大部分公司的技术基础设施都非常差。
有多少个公司能养一个专门的 Infra 团队？有多少个技术团队能专门成立一个小团队，进行 Infra 优化？即使有，有多少个公司能保证 Infra 团队的成果能在全公司推行？
我相信能做到这样的公司是凤毛麟角的。
中小公司不必说，在这样高度竞争环境下，哪有财力养一个不能直接带来 KPI 提升的团队，即使有钱，也没时间搞优化。
而大公司呢，即使腾讯这样的体量，有一个 TEG 事业群做基础设施建设。但是现实情况是，依然没有全公司通用的内部工具，各个团队依然在重复造轮子。阿里算是做的很好的，前几年开始推行的大中台战略取得了显著的成果，解放了各个产品部门的生产力。
计算机程序这种东西，一个人写和一群人写，几千个用户使用和几千万用户使用，是完全不同的概念。没有强大的基础设施建设，技术团队越壮大，效率越低，用户数越多，bug 越多。出来混总是要还的，今天没有人关注基础设施，未来就会又无数个程序员为此加班。
而说回美国这边，专门的 Infra 团队几乎是每个公司的标配了。这也是工程师文化的结果，创始人、高管团队一定有很强的技术背景，走过了很多弯路，所以非常重视基础设施建设这种“重要而不紧急”的事情。
畸形的职场文化
最后再来说说文化的差异。
美国人非常注重个人和家庭，牺牲自己的时间来给公司加班，这是不可能的。一到下班时间准点走，非上班时间完全不查邮件。很多公司入职培训就专门强调了怎么平衡工作和生活，其实就是说：下班时间就是你的时间，你有权利不处理公司事务。
反观国内，不知道从什么时候起，加班就是约定俗成的。还出现了看似很有道理的人生经验，比如“年轻人就应该多拼一下”，“加班能学到更多东西，对未来也有好处”。
加班，竟然成了光荣的、可以拿来攀比的现象，比如说加班到凌晨一两点，拍个照，发个朋友圈，收到老板的点赞很开心。而管理者呢，还就吃这一套，谁加班多、会来事儿，考核的时候就更有好处。
在这种加班氛围下，甚至还出现了“伪加班”。早上十点到公司，上个厕所、看会儿新闻、刷刷朋友圈，就到十一点半了，什么工作也没做，然后准备吃午饭；饭后逛一逛、睡个觉，又到2点上班时间了，写会儿代码、刷刷知乎，一下午又过去了，很多公司有免费晚餐，吃完饭回来7点左右，再写写代码，磨到10点。哦耶，又是充实的一天呢，发个朋友圈给老板知道。
其实一天有效工作时间还不够8小时，但就是“加班”了。
综上，大概就是国内加班严重的原因。
我觉得这也是某个时代特有的现象，谁都没有错，谁也没有办法改变这种情况。在国内这样一个高度竞争的环境下，公司为了生存必须跑快点，个人为了发展必须多做事，毕竟你不做就会有千千万万的人来抢。等到中国真的发展到美国这样的发达程度，生存的压力减小了，才有可能谈更好的生活品质。
关于找工作，我拿到过 Google/Facebook 等大大小小公司的众多offer，如果你想知道怎么在北美求职，
欢迎关注我的公众号“LJ说”（ID: LjNotes），回复“硅谷”查看独家秘籍~","我在参加工作前看过《
人月神话
》，思想上也很受推崇
敏捷开发
的国外前辈影响，加上我工作的大部分公司都是外企，所以，我观念上早就认定这样一个道理：
一个程序员如果一周工作时间超过40个小时是肯定会降低工作效率的
。
换句话说，加班肯定会让程序员工作效率降低。
当然，话不能说死，有一种加班实际上有利于效率的，那就是程序员主动加班（我说的是真的主动，而不是签了“奋进者”之类协议之后的“主动”），如果程序员真心热爱自己的工作，停不下来，加班把事情昨晚，当然更好。但是，这同样不长久，之后程序员依然需要休息才能恢复过来。
其实，当过程序员的都明白这个道理，
绝大部分加班都是效率低下的表现。
要是效率真的高，还很犯不上加班，那么，为什么程序员还要加班呢？
我再说个大实话吧：
绝大部分加班，都是管理者无能或者无耻的表现
。
管理者如果懂得现代管理，知道让员工发挥主观能动性、让员工热爱这个公司、让员工身心健康对公司对员工都是好事，那就不会强制加班，但是，我国目前大部分管理者无此觉悟。
我国大部分管理者和资本方的意识（或者潜意识）是：我给你工作机会，我培训你工作技能，我给你工作经验，过几年之后谁说的准你还跟不跟我干，赶紧压榨你才是正经的，能多压榨一点是一点，什么科学管理，狗屁，没那时间也没那必要去搞。
从程序员角度出发，这个行业风气如此，你对一个公司不满意可以辞职不干，但是你换一个工作可能还是这样的风气，所以你逃不出这个行业的魔掌。
谁也没办法和风气作对啊
。","来传递点负能量，做了4年多游戏了
在国内做游戏都是外行指挥内行，做的越快越多改的越多
还不如直接拖到deadline之前做完，大家都没时间改，你好我好大家好
在国内，你做的快是工作不饱和，下次分配任务你会被增加工作量，而且你做的快还不能早下班，早下班就是没有集体意识
这种环境下怎么出效率出产品？
还有看楼下说开会的，国内开会现在也开，开会定了之后leader说改就改，你还不能有意见，因为人家说是对数据负责，改了之后的工期还要算在你头上，你上哪说理去？","时隔两年多，更新一下。
两年前相比，国内近年来对
devops
/（翻译为研发效能）开始反复提及，这也算是一种进步吧。
然而，和上一次说的情况相比，新的奇葩问题又冒了出来。
某司两年多之前声称要改革，然后...然后制定了一堆据说是反复研究了google之后定义出来的“研发效能标准”，比如啥
lead time
要多少天，覆盖率要多少（这个还算正常），说开发人员必须负责所有自动化用例编写（？？g家的兄弟出来说说，你们帮印度qa在写自动化？），什么自动化成功标志就是线上bug漏出只有多少多少个，哦，还有个啥圈复杂度（我是这么多年第一次听说）...
此外还加了一堆线上运维指标...
其实说白了就是自动化覆盖+运维响应，这也没什么稀奇。然而这帮中层干部就开始作妖了，说一定要统一，单测框架要统一，研发流程要统一，工具全部要统一。这个统一不是业务开发说了算，是并不负责业务产品的研发部说了算。而这研发部呢，其实是以前多测试部门...
其理由是：业务团队的开发不懂怎么设计通用型服务（貌似qa很懂），所以不管是xx还是yy（不说产品名字，反正都是大家从小用到大的东西）历经十多年内部的工具体系统统不算数，统统都是“没考虑通用性”，只有某顾问定义的“效能体系”下给出的工具才能是“标准统一”。
然后就疯狂要hc要人呗，做一堆奇葩的工具，这部门自己都无法全部串联起来，然后再申请hc，说要去“培训开发团队写单测”，不然的话开发者不知道不会写单测...
具体就不写了，不然太多细节。
总之好处是研发体验开始收到重视，是个好事，但由于中高层的一窍不通，底层一线缺乏实际经验，cr也好ci也好能起到什么作用都不清晰，只能说勉强在摸着石头过河。
然而不会有人出来回答：能否大规模统一使用jenkins
用jenkins？这tm怎么好去申报项目？怎么好意思在大众面前吹逼。一定要自研，一定要“统一，面向未来”...
******分割线******
举个例子，中国某家一线互联网公司，没有统一的ci体系，问一下有没有内部公用的jenkins系统，说都是各个项目组自己搭建维护（修正一下，今天了解到其实有一套，应该是在jenkins上搭建，设计思路很有些特色，虽然初次使用一如既往被网络隔离卡了一下，但是我觉得还是个不错的系统。然而，也失去了使用
jenkins
各种插件的可能。。。不过应该满足我自己团队目前需求了。这套他们自造的轮子似乎只是用来给应用做daily build，跟CI其实没啥关系，比如并没有针对单元测试做出什么东西，可能压根就没觉得CI要包括测试。。。）
然后不知道从哪里规定“代码必须只能在公司内部机器”，所以你要学美帝去work from home是不可能的，要接触代码必须在公司工位上。
所以呢，单元测试没有的，自动跑测试是没有的，code review更是做梦。
所以只能瞎check in，然后不敢回家只能等，出了问题赶快加班，测试全靠手，然后最爱扯性能和安全。
最可怕的是因为大多数中高层老板在他们的职业生涯中是在国内早期互联网浪潮中野蛮成长的，对现代开发流程和工具可以说没什么体会和了解，现在面临
新浪潮
的冲击，首先是要让他们自己能理解现代模式，这就更难，别人说老子不玩你那套一样在赚钱，你忽悠谁呢？
累吗？
但是另一方面，国内程序员自己也有相当大责任。小组之间互相不透明，生怕别人看到自己代码，不愿开放共享，造成难以独立debug（所以国内把“联调”看得很重）；对微服务不理解，很多喜欢把自己的东西作为“组件”（也就是库或者独立程序）提供，非要别的组用各种奇葩方式来调用，说自己已经提供了sdk，已经达到要求。。。然后就是各种艰难的调试。。。
还有个现象是一方面老板重业务，程序员又喜欢用性能做借口，我看起来很快就能实现的改动，下面的非要说影响性能所以要做几周。。。没有那种get things done的思维，一天纠结些细枝末节的东西。产品还压根没几个人用就在纠结性能～～～
我tm看着他们做得都累，何苦。","话说回来，谁会真的996满负荷拼命呢，还不是上有政策，下有对策，得过且过。
最关键的一点是，不能做一块总是能挤出水的海绵，否则就等着被挤干吧。
这不，世界杯话题聊了两个小时，晚上继续加班。
今天带薪拉屎 了40分钟，出去抽了三次烟，每次15分钟，聊聊各种话题（不包括上面说的世界杯话题）50分钟，午睡晚起了10分钟，早上打卡后早饭吃了15分钟，刷刷手机网页各类信息1个多小时，等着编译器转菊花......
我是996，我骄傲 ??。
最后补充一句，一个人加班是自己能力的问题，整个公司（大多数人）加班就是公司的问题。","恰恰相反。
国内程序员，单打独斗的能力绝对一流，不敢说远超越国外，但至少不逊色。
但问题是，为什么这些一流的程序员和在一起，同样的产出，却要比别人工作更长时间，付出更多辛劳呢？
我们不禁要问，我们多付出的时间和辛劳都去了哪里呢？
想到这，我要分享一个故事，就是最近，疫情期间，我朋友公司的故事。
朋友做Java后端开发，受疫情影响，公司业务大跌。
要说，这种情况下，大家应该无事可做才对，但和朋友聊天，情况恰恰相反，朋友的原话是：
“忙疯了！原来加班到10点，现在则是12点，活根本干不完！”
听罢，我回了句“呵呵”，然后冷冷的说：
“瞎忙，行为艺术而已！”
沉默了一会，朋友回复说：
“太对了，就是瞎忙！”
“因为没有业务，怕被裁员，大家就越拼命加班，好显得自己很忙，很重要的样子。”
“其实，公司都没业务了，做的东西不过是闭门造车，根本就是伪需求！”
“但这不重要，要的是态度，是表现！”
朋友的这段话，真真道出了程序员整日忙碌、整日辛苦的天机。而这个天机恰好在疫情期间被戏剧性的放大了，但本质和原来并没有区别。
不是我们的工作需要辛苦，而是我们需要做出辛苦的样子
。
因此，朋友，如果你是一名程序员，你可曾质疑过自己，我们每日开发的东西，有那些是用户真正的需求？又有那些不过是些“表演艺术”？
也许，经过思考后，你会发现，我们的忙碌根本经不起审视，它一直很“荒谬”！
荒谬的领导，荒谬的需求，荒谬的任务，荒谬的KPI，荒谬的…
最后，导致的是荒谬的忙碌！","严格执行劳动法
严格执行加班薪酬补偿制度
聚餐时看到这个问题，恰巧旁边坐了一位在皇家银行做码农的同学，问了一下他加班和工作强度的情况
他的回答是加班不少，但项目管理人员事先要和员工打招呼，并且发比正常时薪高两到三倍的加班费，如果是在周日超时加班，加班费可能高达正常时薪4到5倍。看在待遇的份上，他本人是很愿意加班的，毕竟下班回家闲着也是闲着，加班有这么多钱拿何乐而不为。
但，即使他想加班，所在岗位也不允许他随意加班，原因就在于高昂的加班费。
每次领超额的加班费，他首先要和项目管理人员签一份合同，他本人同意加班，经理同意发加班费，然后经理要拿着这个合同再去人事部门得到批准，人事和经理两边都过关后这份文件再转到财务部门，这时财务部门才给他发加班费用。
如果一个项目组总是要加班，总是要支付大额的加班费，财务部门就会面临超支的问题，质问项目组负责人在经费和人员安排上是不是不合理。如果项目方表示活太多人手太少，财务部门就要征询人事部门为什么事先不招够有水平的人；反之，如果项目总是出现延误而不得不临时加班，人事和财务要质询项目管理人员的管理能力。
当然，这里面有一个时间差可以利用。项目部门可以和工作人员签合同让他们加班，然后再以人事部门和财务部门不同意为利用不发加班费。我同学表示这种事情也发生过，不过非常少，经常这么干员工们会投诉，管理层会被纪律和HS（Health and Safety）部门撸掉的。
如果公司什么都不干，劳动法伺候之
不过
不过
不过
企业的应对办法有
1，找临时工，即劳务派遣工，contractor，虽然都坐在同一个办公室内，但这些员工不享受任何福利，没有退休金，没有劳务补偿，想让他们加班多久就干多久。作为平衡，这些人的时薪比正常员工通常高两倍。
2，不按时薪和月薪来，按照项目进度和完成度发薪水。开放远程和在线办公，八个小时工作时间排进十二个小时才能完成的任务量，如果你还是能在八小时内完成，算你是大神你牛×；如果不行，自己回家在远程平台上继续干完，不过既然是下班后自己在家干活，就不算是加班。
3，量大而简单重复性的工作交给实习生。实习生不算正式员工，任劳任怨，一般只要给比法定最低薪水高一点点的工资就分满足了。
4，签 zero hour contract，上面第2点的加强版，在合同里点明了这份工作要经常超时加班，下班后还要on call，你愿意签就来干活，不愿意就滚，一个愿打一个愿挨。
在就业压力下，以上4点很容易执行，大批老印老中排队干contractor同时还自愿把薪水降低到普通员工还低的水平。","美国的环卫工人每月的薪水也比中国环卫工人薪水高呢，找谁说理去？
难道美国的黑叔叔效率更高？","这个题目能出书了。两边的IT的企业五花八门，形形色色的都有。大部分答案都是抱着批判的态度。主要谈谈自己的看法吧。毕竟我也只在一家美国公司工作过，国内的工作经验为0，不足的地方希望指正。
社会形态的差异
社会形态的差异肯定是原因之一。美国是一个很讲究Work Life Balance（工作生活平衡）的国家，人权大于公司的利益。所以如果企业如果过分“压榨员工”，是肯定会被劳工部告的。大公司只要有任何风吹草动，都可能惹上负面新闻。
比如，
Google paid female employees less than male colleagues
?
www.theverge.com/2017/12/6/16742506/google-sex-discrimination-lawsuit-vague
告的就是Google付给女性员工的工资低。当然男性员工也在告Google。
Google accused in lawsuit of excluding white and Asian men in hiring to boost diversity
?
www.usatoday.com/story/tech/news/2018/03/01/google-accused-lawsuit-excluding-white-and-asian-men-hiring-boost-diversity/387532002/
举这个例子只是说，在我们眼里，美国是一个非常
“事儿逼”
的国家。两国人民从小接受的教育非常不一样，美国人偏理想主义，而中国人比较现实主义。
美国的企业非常怕事，哪怕他们没错，他们都会花重金摆平这件事情。比如前段时间的UA事件，Starbucks事件，都很好的说明了美国企业有多怕事。所以过度加班这种高压红线根本不敢碰。作为一个企业CEO，该破产就破产。美国的企业是非常好“碰瓷”的，告自己雇主的事情是在太多了。在我们眼里，屁大的事情他们都能够上法庭。公司即使没有错，也会花钱摆平。不然一帮好事的媒体整天在显眼的地方报道这些新闻，非常影响企业的声誉。
企业是趋于利益的。而且有时候确实需要加班来满足需求。所以很多公司喜欢雇佣亚洲人和墨西哥人，因为这两种人即使加班也不会抱怨。很多美国公司用各种非美国人的Contractor和ICC也是这个道理。
当然美国某些公司也是加班很严重的，比如四大。但是（听说）美国的四大好像没国内累。只是相对而言。
美国人看重家庭大于工作，家庭比工作重要。所以那种牺牲自我，保全公司利益的行为是很少会发生的。
当然中国也不是最差的啦。日本加班比我们多多了。这边加班太多了。日本人讲究的是为了工作可以抛弃一切。要论程序员的幸福度：美国 > 中国 >>> 日本。
我没有见过美国码农的公会。也没见过罢工。。。
公会发达的是欧洲。法国是公会的巅峰。啥屁事，都罢工，而且完全不管后果。你能想象地铁和大巴司机罢工吗？整个城市会陷入大混乱。有一次考试，我辛辛苦苦背完了所有的概念，结果地铁罢工，考试取消。。。导致我第二周得继续再背一遍。
封装和抽象
大学经常学的Encapsulation(封装）也是主要原因之一！OOP编程里面的封装其实非常重要。美国这边的公司非常注重Encapsulation。最简单的例子就是，用web framework去写server比徒手用原生java sockets去写要容易多了。
很多公司都喜欢Everything As Service (把所有技术都封装成服务），然后把这些Service做成Platform（平台），然后模块化。比如在Google，所有的Infrastructure（架构）都被封装成Service了，使用起来只要关心业务逻辑和资源分配就行，非常省时间。在新的Server里面加Feature也只需要加一个加一个新的模块就行。相比而言，如果花大量时间去调各种开源软件的配置，会花大量的时间。Google的做Infra时间比Facebook长，Infra种类多余FB，这也是“Google比Facebook轻松一点的一个原因”。
每次开发产品，我都有种搭积木的感觉。从web framework，到pipeline framework，到monitoring和resource，基本都是非常直观的事情。偶尔有问题，一个邮件就能解决。
平心而论，硅谷的Infrastructure比国内好太多了，每个公司都有专门的组去认真研发新的Infra。所以硅谷的公司，只要不是太小，都多多少少有一些开源的项目。
凡是做Public Cloud Computing的公司，封装都不会太差。国内现在很多公司也开始做了。因为Cloud Computing讲究就是把自己Infra打包给外面的程序员使用，同样的功能，接口越简单越好。如果外面的人都可以很好的使用，自己人就更容易了。
中国企业的迭代速度快
硅谷技术强，但是产品迭代速度比国内差太远了。所以，Uber，Airbnb，Linkedin在国内的市场表现都不怎么好。很多技术壁垒不高的产品，比的就是用迭代速度去占领市场。技术壁垒高的产品，不是迭代速度能解决的。
中国的IT公司对用户的需求感知的特别快，他们清楚的知道用户需要什么。国内公司对竞争对手的动作也特别敏感（抄的特别快）。你会发现， 阿里，京东比Amazon的功能多多去了。饿了吗，美团也比Ubereats功能多多了。王者荣耀的新东西出的实在太快了。
Google的大佬很多都是工程师出生，重技术，轻产品。而硅谷大部分有特色的新型互联网企业早期都有大量的前Google员工，所以这也是硅谷的一个特色之一。
所以中国的IT和硅谷其实是两种IT。迭代速度和发现新的Use Case是中国企业的强项。为了保持这个优势，唯一的方式就是加班了。","主要是因为在美国违反劳动法代价太大了，扯别的都没啥用……大家都必须合法经营的时候，自然是在这个基础上去比拼效率；而大家都可以一定程度违法（比如996）的时候，996的天生有优势，那么公司也都会倾向于996走起。在国内，目前无论是仲裁还是起诉，都难以对这种利用KPI逼迫程序员“自愿加班”的做法提出补偿请求，而且即使成功，也只是针对单个员工，并没有集体诉讼的手段，也没有集体诉讼的群众基础。
另一方面，中国程序员群体很年轻，买房、结婚压力很大，本身也有许多人愿意花更多的时间、甚至一定程度上牺牲健康来换更多的钱。这也导致程序员群体本身没有办法团结起来去反对996――如果严格40小时工作制，但是工资减半、年终奖减半，很多程序员也是不乐意的。
其实说到底，为什么美国对于劳动法执行这么严格？的确8小时工作制是无产阶级通过艰苦斗争甚至流血牺牲争取来的，但到了今天，坚决维护8小时工作制其实更有利于大资本家，因为如果不严格执行，大资本家有舆论监督，而小资本家偷着996，就很容易追赶上大企业，尤其是在互联网行业；反过来，严格执行8小时工作制，大企业就能在同等条件下产生体量优势。所以大企业会反过来推动更严厉的执法，保证小企业不会利用不对称的优势威胁自己的垄断地位。所以你也会看到美国不遗余力地要把劳工权益保护写进自贸协定里。中国反过来，大企业带头加班，这就比较烦人了。","这个我来答吧。本人在美国IT公司快十年了，大小公司都待过，也做过经理雇过人，从来没有加班过，除了唯一一次做release做到了半夜，当时还是report给一个中国老板！不仅不加班，而且我还经常在家工作。平均每天上班时间，扣除通勤，只有6个小时，额。。。很多公司还有unlimited paid-time off了。。。我每年带薪假至少用20天，不亏着，当然也不好意思用太多。这相当于每年工作11个月。
上班有时候还能开个小差，吃个2小时的lunch break，出去散散步，买个咖啡，看个医生啥的。我做的最过分的是在旁边ucsf开了个健身馆会员，有时中午开车去游个泳洗个澡，回来一身氯水味估计下属都能闻到。
为毛不用加班呢？分析有一下几点，有个人原因，也有企业文化和法律原因。
个人原因，我基本上都能meet老板的 expectation，不会有工作做不完的情况，所以从这点来说，我是不需要通过加班来弥补工作效率的。工程师也是个技术活，有人做的快，有人做的慢，我有些同事搞个小事都能做半天，教他也教不会，那他只能偷偷私下加班了。我也不喜欢加班，硅谷加班的公司其实不少，大公司每个组也不一样，有的闲的没事干，有的忙的天天加班。你可以避开哪些要加班oncall的公司，比如amazon就是比较有名的传呼机公司呵呵。虽说美国不养懒人，但加班也不是美国企业文化，更不是什么行规。如果有公司经常要求我加班，用不了多久我就会闪人，又不是找不到工作。
说到企业文化，美国公司更相信好的文化，积极的鼓励，健康的作息对企业的发展更好，这个是急功近利的国内软件业所不能体会的。很多人觉得写代码就像搬砖，加班多写一行就赚一行，其实这个大错特错了。写程序是有体力的成分但更是个脑力活，很多时候心情不好，身体不适，或睡眠不好的情况下，是写不出什么好程序的，更别提创意了。不好的架构，临时的代码补丁，低效的沟通，没有时间系统的研究问题，在代码里往往需要很多bug，修改，返工甚至推倒重来。这些最后都是企业的成本。虽说996的公司也许工资高些，但是如果是我的话，我宁愿用同样的钱招2个不用加班的人来干，这样的产出最健康。美国的很多公司都补贴gym的费用，流感疫苗的费用，鼓励员工搞好身体，这样才能更好的被剥削嘛。薅羊毛也不能不停的薅，总得让羊毛长长再薅，这样才薅的科学，薅的符合自然规律。一个个加班加的未老先衰干不动了，双输。
法律风险。为啥美国航空公司盛产空大妈？因为没人能证明空姐必须是年轻漂亮的女性才能胜任（养眼不算job function）。只雇佣年轻漂亮的属于歧视。话说回来，美国没有父母给带孩子的传统。每个公司都要求996，那有家有孩子的人咋办？只能坐等被炒鱿鱼或者干脆面试过不了？公司只能雇佣未婚未育的年轻人？这个在法律上无法解释的过去，因为没人能证明程序员的工作必须要年轻人，那么只雇佣年轻人的结果就是年龄歧视，属于法律上的雇佣歧视的sterotype一种，公司是可以被告赔款的。避免歧视这个在大公司HR培训里面都是会强调的。（其实这一条在硅谷现在不怎么好用了，有些公司明目张胆的要求加班甚至996，可能是因为码农好找工作所以大家选择多，不怎么计较，如果将来有码农的工会可能就没这么好说话了。对于大龄码农来说，这些要加班的公司性价比极差，工作时间可以多一倍，工资只能多一半，也只有年轻人愿意去了。）
最后，说实话，空大妈没关系，也就不养眼呗，但胖子空大妈最好还是别再招了。。。我能证明胖子空大妈挡着我拖行李。。。。","美国程序员工作比中国程序员工作轻松、加班少总体来说是事实，但都归结到美国程序员效率更高，制度更好之类就过于片面了。我觉得主要原因在于别的一些地方，例如加班的边际效用，程序员的生活习惯。
背景：我在baidu（北京）和
amazon
（湾区）都干过，微软研究院（北京）和google研究院（湾区）也实习过，因为目前做云计算和开源，所以也接触过很多公司。整体来看，
不觉得美国程序员比国内程序员水平高多少，特别是在年轻人身上。2000年后计算机专业红火，学生生源好，这些人是当前程序员的主干力量。而且中国教育在工程学科上更加扎实，适合培养程序员。
美国有非常厉害的领导者，例如几家大公司创始人都很厉害。但加班文化更多是每个项目的实管人控制。我见过好的，也见过差的。虽然没有具体统计过比例，但没觉得中美差异明显。
美国这边开会确实要多一些，但这个也是美国教育重视沟通相关（3，4岁的小孩就开始练习演讲了）。开会对于大组织有用，这样可以几百人在同一个思想层面往前冲，但用这个来衡量百来人的小公司就不见得适当了。
美国公司创新度更高，一是社会认可，二是不创新难有机会生存，三是国内只盯着创新的公司看。但创新公司加班很普遍，例如
Tesla
老大都睡在厂房。
所以我觉得问题在于一些更本质的东西。这里是我的几点观察：
第一是边际效用
。美国社会成熟度比较高，在湾区生活的同学也许过去10年都感觉不到特别大的变化，而中国则翻天幅度，特别是互联网领域。例如手机支付，美国普及很难，因为信用卡已经很普及了，手机支付带来的好处不显得很大。但中国的基础设施没跟上，所以手机支付在便利性上提升特别大，同样的技术，大家会不惜余力的去推广。
经济学上这个叫做边际效用。同样的技术，中国的边际效用比较高，所以大家可以全力推广。美国因为起点高，所以更加谨慎一些。
这个影响到了加班文化。通过加班可以完成更多工作。如果项目经理觉得这些工作带来丰厚回报，他们肯定会压着组员做。在中国很可能是这样，例如做出这个产品马上会有人用，升职加薪跟着就来。然而在美国，即使今天做出来，用户也是慢慢的过来，完全不需要急着那么几天。
第二是生活习惯
。美国程序员年龄普遍偏大，因为计算机行业在2000年在美国就很红火（参考互联网泡沫），培养的大量的程序员，这些人现在很多都有小孩。在美国小孩都是自己带，双方父母不怎么帮忙。请人又特别贵，例如湾区工作日请人带娃一个月起码是2千美金起。而且学校课程松，所以放学后都要靠父母照顾。此外，很多人住的房子都带院子，请人打理费用贵，很多时候大家亲自动手。例如
Robin
在创立百度前曾醉心于在湾区种菜。
于是在加班边际效用不高的情况下，大家纷纷早点下班回家做家务。并冠冕堂皇的叫work-life balance。
我认识好几个未婚朋友，他们觉得每天那么早下班实在是太寂寞，毅然回国去了创业公司，并对996大家赞赏。记得
Andrew Ng
也表达过类似的观点。
但反过来说，早9晚5真的好？
计算机技术日新月异，而且随着经历增长，需要提升各项领导能力。这些都需要足够多的时间去学习。我认识的厉害的人无一不是在下班后努力挤出时间工作，丝毫不比996工作时间少。与其现在羡慕别人轻松，不如埋头努力工作十年再来看。
===19年更新===
我对答案中对996淡淡的赞同表示很惭愧。反观我自己，在身体和家庭允许的一些时间里，可能每周会工作60、70小时。但如果每周坚持是不可能的。很是不赞同企业家大肆鼓吹必须996。","不知道别人的情况，说说国内的几个典型情况：
需求完成了一半，项目经理过来说领导 PPT 里的思路又变了，需求要推翻重来――面向领导编程日常一。
需求完成了一半，项目经理过来说客户方领导换了，需求不做了――面向领导编程日常二。
产品怪程序员脑子瓦特了，一点点需求做半天；程序员怪产品不懂技术，需求前后调整 7 次。
公司为省成本，找了几个实习生干活。实习生走了，留了一堆翔一样的代码，还得推倒重来。
你不愿 996 你就是没有价值观，性质跟抢月饼等同视之。
你不努力你的活可能很快就被培训班出来的所取代，人家还比你更便宜，应聘的排着队等。
今年的指标比去年增加了一倍，为了完成指标天天白天开会晚上写代码。
离职入职公司走马灯似地换人，接手的代码没文档，代码都不知道经手了几茬人，天天不是重构就是重写。","亚洲国家，人多资源少，没人能过上真正优雅的生活
要么你拼命，能维持阶层不倒退。要么你被别人踩下去
即使你觉得这样没意思，想安心过简单的生活，不想踩别人，还有人看你位置好，想踩你一脚呢
你跟中国人比谁牛逼，谁更会拼命，谁更拼命谁拿钱更多，这样比比就算了。人家美国欧洲的人，跟你不是一个维度的，谈不上在一个指标上竞争。人家生活质量高，不是因为人家更牛逼更拼命，而是人均资源丰富（美欧澳），靠金融资本生存（欧洲），靠掌控世界资源和能源（美国），靠已有科技优势（美日英法），靠资源出口（美澳）。。。各有各的活法，唯独不靠劳动压榨国民，不需要这么拼命搞
只有靠劳动力的国家，才尊崇努力奋斗，996，养老靠自己，70岁也要买房，这样
中国要复兴，宣传捋起袖子加油干。美国要复兴，川普号召工人去996了么？逗呢。人家要的是制造业回流，加强知识产权保护，要中国金融开放，唯独不逼着自己国民去加班，去延迟退休，去靠自己养老，去买房。。。
依靠劳动力的国家，老龄化就完了。所以中国歧视年纪大的，码农3040失业，前台只收年轻小女生，年轻人在北上广奋斗十几年然后被撵出去，等等
除了中国，亚洲的日本新加坡也是如此，新加坡活到老干到老，和天朝有一拼。不过它们发展的早，积累的红利多，福利情况好一点
简单的道理
现在你知道为啥人家要移民了吧。移民之后变nb了吗？非也。出了国门，没人在乎你多拼命多牛逼。也不要问为啥在美国朝九晚五就买得起大house，在中国996连首付也攒不起。情况不一样，单纯比谁努力，没有意义","管理文化不一样。
中国官大一级压死人，所以像狗一样言听计从的狗逼多，上面说什么就干什么，不考虑可行性，不会据理力争，然后把pressure压给下面，到时候甩锅下面。
美国，你是一个manager就要为自己的决策负责，干不成要买单，因为你对你的同事有责任，于是会陷入管理层的bullshiting，很多事情就不会放下去做，也会丧失一些idea实现的机会。所以下面干的轻松。
说白了，中国就是靠着频繁的无用功来以量取胜，奈何我国农民太多，这帮农民失败了就无处可去，他们失败了就是死路一条。所以你是这种人的管理，让他们跪下来叫爸爸都行。
期待中国人口红利消失的那一天，让这些狗逼集中的企业彻底没人来，然后这些落后的企业淘汰完蛋，这些占据了资源的企业才是中国创新上不去的根源，它们不死，中国进步不了。就像当年的国企一样。"
,,,,,,,,,,,,,,,,,,,,,
学会了 C 语言真的可以开发出很多东西吗？,我现在c语言入门，基本靠自学，就看网上的那种教程，但是我怎么觉得它就是只能做下数学题，我觉得它并不能编辑出一个啥子游戏或者软件出来噢……初学者，见谅。,"马里奥碰到花朵就变身。
什么是马里奥？一个装着 16 × 32 个小色块的长方形，其中一些色块填着颜色，另一些没有。什么是花？一个 16 × 16 的正方形。什么是「变身」？把马里奥这个方块里面代表衣服的褐色变成红色，代表背带裤的红色变成白色。什么是褐色？暂且说它是 0x887000 这个数字。什么是「碰到」？马里奥的长方形与花朵的正方形有所重叠。什么是「重叠」？假设马里奥的这个方块占据屏幕（什么是屏幕？一个能装下 256 × 240 个小色块的矩形）中 X 方向 101 到 116、Y 方向 21 到 52 之间的区域，那么只要这个区域内有一点或更多点也被花朵所占据（比如花朵处在 X 116 到 131、Y 21 到 36 之间的区域内），我们就认为两者有所重叠。
若给定以八个数值代表的两个矩形区域，请写出判断两个区域是否有重叠的 C 语言程序。如果你能写出来，那么祝贺你，如果有朝一日你想自己用 C 做一遍 NES 版本的《超级马里奥》，你至少知道让他变身需要做什么了。
是的，C 语言也许「只能」做数学题。可是，绝大多数游戏的运行过程就是不停地做数学题，而所谓编写游戏，也就是把游戏的规则和游戏的效果转化为数学题而已。其中不少题目电脑都已经知道怎么解――是别的程序员事先告诉它的――比如「求一堆散落在三维直角座标系之中的多面体在 8(x?3)?10(y+1)?11(z?1)=0 这个平面上一个给定范围内的投影」或者「给定一些彼此相连的顶点，求任意两点之间的最短路径」之类的数学题，它只需要千万分之一秒就能给你解好。这种能力有什么用？电脑上 FPS 游戏的本质活动就是不停地求三维座标系下的多面体经过变换之后在二维平面上的投影，不停地判断两个多面体是否彼此重叠，以及不停地寻找两个顶点之间的
最短路径
，最终达到让怪物冲到你面前咬你一口的目的。不止游戏如此，其他软件也都差不多，每一个细节都是某种数学题――比如知乎页面顶端的蓝色导航条背景，是 CSS 描述的一个浅蓝到深蓝的渐变――渐变是怎么回事呢？给出两个数字分别代表两种颜色，以及第三个数字代表一段距离，求一系列颜色的数值以及次序，使得这段距离中任意两种相邻颜色之间的变化最小。数学题。别说 C 语言，一切编程语言最终都只能做数学题，根据给定的数据，算出另一些数据，算出更多的数据，然后存贮、发送或者呈现算出的数据。总结来说，
由于数学可以解释真实的世界，所以能用于创造虚拟的世界。
真实世界里的炮弹会以近似抛物线的轨迹下落，所以你在游戏里以抛物线不断绘制一枚炮弹，它看起来就很真实。
不过我能理解你的困惑。投入大量时间看完教程，结果只能在黑框里输出一串数字。这是在学编程还是在向七十年代致敬？编程是这样无法给人成就感的活动吗？是，也不是。看你的表述，应该不是小孩子了，因为小孩子不会因为初学编程能做的事情很少而没有成就感，或者说，觉得这样做没有成就感的小孩子根本不会继续学下去。最初学编程的成就感单纯来自于「我居然可以指挥机器做一些事」，至少我小时候用中华学习机编一个程序帮我算暑假作业上的
四则运算
题时是这样感觉的。写出这些程序并用它解题虽然远比自己动笔去把题目算出来费时，却让人乐此不疲。那时候我还不知道
马里奥
碰到花会变身这种事情其实也是靠编程编出来，所以我也不会去想学编程「并
不能
做什么」。
无奈大多数人过了一定年纪就很难再靠「我能指挥机器」这种简单原始的快乐来驱动自己学编程。见过世面，听过传言，欲望和野心变得复杂而庞大，你想要图形界面，音乐音效，人工智能，云端同步，可是你闷头学了几堂课，还是只学会在黑框里显示一串数字。你怀疑这是学 C 语言的错，于是你到知乎上来问了这个问题。
你的疑惑是有道理的。
如果能把编程学下去，日后你就会明白，任何程序都是一座冰山，最终用户能看到的界面和使用的功能，只是程序浮在水面上的十分之一。知乎这个网站其实也是个运行在某台电脑上的程序，你能看到的十分之一是用什么编写的呢？HTML，CSS，JavaScript，或者 Objective-C。而你看不到的那十分之九是用什么编写的呢？Python。这些你无法直接观测到的 Python 程序运行在世界某个角落的某些计算机上，隔着光缆、双绞线和无线基站，为你面前或掌上的用户界面注入生命。
（ 
xkcd: Python
 ）
……可是 Python 是用什么编写的呢？C 语言（当然，这么说并不严谨，Python 理论上可以用任何其他语言实现，实际上也已经被用很多其他语言实现了，不过这并不是重点）。任何编程语言都是实现某个功能的工具，Python 实现了知乎这个网站的大部分功能，而 C 实现了「用 Python 写程序」这个功能。为什么是 C？
C 很别扭又缺陷重重，却异常成功。固然有历史的巧合推波助澜，可也的确是因为它能满足对于这样一种系统实现语言的需要：既有相当的效率来取代
汇编语言
，且又足够地抽象而流畅，能够用于描述各种各样的环境之下的算法与交互。
C is quirky, flawed, and an enormous success. Although accidents of history surely helped, it evidently satisfied a need for a system implementation language efficient enough to displace assembly language, yet sufficiently abstract and fluent to describe algorithms and interactions in a wide variety of environments.
――C 语言之父，Dennis M. Ritchie
C 是初代程序员所使用的语言，那时候硬件很贵，软件必须高效；而计算机的用户都是职业程序员，对于硬件有足够的理解。C 贴近硬件，就意味着它容易译成机器能懂的语言，而它的设计者也并不需要操心普通人学起来可能会比较困难――而且，说真的，其实也不很难。但是，这么多年过去之后，软件规模变得越来越大，C 就像锤子和手锯，修小木屋得心应手，造摩天楼就比较力不从心；但 C 语言可以用来造出其他更适合建造摩天楼的工具，乃至组成摩天楼的预制件，就好比用锤子和手锯造出挖掘机和吊车、混凝土板和一体门窗一样（当然，这个类比并不十分贴切。可是没有什么类比能贴切地描述软件工程，因为软件工程像许多东西，却又什么东西都不像）。
所以，回到你的问题上来，是的，学会 C 计算机语言真的可以开发出很多东西，但除非内力深厚，场合适当，并且闲得蛋疼，大多数人不会拿 C 或者只拿 C 来开发太大的东西。如果你只是想要一门能够让你「编辑出一个啥子游戏或者软件出来」的语言，而且你用 Windows，那建议你转去学学 C#。它长得和 C 挺像，但却能迅速地写出至少是带有图形界面的程序，用起来也很方便，鼠标点一点就能让你对自己的程序看起来什么样有个比较直观的印象。还有，在国内，C# 的教材也相当容易找到。当然 Python 也是一个很好的选择。
另外，还有一件事你必须弄明白：现代的所谓编程这一活动，其实大部分时候是在「合理地堆砌别人已经实现的功能来实现新的功能」，C 语言莫不如是，比如 
printf
 这个东西，是别人做出来的「把一些数据按照指定格式输出到屏幕上」这一功能。而别人还做出来许多其他功能，比如「在发现用户短时间内连续两次按下鼠标又松开的时候调用你写好的一个函数」。学会怎样在 C 或者其他任何程序语言中使用这些既有功能，也是学习编程的一门重头戏。等你弄明白这一点，你也就找到了你问题的答案。
尾注1：题图画错了。马里奥身宽应为 16 像素，我画成了 17。
尾注2：NES 上的超级玛利奥使用 6502 汇编完成，并不是 C，碰撞检测也不是像素级的。
尾注3：我不是
易语言
发明者。","你能想到的，C语言都能搞，可以说是无所不能，把C学好，上手其他语言也会事半功倍。题主只是还没有入门，只看教程不动手永远学不会，推荐5个免费的C语言入门小项目，由易到难，开始动手做一些常见的小东西吧。
1.
C/C++ - C语言制作简单计算器
用C语言做一个简单的计算器，进行加、减、乘、除操作。项目涉及的所有数学知识都很简单，但输入过程会增加复杂性。
2.
C/C++ - C语言制作2048
2048是之前十分火爆的一款益智游戏。项目将使用 C 语言完成一个2048游戏。
3.
C/C++ - C语言版扫雷游戏
扫雷是Window系统中自带的经典游戏。项目将使用 C 语言完成一个简单的扫雷游戏。
4.
C/C++ - C语言编写万年历
本次课程将使用 C 语言完成一个简单的日历功能。输入相应的年/月即可看到当月的日历。
5.
C/C++ - C语言快速实现五子棋
用最最简单的代码来实现五子棋游戏，帮助大家复习基础知识，了解一个项目的开发流程。
收藏的童鞋们顺便点个赞吧：）","首先可以肯定的是，
c语言可以做一切事情。
纯c写的超级
马里奥
世界第一个3d射击游戏
doom
那为什么我学完c语言感觉什么也不会呢。
答案是，你学的只是c语言语法，是与平台无关的，不调用图形接口，就没法写windows应用。
不调用操作系统网络接口，就没法写通信程序。不学习
linux内核
,你就不会用c写linux内核.
不学习硬件平台,就没法开发
嵌入式程序
.
c语言只是个语言
,是你进入计算机世界,和电脑沟通的基础.
试问一下,你学会一门语言,就能了解当地人的习俗和文化,并能和当地人开展生意了吗?
不能!
你总得了解下当地人的习性,文化吧!
你还得学习一系列其他知识,才能真正干活.
你要是想去火星当包工头子,就得再学火星的建筑术语,怎么和火星打工人沟通,火星建筑学!
这个与c的发展历程有关，现在的c多用于底层库开发，而多年前，这个c相当于现在的安卓java，是几乎所有操作系统程序开发的标准语言，现在因为其过使用起来过于繁琐复杂，开发周期长，被java等高阶语言所替代。
学好c语言,就可以进一步学习c++了,c语言就业面比较窄,学好c++,不错的工作还是很多的.如果还有童鞋对于C++学习还有疑问。这里我推荐下
开课吧
家的课程，里面的课程都很不错，而且质量非常高，对于小白很友好，还能领取项目题库资料，需要的同学点击下方链接，免费听一下他们家的试听课程
广告
【限时免费】超适合小白的C++高效学习路线！基础+实战+大咖，3天也能轻松入门！
已失效
?
目前c语言应用比较多的领域
linux内核工程师
高性能服务端
基础架构
嵌入式设备
已经消失的职业
,windows c开发, 游戏开发,dos应用程序开发
举几个用c开发的程序例子。
notepad(记事本）、notepad++、notepad2 (属于win32图形界面开发)
pidgin（全平台的聊天软件）(属于linux图形界面开发)
apache、nginx, redis这几个服务器软件几乎是所有linux服务器的标配(linux后台开发)
linux内核
linux下很多常见的命令,比如cat命令(linux环境编程)
开源版超级马里奥(
jubalh/raymario
)(需要图形学前置知识)
fps射击游戏先驱doom (
id-Software/DOOM
)
嵌入式开发
,也很常见
嵌入式单片机,广泛存在于洗衣机,空调,微波炉,空气净化器里
下图是一个基于单片机控制的
半导体冰箱
有兴趣的可以搜索单片机入门学习一下.
51单片机入门教程（完整版）27集全_哔哩哔哩 (b-b)つロ 干杯~-bilibili
如果你想边学边应用
,推荐读嗨翻c语言,里面有一些实用小项目
包括
arduino嵌入式开发
opencv图像处理
网络程序开发
等等,教给你很多其他书没有的实用技能.
广告
图灵程序设计丛书：嗨翻C语言(图灵出品）
京东
￥69.80
去购买
?
如果你已经入门了
你可以考虑读一下,unix环境编程,unix网络编程,Windows c程序设计(不建议,95年的技术了,我初中看过)
unix环境编程能叫你写linux各种常见命令行程序
unix网络环境编程能教你linux后台程序如何设计
学一下arduino,来掌握嵌入式设备的编程方法.
如果要写桌面软件,可以试试linux下的gtk(不建议学),Windows 
c程序设计
(不建议,95年的技术了)
如果你实在想做app,我建议你去学java或者swift,个人更建议swift,相对容易
下面是一些网络上的教程
你可以用c语言写一个简单的http服务器
EZLippi/Tinyhttpd
如何用c语言写windows程序呢，看这个视频，一周内学会，
c语言写windows程序
进阶篇，用vc写屏幕保护程序，
用VC++6.0编写一个完整的Windows屏幕保护程序
进阶，给流行的pidgin聊天软件开发插件，
pidgin插件的入门教程
如果你觉得自己学习困难,没有头绪,没人指导,建议找一门在线课程,开课吧一个c++免费的偏实战的课,可以弥补实战不足的问题,对于小白还是很友好的，，还能领取项目题库资料，需要的同学点击下方链接，免费听一下他们家的试听课程
广告
【限时免费】超适合小白的C++高效学习路线！基础+实战+大咖，3天也能轻松入门！
已失效
?","曾经我对C语言的认识是：黑框框+数学题，后来变成：C语言----让生活更美好。直接上实物图!!!一起体验硬件开发中，C语言的黑魔法。
内附：追女神的套路
新增几个娱乐点：
1.难度系数：任何一个东西要想做的很精，都很难，所以很难下结论。这里难度系数，答主默认为从学生角度来看，实现的难易程度。
2.介绍：怕大家看不懂图片，多多介绍功能。
3.背后的故事：讲述答主和该项目的故事
1.喜闻乐见的智能车
那些年，我们一起玩过的智能车。
因为这个被带入不归路的同学，请举起你们的双手！！！我从手机翻了很久才找到这张照片，让大家娱乐一下。
说一下我做过的三类车：
（1）避障车：
功能：①遇到障碍物可以自己躲避（因为有超声波传感器可以检测到前面有障碍物），比我们小时候的四驱车智能多了吧！！！！！
②当然还有其他功能：液晶屏显示走过的距离，红外避障之类的。（难度系数：★）
（2）
两轮平衡车
：
我们将两个轮子的车放在地上，那它必然会摔倒。平衡车就是利用
PID算法
来不断调整姿态，让两个轮子的小车可以稳稳的站住。（难度系数：★★）
（3）WIFI视频车：
该小车自带一个摄像头，如果电脑和小车上的WIFI连接了以后，我们通过PC端的一个软件，就可以看到小车摄像头实时传过来的画面。（难度系数：★★★）
背后的故事：
答主大一最爱的就是做车。。。。。。。
2.萝莉语音温度播报
介绍：
①可以显示温度
②如果按下播报键，可以语音播报当前温度
③同时还具有蓝牙功能，几十米也能收到温度消息（用手机或者PC直接连接温度器的蓝牙就能收到！）
④可以将温度实时传送至PC，并在动画中显示温度变化
⑤声音自己可以录制，选择你喜欢的声音
难度系数：★★★
背后的故事：
当时有个好基友假期要做兼职，我说做兼职多没‘’钱途‘，我们来做这个比赛，基友拒绝。两个月后颁奖。。。。学校给了一部
itouch
，答主那时经济危机，果断卖之，900到手。基友补课赚了600，已哭，,回来说以后不能不听我的话了。
3.万年不变的万年历
介绍：
①可以显示日期，温度，还可以设置闹钟叫醒自己哦！！！！！！！！！！！！！
②可以在特定日期，屏幕显示特定的祝福。-------据说有无数宅男做出这个送给了女神
③不要看不起它哦，大家想象一下，送给女神后：三个月晚上的某一天正好是情人节，半夜12点，铃声响起，女神下床一看，屏幕显示了一句告白的话~~~~~~~~~~~后面的剧情自己脑补
难度系数：★★
背后的故事：
没故事，答主练手做的。
4.采矿致富车--------------电赛作品--金属探测车
介绍：
这是某一年
全国电赛
的题目，TI出的，用铁丝围了一个圈，要求车能很快围绕着铁丝走一圈！！遇到硬币能够报警。测量自己走过的距离。要求用最少的时间走完一圈
难度系数：★★★★
背后的故事：
做出来简单，做的稳定+快就难了。答主的车跑的飞快。。。，测试的时候竟然跑出线了，吓尿！幸好最后没事了，喜拿1等。
5.基于物联网的家庭安防系统-----九宫格解锁（隔空解锁）
介绍：
这是答主参加某比赛做的，是不是一脸懵逼？看不懂？其实很简单，用九个传感器仿照手机九宫格解锁，使用者只要在远处挥动手势，这个门就可以打开，如果三次错误就向主人打电话报警！！（还会语音提示：小偷，我已报警，请走开。喇叭就在右下角，大家应该能看到）同时还会在我们做的网站上，提示有人盗窃~~~~~~~~~~~~~可惜图不全了，不然一定放出来！ 
难度系数：★★★★，做出来简单，做的好看+稳定就难了。
背后的故事：
我能说人生第一次上电视，是因为这个么。。。。。虽然就晃悠几秒
6.基于心理治疗的儿童电子琴
介绍：
啧啧啧，这可不是普通的电子琴哦。使用者可以隔空弹琴，隔空哦！！一个学姐拿这个，儿歌弹得飞起。。。。其实是为抑郁症,残疾儿童等设计的，用于心理治疗。
难度系数：★★★★
背后的故事：
虽然这个项目不是我做的，但是也算节间参与，也正是因为这个项目，把我带上了不归路。。。。。。。该项目‘’荣获‘’大学生喜闻乐见的比赛--挑战杯XXX国家级XX奖，答主蛮惊讶的还，毕竟我一直当它是玩具。。。。。它还有多种模式，可以选择某一首歌播放，也可以自己弹，哪个键动了，对应的动画也动，如下图：
7.用一次就想丢的-----
蓝牙防丢器
生活中，你是否遇到这样一些问题？
不用怕，只要用了我们的蓝牙防丢器，保证你以后再也不敢丢了。
介绍：
找不到图了，放一张百度的图
功能：
①手机和防丢片通过蓝牙，只要一个离开一个（超过一定距离），双方都会响
难度系数：★★★
背后的故事：
参加挑战杯XXX比赛做的，一个学弟仿照淘宝的东西，让我照做一个出来。绝对是坑啊，离开一两米就响那确实能防盗。这东西和手机离开三十米估计才响，你让我去哪里找贼啊？而且声音很低。。。人多听不见啊。。为了考证，我去淘宝买了两个，结果一模一样的毛病，已哭，现在不知道被我扔到哪里去了。这也从另一个角度告诉我们，这些比赛有多水（其实很多角度都能看出来，哈哈），最后得了个省XXX奖，不醉不行。比赛失利的孩子，不要哭，继续撸。
感慨：还有好些项目，找不到图了，答主吃完饭回来看能找到不！真后悔当初乱删照片，现在看到这些照片真激动，全是青春的回忆啊~~~~~~~~~~~~~~~~~~~~
8.操作系统
嵌入式系统，可以运行在真机。我发了一个15天内制作操作系统的攻略，有完整的编写教程。想写操作系统的朋友，可以看看
如何从零开始写一个简单的操作系统？ - 梦人亦冷的回答 - 知乎
结尾：C语言----让生活更美好
9.如何让C语言走进生活？
这样的例子数不胜数，答主举个简单的例子，抛砖引玉，剩下的发挥空间，交给你们了！
相信知乎有很多爱养宠物的童鞋们，有时候经常加班或者没时间照顾小猫小狗，何不考虑做个宠物喂食器，就算自己长期不在家，也能让他们安然无忧。
①比如这样的，喂水器：（小狗走近就会滴水）
②.又或者这样的喂食器：（小狗走近就会落食）
③.喂水+喂食+逗他们玩的恶作剧，也是可以的啊！自己制作的好处就是，可以方便的增删功能，贴近自己的生活习惯。
④怎么做：只要有C基础的童鞋，想速成，非常快！！！！！！！！！！！认真做，一个礼拜就能做成一个有雏形的喂食器了。是不是感觉很有趣啊~~~~~~~~~~~~~
结尾：C语言----让生活更美好","注意，不要这样学习C语言！
对于大部分初学者，学习C语言的目的是希望做一名合格的程序员，开发出靠谱的软件来。
但是学了C语言的基本语法后，发现只能开发“黑底白字”的DOS程序，完全没有漂亮的界面和生动的交互。似乎只有黑框框:
于是学数据结构，学算法，学操作系统，越陷越深，越来越难，最后迷茫了，不知道学C语言能做什么，认为学习编程很难，开始怀疑自己，甚至想放弃。
其实，这是很多初学者都会踩到的一个坑！
C语言本身是一门很简单的语言，提供的实用功能不多，大部分要借助操作系统、第三方库、单片机来完成。
也就是说，只学C语言基本什么也做不了，也基本找不到工作。
首先，给学弟学妹们分享一份大学期间自己整理的电子书库，绝不是在网上那种打包下载的，而是自己需要学到某个方向知识的时候，去网上挨个找的，最后汇总而成。
汇集了编程语言(Java、C++、C、Python等等)、操作系统、计算机网络、系统架构、
设计模式
、程序员数学、测试、中间件 、前端开发、后台开发、网络编程、Linux使用及内核、数据库、Redis....等主流的编程学习书籍。
这部分我是会不断把它完善的，当成自己的小电子书库，不多，但贵在精。
我整理的这些书大家可以在这里获取，对于学习计算机的同学帮助非常大，且十分系统
：
书单：
C语言是一门通用性的语言，并没有针对某个领域进行优化，在实际项目中，C语言主要用于较底层的开发，例如：
Windows、Linux、Unix 等操作系统的内核90%以上都使用C语言开发；
单片机和嵌入式属于软硬件的结合，有很多使用C语言的地方；
开发系统组件或服务，用于支撑上层应用；
编写PHP扩展，增强PHP的功能；
如果对软件某个模块（例如算法和搜索部分）的效率要求较高，也可以使用C语言来开发。
所以C语言永不过时:
 既然C语言的应用这么多，为什么很多读者觉得它什么也做不了呢？
我们先说一个概念，就是库（Library）。库就是编程专家写好的代码，我们可以拿来直接使用，这样能够节省开发成本，提高开发效率，并且库代码的执行效率、严谨性、安全性和规范性要明显优于我们自己编写的代码，市场上有很多优秀的库，有的收费，有的免费，我们要善于利用这些库，尽量不要重复造轮子。
另外，推荐一个谷歌大佬的刷题笔记，强烈推荐：
Github 疯传！史上最强！BAT 大佬「LeetCode刷题手册」电子书开放下载了！
1891 赞同 ・ 51 评论
文章
库一般分为两种：
编程语言的开发者在开发编程语言的时候，一般都要预先写好常用的代码，或者说常用的功能，例如输入输出、数学计算、文件操作、网络操作、日期时间、错误处理、字符串处理等，这些由官方编写的库称为标准库（Standard Library），它们随编程语言一起发布，可以认识是编程语言的一部分。
有一些组织机构或者个人也会开发一些库，有的是为了盈利，有的是业余爱好，有的是本公司正在使用的代码，开源出来造福人类，这些库称为第三方库（Third-party Library）。
 第三方库不是由官方开发，没有质量把控，良莠不齐，但是有相当一部分也非常优秀，已经得到了大家的认可，已经应用在大公司的项目开发中，这些库能够和标准库媲美。
标准库是我们在学习编程语言时就要一起学习的，例如C语言的输入输出、文件操作、日期时间、字符串处理、内存管理等都是标准库提供的功能，它们并不是C语言语法的内容。
如果一门编程语言的标准库强大，初学者经过简单的学习后就很容易开发出实用的项目。例如Java，它的标准库包含了GUI（图形界面）、图形处理、网络通信、网络服务器、HTML解析、HTTP协议、多线程、多进程、
正则表达式
、压缩文件、加密解密、数据校验、音频视频处理、数据库操作、XML操作等常用功能，初学者学了以后立马就能够开发网站、开发PC软件，感觉很实用，也感觉学到了东西。Python、
C#
、VB、PHP、JavaScript、Ruby 等都是非常实用的语言，学了就能做出东西来。
反观C语言，它的标准库只有输入输出、文件操作、日期时间、数学计算等基本功能，都是在黑黑的控制台下进行的，跟网站、PC软件、APP等八竿子打不着，所以初学者觉得C语言没有用。
那么，C语言到底能不能开发网站、PC软件或者APP呢？
C语言的标准库肯定不能干这些事情啦，就得依靠第三方库了，遗憾的是，C语言的第三方库大都也是底层库，支持应用开发的库寥寥无几，只有一个 GTK 库能够开发出 PC 软件来，而没有与网站开发和APP开发相关的库。
GTK 库在PC软件开发中也很少用了，PC软件开发已经是 C++、C#、VB、Java、Delphi 的天下了。换句话说，开发PC软件基本不使用C语言，而是使用 C++、C#、VB、Java、Delphi 等其它语言。
记住，C语言几乎不用来做软件、网站、APP等这些应用层开发，其它的编程语言能够更好地完成任务，没必要非得使用C语言，C语言基本都是用来做
底层开发
，也就是看不见摸不着的、在后台默默提供服务的那些项目，而这样的项目对初学者来说基本没有实用价值，初学者也不知道它们该怎么使用。
初学者想要的C语言没有，C语言能做的初学者用不到，就是这种矛盾导致初学者非常迷茫。
有人可能会问，C语言不是还可以用来开发单片机或者嵌入式吗？是的没错，但是这个方向是软硬件结合的，不是在我们的电脑上进行开发，而是在特殊的开发板上进行开发，并且还需要学习数字电路、模拟电路、汇编、ARM、Linux 等方面的知识，只学C语言也没有用武之地。
如果你觉得学了C语言没用，那么恭喜你，你是对的，应用层的开发一般真的用不上它。
但是，没用也要学，学习C语言并不一定是要应用它，C语言可以夯实你的编程基础，尤其是数据结构、算法、内存、线程、进程、通信、操作系统等底层的计算机知识，没有C语言基础是学不好的。
这些底层知识并不一定能够直接应用在实际开发中，但是它们会让你有底气，会让你透彻地理解编程概念，会让你站的“低”看得远，会让你避免很多低级错误，会让你心中有“
架构师
”的思维。
部分内容来自网络：
来源：
http://
c.biancheng.net/view/vi
p_1732.html
  作者：c语言开发者
如何学习底层知识
关于数据结构、算法、内存、线程、进程、通信、操作系统等这些基本的知识，重要的是理解概念，知道计算机是怎么回事，千万不要深入细节，把自己绕进去，耽误一两年的功夫，要尽早跳出来去做应用开发，找到兴趣点，获得成就感。
这个时候，C语言主要的作用是让你入门，了解编程语言的基本语法，强化编程思维，学习计算机底层知识，为以后的职业生涯打下坚实的基础，而不是用它来做实际开发。
在实际开发中，遇到问题，或者哪里理解不透了，可以再来回顾这些底层知识，这个时候就可以深入细节了。因为有了实际开发经验，再学习底层知识就知道哪里是重点了，不会像无头的苍蝇一样乱飞，什么都学。
【拓展】C语言为什么没有应用层开发的库
C语言是一门“古老”的语言了，在中大型的应用层项目开发中，C++、Java、Python、C# 等其他编程语言能够更好地胜任，为C语言开发应用层的库简直是费力不讨好，所以几乎没人这么做。
GTK 算是一个应用层的库，但是它也比较老了，新版的 GTK+ 已经支持 C++ 了，不再仅仅支持C语言了。
我们先不管
面向过程
、面向对象、泛型这些晦涩的编程概念，简单地理解就是，C语言支持的特性少，用起来费劲，开发效率低，而 C++、Java、Python、C# 等支持的特性多，用起来方便，开发效率高。
C语言的优势是运行效率极高，这正是底层开发所看重的。底层开发有时候就是一个模块，或者是一个服务，规模不算大，但是对效率有严格的要求，此时用C语言就非常合适，所以针对底层开发的C语言库较多，因为它们有非常大的实用价值。
另外，在这里也送大家一本帮助我拿到BAT 等一线大厂 offer 的算法笔记，是一位阿里大神写的，对于算法薄弱或者需要提高的同学都十分受用，算法一定是计算机学习的重中之重：
呀！是 BAT 大佬的刷题笔记 PDF !（文末发圣诞红包
?
mp.weixin.qq.com/s/vSGzpEPZCTunsczuIcsjWQ
推荐几篇我写的关于C语言的文章：
为什么指针被誉为 C 语言灵魂？
你已经是个成熟的985大学了，请不要在大一教 C 语言！
我揭开了「对象」的神秘面纱，就这？
觉得不错的同学，记得帮我
 
@编程指北
 
点个赞哟~ 笔芯
// 欢迎关注公众号【编程指北】，分享有用的编程学习方法和硬核知识。","什么是计算机？一个
加法器
（仅会1+1）和一个搬运工。这就是我认为的计算机。
那为什么世界可以这么美？
减法用
补码
加，乘法多次算，除法转乘法。
这是计算。
8位一字节，128个
ASCII码
，
数字就成了字母。
字母组单词单词做指令，数可以代表指令也可以代表运算部件，指令有操作码和操作数。指挥加法器操作数。
这时候是汇编。
图像RGB三元色256灰度，声音44.1kHz采样，汉字两字节unicode。于是世间音形变成01。
有了这些，我便可以用单片机控制led。我传1你就亮，这是开关。当我128*64个液晶一起控制，这是12864液晶显示屏。当我1920*1080这就是锤子的屏幕。于是显示器出来了。怎么现实锤子二字？怎么使用键盘扫描a这个字母？怎么打开wifi模块？怎么写驱动？这都是c语言在干的。
这就是驱动。
驱动出来了，处理器改怎么分配时间，内存怎么占用，硬盘内存cache怎么分，进程何时用，外设驱动怎么处理，等等，这些写好了就是简易操作系统吧。linux内核全用c哦，
这就是操作系统。
屏幕可以任意显示了，音响可以随意响了，有os做底层支撑了。然后我让屏幕显示一把枪，我定义它为一个物体，定义一些操作，比如扣动扳机。再定义一些人物，场景，定义一些规则。这就是cs了吧。这里枪只是一个枪，我不会去管它怎么画怎么显，我只要知道他是一个东西，我可以用它。
这就是面向对象编程。
于是就出来了楼主所说的
游戏。
当然游戏还牵扯到gpu等外设，还牵扯到建模，曾见过物理博士就搞游戏里水怎么建模，流体嘛，什么美工，什么渲染，联网还要数据库，外挂还有脚本
但是从那
三极管
的电子空穴阴阳中和到你一枪爆头有关系吗？
让你学c不是让你用它写出什么中国版linux，是为了让你明白如何去操作工具。学的是如何用机器思想思考。而不是你说开机就开机。
入门，学的是语法的抽象。是知道名词动词和句子有结构这个事实。至于汉语主谓宾和英语主谓宾，学了一个另一个不就好懂了吗
我也不知道我要说啥了T T。
这里的每一段的一个功能或许就是几百个博士教授一生的目的。
其实就是讲计算机的一些原理。对象语言更多的是使用工具，比如库，函数，调用什么的。而c是他们的基石。
更新于22夜晚
我们大家都忘了一个事，软件真的只是写代码吗？写代码只占了不到百分之十吧，大多的是在维护，规划，文档，找bug。。。。
编程语言有好多，
汇编，是最直接效率最高，但是看到一堆1001谁都眼花。别信什么传说曾经有人用针在光盘上刻出过一个操作系统，现在几乎都可以用c代替了吧。但是还要懂一点灵魂。
c是高级结构语言，但还是偏向与硬件。linux仅仅几百k的源码大多就是什么处理器内存存储管理，进程管理。linux牛是因为他驱动多。c就是一线员工，危险都得上，但少了他不行。老师们教导我们劳动只有分工不同没有贵贱之分。反而很多c工程师待遇超好。
java ，
cpp
，c sharp，是对象语言。像是将军指挥下属，不必去知道盔甲怎么铸造。
javascript之类
脚本语言
，这个没学，不太懂，不敢说了，求介绍
matlab fortan之类偏向数学吧。什么控制，图像处理，识别，人工智能，神经网络，机器学习。感觉好高大上哦。这些东西都是你看不到，但神奇的可以很实用的问题，这就是数学的魅力。你知道一个
傅里叶变换
搞出了多少高科技吗？？？看系里有人学这个好羡慕，自己没那命。
vhdl， 
verilog hdl
之类的。纯硬件语言。这个不是通用cpu，是
cpld
，fpga之类的大量运算，这种语言弄得是芯片里的布线，就是改变硬件连接。而通用cpu那些只是重复。这个里面就有了
ip核
，很有用的知识产权。什么
arm架构
，其实卖的不是芯片，仅仅是芯片规划也就是ip核，中国这个可怜啊，这才是赚钱的地方呢。以前听过一个老师说，你以为我们愿意买美国国债啊，你不买，ip核不卖你，你就不行。哎，intel，arm什么这个积累多啊，中国，哎不说了。希望华为海思可以搞好吧。
html之类，求指教
但所有编程不都是一个理嘛，一个物质操纵另一个物质，加法器操作数，系统操作开关，屏幕。你的鼠标操纵一个对象，whdl操纵一条电子线路。
当然还差很多，要实现这些，还有太多太多。
最后什么国产e语言。我觉得没啥用，除了汉语好看，没一点用","理论上C语言能开发出几乎所有软件。
但是，计算机发展了几十年，留下的大量的轮子和解决方案。C后产生的各种新语言和第三方库如此丰富，这已经是巨大的财富。我们没有必要
回到石器时代
去创建新的文明，而且就算重来，也未必能创建出更加优秀的文明。已经能站在巨人肩上，理性地选择拿来主义，择优出解决方案才是王道。
我接触C语言完全是因为课程的安排。C基本语法掌握后，接下来就是数据结构。开始了想题主一样，做“数学题”。用C实现链表、
平衡树
、排序和一些算法等后，我也只是在后台黑框框输出我的成果，确实枯燥。
但是这个过程对我的影响几乎是最大的。
数据结构课程
结束，我对编程的认识大致就是函数的logical control+存储的data。软件的运行其实也就是一大坨从现实需求中抽象出来的数据通过代码的控制逻辑一直在变化。后来看到Nicklaus Wirth曾用“算法+数据结构=程序”来概括，看来我没有认识跑偏。在我看来，C语言抽象了2进制，它让我们大脑中的“数据”概念映射到了电脑中。即便同是数值，我们也有了更好被我们大脑理解的char。还有
struct
这种custom的数据集合，完全就是为了照顾我们愚蠢的大脑。我们关注了C衍生出的抽象概念，而不再去死磕零零碎碎内存。我们还有便于逻辑展开的胶合物function。只要我们把现实世界的东西，通过我们大脑抽象出“数据和逻辑”，就能映射到电脑上，变成软件。即便C语言本身看起来很整洁，但是这种松散的数据表达和粗犷的回收机制，让我在大二美好的时光中，度过了大姨妈和Bugs同时问候我的心酸时光。后来投向C++，有了还算不错的
语法糖
和特性，接触OOP，生活有了点改善。而且也学会偷懒，有轮子就那来用，而且实际项目开发过程，其实也没发现比啃数据结构课程难。C语言开发的经历，让我在看OOP那些
设计模式
的时候，自恋地傲娇，“这些不用你教我也玩过好吧！”
再后来接触Java和Python，特别是Python，太改善生活质量了。所以毕设毫不犹豫选择Python做开发语言。这之后，我开始关心开发的复杂度。其实实际开发过程中，业务逻辑本身带来的复杂度是无法消除的，而且开发过程使用的语言和选择的框架也会带入复杂度。我之前搞C语言，特别是多线程的时候，内存回收太容易出Bug了，很头疼。即使使用了
消息传递机制
来缓解，开发还是很耗时啊。现在很多语言都支持垃圾回收机制，一般情况我们不用关心回收。这其实就是控制开发复杂度的强有力的手段。
我个人的观点，就是用最接近人脑理解的方式来抽象，即使增加开发成本也可是付出的。让数据有更好的组织形式，优先考虑良好的数据结构表达而不是沉迷于OOP的设计模式，减少抽象过程带入的胶合层，能吞掉的就不要暴露给使用者。毕竟胶合层本身就是增加复杂度的大隐患。减少开发的复杂度真的可以改善生活！请相信我。
我推荐还在大学学习的，时间多的是，不要根基不稳就追逐看似高大上的新玩意，很多真的当你用的时候在去看也不晚，多看看C和数据结构以及算法。折腾明白了，学其他的会比较快，而且不会迷失在各种框架里面。","学的不够
初期: 
一.基本算法:  
     (1)枚举. (poj1753,poj2965) 
     (2)贪心(poj1328,poj2109,poj2586) 
     (3)递归和分治法.  
     (4)递推.  
     (5)构造法.(poj3295) 
     (6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996) 
二.图算法:  
     (1)图的深度优先遍历和广度优先遍历.  
     (2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)  
        (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240) 
     (3)最小生成树算法(prim,kruskal) 
        (poj1789,poj2485,poj1258,poj3026) 
     (4)
拓扑排序
 (poj1094) 
     (5)二分图的最大匹配 (
匈牙利算法
) (poj3041,poj3020) 
     (6)最大流的增广路算法(KM算法). (poj1459,poj3436) 
三.数据结构.  
     (1)串 (poj1035,poj3080,poj1936) 
     (2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299) 
     (3)简单并查集的应用.  
     (4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)    
        (poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503) 
     (5)
哈夫曼树
(poj3253) 
     (6)堆  
     (7)
trie树
(静态建树、动态建树) (poj2513) 
四.简单搜索  
     (1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251) 
     (2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414) 
     (3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129) 
五.动态规划  
     (1)背包问题. (poj1837,poj1276) 
     (2)型如下表的简单DP(可参考lrj的书 page149):  
       1.E[j]=opt{D[i]+w(i,j)} (poj3267,poj1836,poj1260,poj2533) 
       2.E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (
最长公共子序列
)     
         (poj3176,poj1080,poj1159) 
       3.C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(
最优二分检索树
问题)  
六.数学  
     (1)组合数学:  
        1.加法原理和乘法原理.  
        2.排列组合.  
        3.递推关系.  
          (POJ3252,poj1850,poj1019,poj1942) 
     (2)数论.  
        1.素数与整除问题  
        2.进制位.  
        3.同余模运算. 
          (poj2635, poj3292,poj1845,poj2115) 
     (3)计算方法.  
        1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122) 
七.计算几何学.  
     (1)几何公式. 
     (2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039) 
     (3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)  
         (poj1408,poj1584) 
     (4)凸包.  (poj2187,poj1113) 
中级: 
一.基本算法:  
     (1)C++的标准模版库的应用. (poj3096,poj3007) 
     (2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706) 
二.图算法:  
     (1)差分约束系统的建立和求解. (poj1201,poj2983) 
     (2)
最小费用最大流
(poj2516,poj2516,poj2195) 
     (3)双连通分量(poj2942) 
     (4)强连通分支及其缩点.(poj2186) 
     (5)图的割边和割点(poj3352) 
     (6)最小割模型、网络流规约(poj3308, ) 
三.数据结构.  
     (1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750) 
     (2)静态二叉检索树. (poj2482,poj2352) 
     (3)树状树组(poj1195,poj3321) 
     (4)RMQ. (poj3264,poj3368) 
     (5)并查集的高级应用. (poj1703,2492) 
     (6)
KMP算法
. (poj1961,poj2406) 
四.搜索  
     (1)最优化剪枝和可行性剪枝  
     (2)搜索的技巧和优化 (poj3411,poj1724) 
     (3)记忆化搜索(poj3373,poj1691) 
五.动态规划  
     (1)较为复杂的动态规划(如动态规划解特别的施行商问题等) 
         (poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034) 
     (2)记录状态的动态规划. (POJ3254,poj2411,poj1185) 
     (3)
树型动态规划
(poj2057,poj1947,poj2486,poj3140) 
六.数学  
     (1)组合数学:  
        1.容斥原理.  
        2.
抽屉原理
.  
        3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).  
        4.递推关系和母函数.  
     (2)数学.  
        1.
高斯消元法
(poj2947,poj1487, poj2065,poj1166,poj1222) 
        2.概率问题. (poj3071,poj3440) 
        3.GCD、扩展的欧几里德(
中国剩余定理
) (poj3101)  
     (3)计算方法.  
        1.0/1分数规划. (poj2976) 
        2.三分法求解单峰(单谷)的极值.  
        3.矩阵法(poj3150,poj3422,poj3070) 
        4.迭代逼近(poj3301) 
     (4)随机化算法(poj3318,poj2454) 
     (5)杂题. 
         (poj1870,poj3296,poj3286,poj1095) 
七.计算几何学.  
        (1)坐标离散化.  
        (2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).  
            (poj1765,poj1177,poj1151,poj3277,poj2280,poj3004) 
        (3)多边形的内核(半平面交)(poj3130,poj3335) 
        (4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429) 
高级: 
一.基本算法要求:   
      (1)代码快速写成,精简但不失风格   
          (poj2525,poj1684,poj1421,poj1048,poj2050,poj3306) 
      (2)保证正确性和高效性.  poj3434 
二.图算法:  
      (1)度限制最小生成树和第K最短路. (poj1639) 
      (2)最短路,最小生成树,二分图,
最大流问题
的相关理论(主要是模型建立和求解) 
         (poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446 
      (3)最优比率生成树.  (poj2728) 
      (4)最小树形图(poj3164) 
      (5)次小生成树.  
      (6)无向图、有向图的最小环    
三.数据结构.   
      (1)trie图的建立和应用. (poj2778) 
      (2)LCA和RMQ问题(LCA(
最近公共祖先
问题) 有离线算法(并查集+dfs) 和 在线算法  
          (RMQ+dfs)).(poj1330) 
      (3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的 
          目的).  (poj2823) 
      (4)左偏树(可合并堆).   
      (5)后缀树(非常有用的数据结构,也是赛区考题的热点).  
         (poj3415,poj3294) 
四.搜索   
      (1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426) 
      (2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A*算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482) 
      (3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA*算法. (poj3131,poj2870,poj2286) 
五.动态规划   
      (1)需要用数据结构优化的动态规划. 
         (poj2754,poj3378,poj3017) 
      (2)四边形不等式理论.  
      (3)较难的状态DP(poj3133) 
六.数学   
      (1)组合数学.  
        1.MoBius反演(poj2888,poj2154) 
        2.偏序关系理论.  
      (2)博奕论.  
        1.极大极小过程(poj3317,poj1085) 
        2.Nim问题.  
七.计算几何学.   
      (1)半平面求交(poj3384,poj2540) 
      (2)可视图的建立(poj2966) 
      (3)点集最小圆覆盖.  
      (4)对踵点(poj2079) 
      八.综合题. 
      (poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263) 
-----------------------------------------------------
动态规划
Dp状态设计与方程总结 
1.不完全状态记录 
<1>青蛙过河问题 
<2>利用区间dp 
2.背包类问题 
<1> 0-1背包，经典问题 
<2>
无限背包
，经典问题 
<3>判定性背包问题 
<4>带附属关系的
背包问题
 
<5> + -1背包问题 
<6>双背包求最优值 
<7>构造三角形问题 
<8>带上下界限制的背包问题(012背包) 
3.线性的动态规划问题 
<1>积木游戏问题 
<2>决斗（判定性问题） 
<3>圆的最大多边形问题 
<4>统计单词个数问题 
<5>棋盘分割 
<6>日程安排问题 
<7>最小逼近问题(求出两数之比最接近某数/两数之和等于某数等等) 
<8>方块消除游戏(某区间可以连续消去求最大效益) 
<9>资源分配问题 
<10>数字三角形问题 
<11>漂亮的打印 
<12>邮局问题与构造答案 
<13>最高积木问题 
<14>两段连续和最大 
<15>2次幂和问题 
<16>N个数的最大M段子段和 
<17>交叉最大数问题 
4.判定性问题的dp(如判定整除、判定可达性等)     
<1>模K问题的dp 
<2>特殊的模K问题，求最大(最小)模K的数 
<3>变换数问题 
5.单调性优化的动态规划 
<1>1-SUM问题 
<2>2-SUM问题 
<3>序列划分问题(单调队列优化) 
6.剖分问题(多边形剖分/石子合并/圆的剖分/乘积最大) 
<1>凸多边形的
三角剖分
问题 
<2>乘积最大问题 
<3>多边形游戏(多边形边上是操作符,顶点有权值) 
<4>石子合并(N^3/N^2/NLogN各种优化) 
7.贪心的动态规划 
<1>最优装载问题 
<2>部分背包问题 
<3>乘船问题 
<4>贪心策略 
<5>双机调度问题Johnson算法 
8.状态dp 
<1>牛仔射击问题(博弈类) 
<2>哈密顿路径的状态dp 
<3>两支点天平平衡问题 
<4>一个有向图的最接近二部图 
9.树型dp 
<1>完美服务器问题(每个节点有3种状态) 
<2>小胖守皇宫问题 
<3>网络收费问题 
<4>树中漫游问题 ","大一的C语言课选了一个很有趣的老师，当时微信的打飞机游戏正火，于是老师期末考试就让我们用SFML图形库模仿微信写一个打飞机游戏。
最开始真的是一脸懵逼，虽然上大学前写过一点小程序，但当时我也跟题主一样就只能写写算法题，一个真正像样的软件都写不出来。。
后来就天天泡图书馆看SFML的官网的API文档，跟着《SFML Game Development》这本书一步步学，最后终于赶在deadline的前几天通宵写出来了23333
刚写出来那会特别有成就感，抱着这游戏可以玩一整天:-D  毕竟这是我第一个能拿得出手的程序，虽然代码写的很糟糕，很多地方还可以优化，但也无伤大雅啦hhh
后来我一个比较喜欢的女生也找我要这个游戏玩，我偷偷地把难度调到了最高，然后跟她打包票说打通关了请你吃饭2333
诶等等..我好像知道我为什么一直单身了(?_?)
-------------------------------------更新------------------------------------------
看到大家对这个感兴趣我就把源码放出来吧
CarlCurist/C-CPP-Class-Practice
但是真的写的很烂啊..
为了减少游戏难度，自家飞机机身中弹判定点只有机头上那一点(其实是因为懒..)
部分地方算法写的比较烂，导致子弹/飞机一多就会有卡顿
自身存活30s(或者是60s？记不太清了)，boss就会出现，但击败boss之后没有写通关界面(还是因为懒..)
这个作业交上去后我也没再改它了，所以留下了这个烂摊子...大家如果想看写的比较好的可以参考《SFML Game Development》这本书，我几乎就是跟着这本书上的内容一步一步写的。
噫..写完这个答案突然发现自己原来是这么懒...估计已经是懒癌晚期了orz
PS:之前还帮过一个在国外读计算机的同学写了他们的一个作业，一个五子棋程序+简单的AI。但代码我现在已经找不到了..orz，大家如果想用c语言写一些有趣程序也可以尝试写一个五子棋程序，这个比较好上手(可以不用写图形化)，而且也有一定的难度(AI想写的好还是很难的，我写的那个AI只能算最基础的)，貌似别的答主也给出了一个五子棋程序，大家也可以参考一下。
顺便吐槽一下国内的本科cs教育..真的是超级无聊，跟我国外的同学比不知道差多远了。我大学期间遇到的比较好的老师也就是我的c语言老师了，除了教c语言他还会教我们git(我们的作业全部要求交到github上)，设计模式等等，总之还是学到了很多有用的东西。本科想学点有用的东西还是要靠自学，光学习课本上的内容是远远不够的。","当然可以开发出很多东西!
翻了下各各回答,有单片机的,有小游戏的,有说linux内核的,也有各式各样的算法的,当然,这些东西都挺牛逼的,但C开发的玩意,尽管东西牛逼,但可观赏性不强,娱乐效果不够,导致大家对c的看法就是这玩意做不出多少东西
既然如此,那我来给大家表演个绝活儿.
前言
最近不是
vtuber
很火么,我也想当vtuber怎么办?
好说,打开sai,先简单画个人设试试水呗
现在模型有了,可她不会动啊,不会动怎么能骗粉,这个时候就得上Live2D了,可打开官网
emmmmm
一年800块钱,都够我去三次海底捞了,吃着火锅唱着歌儿不比当vtuber爽多了,要掏钱还当啥vtuber,不行!我琢磨着,翻了翻live2D的教程
再次陷入沉思
然后
动手!
首先,我们先创建一个窗体,拉上一堆控件,作为编辑平台
然后我们把整个模型加载进来
第一步我们需要先建立网格,之前在我其它文章有提到过的,使用C语言编写一个3D软渲染器,不过现在我们只需要图元
光栅化
那部分代码,这部分代码,复制一下改改就能用,比如zbuffer之类的,就没必要了,直接给它删掉.有了图元渲染,剩下就是建立网格了,这部分可以直接使用点集建立Delaunary三角划分
这样,我们就能通过添加点集来建立网格了
当然,骨骼必不可少,为此,将每个图层设置一个骨骼节点,然后连接这些节点,形成骨骼
最后,进一步编辑每个顶点的弹性系数,形成那种头发弹弹弹的效果
这样,我们就可以通过编辑骨骼来实现那种弹弹弹的头发和耳朵效果了
进一步完善功能,包括了骨骼的基础旋转
伸缩
网格变换
外力施加
纹理切换等功能
最终完成动画效果
当然,上面你所看到的一切,包括编辑器及整个动画框架,都由C语言编写完成
最后,代码及程序,在
http://
PainterEngine.com
的下载中都可以下载到
每次听到C语言不适合图形开发GUI开发只能黑框框之类的言论,我就想笑
C语言图形编程 PainterEngine Live模型的建立
3901 播放 ・ 17 赞同
视频
?","C啊, 虽然作为几乎所有搞编程的人的入门语言, 但是C确是一个波大井深, 有着大能力的语言, 为什么都说C/C艹比其他语言难呢? 初学者学完了C的语法后都觉得这破烂玩意只能写写加减乘除.....
好吧, 我就说说我的理解好了.
当今程序世界两大方向, 一是向上层发展, 面向对象, 面向方面, 面向这面向那, 所谓的高级语言, 高级语言可以轻松的完成一些非常复杂的任务, 因为他们以及有了很多现成的封装好的库. 另一是向底层发展, 被称为
面向过程
的C语言便是这方面的主力, C及其他低级语言拥有高级语言不具被的直接操作内存的能力, 换句话说就是直接操作设备, 在嵌入式领域以及所有涉及到硬件驱动等操作的地方有着不可替代的地位.
如果你看过计算机原理, 或许你能更好的理解直接操作设备意味着什么. 正如某楼说的那样, 图像是由一个个像素构成的, 对于未压缩的24位RGB位图, 每个像素的颜色是由RGB
三原色
构成的,每个颜色一个字节大小,取值0~255,一个像素是3个字节(事实上是4个), n个像素构成的bitmap图像就是n*3个字节大小, 不算文件头. 这么大一块内存放在硬盘里, 要将它绘制到屏幕上要怎么做呢?
屏幕分辨率这个东西事实上就是屏幕的像素, CRT这种老古董不谈, LCD就是无数的晶体构成无数的像素, 所有晶体构成的物理像素个数便是一个LCD显示器分辨率的极限.LCD显示屏纵向和横向各有一排线路来定位激活某一行或者某一列的晶体使之呈现颜色, 这些线路链接到LCD显示器主控处理器的各个管教, 由一个驱动程序控制, 这个驱动程序一般情况下都是C写的, 不排除ASM... 当想要在某个像素显示某个颜色时, 驱动程序将对应的管脚电平拉高或者拉低, 管脚的地址是显示器处理器芯片定义好的, 程序只管修改那个地址的值就可以实现功能. 通过VGA或者其他方式交互数据. 
要把一个图片从硬盘绘制到屏幕上怎么做呢? 先读硬盘上的图片, 将图片数据加载到内存, 然后将这块内存交给显卡驱动, 显卡驱动开始控制显卡上各个模块处理这个图片, 只是绘制的话不需要做处理, 显卡直接将图像数据转化成显示器能识别的数据, 发送到显示器, 显示器处理芯片控制每个管脚作出改变, 使屏幕上的像素跟图像的像素颜色对应起来. 这样一副图就呈现了....
显卡驱动是直接操作显卡硬件的程序, 基本上就是C写的,效率要求变态的地方会用ASM. 而显卡提供的大量底层接口不可能让一个普通开发者直接调用啊, 我要绘制一个图标不至于读显卡的产品手册吧. 所以就来了各种各样的图形库, 什么GDI, CxImage, OpenGL, DirectX......这些是封装了或通用或独家的显卡驱动接口, 将复杂的调用简单化, 而这些大牛级别的东西肯定是C/C艹写的, 更复杂的东西例如虚幻3之类的3D引擎, 或许是调用DirectX, OpenGL之类的程序, 肯定也没跑是C/C艹写的...
顺带一提另一个跟这些不怎么相干的, 有个东西叫VLCPlayer, 是用C写的, Linux下会用OpenGL, Windows下可以用DirectX, 都支持, 如果你还是觉得C只能写写数学题, 就拜读一下VLCPlayer的源码去吧. 希望有一天你也能写出个这种级别的的东西来.","C 语言本身只是一门语言，要想做出可见的产品需要借助库。但是 C 语言本身又很特殊，很多高级语言都是从 C 语言演化而来，掌握好了 C 语言对学习其他语言有很大的帮助。
比如理解了 C 语言里面的函数指针，那么再去学习高级语言里面的函数回调，Windows GUI 编程中的基于事件驱动的框架模型，还有 Java，C# 里面的 Action，Invoke 就简单了。
又比如，理解了 C 语言里面的数据和指针，那么高级语言里面的类理解起来就简单了；在 Java/C# 的面试中，很多人经常被问到 StringBuild 和 String，如果没有深入理解指针，则只能回答 “StringBuild 是结构，String 是类” 这种简单的回答，但如果深入理解了指针，你便可以这样说 “String 是类，如果修改 String，之前的 String 还在，同时会创建一个新的 String，但StringBuild 不会，StringBuild 会直接修改数据” 这样完整的回答。
学会了C语言可以开发出什么东西？人邮君结合C语言的不同应用，来给大家介绍一下。
初级：基于编译原理，使用 C 语言实现一个计算器。
在你的问题描述中，你说 C 语言只能做数学题，这倒是可以做一些比如快速计算 24，
冒泡排序
之类的问题，但要做一些有挑战性的，比如用 C 语言实现一个公式的计算，你可以这样做：在控制台上不再是两次 scanf 得到两个整数，然后相加输出结果，而是直接在控制台上输入字符串 “10 + 20”，更复杂一点的比如 ""( 10 + 20 ) * ( 1 + 2 )""。
首先要说明的是，结构 struct 存储单个字符信息，再对字符串进行步进处理，然后进行第二次处理，分析得到的运算符、括号、整数、小数等等，通过语法分析和
词法分析
构造一个树形数据结构，最后通过项式消减得到最终结果。
通过这个项目可以把 C 语言的所有语法知识全部整合起来，包括但不限于：ASCII 码，基本数据类型的使用，char、int、float 等，if、switch 等条件判断的使用，递归函数的使用，函数指针，数据结构。
中级：基于 Win32 编程，使用 C语言开发一个记事本。
现在 Win32 非常少见，因为太原始了，同时也因为高级语言做应用开发速度更快。但是用 C 语言开发一个 win32 记事本对于理解应用程序运行的内部原理还是很有帮助的，“最基础的就是最有用的”，Windows 编程圣经 
《Windows 程序设计》
第一个案列就是记事本。
 Win32 API 为 C语言提供了接口，C语言可以调用以此来和操作系统互动，在开发记事本的过程中可以学习到以下知识：
窗口句柄
（Hwnd）是什么，GDI绘图原理，windows 消息处理原理等等。
由于操作系统本身就是使用 C 语言开发的，所以即使高级语言对底层抽象做的很好，但是在很多时候仍然需要调用 C 语言写的 dll，这个时候如果学过 C语言应用开发就很容易理解。
高级：使用任何一门高级语言将 C 语言翻译成汇编语言。
计算机专业有几大基础课：
编译原理
，数据结构，汇编，C语言
等等。使用任何一门高级语言（可以是 C 语言本身）将一段 C 语言代码翻译成汇编语言，然后使用汇编编译器编译，编译成可执行程序，可以在一定程度上将这几门课融合起来，这些知识不再是知识孤岛。
我们来看如何实现一段最简单的 C 语言代码：
#include
 
<stdio.h>


#include
 
<stdio.h>


int
 
main
(
void
)


{


printf
(
'
Hello
 
World
!
\
n
'
);


return
 
0
;


}
终级：使用 C语言开发一个 mini 操作系统。
操作系统是软件领域最复杂的，难度最大的，实现起来涉及的知识面非常广。首先需要有一定的汇编知识，用汇编写一段代码将操作系统的代码写入引导扇区，以及做一些切换处理器模式的工作，剩下的都是 C 语言干的活。
操作系统的四大模块：
进程与线程管理、内存管理、IO与文件系统、设备管理
。其中内存、进程、IO 是重点，当然要先从简单的开始，可以利用C语言先写一个最基本的 FAT32 文件系统，写一个文件管理器出来。
总的来说大概有以下几个步骤：
1. boot loader，这个要用汇编来做。
2. GDT, IDT 中断，捕捉系统错误。
3. 实现虚拟内存和分页机制。
4. 多进程，多线程。
5. 硬盘驱动，实现一个基础的文件管理系统。
6. GUI 图形界面。
学会 C 计算机语言真的可以开发出很多东西，但一般来看，大多数人不会拿 C 或者只拿 C 来开发太大的东西，因为需要很深厚的功底和时间，以及合适的条件。
如果你是小白并且想系统了解C语言，可以看下
《
C Primer Plus 第6版 中文版
》
，它涵盖了C语言编程中的核心内容。《
C Primer Plus（第6版）中文版
》作为计算机科学的经典著作，讲解了包含结构化代码和自顶向下设计在内的程序设计原则。
广告
C语言程序设计入门教程：C Primer Plus第6版中文版+习
京东
￥89.70
去购买
?
如果你想了解C语言还可以开发什么好玩的东西出来，推荐
《C和C++游戏趣味编程（全彩印刷）》
这本书，它依次介绍了C和C++编程语言的基本概念、数据类型、if语句、while循环、for循环、一维数组、函数、二维数组、字符串、文件读写、指针、递归、面向对象编程、链表和C++标准模板库等知识，其中贯穿了众多的小案例和游戏，最后综合应用这些知识编写了一款冒险游戏，很有趣。
广告
C和C++游戏趣味编程（全彩印刷）
京东
￥49.50
去购买
?
========
赠人玫瑰，手留余香，不要忘记点赞、收藏、关注 
@人民邮电出版社
 哦！
一键三连，感恩有你~","哈哈哈哈哈  终于写出了一个像样的程序 
使用easyx图形库  写了一个中国象棋  比贪吃蛇好玩多了 
#include
<stdio.h>


#include
<stdlib.h>


#include
<easyx.h>





void
 
firstmap
(
void
);


void
 
pmap
(
void
);


void
 
pmap_zhexian
(
int
 
x
,
 
int
 
y
);


void
 
pmap_qizi
(
int
 
user
,
 
int
 
number
,
 
int
 
x
,
 
int
 
y
);


void
 
pmap_allqizi
(
void
);


int
 
mousexy
(
void
);


void
 
hit
(
int
 
player
);


void
 
pmap_xuanzhong
(
int
 
x
,
 
int
 
y
);


int
 
mouseleft
(
void
);


void
 
pmap_cleanxuanzhong
(
int
 
x
,
 
int
 
y
);


void
 
pmap_qipan
(
void
);


int
 
panding1
(
int
 
x1
,
int
  
y1
,
int
  
x2
,
int
  
y2
);


int
 
panding2
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
);


int
 
panding3
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
);


int
 
panding4
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
);


int
 
panding5
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
);


int
 
panding6
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
);


int
 
panding7
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
);






int
 
map
[
10
][
9
][
2
]
 
;


int
 
MOUSELEFT
 
=
 
0
;




int
 
main
(
void
)


{

	
BOOL
 
player
=
0
;

	
firstmap
();

	
pmap
();

	
pmap_allqizi
();


//int x = mousexy();

//pmap_qizi(1, 1, (x % 10)*100+47, 47 + (x / 10) * 100);//鼠标下棋

	
while
 
(
1
)

	
{


		
hit
(
player
);

		
cleardevice
();

		
pmap_qipan
();

		
pmap_allqizi
();

		
player
 
=
 
!
player
;


	
}







}




void
 
firstmap
(
void
)
 
//棋盘初始化  有问题

{

	
for
 
(
int
 
a
 
=
 
0
;
 
a
 
<
 
9
;
 
a
++
)
//设置全部棋子归属

	
{

		
if
 
(
a
 
<
 
4
)

		
{

			
for
 
(
int
 
b
 
=
 
0
;
 
b
 
<
 
9
;
 
b
++
)

			
{

				
map
[
a
][
b
][
0
]
 
=
 
1
;

			
}

		
}

		
if
 
(
a
 
>
 
4
)

		
{

			
for
 
(
int
 
b
 
=
 
0
;
 
b
 
<
 
9
;
 
b
++
)

			
{

				
map
[
a
][
b
][
0
]
 
=
 
0
;

			
}

		
}

	
}




	
for
 
(
int
 
a
 
=
 
0
,
b
=
8
;
 
a
 
<
 
9
;
a
++
,
b
--
)

	
{

		
if
 
(
a
 
<
 
5
)

		
{

			
map
[
0
][
a
][
1
]
 
=
 
a
+
1
;

			
map
[
9
][
a
][
1
]
 
=
 
a
+
1
;

		
}

		
else

		
{

			
map
[
0
][
a
][
1
]
 
=
 
b
+
1
;

			
map
[
9
][
a
][
1
]
 
=
 
b
+
1
;

		
}

		
		
	
}



	
map
[
2
][
1
][
1
]
 
=
 
6
;
 
map
[
2
][
7
][
1
]
 
=
 
6
;
//炮

	
map
[
7
][
1
][
1
]
 
=
 
6
;
 
map
[
7
][
7
][
1
]
 
=
 
6
;


	
map
[
3
][
0
][
1
]
 
=
 
7
;
 
map
[
3
][
2
][
1
]
 
=
 
7
;
 
map
[
3
][
4
][
1
]
 
=
 
7
;
 
map
[
3
][
6
][
1
]
 
=
 
7
;
 
map
[
3
][
8
][
1
]
 
=
 
7
;
//卒

	
map
[
6
][
0
][
1
]
 
=
 
8
;
 
map
[
6
][
2
][
1
]
 
=
 
8
;
 
map
[
6
][
4
][
1
]
 
=
 
8
;
 
map
[
6
][
6
][
1
]
 
=
 
8
;
 
map
[
6
][
8
][
1
]
 
=
 
8
;
//兵


	
map
[
9
][
2
][
1
]
 
=
 
9
;
 
map
[
9
][
6
][
1
]
 
=
 
9
;
//象


	
map
[
9
][
4
][
1
]
=
10
;
//帅

}







void
 
pmap
(
void
)


{

	
initgraph
(
900
,
 
1000
);

	
setbkcolor
(
RGB
(
204
,
 
232
,
 
207
));

	
cleardevice
();

	
	
pmap_qipan
();




}



void
 
pmap_qipan
(
void
)


{

	
setfillcolor
(
BLACK
);

	
for
 
(
int
 
i
 
=
 
0
;
 
i
 
<
 
10
;
 
i
++
)
//棋盘方框

	
{

		
solidrectangle
(
45
,
 
45
 
+
 
100
 
*
 
i
,
 
849
,
 
49
 
+
 
100
 
*
 
i
);
//横

		
solidrectangle
(
45
 
+
 
100
 
*
 
i
,
 
49
,
 
49
 
+
 
100
 
*
 
i
,
 
949
);
//竖

	
}

	
clearrectangle
(
49
,
 
449
,
 
845
,
 
545
);
//清理楚河汉界


	
int
  
shi_xiexian1
[]
 
=
 
{
 
351
,
47
,
347
,
51
,
543
,
247
,
547
,
243
 
};
  
//士的两条斜线  \\//顺序

	
solidpolygon
((
POINT
*
)
shi_xiexian1
,
 
4
);

	
int
  
shi_xiexian2
[]
 
=
 
{
 
351
,
747
,
347
,
751
,
543
,
947
,
547
,
943
 
};

	
solidpolygon
((
POINT
*
)
shi_xiexian2
,
 
4
);

	
int
  
shi_xiexian3
[]
 
=
 
{
 
351
,
251
,
347
,
247
,
543
,
43
,
547
,
47
 
};

	
solidpolygon
((
POINT
*
)
shi_xiexian3
,
 
4
);

	
int
  
shi_xiexian4
[]
 
=
 
{
 
351
,
951
,
347
,
947
,
543
,
743
,
547
,
747
 
};

	
solidpolygon
((
POINT
*
)
shi_xiexian4
,
 
4
);


	
pmap_zhexian
(
147
,
 
247
);
 
pmap_zhexian
(
747
,
 
247
);
 
pmap_zhexian
(
847
,
 
347
);
 
pmap_zhexian
(
647
,
 
347
);
 
pmap_zhexian
(
447
,
 
347
);
 
pmap_zhexian
(
247
,
 
347
);
 
pmap_zhexian
(
47
,
 
347
);
//炮 兵 折线

	
pmap_zhexian
(
147
,
 
747
);
 
pmap_zhexian
(
747
,
 
747
);
 
pmap_zhexian
(
847
,
 
647
);
 
pmap_zhexian
(
647
,
 
647
);
 
pmap_zhexian
(
447
,
 
647
);
 
pmap_zhexian
(
247
,
 
647
);
 
pmap_zhexian
(
47
,
 
647
);

	
clearrectangle
(
0
,
 
0
,
 
44
,
 
999
);
 
clearrectangle
(
850
,
 
0
,
 
899
,
 
999
);
//清理边界兵 折线



	
RECT
 
wenzi
 
=
 
{
 
49
,
449
,
845
,
545
 
};

	
settextstyle
(
66
,
 
0
,
 
NULL
);

	
settextcolor
(
RED
);

	
drawtext
(
_T
(
""楚河                    汉界""
),
 
&
wenzi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);


}






void
 
pmap_zhexian
(
int
 
x
,
 
int
 
y
)


{

	
solidrectangle
(
x
 
+
 
5
,
 
y
 
+
 
20
,
 
x
 
+
 
10
,
 
y
 
+
 
5
);

	
solidrectangle
(
x
 
+
 
10
,
 
y
 
+
 
10
,
 
x
 
+
 
20
,
 
y
 
+
 
5
);

	
solidrectangle
(
x
 
+
 
5
,
 
y
 
-
 
5
,
 
x
 
+
 
10
,
 
y
 
-
 
20
);

	
solidrectangle
(
x
 
+
 
10
,
 
y
 
-
 
5
,
 
x
 
+
 
20
,
 
y
 
-
 
10
);

	
solidrectangle
(
x
 
-
 
10
,
 
y
 
-
 
5
,
 
x
 
-
 
5
,
 
y
 
-
 
20
);

	
solidrectangle
(
x
 
-
 
20
,
 
y
 
-
 
5
,
 
x
 
-
 
10
,
 
y
 
-
 
10
);

	
solidrectangle
(
x
 
-
 
10
,
 
y
 
+
 
20
,
 
x
 
-
 
5
,
 
y
 
+
 
5
);

	
solidrectangle
(
x
 
-
 
20
,
 
y
 
+
 
10
,
 
x
 
-
 
10
,
 
y
 
+
 
5
);


}



void
 
pmap_cleanxuanzhong
(
int
 
x
,
 
int
 
y
)


{

	
clearrectangle
(
x
 
-
 
45
,
 
y
 
+
 
45
,
 
x
 
-
 
40
,
 
y
 
+
 
20
);

	
clearrectangle
(
x
 
-
 
40
,
 
y
 
+
 
45
,
 
x
 
-
 
20
,
 
y
 
+
 
40
);

	
clearrectangle
(
x
 
+
 
40
,
 
y
 
+
 
45
,
 
x
 
+
 
45
,
 
y
 
+
 
20
);

	
clearrectangle
(
x
 
+
 
20
,
 
y
 
+
 
45
,
 
x
 
+
 
40
,
 
y
 
+
 
40
);

	
clearrectangle
(
x
 
-
 
45
,
 
y
 
-
 
20
,
 
x
 
-
 
40
,
 
y
 
-
 
45
);

	
clearrectangle
(
x
 
-
 
40
,
 
y
 
-
 
40
,
 
x
 
-
 
20
,
 
y
 
-
 
45
);

	
clearrectangle
(
x
 
+
 
40
,
 
y
 
-
 
20
,
 
x
 
+
 
45
,
 
y
 
-
 
45
);

	
clearrectangle
(
x
 
+
 
20
,
 
y
 
-
 
40
,
 
x
 
+
 
40
,
 
y
 
-
 
45
);


}






void
 
pmap_qizi
(
int
 
user
,
 
int
 
number
,
 
int
 
x
,
 
int
 
y
)


{

	
setfillcolor
(
RGB
(
248
,
 
226
,
 
128
));
//填充黄色

	
fillcircle
(
x
,
 
y
,
 
40
);
//圆的半径


	
RECT
 
xy_qizi
 
=
 
{
 
x
 
-
 
20
,
y
 
-
 
20
,
x
 
+
 
20
,
y
 
+
 
20
 
};
//文字区域坐标


	
if
 
(
user
 
==
 
0
)
settextcolor
(
RGB
(
255
,
0
,
0
));
//获取用户ID

	
else
 
settextcolor
(
BLACK
);



	
setbkmode
(
TRANSPARENT
);
//文字背景设置为透明

	
settextstyle
(
46
,
 
0
,
 
NULL
);

	
switch
 
(
number
)

	
{

	
case
 
1
:
drawtext
(
_T
(
""车""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;

	
case
 
2
:
drawtext
(
_T
(
""马""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;

	
case
 
3
:
drawtext
(
_T
(
""象""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;
//红相黑象

	
case
 
4
:
drawtext
(
_T
(
""士""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;

	
case
 
5
:
drawtext
(
_T
(
""将""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;
//红帅黑将

	
case
 
6
:
drawtext
(
_T
(
""炮""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;

	
case
 
7
:
drawtext
(
_T
(
""卒""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;
//红兵黑卒

	
case
 
8
:
drawtext
(
_T
(
""兵""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;

	
case
 
9
:
drawtext
(
_T
(
""相""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;

	
case
 
10
:
drawtext
(
_T
(
""帅""
),
 
&
xy_qizi
,
 
DT_CENTER
 
|
 
DT_VCENTER
 
|
 
DT_SINGLELINE
);
 
break
;

	
}







}




void
 
pmap_allqizi
(
void
)


{

	
for
 
(
int
 
a
 
=
 
0
;
 
a
 
<
 
9
;
 
a
++
)

	
{

		
for
 
(
int
 
b
 
=
 
0
;
 
b
 
<
 
10
;
 
b
++
)

		
{

			
if
(
map
[
b
][
a
][
1
]
!=
0
)
pmap_qizi
(
map
[
b
][
a
][
0
],
 
map
[
b
][
a
][
1
],
 
47
 
+
 
a
 
*
 
100
,
 
47
 
+
 
b
 
*
 
100
);

		
}

	
}


}






int
 
mousexy
(
void
)


{

		
MOUSEMSG
 
mousemg
;

		
mousemg
 
=
 
GetMouseMsg
();
 
Sleep
(
5
);
//直到鼠标左键按下

again
:
	
while
 
(
mousemg
.
mkLButton
 
==
 
false
)

		
mousemg
 
=
 
GetMouseMsg
();
 
Sleep
(
5
);


		
int
 
x
 
=
 
mousemg
.
y
 
/
 
100
;
 
int
 
xx
 
=
 
mousemg
.
y
 
%
 
100
;

		
int
 
y
 
=
 
mousemg
.
x
 
/
 
100
;
 
int
 
yy
 
=
 
mousemg
.
x
 
%
 
100
;

		
mousemg
.
mkLButton
 
=
 
false
;

		
if
 
(
xx
 
>
 
87
 
||
 
xx
 
<
 
7
)
 
goto
 
again
;

		
if
 
(
yy
 
>
 
87
 
||
 
yy
 
<
 
7
)
 
goto
 
again
;


		
return
 
10
 
*
 
x
 
+
 
y
;



}





void
 
hit
(
int
 
player
)


{

	
int
 
x1
 
=
 
0
;
int
 
y1
 
=
 
0
;



jump1
:
	
x1
 
=
 
mousexy
();

	
y1
 
=
 
x1
 
%
 
10
;
 
x1
 
/=
 
10
;


		
while
 
(
1
)

		
{

			
if
 
(
map
[
x1
][
y1
][
1
]
 
!=
 
0
 
&&
 
map
[
x1
][
y1
][
0
]
 
==
 
player
)
break
;
  
//直到获取到一个可用的选中坐标

			
x1
 
=
 
mousexy
();

			
y1
 
=
 
x1
 
%
 
10
;
 
x1
 
/=
 
10
;

		
}

		
pmap_xuanzhong
(
47
 
+
 
100
 
*
 
y1
,
 
47
 
+
 
100
 
*
 
x1
);
//数组交换坐标


		
/* 开始进行第二次坐标获取 */


		
int
 
x2
 
=
 
0
;

		
int
 
y2
 
=
 
0
;



getmouse
:
x2
 
=
 
mouseleft
();


		
if
 
(
x2
 
==
 
-
1
)

		
{

			
pmap_cleanxuanzhong
(
47
 
+
 
100
 
*
 
y1
,
 
47
 
+
 
100
 
*
 
x1
);

			
goto
 
jump1
;

		
}

		
y2
 
=
 
x2
 
%
 
10
;
 
x2
 
/=
 
10
;

			
		
switch
 
(
map
[
x1
][
y1
][
1
])

			
{

			
case
 
1
:
if
 
(
panding1
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//

			
case
 
2
:
if
 
(
panding2
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//

			
case
 
3
:
if
 
(
panding3
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//

			
case
 
4
:
if
 
(
panding4
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//

			
case
 
5
:
if
 
(
panding5
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//帅

			
case
 
6
:
if
 
(
panding6
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//炮

			
case
 
7
:
if
 
(
panding7
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//兵

			
case
 
8
:
if
 
(
panding7
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//兵

			
case
 
9
:
if
 
(
panding3
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//象

			
case
 
10
:
if
 
(
panding5
(
x1
,
 
y1
,
 
x2
,
 
y2
))
goto
 
next
;
goto
 
getmouse
;
//将


			
}




next
:
	
map
[
x2
][
y2
][
0
]
 
=
 
map
[
x1
][
y1
][
0
];

		
map
[
x2
][
y2
][
1
]
 
=
 
map
[
x1
][
y1
][
1
];

		
map
[
x1
][
y1
][
1
]
 
=
 
0
;


		





}
 







void
 
pmap_xuanzhong
(
int
 
x
,
 
int
 
y
)


{

	
setfillcolor
(
GREEN
);

	
solidrectangle
(
x
-
45
,
y
+
45
,
x
-
40
,
y
+
20
);

	
solidrectangle
(
x
-
40
,
y
+
45
,
x
-
20
,
y
+
40
);

	
solidrectangle
(
x
+
40
,
y
+
45
,
x
+
45
,
y
+
20
);

	
solidrectangle
(
x
+
20
,
y
+
45
,
x
+
40
,
y
+
40
);

	
solidrectangle
(
x
-
45
,
y
-
20
,
x
-
40
,
y
-
45
);

	
solidrectangle
(
x
-
40
,
y
-
40
,
x
-
20
,
y
-
45
);

	
solidrectangle
(
x
+
40
,
y
-
20
,
x
+
45
,
y
-
45
);

	
solidrectangle
(
x
+
20
,
y
-
40
,
x
+
40
,
y
-
45
);


}




int
 
mouseleft
(
void
)


{

	
MOUSEMSG
 
mouselr
;

	
MOUSELEFT
 
=
 
0
;

	
mouselr
 
=
 
GetMouseMsg
();
 
Sleep
(
5
);


againx
:
	
while
((
mouselr
.
mkLButton
==
false
)
&&
(
mouselr
.
mkRButton
==
false
))

	
{

	
mouselr
 
=
 
GetMouseMsg
();

	
Sleep
(
5
);

	
}

	
if
 
(
mouselr
.
mkRButton
)

	
{

		
MOUSELEFT
 
=
 
1
;

		
return
 
-
1
;

	
}

	
int
 
x
 
=
 
mouselr
.
y
 
/
 
100
;
 
int
 
xx
 
=
 
mouselr
.
y
 
%
 
100
;

	
int
 
y
 
=
 
mouselr
.
x
 
/
 
100
;
 
int
 
yy
 
=
 
mouselr
.
x
 
%
 
100
;

	
mouselr
.
mkLButton
 
=
 
false
;

	
if
 
(
xx
 
>
 
87
 
||
 
xx
 
<
 
7
)
 
goto
 
againx
;

	
if
 
(
yy
 
>
 
87
 
||
 
yy
 
<
 
7
)
 
goto
 
againx
;


	
return
 
10
 
*
 
x
 
+
 
y
;



}







int
 
panding1
(
int
 
x1
,
 
int
 
y1
,
int
 
x2
,
int
 
y2
)


{

	
int
 
qx
 
=
 
((
x1
>=
x2
)
?-
1
:
1
);
 
int
 
qy
 
=
 
((
y1
 
>=
 
y2
)
 
?
 
-
1
 
:
 
1
);

	
if
 
(
x1
 
==
 
x2
 
&&
 
y1
 
==
 
y2
)
return
 
0
;
 
if
 
(
map
[
x2
][
y2
][
0
]
 
==
 
map
[
x1
][
y1
][
0
]
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;
//不是原点  目标点归属不为自己或为自己但是空

	
if
 
(
x1
 
==
 
x2
)

	
{

		
for
 
(
int
 
a
 
=
 
1
,
 
b
 
=
 
0
;
 
a
 
<
 
(
b
 
=
 
((
y1
 
>
 
y2
)
 
?
 
(
y1
 
-
 
y2
)
 
:
 
(
y2
 
-
 
y1
)));
 
a
++
)
//两点之间为空

		
{

			
if
 
(
map
[
x1
][
y1
 
+
 
qy
*
a
][
1
]
 
!=
 
0
)
return
 
0
;

		
}

		
if
 
(
map
[
x2
][
y2
][
0
]
 
==
 
map
[
x1
][
y1
][
0
]
&&
 
map
[
x2
][
y2
][
1
]
!=
0
)
return
 
0
;

		
return
 
1
;

	
}

	
else
 
if
 
(
y1
 
==
 
y2
)

	
{

		
for
 
(
int
 
a
 
=
 
1
,
 
b
 
=
 
0
;
 
a
 
<
 
(
b
 
=
 
((
x1
 
>
 
x2
)
 
?
 
(
x1
 
-
 
x2
)
 
:
 
(
x2
 
-
 
x1
)));
 
a
++
)

		
{

	
			
if
 
(
map
[
x1
 
+
 
qx
*
a
][
y1
][
1
]
 
!=
 
0
)
return
 
0
;

		
}

		
return
 
1
;

	
}

	
else
 
return
 
0
;


}




int
 
panding2
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
)


{

	
if
 
(
x1
 
==
 
x2
 
&&
 
y1
 
==
 
y2
)
return
 
0
;
 
if
 
(
map
[
x2
][
y2
][
0
]
 
==
 
map
[
x1
][
y1
][
0
]
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;


	
if
 
(
x2
 
-
 
x1
 
==
 
2
)

	
{

		
if
 
(
y1
 
-
 
y2
 
==
 
1
 
||
 
y2
 
-
 
y1
 
==
 
1
)

		
{

			
if
 
(
map
[
x1
 
+
 
1
][
y1
][
1
]
 
!=
 
0
)
return
 
0
;

			
return
 
1
;

		
}

			
		
return
 
0
;

	
}

	
if
 
(
x2
 
-
 
x1
 
==
 
-
2
)

	
{

		
if
 
(
y1
 
-
 
y2
 
==
 
1
 
||
 
y2
 
-
 
y1
 
==
 
1
)

		
{

			
if
 
(
map
[
x1
 
-
 
1
][
y1
][
1
]
 
!=
 
0
)
return
 
0
;

			
return
 
1
;

		
}

		
return
 
0
;

	
}

	
if
 
(
y2
 
-
 
y1
 
==
 
2
)

	
{

		
if
 
(
x1
 
-
 
x2
 
==
 
1
 
||
 
x2
 
-
 
x1
 
==
 
1
)

		
{

			
if
 
(
map
[
x1
][
y1
+
1
][
1
]
 
!=
 
0
)
return
 
0
;

			
return
 
1
;

		
}


		
return
 
0
;

	
}

	
if
 
(
y2
 
-
 
y1
 
==
 
-
2
)

	
{

		
if
 
(
x1
 
-
 
x2
 
==
 
1
 
||
 
x2
 
-
 
x1
 
==
 
1
)

		
{

			
if
 
(
map
[
x1
][
y1
 
-
 
1
][
1
]
 
!=
 
0
)
return
 
0
;

			
return
 
1
;

		
}


		
return
 
0
;

	
}

	
	
return
 
0
;


}




int
 
panding3
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
)
//象 相

{

	
if
 
(
x1
 
==
 
x2
 
&&
 
y1
 
==
 
y2
)
return
 
0
;
 
if
 
(
map
[
x2
][
y2
][
0
]
 
==
 
map
[
x1
][
y1
][
0
]
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;


	
if
 
(
map
[
x1
][
y1
][
0
]
 
==
 
0
)

	
{

		
if
 
(
x2
 
<=
 
4
)
return
 
0
;

		
		
if
 
(
x2
 
-
 
x1
 
==
 
2
 
&&
 
y2
 
-
 
y1
 
==
 
2
)

		
{

			
if
 
(
map
[
x1
 
+
 
1
][
y1
 
+
 
1
][
1
]
 
==
 
0
)
return
 
1
;

			
return
 
0
;

		
}

		
if
 
(
x2
 
-
 
x1
 
==
 
-
2
 
&&
 
y2
 
-
 
y1
 
==
 
2
)

		
{

			
if
 
(
map
[
x1
 
-
 
1
][
y1
 
+
 
1
][
1
]
 
==
 
0
)
return
 
1
;

			
return
 
0
;

		
}

		
if
 
(
x2
 
-
 
x1
 
==
 
-
2
 
&&
 
y2
 
-
 
y1
 
==
 
-
2
)

		
{

			
if
 
(
map
[
x1
 
-
 
1
][
y1
 
-
 
1
][
1
]
 
==
 
0
)
return
 
1
;

			
return
 
0
;

		
}

		
if
 
(
x2
 
-
 
x1
 
==
 
2
 
&&
 
y2
 
-
 
y1
 
==
 
-
2
)

		
{

			
if
 
(
map
[
x1
 
+
 
1
][
y1
 
-
 
1
][
1
]
 
==
 
0
)
return
 
1
;

			
return
 
0
;

		
}

		
return
 
0
;


	
}

	
if
 
(
map
[
x1
][
y1
][
0
]
 
==
 
1
)

	
{

		
if
 
(
x2
 
>=
 
5
)
return
 
0
;


		
if
 
(
x2
 
-
 
x1
 
==
 
2
 
&&
 
y2
 
-
 
y1
 
==
 
2
)

		
{

			
if
 
(
map
[
x1
 
+
 
1
][
y1
 
+
 
1
][
1
]
 
==
 
0
)
return
 
1
;

			
return
 
0
;

		
}

		
if
 
(
x2
 
-
 
x1
 
==
 
-
2
 
&&
 
y2
 
-
 
y1
 
==
 
2
)

		
{

			
if
 
(
map
[
x1
 
-
 
1
][
y1
 
+
 
1
][
1
]
 
==
 
0
)
return
 
1
;

			
return
 
0
;

		
}

		
if
 
(
x2
 
-
 
x1
 
==
 
-
2
 
&&
 
y2
 
-
 
y1
 
==
 
-
2
)

		
{

			
if
 
(
map
[
x1
 
-
 
1
][
y1
 
-
 
1
][
1
]
 
==
 
0
)
return
 
1
;

			
return
 
0
;

		
}

		
if
 
(
x2
 
-
 
x1
 
==
 
2
 
&&
 
y2
 
-
 
y1
 
==
 
-
2
)

		
{

			
if
 
(
map
[
x1
 
+
 
1
][
y1
 
-
 
1
][
1
]
 
==
 
0
)
return
 
1
;

			
return
 
0
;

		
}

		
return
 
0
;


	
}

	
return
 
0
;



}





int
 
panding4
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
)
//士

{

	
if
 
(
x1
 
==
 
x2
 
&&
 
y1
 
==
 
y2
)
return
 
0
;
 
if
 
(
map
[
x2
][
y2
][
0
]
 
==
 
map
[
x1
][
y1
][
0
]
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;


	
//范围限制

	
if
 
(
y2
 
>
 
5
 
||
 
y2
 
<
 
3
)
return
 
0
;

	
if
 
(
map
[
x1
][
y1
][
0
]
 
==
 
0
)

	
{

		
if
 
(
x2
 
<=
 
6
)
return
 
0
;

	
}

	
if
 
(
map
[
x1
][
y1
][
0
]
 
==
 
1
)

	
{

		
if
 
(
x2
 
>
 
2
)
return
 
0
;

	
}


	
if
 
(
x2
 
-
 
x1
 
==
 
1
 
&&
 
y2
 
-
 
y1
 
==
 
1
)
return
 
1
;

	
if
 
(
x2
 
-
 
x1
 
==
 
-
1
 
&&
 
y2
 
-
 
y1
 
==
 
-
1
)
return
 
1
;

	
if
 
(
x2
 
-
 
x1
 
==
 
-
1
 
&&
 
y2
 
-
 
y1
 
==
 
1
)
return
 
1
;

	
if
 
(
x2
 
-
 
x1
 
==
 
1
 
&&
 
y2
 
-
 
y1
 
==
 
-
1
)
return
 
1
;


	
return
 
0
;



}




int
 
panding5
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
)


{

	
if
 
(
x1
 
==
 
x2
 
&&
 
y1
 
==
 
y2
)
return
 
0
;
 
if
 
(
map
[
x2
][
y2
][
0
]
 
==
 
map
[
x1
][
y1
][
0
]
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;


	
if
 
(
y2
 
>
 
5
 
||
 
y2
 
<
 
3
)
return
 
0
;

	
if
 
(
map
[
x1
][
y1
][
0
]
 
==
 
0
)

	
{

		
if
 
(
x2
 
<=
 
6
)
return
 
0
;

	
}

	
if
 
(
map
[
x1
][
y1
][
0
]
 
==
 
1
)

	
{

		
if
 
(
x2
 
>
 
2
)
return
 
0
;

	
}


	
if
 
(
x2
 
-
 
x1
 
==
 
1
 
&&
 
y2
 
-
 
y1
 
==
 
0
)
return
 
1
;

	
if
 
(
x2
 
-
 
x1
 
==
 
0
 
&&
 
y2
 
-
 
y1
 
==
 
-
1
)
return
 
1
;

	
if
 
(
x2
 
-
 
x1
 
==
 
-
1
 
&&
 
y2
 
-
 
y1
 
==
0
)
return
 
1
;

	
if
 
(
x2
 
-
 
x1
 
==
 
0
 
&&
 
y2
 
-
 
y1
 
==
 
1
)
return
 
1
;


	
return
 
0
;


}











int
 
panding6
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
)
//炮	

{

	
int
 
t
 
=
 
0
;

	
int
 
qx
 
=
 
((
x1
 
>=
 
x2
)
 
?
 
-
1
 
:
 
1
);
 
int
 
qy
 
=
 
((
y1
 
>=
 
y2
)
 
?
 
-
1
 
:
 
1
);

	
if
 
(
x1
 
==
 
x2
 
&&
 
y1
 
==
 
y2
)
return
 
0
;
 
if
 
(
map
[
x2
][
y2
][
0
]
 
==
 
map
[
x1
][
y1
][
0
]
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;
//不是原点  目标点归属不为自己或为自己但是空

	
if
 
(
x1
 
==
 
x2
)

	
{

		
for
 
(
int
 
a
 
=
 
1
,
 
b
 
=
 
0
;
 
a
 
<
 
(
b
 
=
 
((
y1
 
>
 
y2
)
 
?
 
(
y1
 
-
 
y2
)
 
:
 
(
y2
 
-
 
y1
)));
 
a
++
)
//两点之间为空

		
{

			
if
 
(
map
[
x1
][
y1
 
+
 
qy
 
*
 
a
][
1
]
 
!=
 
0
)
t
++
;

		
}

		
if
 
(
map
[
x2
][
y2
][
0
]
 
==
 
map
[
x1
][
y1
][
0
]
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;

		
if
 
(
t
 
>=
 
2
)
return
 
0
;

		
if
 
(
t
 
==
 
1
 
&&
map
[
x2
][
y2
][
1
]
 
==
 
0
)
return
 
0
;

		
if
 
(
t
 
==
 
0
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;

		
return
 
1
;

	
}

	
else
 
if
 
(
y1
 
==
 
y2
)

	
{

		
for
 
(
int
 
a
 
=
 
1
,
 
b
 
=
 
0
;
 
a
 
<
 
(
b
 
=
 
((
x1
 
>
 
x2
)
 
?
 
(
x1
 
-
 
x2
)
 
:
 
(
x2
 
-
 
x1
)));
 
a
++
)

		
{

		
			
if
 
(
map
[
x1
 
+
 
qx
 
*
 
a
][
y1
][
1
]
 
!=
 
0
)
t
++
;

		
}

		
if
 
(
t
 
>=
 
2
)
return
 
0
;

		
if
 
(
t
 
==
 
1
 
&&
 
map
[
x2
][
y2
][
1
]
 
==
 
0
)
return
 
0
;

		
if
 
(
t
 
==
 
0
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;


		
return
 
1
;

	
}

	
else
 
return
 
0
;


}



int
 
panding7
(
int
 
x1
,
 
int
 
y1
,
 
int
 
x2
,
 
int
 
y2
)


{

	
if
 
(
x1
 
==
 
x2
 
&&
 
y1
 
==
 
y2
)
return
 
0
;
 
if
 
(
map
[
x2
][
y2
][
0
]
 
==
 
map
[
x1
][
y1
][
0
]
 
&&
 
map
[
x2
][
y2
][
1
]
 
!=
 
0
)
return
 
0
;


	
if
 
(
map
[
x1
][
y1
][
0
]
 
==
 
1
)

	
{

		
if
 
((
x2
 
-
 
x1
)
 
<
 
0
)
return
 
0
;

		
if
 
(
x1
 
<=
 
4
)

		
{

			
if
 
(
x2
 
-
 
x1
 
==
 
1
 
&&
 
y2
 
-
 
y1
 
==
 
0
)
return
 
1
;

	
//		if (x2 - x1 == 0 && y2 - y1 == -1)return 1;

	
//		if (x2 - x1 == -1 && y2 - y1 == 0)return 1;

	
//		if (x2 - x1 == 0 && y2 - y1 == -1)return 1;

			
return
 
0
;

		
}

		
if
 
(
x2
 
-
 
x1
 
==
 
1
 
&&
 
y2
 
-
 
y1
 
==
 
0
)
return
 
1
;

		
if
 
(
x2
 
-
 
x1
 
==
 
0
 
&&
 
y2
 
-
 
y1
 
==
 
-
1
)
return
 
1
;


//		if (x2 - x1 == -1 && y2 - y1 == 0)return 1;

		
if
 
(
x2
 
-
 
x1
 
==
 
0
 
&&
 
y2
 
-
 
y1
 
==
 
1
)
return
 
1
;

		
return
 
0
;

	
}




	
if
 
(
map
[
x1
][
y1
][
0
]
 
==
 
0
)

	
{

		
if
 
((
x2
 
-
 
x1
)
 
>
 
0
)
return
 
0
;

		
if
 
(
x1
 
>=
 
5
)

		
{


//			if (x2 - x1 == 1 && y2 - y1 == 0)return 1;

//			if (x2 - x1 == 0 && y2 - y1 == -1)return 1;

			
if
 
(
x2
 
-
 
x1
 
==
 
-
1
 
&&
 
y2
 
-
 
y1
 
==
 
0
)
return
 
1
;


//			if (x2 - x1 == 0 && y2 - y1 == -1)return 1;

			
return
 
0
;

		
}


//		if (x2 - x1 == 1 && y2 - y1 == 0)return 1;

		
if
 
(
x2
 
-
 
x1
 
==
 
0
 
&&
 
y2
 
-
 
y1
 
==
 
1
)
return
 
1
;

		
if
 
(
x2
 
-
 
x1
 
==
 
-
1
 
&&
 
y2
 
-
 
y1
 
==
 
0
)
return
 
1
;

		
if
 
(
x2
 
-
 
x1
 
==
 
0
 
&&
 
y2
 
-
 
y1
 
==
 
-
1
)
return
 
1
;

		
return
 
0
;

	
}




	
return
 
0
;


}
好久之前占的坑，今天把代码整上来让大伙喷几句，虽然写的很蠢，但是当时确实很开心。
没有AI，一人一手，红先，不能悔棋，右键取消选中。","“我是一台没有机械装置的机器，没有可以旋转的机械臂、亦或是可以带我飞上天的螺旋桨。
我唯一会做的事情就是计算，从储存器中拿出操作数、做完计算、再放回去。
别的机器都在嘲笑我：看那，这家伙就是一个大坨坨，不会动还死耗电，真不知道要它干啥。
我很伤心，但我什么都做不了，因为我就是个大坨坨，不像坦克大炮一言不合就可以崩了他们。我甚至不能流泪，因为我没有机油。
我就是这么无能，我唯一能做的就是计算，不停的计算。我骗自己：只要你算得足够快，就将有奇迹发生。
于是我只能不停的算，越算越快，每秒5000次、一万次、千万次，直到千万亿次、亿亿次。
后来，我发现嘲笑我的机器越来越少了，反而越来越多的机器开始需要我的控制、我的指挥，我想这就是改变。
计算是我唯一能做的一件事。
但我知道，只要将这一件事做到极致，就会有奇迹出现。”
―― 一台计算机内心的独白","一楼
涛吴
的回答非常棒。
我同时认为，现在这个时代里，真的应该把php作为初学入门的语言了--你可以在学会基本语法之后很短的时间里就做出一个web网站来，你还可以学会如何操作数据库，如果你同时在学习linux，还可以拿php当python用，写一些跑在终端的小工具。你还可以结合
bootstrap
这样的库，迅速的把你的网站弄的很漂亮很“专业”，再进一步，还可以让它在移动端可以正确的显示。这一切都可以围绕php来进行。
以后，根据这个过程，你就知道自己最大的兴趣点在哪，到底是做酷酷的前端web界面，还是喜欢在黑色终端下写系统服务或者工具，然后再去扩展这个方面的知识。这样的过程比学校惯用的先用汇编和C语言吓死你的方式要好的太多了（但由于提高了大家的学习兴趣，所以可能不能淘汰很多人出去，而这正是学校需要的）。","这个问题挺有意思的，我大一时候刚开始学C语言的时候也是这种感觉，总是在做排序啊之类的计算逻辑。大一时候的编程通识课其实就是一门通识课，你基本不能通过它学会编程。
想要解决你这个困惑其实非常简单！找《C语言项目实战》||《C语言
编程实例
》，不求看懂里面的代码，你就随便翻翻，大概就能找到C语言能做哪些工作了，并且大致上是怎么实现的。
等到你再深入之后，就能通过模仿那些书上的模块案例代码，来组装一个自己想要的功能。","对于初学者，有一个要正的三观。
那就是所有的语言，只是语言。就像中文，你也掌握中文了吧？为什么你写不出名著？
同理，不是学会了c就能开发出游戏的。语言本身只是工具，真正重要的是你肚子里的货。比如算法，比如数学。","是的
众所周知,一切能用JS解决的问题最后都会用JS解决
而C,可以用来写一个JS解释器","一般遇到问学习c语言的问题，我都会写鼓励+引导的回答。因为大部分同学是在大学期间，因课程需要而学c语言。
但看到“c语言入门”、“自学”、“就看网上的那种教程”几个关键词，我还是劝题主先多了解一下。
举个例子――4个小伙伴同时开始学编程，A选择了Python，B选择了JavaScript，C选择了Unity或者UE4游戏引擎，D选择了c语言。
假设他们都在认真学习，两个月后：
A：我用Python做了个简单的爬虫，爬到了很多新闻数据，我还把它们整理到了数据库里。
B：我用JavaScript加HTML做了个互动网页，你们来看看效果。
C：我做了个手机小游戏，你们来玩玩看。还有网页版的。
D：你们知道指针、字符串和数组之间的关系吗？
对于立志学习计算机，未来从事相关行业的人来说，c语言是非常重要的一种语言。
但对于编程爱好者，想学一门语言做点小软件、小游戏，选择其他热门语言更容易取得成果，在成就感的驱动下容易走的更远。
（并不是说别的语言能做的c语言不能做，主要问题在于学习曲线比较漫长曲折。）","答案是既是又非。
是，是因为 c 语言是个基础，包括基本语法，基本 IO，简单数据结构，
程序流程控制
，
而且确实可以做出很多东西。但这仅是必要条件。
非，是因为你入门 c 语言，学会的仅仅是语法。此条件不充分。
不包括数据结构，算法，计算机思维/建模，不包括面向对象，不包括平台相关知识（例如 WIN32 程序如何编写，消息机制，MFC，GDI，OPENGL，DIRECTX 等等）。
而后者中的东西，则是做个实际东西，可能需要的。那么在仅掌握 c 的语法的条件下，当然，基本接近于“什么也做不了”的层次。"
,,,,,,,,,,,,,,,,,,,,,
面试被问到不懂的东西，是直接说不懂还是坚持狡辩一下？,None,"看情况。
如果是技术面，我只谈自己懂的技术。
如果是
HR面
，就没有我不懂的技术。
如果是老板面，没有人比我更懂技术。","当年我回国，去四大面试咨询组。
面试我的是个英国合伙人。
英国叔年纪不小了，但仍旧是个好奇宝宝。
听说我之前在ASML做算法，就揪着不放，一直问一直问。
问得我有点烦了，心想这玩意跟咨询有个毛关系啊？
心里这么想着，回答得就有点漫不经心。
合计着就把这次面试当练手吧，反正后面还排了好几个。
不过英国叔久经沙场，估计看出我心不在焉，于是突然话锋一转，问我Did you hear of COSO？
我来之前做了功课，还真了解了一下COSO，于是实话实说，Yes，I did.
他吃了一惊，因为这玩意当时刚出来没多久，显然不是我一个做算法的应该听说过的。
他不可置信地看着我，让我说说我的理解。
我说，I just heard of it.
这货听完一愣，接着开始捂着肚子笑，边笑边抱歉，说自己实在忍不住了。
他这一笑把我给笑懵了，也没觉着有什么好笑啊？
又一琢磨，哦，是不是他把I just heard of it，理解成了I have heard of it from you just now了？
你别说，要是这么理解，还真挺好笑的，尤其在面试中。
这么想着，我也笑了。
我俩笑了一会儿才收住，但面试从此便朝着诡异的方向一路狂奔。
英国叔说，这是他工作30年来，听过最好笑的笑话。
接着又给我大体科普了一下
COSO框架
，问我现在有什么理解。
我说刚才是我第二次听说COSO，可能会比第一次强点，但你要是现在让我说理解，我也只能给你编一个。
反正事已至此，我也不把面试当回事，索性破罐子破摔了。
英国叔听了又笑了，说行，那你就给我编一个吧。
然后我就基于刚听到的信息开始编，毕竟框架有了，往里面增加点细节，并且都改成疑问句式就好了。
编了一阵，我说就这些吧，实在编不下去了。
英国叔居然在那鼓掌，说编得真不错，如果不是他参与制定了COSO，没准真信了。
咱也不知道他葫芦里卖的什么药。
面试出来，我就权当去讲了一场脱口秀，很快把这事给忘了，接着面试。
过了一周吧，HR打来电话，说我被录取了。
我当时一脸懵逼，因为在我的选项里，早就把这家排除在外了，根本没想起来。
后来跟人家确认之后才想起来，这不就是我去说脱口秀那家嘛。
但我的第一反应是，他们是不是搞错了？
得到再次确认之后，我还是有点打退堂鼓，心想这也太儿戏了吧？
于是就跟HR说，我手上有几个offer，要考虑考虑，其实就是想婉拒了。
HR也没说啥，让我第二天给她答复。
第二天我也没想起来这事，到了晚上又接到一个电话，又是那家，说的还是英文。
聊了两句，我才发现，这不是英国叔嘛。
总之他打电话的意思就是看好我，劝我接受offer，会重点培养我。
我说是因为咨询需要“编”的能力吗？
他说不是，他看好的恰恰是我的坦诚。
这么一说，我就爱听了，于是当场答应，这事就这么定了。
后来我在四大年年小黑屋拿高分，估计也少不了英国叔的助推。
等到我自己创业，面试也学会了这招，会故意问一些明显超出对方认知范围的问题。
而我想要得到的最佳答案就是，“我不知道”。
其实英国叔当年并没把话说全，他看重的不光是我的坦诚，更是我的自信。
因为只有当你足够强大时，才敢于承认自己的无知。
反正收藏你也不看，点个赞意思下得了……","面试官：请先做个自我介绍吧。
求职者：巴拉巴拉一大堆。
面试官：请问你会造飞机吗？
（求职者内心一万匹草泥马的奔驰，但是想到知乎的网友回答，于是硬扛。）
求职者：有幸参与过x次x架飞机的清洁工作，包括飞机表皮杂质分离（拖地）、人造纳米玻璃的防氧化（擦玻璃）、以及各种
精密机械
的安装测试（插电线版）等工作。
（面试官听不懂但还是要装作听懂的样子，毕竟人不能怂，这样才能PUA求职者。）
面试官：所以，你没有独立造过一架飞机了？
（求职者内心再次被惊讶，飞机还能一个人造？这面试官怕不是脑子瓦特了？）
求职者：造飞机是一个大工程，通常是团队项目。如果公司有需要，我也是可以承担的。此前虽然并不是独立完成造飞机，但是参与的过程中，也丰富了我的见识，理论知识得到实践的提炼，让我具备了独立造飞机的能力。当然，造飞机是大工程，如果让我独立完成的话，效率肯定比不上团队合作的。
（面试官感觉这货很牛的样子，但是又怀疑对方在出牛皮，于是秀出杀手锏）
面试官：好的。我这边基本了解的差不多了。你先在这等下，我去喊我们的造飞机总监过来。
求职者：好的。
....
等待了一会，一个戴着眼镜、秃顶的男子走了进来，姑且称呼对方为造飞机总监。
造飞机总监：你好，请先做下自我介绍吧。
求职者：巴拉巴拉一大堆。
造飞机总监：请问飞机发动机启动后发出超过正常的巨大声音，可能是哪些问题？
（求职者内心复现好几个问号，？？？，这货不会来真的吧，但是求职者牢记知乎网友的建议，死不认怂）
求职者：如果只是单纯的巨大声音，可以考虑xxx手段（反正瞎扯的，对错全看天意）
（造飞机总监回顾了一下刚刚百度的答案，似乎和求职者的回答完全不一样，但是求职者的勇气似乎也说明了他并非完全不知，会不会是百度的答案有问题？）
造飞机总监：你在上家公司造飞机的过程中遇到了哪些困难，又是如何克服的？
求职者：整体的造飞机过程还是比较流畅的，但是的确也会碰到一些极端情况。比如下雨天的时候，人造纳米玻璃抗氧化就需要特别小心（雨水路滑，易摔倒。）这个时候就需要特制装备了。这个虽然是我弄出来的，但是因为跟上家公司有保密协议，所以请原谅我不能透露。
造飞机总监：理解理解。我这边基本没问题了。你有什么问题要问的吗？
求职者：请问贵公司的造飞机团队有多少人？
造飞机总监：你来了之后就有2个人了。还有什么问题吗？没有的话我需要跟老板商量一下。今天的面试到此为止，我们会在3个工作日给你回复的。
求职者：好的。（起身，离开。造飞机总监浅送后返回。）
另外一个会议室，面试官，造飞机总监正在跟老板汇报。
老板：这几天的面试怎么样了？有可以入选的人员没？要知道，虽然拧螺丝不怎么需要技术含量，但是如果有个会造飞机的来拧螺丝的话，那么万一造飞机的不干了，他还能顶上。
面试官：今天面试的还不错，有过造飞机的团队经验。虽然没有独立完成过，但是参与过。
造飞机总监：虽然有些地方不够精通，但是培养培养还是可以用的。
老板：行吧，你们都这么说，就他了。
求职刚坐上回家的公交，手机来电话了。
HR：你好，请问是x先生吗？这里是xxx造飞机公司。你刚刚的面试通过了。你看下你什么时候方便来公司办理入职手续？
求职者：一周内吧。
HR：好的，x先生，稍后会发offer到你的邮箱，请注意查收。来公司后直接打我手机，到时候我带你办理入职。
求职者：好的，谢谢。
（几天后，求职者没找到更好的工作，于是只能来这家造飞机公司。HR带领x先生认识了该公司造飞机团队的另外一个主力：造飞机队长。双方了解后，HR离开。）
造飞机队长：咱们的工作还是比较闲的。你平时给我打下手拧下螺丝就行了。
求职者：好嘞，我一定好好的拧螺丝！（吓宝宝一条，差点以为真的要造飞机了。）","完全不懂，就答：这个不了解，感谢您的问题，我下来学习一下。
如果懂类似的知识点，就答：这个我不了解，但是好像，有个类似的知识……
面试，其实是个非常考验情商的环节，只不过很多人忽略了这个。
遇到自己非常懂的问题，尽量多说一些。
很多人喜欢一句话就答复完问题，这样会迫使面试官为了保证面试时间，不得不提出更多的问题，被问的多了，难免被问住了。
很多年前有一次面试，面试官问我
elastic search
的索引原理，我拿了一张纸，从一个搜索动作开始描述，到一个线程进入以后，如何根据fst
前缀树
定位到一个索引文件，到为何使用fst结构，到索引生成时如何在内存中合并、到如何优化内存和CPU、到CPU缓存和内存交互……
这个问题的回答占用了面试官太多时间，也足够表现我对某个知识点的深入理解，之后面试官对别的问题问的就不是那么细致了，很容易就通过了。
要尽量自己把握节奏，有些面试官见你答出一个问题，会粗暴的打断你的发挥，继续问下一个问题。
面对这种面试机器人，不要慌，见缝插针，一定要在自己熟悉的领域，把自己的主动权抢过来。
只要你在面试过程中，
哪怕找到一次这样的机会，就足够给面试官留下不错的印象
。
而如何可以让面试官不打断你，你就一定要把事情说的有趣，自己在家要多练。这一点不仅仅针对技术面试，一切面试都是这个道理。
面试，并不是说你要答对所有问题，但是你一定要给面试官留下深刻印象。
我曾经有几年时间，利用这个窍门，变成了
面霸
，基本上只要面了就过……
不要以为技术面试拼的都是技术，每个技术人都有自己熟悉的领域，突出自己有些时候更看一点运气和情商……
有些面试官不喜欢顾左右而言他的，这个就需要你把回答说的足够有趣，才能吸引面试官足够的兴趣。
另外一个小窍门，就是不打无准备之仗，面试心仪的公司之前，最好去几个次一级的公司面试练手，面试，看的并不是绝对实力，技巧也起到很大作用。
而技巧，可以通过多面试来锻炼，熟能生巧以后，你就是面霸。
技术这玩意儿本身就是：无他，唯手熟尔，面试也可以这样来解决。","数十次面试经验：
请用英语介绍下自己：
用了英语介绍自己，面试没通过理由：我英语不好。
说自己英语口语不好，直接拒绝用英语介绍自己，面试全部通过。","面试的时候，聊到具体的技术或者业务问题时，遇到不懂或者完全没接触过的东西，实在太正常不过了，每个领域都是非常宽泛且琐碎的，随便挑几个你完全不可能会的问题，简直不要太容易。
我觉得，如果是在聊具体的业务技术问题时，提到了某个东西，然后你不懂，或者以前接触过但不是很熟，完全可以如实告知，然后有效的面试，就会继续去聊别的问题了。
一般没有人去介意你怎么会不知道这些问题。
为什么面试时，遇到完全不会的问题很正常呢？
因为面试是单方面的问问题。
我们生活中，所有单方面的问问题，只要双方知识差距不是过于悬殊，都能挑出对方压根儿就回答不上来的问题。
这事儿古代文人就经常玩，有的人熟读这本书，有的人熟读那本，然后就互相考对方自己熟的那本书里的各种细枝末节，最后当然是谁都回答不上来。
如果在面试中，对方持续问你不知道的问题，并且一直追着你不会这个点去问。
那很可能，公司想要招你这个人，所以安排你来聊聊，但是问你问题，给你挑错的人，并不是那么想要你。
这很正常，也许这个面试官自己早就安排好了自己人也来面试，所以才要在技术面时为难你一下。
但也不排除，你简历过于美化，去应聘了一个完全不可能胜任的工作，然后面试官只是例行公事一样地问了你几个行业内应该众所周知的问题，你说你不知道，不清楚，不是很了解。
这时候，面试官说，你怎么连这个都不知道？你如果再去狡辩说，行业领域大了去了，遇到几个不知道的问题很正常，就只会继续给自己扣分，如果你所在的行业，圈子比较小，而面试你的这几个人又比较有影响力的话，那你就很难在这个圈子混了。","你说我不懂，面试官得出一个结论：
你是个诚实的废物。
你垂死挣扎说了一通牛头不对马嘴，面试官：
这人喜欢狡辩不诚实。
你胡说八道粘点边，面试官：
虽然很蠢，似乎还可以带一下。
你不试试，直接完蛋。
你试一下，有可能直接完蛋，有可能有一线机会。
所以我建议你试试胡说八道一下。","我来说说这个问题。
有一次我参加HR举办的招聘会。HR首先会提问应聘者若干问题，并查看文凭资料。完成后就到我这里，来询问应聘者的技术知识技能。
某次当一位年轻人轮到我面前时，我询问他有关供配电的基础知识，发现他回答得莫名其妙。后来我问他什么叫做
基尔霍夫
第一和第二定律，他脸红脖子粗地说没学过这种高科技的知识。我告诉他，这是大学一年级读电路分析中的基础内容，是每一位电气专业毕业生的必修课。最后，这家伙不得不承认，他的文凭是从地摊上买来的，本人连初中都没毕业。他以为招聘面试只是看看文凭过关即可，没想到会问得这么深。
想起我自己应聘的事了。我在离开大国企之前，曾经到过一家台资企业应聘电气工程师职务，应聘时先让我们应聘人员填表，然后做几道题。题中有一道有关运算放大器的图和提问，这道题是错的，我没做，并且在答题处指出错误之所在。我想，连应聘试卷都会出错，这家公司肯定不怎样，我不能在这家公司工作。我把试卷交给工作人员，略加说明后离去。
晚间这家公司的总工来电话，要求我直接入职。我告诉他我没兴趣，之后就把电话挂掉了。再之后，这家公司三番五次派人来要求我入职，都被我拒绝。
事后想想，好在没去，后来入职外企多好，比这家烂企业好多了。
总之，应聘时我觉得就要实话实说，别去狡辩，毫无意义，对我们自己不好。同时，对明显错误的提问也要及时指出，以此彰显我们的知识面和能力。","首先我们要搞清楚为什么会问到不懂的东西，分情况去应对。
1、问题超出你的经验、认知、专业范围。
这种挺常见的，
的一种，通常放在面试快结束时问，面试官已经对你的经验和能力摸得差不多了，再来1-2个难一点的问题测你的潜力，看你的思路和求生欲。
遇到这种问题不要慌，很多时候工作中没有绝对对错的答案，条条思路通罗马，谁不是一边百度一边把活干出来的。
先理解问题，快速脑海中寻找相似的经历，然后坦诚说自己经验不足，有条理地说出自己的思路、想法。
如果直接说“我没有经验，我不懂。”那会让面试官失望了，面试官会认为你是一个知难而退的人。
我遇到好多个候选人，经常被最后1-2个很难的问题打击到认为自己面试不通过了，接到我的电话通知面试通过时，还挺意外的。
2、自身专业和经验与招聘岗位有差距。
这种情况再正常不过了，这个世界上没有100%匹配完美的候选人。面试官只是一层一层难度问下去，探一探你的经验深度，从而判断你的水平。
回答思路跟第一种情况一样，不要狡辩，不懂还要装懂，会让面试官觉得你不踏实。
更重要是你的潜力，经验欠缺一些但值得培养，学习能力快的情况下，公司也会录取的。
3、问题超纲，非招聘简章中工作职责内。
有时候业务部门也没搞清楚自己想要什么经验的人，招聘简章（JD）可能是HR一字不漏复制粘贴其他公司的，写的工作方向和面试的工作方向有偏差，所需的技术也不一样。
这种恐怕在IT岗位挺常见的，常听到IT朋友吐槽面试官要的技术方向和他们不一样。
遇到这种情况，要意识到可能岗位与自己发展方向不符，应该反问清楚他们工作方向是什么，需要什么技术，要对齐彼此需求。
4、简历过分美化，数据有明显的逻辑漏洞，面试官故意问一个刁钻的问题去测试你。
我见过候选人被面试官揪着几个看起来很完美的数据一直质疑一直追问，对方在努力去狡辩，把问题解释得似乎合理，下一个问题又暴露出逻辑矛盾，不能自圆其说。
面试官也不是那么好忽悠的。
5、新手面试官上路，乱问问题。
这种情况会出现在看起来很年轻，提问比你更紧张的面试官身上。
我第一次做面试官就是这样了（尴尬脸），对岗位不是很懂，也没把握好HR该问什么问题，想到什么问什么，问一些我自己也没有答案的问题。我和候选人，一个尬问，一个尬聊。
后来我成为那个坐在新手面试官隔壁的面试教练，看着新手面试官也犯着同样的问题，会突然问了一个很傻的问题，候选人懵逼并强行回答，我负责缓和一下尴尬气氛。
遇到这种情况，更不用担心了，畅所欲言就好了，你讲得越多，面试官也许觉得你很厉害（因为他也不懂）。","我记得很多年前，有一次公司要招一个PLC工程师。
当时面试官是HR和用人部门经理。
经理技术出身，做事情特别认真，是公司的金牌技术培训老师。
来了个候选人，学校不错，专业也对口。相关经验三年。
人选挺沉稳，也很有礼貌。点头致意后HR开始提问，先自我介绍。
一切进展顺利， HR偷偷看了一眼经理，经理低着头看人选简历，看不出是否满意。
HR继续问了人选上一份三年的相关工作。
人选有条有理，不慌不忙地回复着。
HR又偷偷看了一眼经理，经理招起头，饶有兴致听着。
HR心里高兴。这个职位招很长时间了，经理就是不满意。
今天这个，应该可以完成招聘任务了。
这时，经理开了口。
“你能不能告诉我西门子PLC和
施耐德PLC
的区别在哪里？”
人选愣了一下。本来放在桌上的双手拧到了一起。
HR心里一惊，充满鼓励看向人选，恨不得她脸上就写了答案。
很快，人选恢复了正常，平静看向经理，说
“我工作三年，只接触过西门子的PLC，施耐德的我没有用过。 ”
“不知您能否给我一些提示，我试着答一下。”
经理兴奋了起来，培训师角色上线了。他把刚才在看的人选的简历翻了个面，在背面画了个图，并给出了一些提示。
人选很认真在听，为了把图看得更清楚，甚至站了起来，弯腰看向经理手里的自己简历的背面。
“。。。。。。”人选边思索边回答。（技术内容早忘了）
经理露着既有鼓励，也有期待的眼神，认真听着。
人选答完了，说”我也不知道自己回答得对不对，还请您教教我。“
经理的培训师热情被彻底点燃了。往人选方向倾着身体，边指着图边给人选回答着。
十分钟，讲完了。人选充满崇拜说”原来是这样的，您真厉害。感谢您。我今天太有收获了。“
HR的心里五味杂陈。又望向经理。
经理一副心满意足的样子。
后来，这个人选被录取了。
经理手把手亲自带。","从售后技术支持转行做软件开发时，只学了 7 天 C 语言，熟悉了语法，就开始投递简历，参加面试。那时什么都不懂，经常被问住。
面试官问，“
野指针
与悬空指针有什么区别？如何避免？”
我连“野指针”、“悬空指针”的名字都没听过，只好抱歉地说，“不知道。我下来学一下。”
面试官问，“不使用递归如何实现
归并排序
？”
见鬼，我都没听说过归并排序，只好抱歉地说，“还没学到。我下来学一下。”
面试官，“怎么在AVL树中实现删除？”
啊，我不知道AVL树，只好抱歉地说，“不知道。我下来学一下。”
我有将近两个月的时间，每天都被问到不懂的东西，每天我都要红着脸低着头很惭愧地说“不知道”，我都能感觉到面试官的摇头和语气变化。
嗯，真的是挺难堪的。
好在我做了一件事：
努力记住不知道的题目，回到租住的地方，立刻翻书学习，或者到网吧上网查找答案。
（当时住处没有装宽带网络）
这件事情的效果，在两个月后显现出来――常见的C语言笔试题和面试题，我都能回答出来了，技术面试的一面基本都能通过。
但接着在二面，就又遇到了非常尴尬的事情。
二面的时候，面试官经常会问，“做过xxx相关的项目吗？”
我从零开始学的编程，一点项目经验都没有，只好说，“没有。我没做过软件项目。”
这么一说，多数面试官就礼貌地问一会儿，就让我回去等消息了。
但我不能说我做过，因为当时我是真的没有做过软件项目，没有任何经验。
印象最深的一次，是面试一家做户外电子屏的公司，笔试、一面都过了，二面是跑到公司的工厂，跟一位负责人聊。
对方只问了我不到五分钟，就因为我没有项目经验，让我离开了。还说不耽误彼此时间。
唉，我为了那个面试，公交车都坐了一个多小时，找地方也花了半个小时，结果就不到五分钟完事，还被当面讥讽。
我离开那个地方的时候，觉得自己真难。
就算如此，在后续的求职过程中，我被问到不懂的东西，也还是直接说不懂，不胡乱说，不转移话题。
到第四个月的时候，遇到一位肯通过我过去的技术支持工作评估我个人潜力的面试官，问了我许多程控交换机和电话故障的问题，我都能很好的应对，他觉得我是可以培养的，给了我机会，我顺利得到了第一份软件开发工作。
在四个月的艰难求职中，
我无数次被问到不懂的东西，我每次都诚实地说自己不知道，然后面试结束后，进一步学习了解，搞明白不懂的问题。
这样随着求职过程的推进，我也在快速成长，也越来越能应对各种面试问题，获得进一步的机会。
因此，
我推荐这种做法：被问到不懂的东西，直接说不懂。如果你还想争取这次工作机会，可以跟面试官要个联系方式，你搞懂了问题后，把自己的理解发给面试官。
这些回答你可能感兴趣：
加入新公司后，如何与主管建立相互信任的工作关系？
工作两年了，没涨过工资要辞职吗？
如何提升工作效率，让每天工作都比较高效？
如果突然被裁员了，你的Plan B是什么？
不上班真的很快乐吗？
你觉得是去大公司打杂好，还是去小公司磨炼好？
人过三十，事业上还没有起色，也没有找到自己的发展方向该怎么办？
都不建议裸辞，那你们是如何出去面试的，总不能老是请假吧，求建议？
你会选择降薪跳槽吗？
对刚入职场几年的新人有哪些建议和忠告？
较远时期的精华，也推荐下：
有哪些典型的学生思维？
为什么跳槽加薪会比内部调薪要高？
二十几岁，朝九晚五的工作，到底该怎么做才能改变自己的人生？
让自己更值钱的要诀
那些很厉害的人是怎么构建知识体系的
如果你有Offer选择、转行、副业等相关问题需要深度咨询，可以戳下面卡片找我咨询。
安晓辉
2492 次咨询
5.0
职场、职业规划、程序员优秀回答者
195208 次赞同
去咨询",真诚一点吧，打不开就说打不开,"首先你直接回答不懂，是无法通过面试的。
企业招聘的本质就是采购知识、技能和经验，如果你不具备这些东西，企业就没有必要去招聘你。
面试官在面试的时候，最怕遇到两种人：
第一种人，是一点不懂，一点儿都不懂。
第二种人，是两点不懂，这也不懂，那也不懂。
其次也不要不懂装懂，因为面试官就会继续深入追问。
然后你支支吾吾，答不出来，也会被淘汰掉。
而且这种情况比第一种更糟糕，因为从面试官的视角来看，第一种人起码还真诚一点。
也有人说，就回答不知道，然后面试结束后回家学。
不会的次数多了，学会的东西也就多了，然后再面试，就无往不利。
这种操作好不好，当然好，从长期看有很强的执行性。
但是，我不得不说，只适合大城市，因为大城市的面试机会比较多，可以不断在面试中试错，以战养战。
然而，在很多三四线城市求职，一个月就那个位数的几次面试机会。这时候，再回答我不知道，我回去学，那么，等到学会，黄花菜都凉了。
所以，面试时一套行之有效的救场措施，还是有必要的。
声明：下面的方法仅针对你对某个知识点有印象，不太懂的情况，不适合你第一次听到这个概念的情况。
具体怎么做呢：
第一步：重复面试官的问题。
您问的是不是XXX。
不要小看重复的力量，很多营销人员都喜欢复述客户的话，这样可以拉近双方的距离，增加好感，然后面试官就会偏袒你。不要以为我骗你，一试便知。
第二步：讲述你和这个概念的关联。
我在XX书上看到过这个概念，但是记忆不深刻。
我看到过同事操作过，所以也了解一点相关内容。
我在公众号上看到过相关案例，大概看了一点。
讲关联其实是告诉面试官你获取知识的渠道，给面试官一个你可以轻松获取这些知识的心理暗示。
第三步：说出你对这个概念的理解。
我对这个概念的理解是这样的：巴拉巴拉巴拉。
如果说的不对的，请您指正。
这是告诉面试官你并不是一无所知，只是不精通罢了。
这样可以让面试官知道你的下限没有他想象的那么低。
第四步：转移话题到擅长领域。
但是其实这种方法不适合所有的公司，我在前公司工作/实习的时候，我们是用XX方法来解决这个问题的，我们当时做了个项目，巴拉巴拉。
如果面试官没有打断你，你基本上就稳了。
面对段位比你高的人，你唯一能做的就是真诚，但真诚不等于实诚，更不等于自我贬低，真诚是把你100%的水平拿出来，去证明你能胜任这个职位。
最后，这是我近期的几个相关回答，有兴趣可以看一下：
有没有HR来说说自己招聘时更喜欢什么样的简历？
面试官通常会问「你有什么要问我的吗」，怎样应对算加分？
如何在谈薪环节与 HR 博弈，为自己争取最高涨幅？
加入新公司后，如何与主管建立互相信任的工作关系？","25年秋招即将进入白热化，起步早的大型央国企已经进入面试环节。
 
网上关于面试的内容很多，一些常规题怎么答步骤一二三写得很清楚，用于入门了解一下可以，但对于985背景想争取高层级热门岗位的同学其实没有太多的参考价值。
 
因为无论是国企、央企、公务员还是其他头部机构，对于高端人才的筛选和甄别整体来说是非常精准的，面试官整体来说也是水平在线的，所以哪些是可培养的人才在面试中一目了然。你的经历、能力、积累、见地都会以表达的方式外化，这些内容是无法突击、无法速成的。
 
而且，被问到你不懂的问题，真的是大概率事件，如何应对不仅考察候选人的思维方式，也考察候选人的临场反应。
 
但是，这并不意味着面试就是听天由命。原因很简单，每一类机构的风格、每一类岗位的职责范围、所需的专业知识是比较明确的，面试官提问的角度、关注的重点也是可以预测的。而且，网上真的有超多面经，你的前辈们早就把过的路，踩过的坑分享出来了，而这些是啥，就是你准备面试的大数据库。
与其面试之前苦苦刷经验贴，不如让这些大数据为你所用，给自己量身定制一个求职辅导导师。这里真的想分享下学弟学妹们常用的一个小助手，就是字节跳动旗下的“豆包”，用好豆包能帮你分门别类的做好各类面试问题的准备，把“面试被问到不懂的问题”概率降到最低。
其实面试的问题看起来天马行空，但其实归结下来就是以下几类：
第一类：关于企业的背景问题。
大家在校招海投的时候真的很难做到对每家企业都有了解，经常是收到了面试通知才发现自己对这家企业的了解仅限招聘公告上那一段背景介绍。想搜集点有含金量的信息，比如经营业绩、发展愿景、主流技术/产品之类的就要花费大量时间，真的让人头秃。
这时候就要借助技术的力量了，我自己一直在用的一款应用叫“豆包”，是字节跳动旗下的拳头产品，不仅没任何广告、全部免费，而且电脑版客户端、网页、浏览器插件全都支持，非常干净又良心的一款产品。
看到某家企业的招聘公告，投简历的同时随手打开电脑端豆包，输入“我想了解xx公司”，豆包会根据公司最新动向、大事件、定期公告、财务报告等等信息你提供这家公司的详尽信息。复制下来记在小本本上，笔试面试之前看一下，完美hold住企业背景相关问题。
比如问豆包“招行和其他国有大行相比有哪些优势？“
豆包列举了金融创新和服务、业务经营和发展策略、风控、金融科技等等四方面的优势，不像有些比较水的搜索引擎会堆砌一些过时信息，豆包提供的内容不仅新、准，还突显了招行本身的特质，不需要自己再去翻各种研究报告、总结提炼，拿来就能用，真的非常省时省力。有了这些基础信息，再可以结合自己的专业加入一些鲜活的例子和个人理解，遇到类似的问题就能答得非常出彩啦。
其实招聘就像找对象，企业都想找真正了解自己、喜欢自己的，所以在面试前充分了解这家企业的发展历程、经营业绩、竞争对手、发展远景非常重要。如果能在面试中结合着自己的经历谈谈对企业未来发展的贡献展望，会非常加分。
第二类：关于岗位的专业问题。
大部分同学在秋招时都会投递与自己专业相关的一堆岗位，但其实每一类岗位的理想人选所需要的专业技能和个人素质是不同的。
而很多跨专业求职的同学，没有时间系统的学习岗位所需的专业知识，也不知道自己的哪段经历面试官会比较看重，凭感觉做些准备，真的很难押到宝。
但是豆包可以借助大数据完美解决这个问题。而且随查随问，下载的话直接电脑浏览器上搜索豆包下载电脑版客户端或直接访问豆包网页版就可以使用啦，非常简单又方便！ 比如我想应聘某top券商的风险管理部，把岗位发给豆包，豆包能迅速获取岗位要求，并且帮你围绕这些要求做好基础知识的复习：
其中，关于风控的基本理论和方法就列举了三大领域和风控模型，可以说是对专业知识的完美提炼，而且经历过几次面试就会发现这些最经典的就是最容易被问到的。只要把经典理论和模型弄清楚搞透彻，有些周边问题即使不完全了解也能答个大差不差。
忘了具体模型是什么内容？不需要自己再去翻书、网上各种搜索学习，直接追问豆包就好，从定义、计算要素、计算方法都给你介绍的明明白白，真的就像找了个家教一样安心：
对于学习能力强的同学，跨专业求职所需的基础知识真的不需要扎进专业书堆里从头学起，选对装备通过提问-回答的方式一样可以应对面试中的大部分问题。
第三类：与岗位所需和个人经历相关的综合性问题。
综合面试环节，面试官通常会结合同学们简历上的实习经历、学术经历、社工经历提问，一方面用于考察经历的真实性，另一方面也是用于判断与岗位适配性的重要依据。
很多同学在学校没有模拟面试的机会，网上搜搜面经就直接上战场，这样真的无异于裸奔…没有条件就自己创造条件。把你的简历和应聘岗位发给豆包，让豆包出一套模拟面试题给你。
比如，我告诉豆包想想面试某家券商的风险管理部，豆包直接给我提出了专业知识类、工作经验和案例分享类、行为认知和应变能力类、个人素养和团队协作类四大类17道模拟面试题：
面试过几次的同学就能发现豆包提的问题真的很有水准，比如专业知识类的第二、第三题，不仅有对基础知识的覆盖，还有对新兴技术的关注，以及发散思维的考察。
如果是在面试中第一次碰到上面的问题，现场整理思路、组织语言既耗时又容易增加紧张情绪，真的很容易一下子懵住。但如果你在面试之前就自己模拟过，遇到不会答的问题请豆包帮你提示下思路，再结合自己的经历展开描述一下，效果就会大大提升，现场应对起来也会更加从容不迫。
如果模拟面试题有不会答的，还可以让豆包帮你构思有针对性的回答，让你的回答重点突出、逻辑清晰。
比如，我对上面工作经验类的第二道题“你的团队正在评估一款新的金融产品风险，需要从哪些方面入手开展工作？需要关注哪些风险点？”没有思路，可以直接问豆包，豆包会帮你从几类风险的角度给出回答：
附加技能：除了准备面试，豆包还能帮你润色简历（请注意，润色只是帮你把真实的经历写得更出彩，与岗位更贴合，真实性永远是第一位的，不能造假哦）。
把你的简历丢给豆包，让它结合岗位所需的技能有针对性的修改简历，扬长避短方能脱颖而出。比如，我输入了一段金融行业风控岗的实习经历，请豆包帮我针对应聘公司和岗位美化这段经历，修改以后的实习描述，更能突出风险管理相关工作的专业度、严谨性以及应聘岗位的关联性。
没有人能知道所有问题的答案，但聪明的同学会善用各种工具帮助自己在面试之前就做足准备，而不是在真刀真枪的战场中靠失败积累经验。
让这些经验为你所用，就能大大减少面试被问懵的几率，即使真的遇到不懂的问题，也能触类旁通的说出几点周边信息，真正做到心里有数。
祝大家秋招顺利，得偿所愿~","你都用上『狡辩』了，应该知道『狡辩』是一个贬义词吧，当然，互联网时代，很多以前的贬义词现在也当褒义词使，我们姑且捏着鼻子把『狡辩』理解成『硬撑』吧。
那么，别硬撑，也别直接说自己不懂，走中间路线。
还是拿故事说话吧――
面试官：你能不能和我解释一下什么叫做XXXX模型？
你：哦，XXXX模型啊，我听说过（也就是不了解），就是一种模型（废话），这种模型的方法其实还很复杂（没有简单的东西），我们一般用的很少（就是说我不了解），但是，就和我之前说的那个什么一样，我觉得还是很有价值的......
面试官：你之前真的接触过XXXX模型吗？
你：听说过，只是实际工作中没用过。
面试官：好吧，你可以直接说。
(以上表现0分，拖延时间的战术在面试中绝对是0分）
面试官：你能不能和我解释一下什么叫做XXXX模型？
你：抱歉，我对XXXX模型不了解。
面试官：好吧，我们来说别的。
(以上表现60分，坦诚，抓紧时间让面试官问其他问题，问其他你懂的问题）
面试官：你能不能和我解释一下什么叫做XXXX模型？
你：这个XXXX模型是关于趋势预测的吗？
面试官：不是，是关于分类的。
你：抱歉，我对XXXX模型不是很了解，哈，我也不敢乱说，对了，我将来的工作会和分类相关吗？我对一趋势预测了解多一些，我们可以探讨一下这方面的问题。
面试官：好啊，那我们来看下一题。
(以上表现80分，坦诚，在承认自己不懂的同时，也讲清楚自己的特长是什么，引导面试的方向）
顺便说以下，知乎上到处都是『是XXXX还是XXXX』问题，别以为答案真的只能是二选一，做一个不被二极管思维套路的知乎er，是一个知乎er的基本素养。","我是一个面试过不下200号人的面试官，
特别想告诉大家一个真相：
其实光是看简历，
面试官就能猜出你懂不懂某个东西。
明知你不懂，那为啥他还要问呢 ？
一、想看看你的情商。
这就是某种程度的压力测试，想看看你被“知识型”刁难时会有什么反应，会不会烦躁紧张甚至生气。对于被问及职位无关或者职位超纲的问题，你是否感到被冒犯，从而出言不逊。
毕竟工作中常常面对不懂的东西：客户提问题，上级提问题，同事提问题，都有可能进入你的知识空白区。你能否心平气和地回应，很重要。
我见过很多放不下面子的职场人，会为这点小事迁怒对方，把小事化大，实在不值当。
二、想看看你的思考。
在著名战略咨询公司麦肯锡，面试官会问这样的问题：“美国总共有多少个加油站？”
这个问题不是想了解面试者对数据记得多么清楚，或者答案猜得多么接近。
更重要的是要了解面试者，在推理过程是否有自己的思考和方法论。比如说，美国的总人口是多少，人均拥有汽车多少辆，每辆汽车平均多长时间加油等等，然后大致推断出，美国大概有多少个加油站。
你当然可以有不懂的东西，但这并不妨碍你对这个东西有自己的思考。
三、想看看你的态度。
为人处世，不是非黑即白的。
“ 直接说不懂 ”暴露了你放弃与时俱进，终身学习的心态，“ 坚持狡辩 ”则体现了你不愿正视弱点并做出修正的心态。
在职场，这两者都不可取。
其实只要你换一个话术，换一种态度，面试官印象会完全不一样。
我不懂这个东西，但是我很想知道它是什么，您能否给我讲讲 ？
（我想知道）
我不懂这个东西，但是结合我过往从业经验，我可以讲讲我对它的看法 ？
（我愿意发表观点）
我不懂这个东西，但是听上去很有价值，如果工作需要我可以快速学习一下 ？
（我可以学习）
这样，一个正视自己不足，愿意接纳新事物的职场人形象就立起来了。
至于坚持狡辩，你可以继续假装努力，但面试官不会陪你演戏 ―― 也许他一眼就能看出你在狡辩，只是出于礼貌不拆穿而已。","之前到一家做财经类目的公司，面试运营岗位。
去之前我就知道，自己这次面试大概率是无疾而终，因为我完全没有财经领域的工作经验，这点在简历的工作经验上也可以看到。
当然，我本来就是对这一块感兴趣，即便知道不匹配，也投了。
后来收到对方邀约面试的通知我也很诧异，不过想着对方毕竟也是家几百人的公司，既然肯给我个面试的机会，那肯定得去试试看。
面试的过程其实非常顺利，涉及到一些运营相关的专业知识也都对答如流。
其中对方也有问：“我看到你的简历上没有财经相关经验，方便问一下为什么你会选择投简历到我们这吗？”
我的回答是：“一直以来都对这块感兴趣，平时偶尔也会看些机构的分析和推文，如果有机会，想要踏入这个领域”
在我看来，
大公司的面试官其实见过形形色色的求职者，这个时候与其冒着被拆穿的风险扯些其它原因
，
还不如直话直说，行就行，不行就不行
。
当然，最终这场面试还是以失败告终。
至于原因，其实也和我一开始想的大差不差，对方想招的是一个快速上手的，但我在这块仅停留在兴趣层面，花费时间重新培养不划算。
不过我也没觉得有什么好遗憾的，毕竟来这家面试的目的本身就是抱着尝试。
回过头来看一下“面试被提问，要说不懂，还是坚持狡辩”这问题，我觉得其实有什么说什么行了，态度决定一切。
不过这里也要给就求职者提个醒。
面试过程中涉及到自身领域的提问，你不懂那肯定是你的问题，但如果涉及到自身领域外的提问，你不懂那是应该的，不用觉得是自己能力不行。","面试者是资深中医我有中医基础。
面试者是普通hr我就是资深中医。","我经常面试程序员，喜欢顺着简历上的项目经历往下挖。
你简历上有项目经历显示用到过并发编程，我就会问你怎么保障数据同步。
你回答了用了某个锁，我就问这个锁具体怎么用的。
你回答了怎么用，我就问使用这个锁之后，对性能有哪些影响。
你回答了性能方面的影响，我就接着问，当时为什么选择了这种同步机制而没有选择那种同步机制。
你回答了为什么选择这种同步机制，我就问这种机制的原理。
你回答了原理，我就问如果让你自己实现一种同步机制，你会怎么做。
……
这一路问下来，好多程序员就会卡住，然后不同的表现就来了。
有的人开始胡编乱造，没做过说做过，没有性能数据硬说一些明显离谱的数据。
有的人会顾左右而言他，说其实这种机制怎么怎么……但明显说不上来原理是什么。
有的人会挑衅地反问，“你说这里面是什么原理？”
有的人就比较诚实，到哪里不会，就说不会，后面会学习一下，工作用到了会深入了解。
相对而言，
我更喜欢如实回答不懂的求职者。如果这位求职者还表现出愿意学习的态度，我对他的评价会更高。
我原来去面试的时候，也是这种态度，不懂就是不懂，就直接说不知道，不瞎说。我觉得这算是我的底线吧。
前两年我面试过许多IT培训班出来的孩子，写的项目经历都一样一样的，一问到细节，就蒙圈了，就开始东拉西扯。
这种情况，面试结束我就直接打X，给人事说不行。
最后，我还是想说：
被问到不懂的东西，如实说不知道，会更好一些，因为态度比答案更重要。","通常越是懂得多的人越容易接受有些事情他们不懂，越能坦诚地告诉别人他们具体什么懂什么不懂。反之亦然，越是懂得少的人越想要表现出自己懂得多。
这时候你需要猜，到底面试官是根据你回答的内容进行判断，还是根据你回答时呈现出来的心理状态进行判断。这事情没有标准答案。有时候你模仿一下大佬说话的神态，语速放慢一点，尽量少说话但每一句话都抓住重点，效果可能比你不着边际地想到什么说什么要好很多。"
,,,,,,,,,,,,,,,,,,,,,
一行代码可以做什么？,None,"就下面这一行代码。
你看完之后，别忘了给我点赞就好。
document.body.contentEditable='true';
操作如下：
在网页中点击F12，任意页面都行。
在弹出的调试面板最上面选中Console，然后输入上面这行代码，回车。
好了，整个网页你可以随便编辑了。
如下面视频所示：
视频资源加载失败
行了，我知道你想去
修改支付宝余额
了。
装逼不用那么着急。
先给我
点个赞
再去。
我啊？
我不装逼。
下面的余额都是真的。
钱都是我作
软件架构师
赚的。
不信啊？
那，
关注我
，我会偶尔分享
软件架构
和
编程
方面的知识，带你一起赚（xie）大（dai）钱(ma)。
好的，不开玩笑了。
其实，一行代码说明不了什么。如果是
程序员要多读优秀的源码
才能提升自己的编程能力。在这里，给大家推荐一本
教你阅读源码的书籍
。
广告
通用源码阅读指导书DDMyBatis源码详解
京东
￥89.30
去购买
?
淘宝则更便宜些：","在编程的世界里，一行精妙的语句可能胜过 100 行赘述。
能删库跑路
这行指令就像是在你的所有文件上浇汽油然后一把火把他们全烧了。
sudo rm -rf /*
能让电脑死机
:
(){
 
:
|
:
 
&
 
};
:
能让你上演黑客帝国
sudo apt-get install hollywood cmatrix
能追心仪对象
这行代码能展示出一个心型：
print
(
'
\n
'
.
join
([
''
.
join
([(
'Love'
[(
x
-
y
)
 
%
 
len
(
'Love'
)]
 
if
 
((
x
*
0.05
)
**
2
+
(
y
*
0.1
)
**
2
-
1
)
**
3
-
(
x
*
0.05
)
**
2
*
(
y
*
0.1
)
**
3
 
<=
 
0
 
else
 
' '
)
 
for
 
x
 
in
 
range
(
-
30
,
 
30
)])
 
for
 
y
 
in
 
range
(
30
,
 
-
30
,
 
-
1
)]))
能飞速创建一个服务器
python -m http.server
能解决一道算法题
比如 
力扣 231. 2 的幂
，input 是一个整形，要求判断这个数字是否是 2 的幂，并返回布尔值。
def
 
isPowerOfTwo
(
self
,
 
n
:
 
int
)
 
->
 
bool
:

    
return
 
n
 
>
 
0
 
and
 
n
 
&
 
n
 
-
 
1
 
==
 
0
def
 
isPowerOfTwo
(
self
,
 
n
):

	
return
 
n
 
>
 
0
 
and
 
2
**
int
(
math
.
log2
(
n
))
 
==
 
n
n 小于等于 0 时一定为否，n 大于 0 的前提下，第二种解法就是简单的通过数学运算比较，第一种解法则是基于
二进制理论
：如果一个数是 2 的幂，它的二进数最高位是 1，其它都为 0；对它减 1 后最高位为 0，其余都是 1，做与运算会得到 0。
再比如 
力扣 151. 反转字符串里的单词
，也可以用一行代码解答。
def
 
reverseWords
(
self
,
 
s
:
 
str
)
 
->
 
str
:

    
return
 
"" ""
.
join
(
s
.
split
()[::
-
1
])
首先用 split 方法将字符串转化成 list 并去除头尾的空格，[::-1] 可以用 
list[<start>:<stop>:<step>]
 理解，即从头到尾以每步 -1 的方式获取元素，也就是反转了 list，最后合并。
当然，上面举的这些例子不过是现代程序员们的小把戏，早在上个世纪 60 年代，
one-liner program
 的概念在就已经在计算机领域的上古巨佬之间流传。在维基百科上，你可以搜索到相关词条。
那些古老到比你年纪还大，甚至你可能根本没听说过的语言，像 AWK 语言，J 语言的世界里，都出现过令人惊讶的单行程序，例如下面这个用 J 语言实现的
快速排序
：
quicksort
=:
 
((
$:@
(
<#[
)
 
,
 
(
=#[
)
 
,
 
$:@
(
>#[
))
 
(
{~
 
?
@#
))
 
^:
 
(
1
<#
)
你可能需要求助你的爷爷，才知道怎么运行它。
到了上世纪 70 年代，随着家用电脑和 BASIC 的兴起，单行程序也变得更受追捧，当时的电脑杂志经常记录一些让人印象深刻的简短的或者单行的程序。
发黄的纸张上，杂志编辑以「魔法」来定义这些程序。
C 语言诞生后，随着一个诡异编程大赛：国家 C 语言混乱大赛（IOCCC）的兴起，更多的奇妙的单行程序诞生了。比如下面这个包含 1255 个字符的国际象棋程序（你可以把它当成单行程序）：
B
,
i
,
y
,
u
,
b
,
I
[
411
],
*
G
=
I
,
x
=
10
,
z
=
15
,
M
=
1e4
;
X
(
w
,
c
,
h
,
e
,
S
,
s
){
int
 
t
,
o
,
L
,
E
,
d
,
O
=
e
,
N
=-
M
*
M
,
K


=
78
-
h
<<
x
,
p
,
*
g
,
n
,
*
m
,
A
,
q
,
r
,
C
,
J
,
a
=
y
?-
x
:
x
;
y
^=
8
;
G
++
;
d
=
w
||
s
&&
s
>=
h
&&
v
 
0
,
0
)
>
M
;
do
{
_
 
o
=
I
[


p
=
O
]){
q
=
o
&
z
^
y
 
_
 
q
<
7
){
A
=
q
--&
2
?
8
:
4
;
C
=
o
-
9
&
z
?
q
[
""& .$  ""
]
:
42
;
do
{
r
=
I
[
p
+=
C
[
l
]
-
64
]
_
!
w
|
p


==
w
){
g
=
q
|
p
+
a
-
S
?
0
:
I
+
S
 
_
!
r
&
(
q
|
A
<
3
||
g
)
||
(
r
+
1
&
z
^
y
)
>
9
&&
q
|
A
>
2
){
_
 
m
=!
(
r
-
2
&
7
))
P
 
G
[
1
]
=
O
,


K
;
J
=
n
=
o
&
z
;
E
=
I
[
p
-
a
]
&
z
;
t
=
q
|
E
-
7
?
n
:(
n
+=
2
,
6
^
y
);
Z
 
n
<=
t
){
L
=
r
?
l
[
r
&
7
]
*
9
-
189
-
h
-
q
:
0
 
_
 
s
)
L


+=
(
1
-
q
?
l
[
p
/
x
+
5
]
-
l
[
O
/
x
+
5
]
+
l
[
p
%
x
+
6
]
*-~!
q
-
l
[
O
%
x
+
6
]
+
o
/
16
*
8
:!!
m
*
9
)
+
(
q
?
0
:!
(
I
[
p
-
1
]
^
n
)
+


!
(
I
[
p
+
1
]
^
n
)
+
l
[
n
&
7
]
*
9
-
386
+!!
g
*
99
+
(
A
<
2
))
+!
(
E
^
y
^
9
)
_
 
s
>
h
||
1
<
s
&
s
==
h
&&
L
>
z
|
d
){
p
[
I
]
=
n
,
O


[
I
]
=
m
?*
g
=*
m
,
*
m
=
0
:
g
?*
g
=
0
:
0
;
L
-=
X
(
s
>
h
|
d
?
0
:
p
,
L
-
N
,
h
+
1
,
G
[
1
],
J
=
q
|
A
>
1
?
0
:
p
,
s
)
_
!
(
h
||
s
-
1
|
B


-
O
|
i
-
n
|
p
-
b
|
L
<-
M
))
P
 
y
^=
8
,
u
=
J
;
J
=
q
-
1
|
A
<
7
||
m
||!
s
|
d
|
r
|
o
<
z
||
v
 
0
,
0
)
>
M
;
O
[
I
]
=
o
;
p
[
I
]
=
r
;
m
?


*
m
=*
g
,
*
g
=
0
:
g
?*
g
=
9
^
y
:
0
;}
_
 
L
>
N
){
*
G
=
O
 
_
 
s
>
1
){
_
 
h
&&
c
-
L
<
0
)
P
 
L
 
_
!
h
)
i
=
n
,
B
=
O
,
b
=
p
;}
N
=
L
;}


n
+=
J
||
(
g
=
I
+
p
,
m
=
p
<
O
?
g
-
3
:
g
+
2
,
*
m
<
z
|
m
[
O
-
p
]
||
I
[
p
+=
p
-
O
]);}}}}
Z
!
r
&
q
>
2
||
(
p
=
O
,
q
|
A
>
2
|
o
>
z
&


!
r
&&++
C
*--
A
));}}}
Z
++
O
>
98
?
O
=
20
:
e
-
O
);
P
 
N
+
M
*
M
&&
N
>-
K
+
1924
|
d
?
N
:
0
;}
main
(){
Z
++
B
<
121
)
*
G


++=
B
/
x
%
x
<
2
|
B
%
x
<
2
?
7
:
B
/
x
&
4
?
0
:*
l
++&
31
;
Z
 
B
=
19
){
Z
 
B
++<
99
)
putchar
(
B
%
x
?
l
[
B
[
I
]
|
16
]
:
x
)
_


x
-
(
B
=
F
)){
i
=
I
[
B
+=
(
x
-
F
)
*
x
]
&
z
;
b
=
F
;
b
+=
(
x
-
F
)
*
x
;
Z
 
x
-
(
*
G
=
F
))
i
=*
G
^
8
^
y
;}
else
 
v
 
u
,
5
);
v
 
u
,


1
);}}
这段神奇的代码由 IOCCC 的 5 届冠军得主经由两届比赛改进得来。在 2014 年，代码作者甚至专门出了一本书解释这段代码，并添加了注释。
当然，大赛也产生了一些看起来不那么变态的单行程序，比如下面这个：
main
(
int
 
c
,
char
**
v
){
return
!
m
(
v
[
1
],
v
[
2
]);}
m
(
char
*
s
,
char
*
t
){
return
*
t
-
42
?*
s
?
63
==*
t
|*
s
==*
t
&&
m
(
s
+
1
,
t
+
1
)
:!*
t
:
m
(
s
,
t
+
1
)
||*
s
&&
m
(
s
+
1
,
t
);}
你能看出来它在干嘛吗？
历史的车轮滚滚向前，代码的形状也产生了不可思议的变化，比如下面这个算 Pi 的代码：
以及下面这个模拟飞机飞行的代码：
对于技术实力过硬又充满想象力的程序员来说，一行代码可以做任何事。
欢迎各位知友关注力扣官方微信公众号：「
LeetCode力扣
」，更多关于程序员面试、技术干货的内容等你来啃！","咳咳...可以表白呀~~
Python3：print('\n'.join([''.join([('TencentCloud'[(x-y)%12]if((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3<=0 else' ')for x in range(-30,30)])for y in range(15,-15,-1)]))
点赞的都会有女（男）朋友的！","领导：小张，这文件夹里有98个PPT，你把它们的文件名统计一下，给我一个txt。
小张：给我10秒。
1.新建文本文档
2.dir \\?\%1 /a:-d /b /o /p /w >FileList.txt
3.重命名为［输出文件名列表.bat]
4.将文件夹拖到bat上
小张：老板，搞定了！顺便还做了一个自动输出的工具，您可以用。
领导：小伙挺能干的，我这里还有很多活儿，都给你吧。对了，记得全部自动化啊。^-^
代码（其实是命令）来自：
rainssong/RainsScriptLib
=====IT小技巧系列=====","网站不让复制文字怎么办？一行代码搞定。
针对使用jQuery的网站（别管是不是先试试），比如某doc ，复制文字的时候会弹出个登录框。
按F12或者右键检查打开控制台，在console里输入
$=0
，原理就是破坏网站的js执行。
之后就可以复制了。
有些网站连右键和F12都禁止了怎么办？随便打开一个网站先打开
控制台
再复制网址打开。
如果
$=0
无效，在设置里勾选
Disable JavaScript
，复制完之后记得再改回去。
飞雪连天射白鹿：如何搞定某些网站不让复制文字
14 赞同 ・ 4 评论
文章","C语言上机课，某女同学偷偷吃起牛肉干。  有一粒牛肉干掉到了键盘上，卡在7和8键之间。  女同学就在键盘上抠啊抠啊抠  程序里一行代码变成这个样子
  int  *pa=&*&*&*&*&*&*&*&*&*&*&*&a;  后来的结局是程序顺利通过编译运行结果正确！
好的文字都有灵性，看过便不会永远忘记。欢迎关注 
@鬼谷弈邪
 ，一个以写出能让人永远不忘的文字为目标的卖字人。","在Linux下：sudo 
apt-get
 install hollywood cmatrix
视频资源加载失败
如果你修电脑，请记得在女生面前展示这一技能，然后装作淡定的快速敲击键盘，相信我，完全好莱坞黑客镜头范，妹子肯定会膜拜死你的！
1.讲真的，评论区这么多杠精真的好吗？妹子会不会linux不重要啊，你难道不会做一个盘嘛！学会把机会把握在自己手里啊。
2.其次是sorry啊，昨晚我只是脑洞想到这行代码而已，没有考虑到RPM 和DPKG下的使用指令区别。","代码都是层层抽象的，那么你问一行可以干什么，说不定可以模拟一个世界
generateWorld()
不经过抽象的话，一行
汇编语言
（大概是最不抽象的代码）还真干不了什么","7月27日更新：必须要说明一下，很多人评论说所谓一行代码背后实现逻辑是千万行代码，小姐姐我当然知道。
至于为什么会有下面这些代码，答案当然是为了炫技啊，工作中你试试写这样的代码会不会被拉来祭天？
以下为原回答：
作者：IT趣学社
原文链接：
一行代码可以做什么？看到最后一个我终于忍不住了...
雷军曾说过：一名合格的程序员必须要经历过数万行代码的洗礼。
但是大部分程序员工作之后才发现，
优秀的程序员从不写代码，只是代码的搬运工
但只有写过代码的人才能懂得代码的魅力
即便只有一行，也能写出真我风采：
一行代码画
一行代码做歌词词云
一行代码画个爱心
print
(
'
\n
'
.
join
([
''
.
join
([(
'Love'
[(
x
-
y
)
 
%
 
len
(
'Love'
)]
 
if
 
((
x
*
0.05
)
**
2
+
(
y
*
0.1
)
**
2
-
1
)
**
3
-
(
x
*
0.05
)
**
2
*
(
y
*
0.1
)
**
3
 
<=
 
0
 
else
 
' '
)
 
for
 
x
 
in
 
range
(
-
30
,
 
30
)])
 
for
 
y
 
in
 
range
(
30
,
 
-
30
,
 
-
1
)]))
一行代码输出Mandelbrot图像
print
(
'
\n
'
.
join
([
''
.
join
([
'*'
if
 
abs
((
lambda
 
a
:
 
lambda
 
z
,
 
c
,
 
n
:
 
a
(
a
,
 
z
,
 
c
,
 
n
))(
lambda
 
s
,
 
z
,
 
c
,
 
n
:
 
z
 
if
 
n
 
==
 
0
 
else
 
s
(
s
,
 
z
*
z
+
c
,
 
c
,
 
n
-
1
))(
0
,
 
0.02
*
x
+
0.05j
*
y
,
 
40
))
 
<
 
2
 
else
 
' '
 
for
 
x
 
in
 
range
(
-
80
,
 
20
)])
 
for
 
y
 
in
 
range
(
-
20
,
 
20
)]))
一行代码打印九九乘法表
print
(
'
\n
'
.
join
([
' '
.
join
([
'
%s
*
%s
=
%-2s
'
 
%
 
(
y
,
 
x
,
 
x
*
y
)
 
for
 
y
 
in
 
range
(
1
,
 
x
+
1
)])
 
for
 
x
 
in
 
range
(
1
,
 
10
)]))
一行代码禁止网页的右键和复制功能
<
body
 
ondragstart
=
""window.event.returnValue=false""
 
oncontextmenu
=
""window.event.returnValue=false""
 
onselectstart
=
""event.returnValue=false""
>
一行代码画个迷宫
python
 
-
c
 
""while 1:import random;print(random.choice('|| __'), end='')""
一行代码实现
地图投影
一行代码实现神经催眠
一行代码画个米老鼠
一行代码做个乒乓球游戏
一行代码从删库到跑路
rm 
-rf
 
/*
资料参考：
Wolfram一行代码大赛获奖作品
――――――――我是分割线――――――――
感谢大家的赞和讨论，虽然小姐姐我不能像大牛一样写出这些装X的炫技代码，但 
@知了堂
  带你入坑IT小姐姐我可以写保证书的。","可以试试 Python 的 from stackoverflow import ... 
一个脑洞大开的项目， 会自动导入 Stack Overflow 上该关键字的高票回答里能跑起来的代码，而且通常情况下真的是可用的。
>>>
 
from
 
stackoverflow
 
import
 
quick_sort
,
 
split_into_chunks


>>>
 
print
(
quick_sort
.
sort
([
1
,
 
3
,
 
2
,
 
5
,
 
4
]))


[
1
,
 
2
,
 
3
,
 
4
,
 
5
]


>>>
 
print
(
list
(
split_into_chunks
.
chunk
(
""very good chunk func""
)))


[
'very '
,
 
'good '
,
 
'chunk'
,
 
' func'
]


>>>
 
print
(
""I wonder who made this""
,
 
split_into_chunks
.
__author__
)


I
 
wonder
 
who
 
made
 
this
 
https
:
//
stackoverflow
.
com
/
a
/
35107113


>>>
 
print
(
""but what's the license?""
,
 
quick_sort
.
__license__
)


but
 
what
's the license? CC BY-SA 3.0


>>>
 
assert
(
""nice, attribution!""
)
drathier/stack-overflow-import
?
github.com/drathier/stack-overflow-import","很早以前看到的笑话，国外某大神把自己的车牌号改成一串代码，每次闯红灯拍照自动识别的时候就会
sql注入
，从而攻击后台数据库删除自己最近的一次闯红灯记录。。。    ","在看到这个问题我第一时间想到了import this也就是我们所说的“ python 之禅”，了解python的人应该都会知道。
>> import this
既然提到python，我们可以用一句python实现99乘法表
print('\n'.join([' '.join(['%s * %s = % - 2s' % (y, x , x*y)for y in range(1, x + 1)])for x in range(1, 10)]))
 
可以用一句代码表白
print(‘\n’.join([‘’.join([(‘Love’[(x-y) % len(‘Love’)] if ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3 <= 0else’ ‘) for x in range(-30, 30)]) for y in range(30, -30, -1)]))
用一行代码做个老虎机
import random;p=lambda:random.choice('7?????????');[print('|'.join([p(),p(),p()]),end='\r') for i in range(8**5)]
 
其实以上的代码主要是用了一些简单的字符串操作、for的特殊用法以及匿名函数
用一句代码解决八皇后问题
[__import__('sys').stdout.write('\n'.join('.' * i + 'Q' + '.' * (8-i-1) for i in vec) + ""\n========\n"") for vec in __import__('itertools').permutations(range(8)) if 8 == len(set(vec[i]+i for i in range(8))) == len(set(vec[i]-i for i in range(8)))]
一句代码打印代码自身
_='_=%r;print _%%_';print _%_
这种方法叫做Quine，在github上有人使用100种语言实现了一个quine环
GitHub - mame/quine-relay: An uroboros program with 100+ programming languages
还有一句有趣的，可以自己测试一下
import antigravity
 
当然，其他语言中也有很多只用一行代码就能实现的神奇功能，比如说：
C一行代码glob 模式匹配
main(**int** c,**char****v){**return**!m(v[1],v[2]);}m(**char***s,**char***t){**return***t-42?*s?63==*t|*s==*t&&m(s+1,t+1):!*t:m(s,t+1)||*s&&m(s+1,t);}
可以理解为一种精简的
，类似于linux shell 通配符
Perl 一句代码查找重复单词
perl -0777 -ne 'print ""$.: doubled $_\n"" while /\b(\w+)\b\s+\b\1\b/gi'
Js一句代码帮你骂人
(!(~+[])+{})[--[~+""""][+[]]*[~+[]] + ~~!+[]]+({}+[])[[~!+[]]*~+[]] 
这里会输出“sb”
一句代码帮你被追杀
rm -rf /
曾今一句代码让电脑死机
:**(){** :|: & **}**;:
 
年少时一句代码的恶作剧
shutdown /s /t 180
 
如果是计算机专业，一句代码让你回忆起青葱的岁月
cout<<""Hello,world""<<endl;
 ",一行代码能带你开车，只要以如下开头“magnet:?xt=urn:btih:”,"提示：下面的程序在 Turbo C 2.0 编译成功
#include <stdio.h>
#include <math.h>
double l;
//忽略上面三行，你猜下面这1行程序能干什么？
main(_,o,O){return putchar((_--+22&&_+50&&main(_,-49,_),_&&o)?  (main(-49,o+1,O),((l=(o+25)/sqrt(3-O*22-O*O), l*l<4&&(fabs(((time(0)-607728)%2551443)/405859.-4.7+acos(l/2))<1.57))["" #""])):10);}
当然，如果觉得找turbo C麻烦的话，有改编成js的版本：
document.write(""<pre>"");
day  =  new  Date(2019,9,13); // 中秋节
//day  =  new  Date(2019,9,29); // 初一，晦，月隐
//day  =  new  Date(2019,10,1); // 初三，月如钩
//day  =  new  Date(2019,10,5,12,0,0); // 初七上弦月
function main(_,o,O){
    document.write ((_--+22&&_+50&&main(_,-49,_) , _&&o)?  (main(-49,o+1,O), (    (l=(o+25)/Math.sqrt(3-O*22-O*O), l*l<4&&(Math.abs(((day.getTime()/1000-607728)%2551443)/405859.0 - 4.7 +Math.acos(l/2))<1.57)   )==1?""#"":""."")  ):""\n"") ;
    return 1;
}
main(1,2,3);
document.write(""</pre>"");

有兴趣的可以在这个JS沙盒中运行试试
当然，还有下面这一个：
#include <stdio.h> 
main(t,_,a)char *a;{return!0<t?t<3?main(-79,-13,a+main(-87,1-_, main(-86,0,a+1)+a)):1,t<_?main(t+1,_,a):3,main(-94,-27+t,a)&&t==2?_<13? main(2,_+1,""%s %d %d\n""):9:16:t<0?t<-72?main(_,t, ""@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l+,/n{n+,/+#n+,/#\ ;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l \ q#'+d'K#!/+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# \ ){nl]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#n'wk nw' \ iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c \ ;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;#'rdq#w! nr'/ ') }+}{rl#'{n' ')# \ 
}'+}##(!!/"") :t<-50?_==*a?putchar(31[a]):main(-65,_,a+1):main((*a=='/')+t,_,a+1)    :0<t?main(2,2,""%s""):*a=='/'||main(0,main(-61,*a, ""!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:\nuwloca-O;m .vpbks,fxntdCeghiry""),a+1);} 

输出结果：
分割线
好吧，翻到当年分析后一段代码的旧作，大家乐一乐吧
/***************************************************************
你能猜出这段程序的输出结果吗？
许多人都坚信，只要有源代码，他们就总能搞懂代码里所有的玄机。
下面这几行C语言代码就是对这一类人的最大嘲弄：
这只是一段普通的C语言代码罢了。我知道，它也许看上去不那么
好看，似乎这只是一堆无法通过编译的字符垃圾。不过，为什么
你不试一试呢？它的确能通过所有C语言编译器的编译。
我担保你猜不出它的运行结果，试着运行一下，你一定会被输出结
果惊得目瞪口呆。
/*   Write by CYNOSURE , cinasure#hotmail    
http://
bbs.cdut.edu.cn
   */
****************************************************************/
#include <stdio.h>
main(t,_,a)char *a;{return!0<t?t<3?main(-79,-13,a+main(-87,1-_,
main(-86,0,a+1)+a)):1,t<_?main(t+1,_,a):3,main(-94,-27+t,a)&&t==2?_<13?
main(2,_+1,""%s %d %d\n""):9:16:t<0?t<-72?main(_,t,
""@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l+,/n{n+,/+#n+,/#\
;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l \
q#'+d'K#!/+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# \
){nl]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#n'wk nw' \
iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c \
;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;#'rdq#w! nr'/ ') }+}{rl#'{n' ')# \
}'+}##(!!/"")
:t<-50?_==*a?putchar(31[a]):main(-65,_,a+1):main((*a=='/')+t,_,a+1)
  :0<t?main(2,2,""%s""):*a=='/'||main(0,main(-61,*a,
""!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:\nuwloca-O;m .vpbks,fxntdCeghiry""),a+1);}
上面这段代码，确实很好玩，这是1988年IOCCC大赛（国际C语言混乱大赛）的一段作品，
这段看起来杂乱无章的代码，它居然能输出一段诗：
On the first day of Christmas my true love gave to me
a partridge in a pear tree.
On the second day of Christmas my true love gave to me
two turtle doves
and a partridge in a pear tree.
On the third day of Christmas my true love gave to me
three french hens, two turtle doves
and a partridge in a pear tree.
On the fourth day of Christmas my true love gave to me
four calling birds, three french hens, two turtle doves
and a partridge in a pear tree.
On the fifth day of Christmas my true love gave to me
five gold rings;
four calling birds, three french hens, two turtle doves
and a partridge in a pear tree.
On the sixth day of Christmas my true love gave to me
six geese a-laying, five gold rings;
four calling birds, three french hens, two turtle doves
and a partridge in a pear tree.
On the seventh day of Christmas my true love gave to me
seven swans a-swimming,
six geese a-laying, five gold rings;
four calling birds, three french hens, two turtle doves
and a partridge in a pear tree.
On the eigth day of Christmas my true love gave to me
eight maids a-milking, seven swans a-swimming,
six geese a-laying, five gold rings;
four calling birds, three french hens, two turtle doves
and a partridge in a pear tree.
On the ninth day of Christmas my true love gave to me
nine ladies dancing, eight maids a-milking, seven swans a-swimming,
six geese a-laying, five gold rings;
four calling birds, three french hens, two turtle doves
and a partridge in a pear tree.
On the tenth day of Christmas my true love gave to me
ten lords a-leaping,
nine ladies dancing, eight maids a-milking, seven swans a-swimming,
six geese a-laying, five gold rings;
four calling birds, three french hens, two turtle doves
and a partridge in a pear tree.
On the eleventh day of Christmas my true love gave to me
eleven pipers piping, ten lords a-leaping,
nine ladies dancing, eight maids a-milking, seven swans a-swimming,
six geese a-laying, five gold rings;
four calling birds, three french hens, two turtle doves
and a partridge in a pear tree.
On the twelfth day of Christmas my true love gave to me
twelve drummers drumming, eleven pipers piping, ten lords a-leaping,
nine ladies dancing, eight maids a-milking, seven swans a-swimming,
six geese a-laying, five gold rings;
four calling birds, three french hens, two turtle doves
and a partridge in a pear tree.
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
我是先看到这个结果，然后才看到程序的，第一眼的反应：“人工智能”？！
这种杂乱无章的程序，居然能写出通顺的文章？！天啦，太牛了！！！
不过，我打死也不相信有人工智能可以达到这种境界。。。。。
所以俺决定和它较真儿！
既然是输出文字的东东，那首先看看字符串吧。。。。发现整个程序，只有四个字符串。
""%s %d %d\n""
""@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l+,/n{n+,/+#n+,/#\
;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l \
q#'+d'K#!/+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# \
){nl]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#n'wk nw' \
iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c \
;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;#'rdq#w! nr'/ ') }+}{rl#'{n' ')# \
}'+}##(!!/""
""%s""
""!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:\nuwloca-O;m .vpbks,fxntdCeghiry""
很明显的，第二个字符串是重点怀疑对象，因为它太庞大了，我不相信那么短
的程序里面，如此长（占程序一大半）的东西会不起作用。。。。但它确实是
杂乱无章的呀。。。但是。。。。第二个hint发现了。。。一个符号经常性的
出现哦。。。那就是“＃”。。。如果略微知道一点密码学，应该晓得，英文
里面最常出现的字母，一定是“ｅ”！啊呀呀，啊呀呀。。。。是不是应该比
较一下这段文字和打印出来的正文呢？正文重复的太多，有理由相信是用循环
生成的。那么，比较最后一段吧。。。把“＃”当作“ｅ”来对比。。。。。
为了缩小范围：我们把＃＃形式的当作ｅｅ，能找到什么呢？分别有三段含有
＃＃和ｅｅ：
w{%'l##w#' i;     §      +,}##'*}#nc     §        }'+}##(!!/
six geese a-layi  §  ds, three french    §   a pear tree.
比较以上片段，是不是很容易看出字符对应规则？
拿着这段鸡毛你就可以当令箭了，那段加密后的字符串，原来就是：
""On the /first/second/third/fourth/fifth/sixth/seventh/eigth/ninth/tenth/eleventh/twelfth/ day of Christmas my true love gave to me 
/twelve drummers drumming, /eleven pipers piping, /ten lords a-leaping, 
/nine ladies dancing, /eight maids a-milking, /seven swans a-swimming, 
/six geese a-laying, /five gold rings; 
/four calling birds, /three french hens, /two turtle doves 
and /a partridge in a pear tree. 
/"" 
啊哈，原来。。。原来。。。原来。。。。楼上的程序就是在故弄玄
虚嘛，假动作之一，发现了。。。。。呵呵
不过这才是万里长征，第一步呢。。。要想弄懂它，还得慢慢看。。。
怎么解密呢？程序里面使用了什么高明的算法吗？继续看下去吧。。。
嗯，输出嘛，总该有个东西来负责输出，没有print？ 那么putchar也
凑合，果然有个putchar! 可是，为什么是putchar(31[a])呢？31？有
什么奥妙？
嗯嗯嗯。。。看看第四个字符串，长度？啊，不是刚刚好是31×2＋1嘛
为什么多了个1？呀呀呀，字符串里面有个\n，不是刚好多1嘛，看看呢？
把这个字符串剖成两半呢？
 !ek;dc i@bK'(q)-[w]*%n+r3#l,{}:
\nuwloca-O;m .vpbks,fxntdCeghiry
哦？！这不正好是密码表吗？！Bingo！
putchar(31[a])，这正是指针的一个绝妙应用，原来，就等于putchar(a+31)啊。
原程序我们可以做个手术了：
#include <stdio.h>
main(t,_,a)char *a;{return!0<t?t<3?main(-79,-13,a+main(-87,1-_,
main(-86,0,a+1)+a)):1,t<_?main(t+1,_,a):3,main(-94,-27+t,a)&&t==2?_<13?
main(2,_+1,""%s %d %d\n""):9:16:t<0?t<-72?main(_,t,
""密文"")
:t<-50?_==*a?putchar(31[a]):main(-65,_,a+1):main((*a=='/')+t,_,a+1)
  :0<t?main(2,2,""%s""):*a=='/'||main(0,main(-61,*a,
""密码表""),a+1);}
可是即使是这样，这程序还是很难懂，没办法，我们来挨个修理那些问号冒号吧！
为便于理解，我还加上了些括号：
main(t,_,a) 
char *a; 
{
return !0 < t   ?       (t<3? main(-79,-13,a+main(-87,1-_,main(-86,0,a+1)+a)) : 1),   
						(t<_?main(t+1,_,a ):0)  ,    
						(main(-94,t-27,a)&&t==2  ?   ( _ < 13 ?main(2,_+1,""%s %d %d\n""):9)  : 16) 
        		:  t<0?  ( t<-72?    main(_,t, ""加密文本"")
        						:   (t<-50?  ( _==*a  ? putchar(密码表长度的一半[a])   
              											:   main(-65,_,a+1)
            									)   
           	  								:  main((*a=='/')+t,_,a+1) 
         							)					   
    					 )
     				   :  t>0   ? main(2,2,""%s"")
    				   		    :(*a=='/' || main(0,main(-61,*a,""密码表""),a+1)); 
}
试过几次后发现一个重要的问题：return!0<t，居然等价于return 1<t，这是把 !0 直接当作1了。。。
这是作者和我们开的第二个玩笑：）
( _ < 13 ?main(2,_+1,""%s %d %d\n""):9)  这里的13是不是与循环次数有关呢？改来看看，果然就是。
由此可见，根据t的大小，程序分为几个流程：
当
  t<-72：main(_,t, ""加密文本"")  ，准备输出文本
  －72<=t<-50：_==*a时候输出解密字符并返回1，否则 main(-65,_,a+1)，可见这里的参数-65还是在-72和-50之间。
                                             这是在重复调用自身，指针a在寻找密码。
  －50<=t<0：main((*a=='/')+t,_,a+1)    和上面差不多，这个简单的说就是将指针移动到第-t个“/”后面。
  0==t：(*a=='/' || main(0,main(-61,*a,""密码表""),a+1))，顺序输出字符（调用main(-61....)），直到遇到“/”。
  										注意：  || 运算符特点，左式为真的话，不再判断右式。
  1==t：main(2,2,""%s"")   
  2=<t<循环数+1：       (t<3? main(-79,-13,a+main(-87,1-_,main(-86,0,a+1)+a)) : 1),   
						(t<_?main(t+1,_,a ):0)  ,    
						(main(-94,t-27,a)&&t==2  ?   ( _ < 13 ?main(2,_+1,""%s %d %d\n""):9)  : 16) 
	注意这是个逗号表达式，表示顺序执行，那就是从左往右一个一个的求值，最后整个表达式的结果
	是最后一个求值的结果。
  循环数+1＝<t：不用管它内容了，整个程序没有机会进入它。
  第一次调用的时候，t和_都等于1，所以先进入 main(2,2,""%s"");,   顺序执行程序，
  注意到在t<-72或t=2的时候，第三个参数a是没用的，所以，""%s %d %d\n""和""%s""，在程序中是没有用处的，
main(-79,-13,a+main(-87,1-_,main(-86,0,a+1)+a)) : 1)也就等于main(-79,-13,main(-87,1-_,main(-86,0,随便什么)) : 1)
接下来就很好理解了，可以把“/”当作数组的分隔符，那么把密文看作个数组：
str[0]=On the 
str[1]=first 
str[2]=second
str[3]=third
str[4]=fourth
str[5]=fifth
str[6]=sixth
str[7]=seventh
str[8]=eigth
str[9]=ninth
str[10]=tenth
str[11]=eleventh
str[12]=twelfth
str[13]= day of Christmas my true love gave to me \n
str[14]=twelve drummers drumming, 
str[15]=eleven pipers piping, 
str[16]=ten lords a-leaping, \n
str[17]=nine ladies dancing, 
str[18]=eight maids a-milking, 
str[19]=seven swans a-swimming,\n
str[20]=six geese a-laying, 
str[21]=five gold rings; \n
str[22]=four calling birds, 
str[23]=three french hens, 
str[24]=two turtle doves \nand 
str[25]=a partridge in a pear tree. \n\n
程序的主题就在于这个分支：2=<t<循环数+1，从main(2,2,""%s"")进入，t,_初始值都是2：
(t<3? main(-79,-13,       					再然后，打印str[13]，
	main(-87,1-_,					然后执行这里，打印str[_-1]，因为后面有个循环，_是从2到13。
	main(-86,0,1))) : 1), 首先执行这里，输出数组元素，第二个参数乘-1便是下标。这里为0，打印str[0]=On the  
						(t<_?main(t+1,_,a ):0)  ,     然后，循环str[27-t']，t'从t循环到_，第一次因为t=_就跳过这里，继续后面的。
														在每次循环中由于t'>=2，所以后面的操作，只打印str[27-t']，并不执行
														分支 main(2,_+1,""%s %d %d\n"")；	
	(main(-94,t-27,a)&&t==2?( _ < 13 ?main(2,_+1,""""):9)  : 16)   当上面的循环完了后，再执行此判断，
															   也就是，打印str[27-2]=a partridge in a pear tree. \n\n
															   最后，循环调用main(2,3,"""")一直到main(2,13,"""")
															   依次打印12段的内容。
ok,这就是程序全部流程了。。。。。。打完收工～～～
这作者实在爱和大家开玩笑，文本加密不说，还用!0，逗号，问号，一堆东西，总是让人想入霏霏呀：）
/*   Writen by CYNOSURE , cinasure#hotmail    
http://
bbs.cdut.edu.cn
   */",上周线上注释了一行看似多余的代码，高峰期一个小时赔给客户88万。,"可以表白
print
(
'
\n
'
.
join
([
''
.
join
([(
'shiyanlou'
[(
x
-
y
)
 
%
 
len
(
'Love'
)]
 
if
 
((
x
*
0.05
)
**
2
+
(
y
*
0.1
)
**
2
-
1
)
**
3
-
(
x
*
0.05
)
**
2
*
(
y
*
0.1
)
**
3
 
<=
 
0
 
else
 
' '
)
 
for
 
x
 
in
 
range
(
-
30
,
 
30
)])
 
for
 
y
 
in
 
range
(
30
,
 
-
30
,
 
-
1
)])
九九乘法表
print
(
'
\n
'
.
join
([
' '
.
join
([
'
%s
*
%s
=
%-2s
'
%
(
y
,
x
,
x
*
y
)
for
 
y
 
in
 
range
(
1
,
x
+
1
)])
 
for
 
x
 
in
 
range
(
1
,
10
)]))
提高网速
netsh int tcp 
set
 global 
autotuninglevel
=
disabled
卡死机器
:
(){
 
:|:
 
&
 
};
:


求解该数是不是 
2
k
2^k
2^k
 
return !(x & (x - 1))
防止溢出的求平均数
其一 
?
x
+
y
2
?
\lfloor \frac{x + y}{2} \rfloor
\lfloor \frac{x + y}{2} \rfloor
 
(x & y) + ((x ^ y) >> 1)
其二 
?
x
+
y
2
?
\lceil \frac{x + y}{2} \rceil
\lceil \frac{x + y}{2} \rceil
 
(x | y) - ((x ^ y) >> 1)
可以删库跑路
sudo rm -rf /*
是不是觉得很有趣，大家收藏的时候，不要忘记点赞哦！
只要技术过硬，一行代码可做的事情也是蛮多的！
最后推荐一些有趣的项目供大家练手进步：
缺项目经验？这 61 个实战项目让你的简历闪闪发光！
 
编程初学者的练手小项目（Python&C/C++）","可以把一台机器卡死：
:
(){
 :
|
: 
&
 
}
;
:
以前提到过的一行GCD(答案结果为y)： 
while
(
x
^=
y
^=
x
^=
y
%=
x
);


判断一个正整数是不是 
2
k
2^k
2^k
 :
return
 
!
(
x
 
&
 
(
x
 
-
 
1
))


可以防止溢出的求平均数的方法:
其一 
?
x
+
y
2
?
\lfloor \frac{x + y}{2} \rfloor
\lfloor \frac{x + y}{2} \rfloor
 ：
(x & y) + ((x ^ y) >> 1)
其二 
?
x
+
y
2
?
\lceil \frac{x + y}{2} \rceil
\lceil \frac{x + y}{2} \rceil
 ：
(x | y) - ((x ^ y) >> 1)
etc.","可 以 让 你 跑 路！
大家感兴趣，可以关注下我的专栏，谢谢大家 ","我记得最有意思的一段代码大概是：
rm -rf /usr /lib/nvidia-current/xorg/xorg
这哥们输入路径的时候碰了一下空格键...
大家在github里已经乐翻了天","一日，我伙同美国投资大师巴菲特老先生来到中国调研，企图寻找中国最值得投资的优秀科技公司。
眼看还有10分钟就要降落，巴菲特老先生转向我，叮嘱道：
“小张啊，我们这一路投资之行必将不会是易事，乙方客户鱼龙混杂，牛鬼蛇神横行，你要好好看好好学，看好我是怎么操作的，等会下了飞机之后，没我的指令你不要说话。”
“是，晚辈记住了，我一定用心观察学习，一定要找到一行价值百万的代码。”
“好，那就好，走，我们这就下飞机！小张，带上我的名片和银行卡！”
――――――――――――――――――――――――――――――――――
半晌，我们便来到第一家科技企业落座，这家企业规模中等，不大不小。过了一会，便来了个年轻销售，进门倒也不寒暄，一只脚刚踏进来，就马不停蹄的开始介绍他们的科技产品：
“我们这款是最新研制的云端B2B平台，它利用了当今最前沿的SaaS...”
“Stop！No need.” 
还未等我方几人反应过来，巴菲特老先生便突然发话了。
“Can you write me a line of code that worth 1 million?”
听到这话，只见那销售一时慌了神，站在那里不知如何是好。
“扫..扫瑞，I...I don’t understand...” 
这销售在一旁憋了半天，终于憋出来一句极为蹩脚的英语。
“这都不懂！巴菲特先生说了，要你们现场写一行估值为100万的代码，以此作为对你们的考验！”一旁的我给翻译道。
“这...巴先生啊，您看，您也知道我们这是初创公司，全屋上下就十来个人，再加俩程序员，市值还没个一百万，上哪儿去给您找估值百万的代码呀。我们公司还有另外两款产品，要不一并介绍给您？”
“不必了。”巴菲特先生衣袖一挥，我和同行的会计便互相使了个眼色，心有灵犀的一齐起身，还未等对方来得及挽留，我们便离开了这家写字楼。
启程去下一站的路上，巴菲特先生语重心长的对我们说：
“像这种公司，就归类为三流公司，切记不能投资，你们一定要牢记在心。”
我在心里默默的的记下，整理好了巴菲特先生的行囊，用先生车上随身携带的咖啡机给大伙煮了一壶咖啡，我们便径直向下一站驶去。
――――――――――――――――――――――――――――――――
“嚯，真气派呀！”
“是呀，这么前卫的人工智能公司，科技水平也一定不会太差！” 我跟同行的会计感叹道。
霎时间，一束耀眼的光从我们头顶射了下来，打在金属质感的地面上，瞬间形成了一个精神矍铄之人的全息投影，四周环绕的立体音响里传来他的的声音：
“巴菲特先生呀，久仰久仰！我是这家公司的CEO―Richard，我正在我的办公室用实时投影+虚拟现实技术带你们浏览讲解！请你们速速带上这VR眼镜。”
“我们公司是一家人工智能公司，在未来，我们将和拥有全中国最翔实用户数据的‘疼逊’公司打通API，再对他们的数据进行人工智能学习。”
“目前我们应用最广的便是一种叫作
卷积神经网络
的技术，江湖人称CNN，利用反向传播的手段得到参数的数据，来进行一系列的预测，譬如谁最有可能需要贷款、谁最有可能还不起马椅花呗、甚至谁最有可能患心脏病等等，只要疼逊公司能搞来用户的数据和信息，管他合法非法，一切都好说！”
巴菲特先生听了满意的点点头，问到：
“Can you show me a line of code than worth 1 million? ”
啊！竟然是跟上次相同的问题！我不禁在心中暗暗感叹巴菲特先生的高明之处！
“Easy！别说是一百万了，就是一个亿，我们的这行代码也能搞定，巴菲特先生，您就等着赚个盆满钵盈吧！秘书来，火速把我们这行代码展示给巴菲特老先生！”
不一会，一个员工几经辗转递来一张纸条。
“巴菲特先生，想必这就是您要的100万代码了！您快快过目！” 
我们一行人也是个个蠢蠢欲动，都想快点一睹这代码的风采。反观巴菲特先生倒是像见过大场面一般不紧不慢，他徐徐的一层层展开这纸条，用手背缓缓抚平，提了提裤子，戴上自己的从中国进口的黑框眼镜，而我们也这才有机会一睹为快。
我凑过去定睛一看，只见这纸条上赫然写着：
import tensorflow as tf
――――――――――――――――――――――――――――――――――――
“像这种公司，虽然技术前沿，但是容易被复制从而形成市场规模，难以垄断，并且依赖于与大型企业的合作，总体来说属于二流。对于这种企业我们的对策就是观望，让那些私募和风投先去投资前几轮，若是其可以做大做强，我们便在中途进场，这样风险既小，又能等到下一轮的人接盘！你们几个记住了吗？”
“记住了！巴菲特先生真是高明！先生这是借鉴了中国共享单车行业的经验啊，既避免了遇上悟空酷骑这样第一轮就死绝的企业，又避免被像ofo这样的繁冗企业死死套牢，高！实在是高！”
“嗯，记住了就好，走，我们去下一家，疼逊公司！”
不一会，一栋川味风格十足的建筑浮现在眼前，空气中还飘来淡淡的牛油火锅味。
“ (四川话) 写！我叫你写！你写滴这是锅锤子嘛！” 疼逊公司的办公楼里，方言叫骂声不绝于耳。
“他们在说什么语言，我怎么听不太懂呢？”巴菲特先生问到。
“回巴菲特先生，这就是汉语普通话里的一种变式――传说中的川普呀！”
“噢，川普，厉害了，厉害了。哎算了，管他什么呢，走，先进去看看！”
刚踏进去，一股动漫二次元风便萦绕身边，而墙上的人物原画中却又透露着些许中国风。
“巴菲特先生，这就是他们那个声称估值为10个亿的项目了，您觉得靠谱吗？”
“靠不靠谱一试便知，来，你们，先给我写一行价值100万的代码！”
“什么，100万？” 办公室的角落里传来一个程序员声音，只见他胡子细长，头发略带油渍，上身着格子衬衫，下身着浅色牛仔裤，一双拖鞋配上巴菲特的同款黑框眼镜。“价值100万，这个简单，给我30秒便是！”
我和巴菲特赶紧凑过去，只见他关掉b站，拨开桌边贴有“老婆”标签的3个限量手办，打开一个之前完成的建模程序，删掉一行代码并敲击了几下。不知为何他手速实在太快，我也未能捕捉到，只是隐约看到几个变量名大致是head、body、legs，和hands。 
“你写的这是什么？” 巴菲特问到。
“这便是我们的热门游戏―汪者荣耀中，后翼的最新皮肤！”
“若是按照往年购买率4%来算，我们每件卖78.8人民币，乘上我们的总用户数和23%的预计增长率，10300人*78.8元*123%，不多不少，刚好100万元。只要有1万人购买这款皮肤，这行代码便值100万！”
“那要是100万美金呢？”
“ 
import 皮肤特效 
”
“那要是200万美金呢？”
“ 
price += 100; cout << price;
 ”
“好啊！好！” 巴菲特先生带头鼓起了掌。“你还会什么，快点都拿出来，老规矩，还是只有一行代码！”
“行，那您试试这个。” 正说着，这程序员打开一个
.ipynb
文件。
while True:
print ( input (‘ ’).replace (‘你’, ‘我’). replace (‘吗’, ‘ ’). replace (‘?’, ‘!’)  )
巴菲特看了一眼，说，“这...这是什么？小张你最懂代码，你来给我翻译一下。” 
“好，我看下。啊？这，这不就是...”
“哎且慢！” 这个程序员突然打断了我的话。“你先试着和他对话试试。”
我：在吗？
电脑：在！
我：你能人机对话吗？
电脑：我能人机对话！
“嘿！神了！”一旁的巴菲特乐得合不拢嘴，“来，让我也试试！”
巴菲特：你会说英语吗？
电脑：我会说英语！
“怎么样，哈哈，这就是我用一行代码做的人工智能对话AI！”一旁的程序员说到。
“啊... 小...小张，快，快去拿我的名片和银行卡来，记住动作要快，避开记者，以免搞出了大新闻，提前影响了疼逊的股票价格。除去可口可乐和苹果公司，这就是我们要找的最优秀科技和龙头企业啊！” 巴菲特颤颤巍巍的说到。
“好！我这就去！您先稍作休息，我去去就来！”
突然，我的手机响了。
――――――――――――-――――――――――――――――――
我看了眼手机，早上6: 45。
“他娘的，谁呀，这么早给我发微信... ”
“啊靠，不好了！是包工头！”
外边天刚蒙蒙亮，微弱的晨光照亮了不远处的工地。我从工厂职工宿舍的床上醒来，地上还有工友昨夜扔下的烟头。
“嚯，哪有什么股神巴菲特啊，原来是我春秋大梦一场，白高兴了。” 我打开微信，第一行映入眼帘的便是包工头发来的信息：
“今早7点钟，壹号工地集合，今有红砖头5吨，速来搬。若再迟到，本月工资降为1000元。”
来不及洗漱，我从冰箱里拿出昨晚吃剩的半碗米饭，胡乱扒了两口，便往工地赶去。
到了砖头堆，我却发出了尖声尖叫，眼前恐怖的景象让我不敢相信这是真的，我强行镇定下来定睛一看，这砖头上个个竟然都刻有一行极为简练，却十分高深，让人看也看不懂的代码。砖头堆一旁立着一个牌子，上面分明写着 “b乎” 两个大字。
不――！这不是真的！我肯定还是在梦里！我头痛欲裂，下意识的搬起一个砖头，随手便往远处扔去...
远处却传来工头不耐烦的声音：“小张，你他娘别磨蹭！快点干！像这种代码砖头，你得搬一吨我才给你发五块钱呢...”
（完）"
,,,,,,,,,,,,,,,,,,,,,
大一一个学期学多少编程算正常?,"计科的学生，大一上学期快结束了，只会用c\c++做做数学题，在oj上写写题   遍一个简单的飞机大战 贪吃蛇 水管鸟(都是字符)     现在在参加学校acm的选拔。    到现在指针还没有搞懂。 
学校的上课进度太慢了，感觉就是漫无目的自己学。
大佬们能不能给个学习顺序。 做界面硬件相关什么的，什么都不懂，不知道从哪里开始提高自己。","1. 去中国大学MOOC把
翁恺
老师的C语言课快速看完。
2. 继续在中国大学MOOC看浙大的
数据结构
。
注意看视频的同时必须把编程题全做完。
如果想玩竞赛，推荐北大的算法系列课程，还是在中国大学MOOC上。
----------时光分割线-----------------------
在评论里看到了奇怪的回复……","推荐一个超级好玩的刷题网站：
计算机学院的学生该怎样提高自己的编程能力？
推荐一个超级好玩的刷题网站：
可以使用任何编程语言，学习编程技巧和常用算法。
题的难度分级。下面就是练习题目录的Easy难度和Medium难度的部分习题，是不是看封面就非常像玩（刷）一下呢？各个题目还用tag的形式标出了用到的知识点，像是循环、列表、图论等。
提供个人等级和排名提升系统吼，反正我已经完全停不下来了哈哈哈。
----------------------（12.19）我火了哈哈，点赞破百了，加个视频吧---------------------
一个演示进入一个题之后的大致使用过程的视频（这个题本质是将二分查找扩展到二维问题，也就是在横向和纵向同时进行
二分查找
，属于稍简单的题型）：
视频资源加载失败
可以看到，界面的右下角是测试用例，左上角是可视化的测试过程，而左下是测试时候的控制台信息。测试是可以暂停，调速，和单步执行的，功能非常强大。
那如果遇到无从下手的题要怎么办呢？没关系，还可以看看别人的讨论和解法：
某个题下面的相关的讨论和解法分享
而这个网站除了刷题功能之外，还会有像是leetcode一样的周赛机制，而且还创新性地加入了15分钟“在线匹配赛”机制，真的是紧张又刺激（匹配赛的难度随着你的等级而增加，刚开始非常简单，所以不用怕的~）。
最后感恩各位亲点赞，有兴趣可以再关注一下本人的专栏吼，祝大家刷题愉快，武运昌隆~
------------------------2020.3.16爆裂热乎大更新-------------------------------------------
更新了一个该网站上有趣的控制类题目的原创解析（内含实战视频）：
当然控制类题目是网站题库中的少数，题库更多的还是传统的算法题，另外还有一些优化类题目。所以如果你想参加
电赛
或者建模比赛的话，说不定更能在这个网站提升自己？
------2020.9.27补充（点赞近万了，希望大家能发现我其实是个视觉编程艺术创作者+硬核科普作者，嘻嘻）-----
延伸阅读：
我的文章：
------------------------2020.1.6以及2020.2.2更新-----------------------------------------
我是如何入门Python编程的
我自己真正入门Python编程其实是从去年夏天学习《Python基础教程（Apress出版社）》开始的。我读书的方法是在电子版的正文中直接进行“高亮标记”，如果感觉一个知识点重要，而且预料到自己以后还会对这个问题产生疑问的话，就在目录的标签上做一下标记。
现在这本书已经是我的
枕边书
了，遇到Python语法方面的疑问，我采取的第一个步骤往往是打开这本书然后“Ctrl+F”，然后就能找个舒适的位置和“故友”交谈一番了~
当然
刷题之路漫漫，单此一本是不足够的
。你往往还需要进一步学习算法方面的相关知识，这里我就不做不过展开了。
但是，其实高校学生中其实还是很多是不以刷题，或者成为程序员为自己的目标的。这些同学的
目的
就是简简单单地
调调包
，做做学科相关的实验，或者
处理一下实验数据
。对于这些同学来说，可能
这本书就能满足其九成“
编程基础
”方面的需求了
。
最后放些自己精读过的编程书，这些书都是超级符合人的认知规律的，前两本我都看了好几遍了，真是越看越好看，妙哉妙哉。
广告
【官方旗舰店】Python基础教程 第3三版 python3核心编
天猫
￥72.80
去购买
?
（Python算法教程翻译得挺差，但书内容绝对无敌。有条件建议找个英文版对照阅读，或者等哪天我牛B了给你们重新翻译一版哈哈哈）：
C语言入门：
 ","漫无目的是真的难受了。
我的建议很简单。选择C ++或Java。然后学习JavaScript。越来越多的基于Web的应用程序需要牛逼的JavaScript技能。然后根据要执行的工作类型选择PHP，Swift或Python。一旦您很好地了解了这三个集合中的每一个，就可以相对轻松地选择所需的任何其他语言或框架。
大一打基础吧。不废话，直接贴出每种语言的顺序，也贴出一些资源。大学四年能学这么多就已经很牛逼了。
c和java后面贴出更详细的版本，毕竟这两个是最重要的。
1、
c/c++
2、java
3、python
4、前端
5、软件测试
C/C++详细图解
资源
轻松掌握C语言视频教程（会打字就能学会）
  对应1、2、3、4知识点。
C++基础完整视频
  对应1、2、3、7知识点
C语言数据结构 培养架构师思维
  对应4、5、6知识点
C++核心编程_打造你的核心编程技能
   对应1-9知识点
QT界面开发
 对应1、2知识点
MFC
 对应3知识点 
linux系统编程
 对应上面所有。
服务器开发之linux网络编程
 对应所有。
最后的实战项目网上一搜一大把
下面开始解析java
零基础想自学java，如何找教学视频或资料？
326 赞同 ・ 22 评论
回答
以前写过，直接贴链接了。
python也是连接，
python 零基础该怎么学?
100 赞同 ・ 1 评论
回答
反正关注收藏这一个视频就行了。码字不易，求好心三连啊。","理论学习篇：
刷完北大计算机系第一课计算概论A ：计算概论与程序设计基础 
计算概论与程序设计基础_北京大学_中国大学MOOC(慕课)
?
www.icourse163.org/course/PKU-1002529002?tid=1002694002
刷完北大NOI金牌小哥哥的算法基础&提高课
看完《算法竞赛进阶指南》：该书包括国内大公司笔试以及noip、acm、蓝桥杯等比赛涉及的绝大部分知识点，较难。
实战篇：
通关acwing-Saber的全部题目：在排行榜留下你的名字！
AC Saber刷题挑战赛
AC Saber近期改版啦，双人pk模式已上线，大家快来挑战鸭！
刷北大的oj，虽然题目有点老，胜在算法题目经典，刷的人也多，比较适合大一同学。
刷完这些，指针都是小问题啦~~","我以前也有过类似经历，第一学期C语言耽误了好几节课，再上课就发现完全听不懂了，也就那一天那一节C语言课的那一刻恍然发现，上课成了看天书，同时心里莫名的慌，但又无济于事。
此时，如果没有前辈或过来人及时指点，大多数人、大概率都会就此迷失方向，甚至自暴自弃。
其实，类似的经历，包括玩游戏耽误课程，然后自弃、逐渐不及格、连续不及格，最后导致被退学的例子，这些年在大学里都不缺。
以下，我作为“侥幸”走出来的“过来人”，给3点个人建议。
1、
大学的真实情况，反而更需要自控、自驱、自强
大一迷失的原因，我相信很多人和我一样，全国的老师在高二高三时，几乎都会灌输这样一个理念：“现在是关键时刻，千万千万要忍住别贪玩，努力拼这一次，等高考完了上了大学，就没人管你了，想怎么玩就这么玩，你就真正自由了”。
实际情况是，假如大学真的自我放纵，自由自在的话，那么之前多少年的努力都可能会化为乌有。
大学恰恰相反，更不能让自己贪图享受，要主动规划、把控自己的在校时间和计划，逐步学会自控，并自我提升，像一块真正的海绵一样，疯狂汲取更多的知识，为进入社会大职场做最后的准备。
这些准备包括，掌握适合自己的分析问题、解决问题、总结问题和经验的体系化能力，养成一种在困难面前的天然自信，这样才可能解决后面的挑战。在大学时的老师、班主任，真实情况是，只是你学习路上的“辅导员”，他们精力有限，只会对有潜质、表现聪慧、有进取心的同学投入真正的精力，如果你真的表现出不上进、贪图享受，即便有的老师愿意和你打成一片，做成朋友，你也不应该需要这样的人脉和生活。如果你没有表现出自己是一块可雕琢的好玉，那他们也不会刻意去引导你、提升你，甚至可能对你不闻不问。
以上，才是大学的真实情况。
所以，果真，我到了大学，确实没人管教，可以随心所欲把控自己的时间，宿友们、同学们也有着各种各样的“课后活动”，其中可能就包括网络游戏。我就被拉着一起玩，周末为了在游戏里等级排第一，趁他们睡觉时玩通宵，结果确实游戏等级上去了，但体力和精力却透支了，上课时注意力难以集中，学业自然下来了。上课听不懂，这样的状态持续到第一学期的寒假，对我来说，这可能是在掉队后，唯一能够弥补自己的机会了，同时我也明白，一旦在一个学期掉队，且没有补上来，第二个学期将加速掉队，后续想补回来，得付出超额的精力投入。
那一年大一上学期结束后，寒假期间因为当时爸爸在外地，没回老家，所以我们一家人也去了外地过年，现在想想庆幸这样一个机会，不然如果是回到老家过年，整个寒假很可能都在和同学、朋友聚餐、娱乐，可能就很难挤出一段时间静心去恶补了。
那时，身在外地，除了家人就没有了其他认识的朋友了，所以一开始时，可以说整个白天都是非常无聊的，当时无意间看见某子院校的官网底部写着“技术支持：某某某”，这个人就是学长，我觉得名字在这个位置显示出来，很牛逼的样子，内心也很羡慕，然后辗转找到了他的联系方式，短信问他，我能不能加入你一起？我应该学什么？学长回复说，让我先学Jsp，我就去附件书店买了本JSP的入门书。
一开始，发现很难学进去，毕竟没有任何基础，就忽然想着，要不先把上学期的C语言课程补回来吧，因为自己有笔记本电脑，就按照课本上（c语言程序设计，
谭浩强
版本）的代码例子，从第一节一点一点重新理解，最重要是每一段代码我都上机敲一遍（有自己的笔记本电脑）。我会先尝试看懂，然后关上书看看能不能想起来，然后上机写出来，一时卡壳了也没关系，就再看书，重复直到代码的完整逻辑全吸收在脑子里，能够在脑子里默写出来，然后再上机重写一遍，其中也会改变代码结构和方法，并主动尝试改造部分代码逻辑，换成其他的逻辑，看看运行效果。
这里，我的建议是要关注“章节目录、章节顺序、相互为何依赖”，心里要大致理解整本书的知识点结构，这样才能形成更牢固的记忆树。
十多天时间，每天从早到晚上十点十一点，除了吃饭基本都在房间里就着笔记本电脑学习，终于学完了《
C语言程序设计
》，看起来时间是很短，实际每天都是煎熬，没有人不想春节期间好好放松放松。这要感谢父母，在这期间很默契，没打扰我学习，也很少叫我外出逛街、散步，相当于有了默认的鼓励，也不希望打破父母对我的这种学习状态的认可状态，所以更容易进入
福流
状态。
但那期间确实很辛苦，从早到晚完全是自发学习、自发理解，感觉比高考的自觉性和渴望度高多了，因为这时是为自己的爱好学习。学会了C语言，我又继续买了本JAVA的书，Java只是学完了SDK的基础入门，包括文件流操作，基本的多线程，所有例子全部敲一遍，再默写出来，但也花了十来天，毕竟体系确实庞大，只不过由于基本具备了C的基础所以Java理解很快。后面又网上下载了本JavaScript的入门电子宝典，有了C语言和Java的基础，JavaScript就更快了，只花了大概3-4天就把入门的电子宝典和基础的代码例子都敲了个遍，也算是搞定了。所以，那个寒假就把这三门语言的“入门知识”全吃了，尤其是C语言，基本功基本吃透了，后来回到学校，状态就焕然一新了，可谓受益匪浅。
首先回到学校，就碰巧开始上新的Java课，因为有了寒假的基础，记忆也都还在，上课时老师布置的问题在我看来就成了入门级简单题，很多同学都学的吃力，也有同学因为大一落下课程，几乎看不懂。这样的话，我在课堂上的优势就出来了，经常主动回答问题，相对轻松的解题，也经常被老师点名去回答别人回答不了的问题，或者在黑板上写下代码答案。这个现象，也逐步扩散到了后来的“数据库原理”、“计算机系统”等课程。老师开始更多的关注到你，也乐意给予鼓励和技术细节的引导，很多时候往往是别人不会答的编程问题时，最后让你去兜个底，你也会偷偷和“个别优秀学生”较劲。所以，这样一段时间下来，学习上就越来越顺了，加上老师和班主任鼓励，同学认可，爱玩的同学也越来越少叫你一起“打发时间”了，加上自己也有欲望和动力想学更多，经常会进入疯狂的汲取状态，也越来越自信。
懂得自控，也能够在娱乐放纵和学习之间，张弛有度
当然了，游戏其实也没完全丢掉，周末偶尔也会放松放松，但一定是玩完了就主动删掉，我虽然自控强，但偶尔也会随性，所以有时候达到学习目的了，也会在某个周五周六晚上，玩几把，甚至会在五一节国庆节这样的大节日，玩个通宵过次大瘾，但天亮了依然会毫不犹豫的删掉游戏和安装文件，过过瘾就挺满足了。以至于，后来节假日有同学找我玩游戏（对战类），基本都会自带U盘/硬盘过来给我拷贝，否则我重新下载也需要花很长时间，玩完了我还会继续删掉，包括安装包。到了这个阶段，基本是已经逐步有了自知之明，懂得什么该做、什么不该做，理解到，玩也只是放纵一把过把瘾，人只有在顺风期的时候，才会对自己有更清醒的认知，也才会有着对更加美好方向的向往。
现在回头看，如果当时大一只是简单看懂，只是学会本学期的C语言，或者毕业时只掌握了大学期间安排的基础课程，其实也只是满足了大学时期对学生的基本能力要求，离社会职场对该领域“优秀学生”的期望还有很大差距。如果你的经历只是完成了基本课程的学习，那么毕业后的起跑线依然和几十万、上百万的应届生在一起，并没有什么突出的优势和竞争力。
2、提前选好一门就业的语言，并尽可能的吃透它
如果你想渴望在将来能进入知名IT企业工作，那么在大一的刚刚开始时，就一定要尽早明确一个专研的领域方向。当然了，Java依然还是多年的主流选择，以Python为代表的AI因为人工智能的火热看起来目前也不错，但入门基础低，前端技术也朝着越来越精细化、纯粹的方向发展，而.Net因为去微软化导致岗位数量一定会越来越少，php也很难再翻身成为一个流行语言，C++入门容易但想精通需要5~7年以上的长期沉淀，而且国内的就业机会也低于国外，相对更偏向技术底层平台。
以上，这里并不想给选型的建议，只是简单聊聊个人看法，不建议选冷门语言，哪怕有名人或机构强力吹捧的未来，也不要选看起来前景很好，但并非当下的热门语言，你并没有这个精力和资本去博它的未来。大学生往往缺乏对这个行业的深刻理解，所以判断看走眼的概率肯定更高些，但选热门一些的语言，意味着岗位的数量相对多，对于火了一段时间、且大厂都在用的，其实刚刚好，所以最重要的是尽量咨询请教那些优秀的、牛逼的、已毕业的专业对口的学长、前辈，比如在一线大厂或知名IT企业工作的前辈，他们对学弟学妹的建议，往往是无私的、靠谱的，尽量找已经走上中高层管理层的学者或前辈。
3、走捷径，是一条挑战更大的路
我的建议是，主动上一线大厂/知名IT企业的社招官网，比如京东、阿里、美团等，或者新兴
独角兽
的IT公司，以SaaS类为主，看看他们的社招招聘信息，而不是去找校园招聘。看看他们对于1~3年工作经验的研发岗位，其职位要求是怎样的能力？岗位职责和技能清单列表中，可能会有很多英文词汇你都看不懂，没关系，一开始大概率看不懂太正常了，这些单词实际是框架、工具、组件、
技术栈
等词汇的名称，我们可以一个一个百度去搜，一个一个去找对应的视频或书本教程跟着学（也可以在线的知名培训网站、B站等），买书的话感觉效率和动力更高一些（花了钱的还是不一样的，尤其是书带给人的即时性、既视感体验），但书本相对更枯燥，坚持学习一二三天的人很多，但能坚持7天、10天、半个月的就很少了，如果没有自信看书，或想省钱的话，买本电子书也可以。
买书时，一定要看最后编写日期或版本，毕竟新的SDK和语言版本迭代较快，新框架或技术理念几乎每个月都在变化，最好是学最新的知识，但也没必要学最新的、超前的，选最近的稳定大版本即可。这里再次提醒，要重视
上机实践
，最重要的就是上机实践！编程只有心里默念了逻辑，在电脑上实践出来，才算是真正吸收了，其实大脑和手指配合，面对电脑输入代码，脑子里想着逻辑、大脑配合着输入，其记忆和速率都是需要磨合的，敲代码最终也可以进入福流的入神状态。你可以上
http://
download.csdn.net
搜索他人提供的示例工程或电子书，选那些下载评论次数多的，然后进行模仿、自定义修改，这样能加快理解。选一本好书、选一个好的在线视频教程，都可以少走很多弯路，书本的话，上京东搜，买那种评价和销量靠前的（可无脑选销量第一的），一天时间送到家。
等你从大一开始，就按照以上方式，提前学完大一到大二所有编程语言类的基础课程，重点不要放在操作系统、计算机网络等课程上，但可以学好基础的SQL语法。从大二开始，一方面完成其他辅助的课程学习，一方面重点投入到按社招的要求，准备大厂所需的
技术栈理解，深入到原理级的理解，再结合视频教程，自行通过项目满足一部分实践的能力
，到大三时基本就能够独立使用这些知识熟练的仿写出一个业务工程了。到校招时，基本就超越至少95%以上的同学了。一线大厂或知名IT企业如果有机会去你们学校校招，我觉得通过的概率几乎是稳定的。
我在某大厂，去过西安、武汉等地校招了数次，发现985、211类学生对大学的基础课程知识，其实理解都相对扎实， 基本知识的评分很容易达到80分以上，并且人数相当多，他们擅长计算机类的应试题考试，要想从中脱颖而出，光靠大学的基础知识体系是很难突围的。所以，在应试考试表现优良的基础上，如果对某些基础知识（编程语言、数据结构）有深入到原理级别的了解，比如Java，涵盖到集合类（梳理知识树）、多线程（线池池）、数据库（SQL语法、MySQL原理）等，甚至参与过性能调优，就相当于向面试官展示出了极强的学习能力和发展潜力，再加上可比肩1年以上社招水准的技术视野和项目实践经历（对框架确实做到相对熟练的应用），也就有了超出普通校招生的足够优势，基本就能给到4.5~5星的较高校招评分了（special offer）。
不付出比他人更努力的代价，是不可能做到脱颖而出的，最好的状态是顺势而为，跟着学习欲望的感觉走，不要让它轻易中断，人一旦进入状态，身边的人都会给予顺势的肯定和支持，反之，一旦打断，就可能会回归到生活的琐事中去。
以上，按这样的话，到毕业时你的能力基本已经达到或超过社招1年以上的水平，何况是去参加校招呢？这时你的自信应该是油然而生、发自内心的，面试官只需要通过几个技术问题就能很快感受到你内心澎湃的知识能量，那时的你，有着超出同龄人的进阶沉淀，也有着比同龄人对大厂职位更精准的理解（通过满足他们1~3年社招岗位的基础要求和部分实践），因为自信了，所以也有着超出同龄人对更高挑战的渴望和坚定。
如果最后录取的人不是你，请从自身上找原因，否则至少应该是一堆好企业围着你给offer。","题主以及很优秀了，大一能主动做书上的题目，还能做出简单的小项目，已经超越很多人了，多少人在大一的青春都献给了 LOL 或王者荣耀，所以大一有做过基本的编程项目已经很牛逼，但是编程的世界不只有编程，在未来的路上，我们还得提高和学习计算机基础知识！
我觉得在校不应该局限于学校的课程进度，有时候我们可以主动在网络上进行学习，现在是互联网时代，你想要什么，基本都能在网络上搜索到！
B 站就是一个学习的网站，很多人在 B 站上大学、考研、学编程，但 B 站的视频资源那更是五花八门，要从里面选择合适学习视频不是那么容易，而且观看人数多，并不意味着是好的。
我周末从 B 站 搜集了些关于学习计算机的视频了，也跟身边的朋友交流一番，特此筛选了下面这些课程的视频，分享给大家。
计算机网络
计算机网络微课堂
《
计算机网络微课堂
》这个视频是湖南科技大学老师制作的，PPT 的动图是我见过做的最用心的了，一看就懂的佳作，而且也适合考研人，因为每个视频末尾都有往年的考题分析。
B 站视频链接：
https://www.bilibili.com/video/BV1c4411d7jb?p=1
计算机网络（谢希仁第七版）-方老师
大学学习计算机网络配套的教材是
谢希仁
的，如果想根据此教材看视频学习的，可以看方老师讲解的计算机网络，
看方老师的视频，你会觉得是一位漂亮的小姐姐在跟你讲课
，方老师不仅颜值高，而且声音也甜，当然最重要是课程质量得到了很多人的认可。
B 站视频链接：
https://www.bilibili.com/video/BV1yE411G7Ma?p=1
Wireshark抓包 从入门到入坟
在工作中，分析网络数据的时候，必然离不开 Wireshark 工具，如果想学习 Wireshark 抓包的朋友，可以快速看看这个视频，当你有一定的
计算机网络基础
后，看这个课程会很快的。
B 站视频链接：
https://www.bilibili.com/video/BV1X5411x7R4?p=1
操作系统
操作系统 - 清华大学
站关于操作系统课程资源很多，我在里面也看了不同老师讲的课程，觉得比较好的入门级课程是《
操作系统 - 清华大学
》，该课程由清华大学老师向勇和陈渝授课，虽然我们上不了清华大学，但是至少我们可以在网上选择听清华大学的课嘛。
B 站视频链接：
https://www.bilibili.com/video/BV1js411b7vg?from=search&seid=2361361014547524697
操作系统 - 哈工大
清华大学的操作系统视频课讲的比较精炼，涉及到的内容没有那么细，《
操作系统 - 哈工大
》李治军老师授课的视频课程相对就会比较细节，老师会用 Linux 内核代码的角度带你进一步理解操作系统，也会用生活小例子帮助你理解。
B 站视频链接：
https://www.bilibili.com/video/BV1d4411v7u7?from=search&seid=2361361014547524697
计算机组成
计算机组成原理 - 快速复习
对于非科班出身的朋友，想快速学习计算机组成原理，推荐这个视频，因为这个视频精炼总结出了跟程序员有关的
计算机原理
知识，篇幅不会太长，一天就可以搞定。
B 站视频链接：
https://www.bilibili.com/video/BV1rV411k7Xf?p=1
计算机组成原理（
唐朔飞
）
如果想系统学习计算机组成原理，可以看哈工大这门计算机原理课，依据的教材正是大学配套的书。
B 站视频链接：
https://www.bilibili.com/video/BV1WW411Q7PF?p=1
数据库
SQL 进阶教程
无意间在 B 站发现一个学习 SQL 很牛逼的视频，主讲人是外国的工程师，这门课程适合初学者和进阶，这位工程师全程以「实战」的方式来授课，案例经典，课程真的通熟易懂，很简练。
B 站视频链接：
https://www.bilibili.com/video/BV1UE41147KC?p=1
MySQL 高级教程
如果你想学习 MySQL 底层原理，这个视频是个不错的选择。
B 站视频链接：
https://www.bilibili.com/video/BV1CZ4y1M7MQ?p=1
Redis 教程
学习 Redis 的同学，可以看看这个视频，每一个视频都很详细了说明了对应的知识点，而且不仅只是说了基础应用，还涉及了底层原理和互联网场景面试的知识点。
B 站视频链接：
https://www.bilibili.com/video/BV1S54y1R7SB?p=1
算法与数据结构
浙江大学
强烈推荐浙江大学的
算法与数据结构
课程，该课程非常系统，也很经典，适合小白入门算法。
B 站视频链接：
https://www.bilibili.com/video/BV1JW411i731?p=1
左程云
这个视频主要是左神讲解国内互联网大厂的高频面试题，是一个突击的好资源。
B 站视频链接：
https://www.bilibili.com/video/BV15D4y1X7Tt?p=1
C++ 编程
侯捷老师全家桶
学习 C++ 直接跟着侯捷老师一系列视频学下去就对了，相信很多人都是看侯捷老师视频长大的。
[侯捷] C++ 面向对象高级编程：
https://www.bilibili.com/video/BV14s411E772?p=1
[
侯捷
] C++11 新特性：
https://www.bilibili.com/video/BV1p4411v7Dh?p=1
[侯捷] C++ 内存管理：
https://www.bilibili.com/video/BV1Kb411B7N8?p=1
[侯捷] C++ STL 源码分析：
https://www.bilibili.com/video/BV1db411q7B8?p=1
Java
Java 入门
不知道大家有没有听过高淇老师，我在读大学的时候，那时候看的是
高淇
老师，讲课的方式很幽默风趣的，这个视频是入门 Java ，一共 300 集，每一集平均 20 分钟，是个干货视频。
B 站视频链接：
https://www.bilibili.com/video/BV1dW411Q7mY?p=1
Java 常见应用
这个视频是 Java 的重点知识整合，是偏向应用类的，比如反射、RPC、SOCKET、文件、JSON、二维码、MAIL、加密等。
B 站视频链接：
https://www.bilibili.com/video/BV1k4411W7xq?p=1
Java SSM 框架视频
这个视频面向的是 Java Web 的，源码级别的方式讲解了spring、
springmvc
、mybatis。
B 站视频链接：
https://www.bilibili.com/video/BV1uE411C7CW?p=1
----------我是分割线------------
最后，说件事。
我想着，这世界上肯定有一些朋友也跟我有一样的苦恼，为此下决心，用图解 + 通熟易懂的讲解来帮助大家理解，利用工作之余，坚持输出图解文章两年之久，我的文章都汇总到了网站：
网站内容共 1000 张图 + 50 万字，网站宗旨让天下没有难懂的
八股文
！（口嗨一下，大家不要当真），网站地址（
https://
xiaolincoding.com
）：
希望图解网站成为你们上班摸鱼必备网站哈哈！
如果对你有帮助，别忘记给个三连呀，这对我非常重要
也欢迎大家关注 
@小林coding","哎，想起以前也是抱着满腔热血报的CS，结果整个大学四年老师真的是啥也没教，基本靠ppt，大一大二基本上玩过来的，不过大二下学期开始有点觉悟，觉得自己不能这么下去，于是下定决心找实习，当时自己的想法是不管有没有薪水，我一定要找家公司干活，然后就找了一家，写
php
，工资发了1200，那段时间还蛮充实的，但是每次回到出租屋，就开始怀疑人生。大三寒假也找实习，在校期间也同样继续工作，大三的时候基本上能自己养活自己了。
回到正题，怎么做？我给你个建议，学
PHP
，真的。我以前也学c，做一些黑白界面上的计算器，贪吃蛇什么的，学java，就搞安卓，搞java swing，因为只有这样，我才有学下去的动力，人就是这样，喜欢做能立刻得到反馈的东西，才会继续学下去。为什么英语难背，数学简单？就是这个道理，英语背完，基本没什么反馈，转眼就忘，但是数学，做完一题，做同样的题目，思路马上就有了，所以这就是我当时的学习方法，直到遇到瓶颈了，靠自己写这种小东西，没什么进步了，太大的，你写不来，太好看的界面，没有涉及思路。这个时候就去找公司实习，且不说有没有人带你，最起码你在那个环境下，愿意去做更有挑战的东西，但是，非常重要的一点，为什么要去学php？因为简单，容易上手，而且用的小公司贼多，我那个时候就天天学php，而且很有成就感，因为快，做的效果又好，然后又接触更多前端，接触微信支付，接触框架，
thinkphp
, laravel，简直不要太爽，
ORM
用起来，还要啥SQL语句？
接着又有一个瓶颈，永远都是增删改查，还是没多大意思，集群，分布式，
微服务
等等一大堆，愿意搞但是公司用不上的东西，这个时候又是一个分叉路口，转Java或者转前端，转Java，直接学
Spring boot框架
，一线城市大多数公司都用这个，有了PHP的开发经验，再加上大学的Java知识，一样很快上手，但是又有一个问题，得不到反馈，学起来费劲无聊，所以我转前端了。
转前端有一个优势，你做的东西，自己能立马看到，给自己带来很大成就感，一开始用
bootstrap
，jQuery之类的，接着进阶学react或者
Vue
，然后一堆node，
webpack
, babel，虚拟Dom什么的，这个时候深入学习JavaScript，了解框架的底层原理，参与
开源社区
项目，比如ant design，react native, 
eggjs
等等，又是一片新天地。
这个过程曲折，孤独，别人在玩，在泡妞，你在敲代码，看不到前方的路，但是相信我，坚持大学，哪怕三年，毕业后你真的不一样。
当时我只准备一年，如果大一开始就这样，相信我也能进阿里或者腾讯吧，哎。大三错过大厂实习，大四错过校招，毕业后半年再找大厂的时候，内推的大神直接告诉我，如果是应届生的话，还是有机会的，社招就算了。
在这里，希望看到的学弟学妹们，要加油，尤其是学校本身不咋地的………","很赞同其他回答说的，大一其实刚开始接触计算机的话，不需要掌握太多，想掌握太多了也掌握不住，对不。毕竟你还得学高数，大物，英语等等其他的课程。
最最最重要的就是掌握一门语言。
掌握的意思就是要用得很熟悉，别只满足于学校的要求，满足于考试过关就行，一定要能自己写不少程序，做一些项目出来。
这样的话，你接下来的学习就能事半功倍了。不管接下来是去做项目，上其他更难一些的课程，还是说去刷题。
语言的话，建议学好Java或是C++。毕竟是计算机科班的学生，如果只是掌握Python的话，我觉得还是不够的，虽然拿Python入门到是没问题。但一定一定要掌握至少一门静态语言，且不说，接下来的课程，比如操作系统这样的课程，肯定是需要用到C++的。
所以，早点学好一门编程语言就很有必要！其中C++是一个很稳妥的选择。
广告
学好C++才是入职大厂的敲门砖！ 当年要是有这课，我的C++也不至于这样
已失效
?
如果想学Python的小伙伴，可以看这个回答：
也可以参考这个课程来学：
广告
【限时0.01元】超适合小白的Python入门课程：基础知识+代码实操+辅导答疑
已失效
?
另外这门python课程也很不错呢，用游戏闯关的方式来学习编程，方式新颖效果不错！
广告
仅限100名！3.9元入门python。游戏闯关式教学，小白也能轻松学会！
已失效
?
Java的应用范围也很广，如果你接下来要做安卓开发，或是
全栈
，Java都是很好的选择。
所以，大一能把一门语言学得比较溜，就是一个很好的起点。
接下来就是如何去加强这门语言基础。
怎么加强呢？那就是用你掌握的这门语言来学好数据结构了
！
大学应该掌握的基本数据结构以及他们的实现，可以看这个回答：
数据结构的书的话，可以快速看这本
大话数据结构
，就能入门了。
最关键的是，需要去把这些数据结构用你掌握的语言一个一个实现
。这个过程当中，你的编码能力就稳步提升了，debug的能力也会得到锻炼。
尽量能写个5000行代码吧，把基本的数据结构和算法都掌握好，这个代码量就达到了！
广告
大话数据结构
京东
￥26.55
去购买
?
快速过一遍之后，就可以跟着算法红包书来一波最基本的算法和数据结构了，虽然这本书书名叫算法，但其实它也囊括了数据结构，而且全书配了很优质的Java代码，想学怎么写简洁高效可维护的Java代码的小伙伴，不容错过这本书，及其配套的网站和网课。
广告
算法(第4版)(图灵出品)
京东
￥66.40
去购买
?
下面这些网课我都上过，有C++，有Java。都是我自学过程中让我获益很大的课程，分享给大家。不过，我建议大家一个个看完，学有余力再看别的，千万别东看一些，西看一点的。
网课可以跟着这几门来学
网络课程的话，则是十二分强推UCB的CS61B。他们家的计算机系的CS61A，B，C课，简直制霸各种课程推荐列表。
CS61B的官网在这里：
https://
inst.eecs.berkeley.edu/
~cs61b/fa19/
 这门课以Java为主。
2. MIT的算法课，教程用的
算法导论
，也是强推的网课：
https://www.
youtube.com/watch?
v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb
 这门算法则基本不涉及到语言层面，主要是算法层面，讲得很好。
3. 然后就是
红宝书
的网课以及配套官网：
https://
algs4.cs.princeton.edu/
lectures/
https://www.
youtube.com/watch?
v=1QZDe28peZk&list=PLRdD1c6QbAqJn0606RlOR6T3yUqFWKwmX
4. 斯坦福2018 Winter CS106B: Programming Abstractions，虽然从名字不太能看出来，但其实是用C++讲数据结构，想用C++的小伙伴不容错过，我看了一半了，特别有帮助，尤其是对
递归
和回溯的讲解，简直醍醐灌顶。
现在因为不可知的原因，Youtube上面已经下架这门课程，但更方便的是，咱们可以在B站直接看：
Again，也可以去这里学：
广告
学好C++才是入职大厂的敲门砖！ 当年要是有这课，我的C++也不至于这样
已失效
?
我觉得大一能掌握好上面的内容，就是A+的成绩了。
接下来再去跟着这个回答，安排大学其他的计算机核心内容吧。
一定一定要自己课余多学，自己push自己，光靠课堂上学的东西是远远不够的。大学是不会教大家怎么去找实习，找工作的。一定要有自己的规划，然后逐步实现。才能在毕业的时候，收获大公司的offer。","当你知道什么叫
内存地址
、堆、栈的时候指针就搞懂了，现在搞不懂也没关系，更没必要强迫自己一定要什么时候搞懂，可以照例子里面指针的用法来模仿。
指针的用法无非就是* &两种，比起很多数理化的公式来说简单多了，一大堆数理化公式不用搞懂照样用得飞起。
其实在搞懂指针之前，连int a;这样简单的语句本质是什么一样是不知道的，就当成自己看懂了，然后就用了，指针也一样，当作一种惯用法去用就行了。
ACM有专门的训练课程，在参加训练之前，直接照着刘汝佳的《
算法竞赛入门经典
》来看就好，书上的例子和题目能做多少做多少，水平自然会提高。
算法竞赛入门经典是国内学习算法的宝典了，知乎上有大量讨论，随便找的图片，不是广告。","大多数时候，一本入门书，一个手册就可以了
。但是，你要是有个培训班，其实也没坏处，但是，你需要用心的去钻研。
从学习的第一天就要开始写代码。
如果你总是看个半个月书，然后一行代码也不写。那你可能确实不适合写程序。
不要把代码例子几百行一次性输入到电脑里。
最好输入一行，或者输入几行就执行一次。不要只看最后的执行结果，关注每一个中间变量是不是跟你预想的一样。这样方便你深入理解代码。同时也不会让你因为输入了几百行，然后里面有很多错误，你费尽心力都无法找全他们而弄得心力憔悴，失去动力。
永远从使用出发去学习。
比如，你学习Python没有意义。比较有意义的是学习Python去写一个
爬虫
，或者学习机器学习，再或者用Python做个网站。这样你会遇到更多实际的问题，而不是大而空的一个语言到底该干啥的问题。
每天都写代码，不要停。
在学校无聊的时候也可以写一些玩的代码，一个程序员需要足够多代码行数的积累。
参考别人的代码，但是永远不要粘贴别人的代码。
看别人代码的目的是弄明白，在某个情境下，别人怎么解决问题，而不是既然有人解决了这个问题，我就不知其所以然的贴到我的代码里面撞大运吧！
巧学系列――编程开发
?
mp.weixin.qq.com/s/QiOMwnDmK3IFcMziP6DSIw
广告
C语言从入门到精通 编程入门零基础自学
天猫
￥39.80
去购买
?","一个学期至少写个上万行吧
 看了题主的问题, 其实就是想问如何快速提高编程能力嘛,,之前有个学妹也这样问过我,我还单独在公众号写过一篇文章,
挺适合这个问题的，我贴过来~
提高编程能力，我自己总结了以下几点：
多实战，做项目，用需求倒逼输入
善用工具，尤其是搜索引擎
看优质资料，特别是经典的计算机书籍
养成自学习惯，提高自学能力
看一些小而美的源码
先上第一点，关于做项目，这也是学妹的痛，不知道如何去开始一个项目。
谈到这点，对不起，我又想讲自己的经历了，有点长。。。
一、实践
 learning by doing
 
是的，我们都知道编程是一门实践的学科，不动手永远学不会，看懂了和学会了之间差了上万行代码。
或者说： 
看懂了 + 上万行代码 = 学会
（此公式未经证明，纯碎自己拍脑袋想的
刚学完一门语言，想必大家都想做点有用的东西，而不是天天写练习题，但是呢，又不知道从何下手，尤其是 C 语言。
我大一上完 C 语言课，就处于这种状态，但是我隔壁一个室友就不一样的。
他在学习 C 语言的过程中，刚学到动态内存分配(malloc)，就去摸索着写贪吃蛇、坦克大战，而且完成度都挺高的，那时候是我们眼里妥妥的大神。
但是大神和我上的课，学的东西都完全一样呀，况且都是上了大学才开始接触编程，为什么差别这么大呢？
以至于那时候，我和学妹一样，常常怀疑自己没有编程天赋，觉得别人天生就是这么强。
这种状态一直持续到大一下，那时候刚学完 Java，而 Java 也比 C 友好了不少，所以总想写点什么。
于是自己就选择写一个类似 QQ 的聊天工具，其实功能就很简陋，就是一个简单的 GUI + Socket 编程，然后在加上用户信息管理就完了。
但是，当我用这个简陋的软件，分别在室友和我的电脑上跑起来并且成功发送消息的那瞬间，我觉得我的编程世界被点亮了。
原来编程这么好玩，原来我也能做一些有趣的东西！似乎找到了一丝编程的感觉，但还说不上到底是什么感觉，毕竟这个程序总共也就几百行。
紧接着，趁热打铁，我又写了一个
联机五子棋
，实现上依然是 GUI + Socket 传输数据。
但是写这个又遇到了不同的问题，比如棋盘在我的实现里是一个 N*N 的数组，棋子是用对象表示，对象里有坐标、颜色这些属性。
当时我就疑惑了，当一方落子后，该怎么把棋子对象通过网络传输给对方呢，再从网络接收的数据恢复到对象？
起初自己的想法是手动的把对象转换成字符串，然后像聊天工具一样发送给对方，比如:
{x: 12, y: 13, color: black .......}
。
这种做法没问题，但是总感觉不够优雅完美，于是上网一番搜索之后发现，原来我想的这个就叫「序列化」和「反序列化」。
并且在 Java 里直接实现 
Serializable
接口就好了，甚至可以直接使用
ObjectOutputStream
类就能完成序列化和反序列化对象。
这些问题在现在看来，根本就不是问题，更像是“常识”。甚至序列化这块，还会选择一些兼容性更好、性能更高的协议，比如 Protobuf、Thrift、Avro 等等。
但是对大一时的我来说，在这个过程中不断的遇到问题并且去解决，就是实打实的编程能力上的提高啊。
在我解决掉一系列问题之后，顺利的和隔壁室友用自己写的联机五子棋对战了几局，这个五子棋还支持不少诸如悔棋、暂停、自动判断输赢等功能。
界面风格和下面这个很相似（这是网上搜的）
但是由于当时没有存 Github 的习惯，代码在换电脑之后没能留下来。
通过写这些项目，我像打通了任督二脉一样，不是学了什么厉害的算法、也不是高深的设计模式、更没有分布式这样高级的东西。
那是什么呢？
我感觉到编程就好像搭积木一样，基本的函数、库、组件就是一个个的积木块，写的代码就是胶水。
只要我们心中有设计图纸，那就能通过胶水把这些积木搭建成想象的模样，缺少什么积木块，用到的时候再去搜索就行了。
在程序的世界，只要你想，你就能。
这段时间大概是我编程能力提升最快的一个阶段之一。
关于这个五子棋，还有个小插曲：
我写的不是联机五子棋嘛，然后启动的时候输入对方的 IP 和 Port 就能连上对战。
后来，我找了一个在其它城市上大学的高中同学，让他和我一起玩五子棋，但是呢，我傻乎乎的让他用 ifconfig 查看自己 IP 后告诉我，然后我在这边连接。
那个 ip 呢，大概长得像 
192.168.1.xxx
，熟悉的同学都知道，这个就是局域网内使用的 IP 了，并非公网上的 IP。
局域网内的 IP 只能在内网才能使用，所以我用这个 IP 是永远连不上的他的电脑的。
但是那时候我才大一，没学过计网，根本不懂这里面的原理。
为啥我和室友能连上呢（因为在一个局域网）？为啥和其它学校的同学就不行？
别看现在这个东西在我看来是常识，但我那时候是一点计网知识都没，就是硬着头皮学的 Socket 编程，去理解 IP 和 Port。
那是怎么解决的呢？
当然是找谷歌呀！
在网上一番查询后，大概明白了，如果想让不同局域网内的主机进行 P2P 通信，需要一个公网中转服务器辅助进行 NAT 打洞。。。后来，我就又去尝试 NAT 打洞了，其中细节就不再描述了。
其实把我个人编程经历上写这么多，就是想展现我是如何一步步去实践的，遇到了什么问题，又是怎么解决的，把这个过程展现出来。
你看我没学任何计网知识，还不是通过边学边用，完成了网络相关的项目。
所以你离项目只差一个开始。
说到这里，不少同学又会说，我知道要多实践、多动手，道理我都懂。
可我还是不知道如何开始去写一个五子棋、贪吃蛇之类的东西。
好，那我就要问问你了
 
小北
：为什么你学了 C 语言还是不会写贪吃蛇呢？
 
 学妹：老师没教我贪吃蛇如何在 C 语言中表示，也没教我如何让画面动起来，更没教我如何绘制 GUI ，所以我不知道怎么做。
 
这应该是大多数同学最典型的问题吧？
那我们以贪吃蛇为例拆解一下，看看是如何从问题到代码的。
首先，贪吃蛇是一个个的节点组成的，节点肯定有横纵坐标吧？一个个的节点组成了一条蛇，那自然应该想到链表吧？
蛇还有什么属性？当前移动的方向
还要食物位置吧？ 那这些属性在 C 语言中用结构体表达出来就是这样：
typedef struct node{
  int x;
 int y;
 struct node* next;// 单向链表
} SnakeNode;

typedef struct snake {
 SnakeNode *pHead; // 蛇头
 SnakeNode *pFood; // 食物
 int direction;  // 方向  0-3 依次表示：上、下左、右
 ...
}


接下要考虑的就是如何去绘制蛇，这个简单呀，就把整个链表从头开始把每个节点打印出来。
每个节点可以是一个圆点，也可以是方形。
那如何让蛇动起来？所谓的动，其实就是不断的将蛇打印出来，然后又清除。
并且不断的根据移动方向更新蛇的位置，只要这个过程够快，快过人眼能够分辨的帧率，那看起来蛇就像是在连续的动一样。
然后这个过程你还要去考虑如何检测碰撞，如何判断吃到了食物，还要随机产生食物。。。 这些东西首先你得想清楚逻辑，代码实现其实if、else 、for 就足够了。
做项目的过程总会遇到不会的东西，也会遇到问题。
但是要相信，所有的问题在你之前基本上都已经有人遇到过了，只需要把问题准确的描述出来，然后去搜索引擎上搜就肯定能找到解决的线索。
如果你要等学会所有东西，才去开始做项目，那估计等到本科毕业也没机会。
本科上的就那几门课，Java/C/C++、操作系统、计网、
编译原理
、离散、数据结构......
可能没有学校会单独开一门课教你 Java Web、Python 写爬虫等等。
学完这些理论课，等到毕业，你会发现，依然好像什么都做不了，所以说，要动手，趁早。
并且理论上，学完一门语言，掌握了数组、链表、 if、for、函数这些编程最基本的概念，就有能力去实现一些诸如贪吃蛇、五子棋、扫雷这样的小玩意了。
这种通过项目去学习，以解决问题为导向的学习才是更加精准和高效的。
课堂上的学习大多数是老师灌输知识、学生记住，然后考试就能拿高分。
实际上有多少知识能转化为解决问题的能力呢？
不好说。
还是那句话，编程就像搭积木，学完基础的，积木块都给你了。
你能搭出房子、车子、还是火箭这全靠自己。
所以动起手来，编程能力是靠码出来的！
全文在这，太长了，我就不放过来了，感兴趣的可以去看下：
觉得有帮助记得关注我 
@编程指北
 哟~，指北不指南！
---update---
除此之外，学习编程过程中一定要多刷题，刷
leetcode
，这里推荐一下刷题方法和开源刷题笔记：","首先我们要明确的是，学编程时我们到底在学什么。我们在学习过程中不能只关注不同的知识点，而更多的学这个领域的思维逻辑。尤其是在学编程初期，我们扎扎实实打基础是好的，但是我们不要过于专注于把一个编程语言的所有库和语言都过一遍，因为过了也会忘记
那我们还怎么学习编程呢，对于在大学还是编程母胎新手的同学请继续往下看，首先我们要知道，可能在你2-4年以后，你的日常会是这样的：
可能在你的想象中，你会只用一个语言然后只用理解这一个语言就好了，但是事实并非如此，因为不用编程语言的不同特性和具体工作需求，很多时候你喜欢很快的在不同的语言中切换，这也是为什么培养
(programmatic thinking)比一味的去刷各种奇门语法和算法在初期重要得多，而且也因为学过的都会忘记，真正的学习是在什么东西都忘记以后所留下的东西。Right,这句话不是我说的是爱因斯坦他老人家说的
Education is what remains after you have forgotten. 
                                                          -- Albert Einstein 
好的在我们把预期设定好以后，我们来看自己在每个学习阶段当中真正需要注意什么，以下方法不只限于编程的学习中，但是我们以编程为例子，首先在我们一开始进入一个新的领域(
beginner
)的时候，我们知道的东西很少，就像下面的这个小灰点一样，所以在这个阶段，我们学什么都增加我们的知识点：
1个你喜欢的语言，和一些简单算法的实现
培养编程思维
做一些不同的小的项目网站也好，小游戏也好
刷刷Harvard CS50这样的公开课
刷一些简单的
的题
在我们学了一定程度以后，我们应该对这个领域的大多数核心方向有所了解，然后相对初学者时的我们来说，有经验(
experienced)
以后我们的知识网也应该是均匀的向外扩张，具体说来有几个方面
这个时候我们应该能知道IO，排序，数据结构，排列与组合，因为大多数非工业级的运用中也就这些东西
开始能用编程解决一些自己或朋友接触的问题
可以在一定时间内，通过看文档能够使用一个自己不熟练的编程语言
能够开始分析算法的复杂度然后进行优化
参加一些黑色马拉松
打打ACM
在这个阶段，我们也就可以开始和同学或跟着导师一起做做一些大的项目了，然后学习他们的一些知识，以及慢慢开始做一些开源的项目参加code review等等，这样自己才能够得到更多的回馈，从而找到自己的不足。
在我们对这个领域和核心方向都掌握得差不多的适合，我们也需要开始发现一些细化的方向来建立自己的长项了这样成为一个专家(
expert
)，比如说云计算，机器学习，分布式架构，或者多线程处理等等，不过当你当了这个程度，应该已经找到了自己学习的一套方法，到时候就
放飞自我即可
。
总而言之，学编程不用急，切记不要焦虑。重要的是心里有谱，自己知道自己现在学的一些东西是不是对这个阶段的自己是最有用的，学会优先级处理学习的先后次序，不然如果只是一个编程小白，非要想去一周写一个编译器出来，就只有等神仙来救你了，不过确实搞不好
出现哈哈。","大一上学期C入门，寒假（疫情期间八个月的寒假）里自己刷题锻炼了一下C，结构体，指针这种老师没重视，于是自己练题也写了有5000行吧，然后自己学了C++STL库，然后也接触了面向对象，之后一直用c++刷题，然后又自己开始学数据结构和算法（严书实在劝退。。）目前大二了开始学于C++
面向对象程序设计
，开始接触工程方面的东西（写一些小游戏）当然算法也还在学，各个OJ大概刷了四百题左右，看了一下编译器上的文件代码大概有2.5w行左右(我喜欢做完题加个注释继续写，不喜欢新建文件)，这学期学python（面向对象编程与
面向过程
差异还是挺大），因为接触过c++因此上手还是挺快，只需要特别注重了一下语言之间的相同点与差异，准备花一个月把C++面向对象学完(在MOOC上刷视频结合c++primer)，开始专注于python，并且自己做一点东西出来（不能只会刷题呀），当然算法也不会停下，既然喜欢就自己去追求呀。","我个人觉得。。正常的大一情况应该是啥字符串操作都不行，写个能做加减乘除的计算器就算行的水平。。。
当然现在大学也在逐渐的不养闲人加大毕业难度。。
起码我们那个年代的大一学生都是这样的（学校还算凑活）。。。。。。
你这个水平的，在我读大学的年代。已经算是学霸了。。笑
。。。。。。。。。。。。。。。
一个月后我突然反应过来了哦。。。题主这是不是在装b啊。。。。。大一都去刷oj参加acm了。。。然后还说自己啥都不懂。。。结果被b乎一堆更会装的人真真实实的教育了一番装b的正确姿势。。只有我一个老实人傻傻的跳出来做反面教材。 。","大一一个学期能学多少编程？换算一下：一个学期== 4.5 个月== 18 周== 126 天，按照《21 天精通 C++》的速度，一个学期少说也能达到架构水平......
当然，以上内容纯属胡扯。下面开始正文。 
二十一天精通 C++ 最简单的方式
刚步入大学生活，有的同学对大学的印象还停留在中学老师们渲染出的美好幻想当中。“上了大学就轻松了，随便玩……”
“编程？编程是啥，能吃么？”
“为什么选计算机专业，我也想知道我怎么调剂到这个学校的计算机专业的。。”
当然也不乏有少部分同学在大学之前已经接触过编程，亦或是天赋异禀 21 天就能精通 C++。但这绝对是凤毛麟角。多数同学都是步入大学之后，打开课本才切切实实的了解到“什么是编程”。而今天要说的主要针对这群同学。
首先，兴趣永远是最好的老师。
对于一个刚接触编程的同学来讲，兴趣当然是最重要的。所有计算机专业的同学，第一学期的一门必修课 ―― C 语言（鸵鸟现在还记得自己在 C 语言第一节课屏幕上打印出“Hello world”时的心情）。
世界上所有和编程相关的东西，都有 C 语言的影子，这是无法否定的。但 C 语言对于一些对编程兴趣不大的同学来说，从一块迈向编程世界的敲门砖，变成了绊脚石。
此时，和编程初次见面的你该如何是好？
第一份入门教程，主要是让你体会到编程是什么。《
与孩子一起学编程
》 ，这本书以 Python 语言教你如何写程序，是一本老少咸宜的编程书。其中会教你编一些小游戏，进而激发你的兴趣；还会和你讲基本的编程知识，相当不错。
再推荐两个
在线编程
入门的网站Codecademy: Learn Python 和 People Can Program ，你也可以在这两个网站上学习 Python，只不过是英文的。然后，你可以到 CodeAbbey 上去做一些在线编程的小练习。（为什么推荐英文网站？信息源很重要，第一手资料很重要，英语也很重要）
第二份入门教程是 MDN 的 Web 开发入门，主要是让你做点实际有用的东西。嗯，做个网页吧。MDN 全称是 Mozilla Developer Network，你可以认为是 Web 方面的官方技术网站。
这个教程会带着你建立一个网站，然后你可以把你的网页发布在 GitHub 上。在制作网页的过程中，你写的每一步，都可以很直观的看到，也就更能刺激你疯狂分泌多巴胺。
想想有多少同学是因为本身对编程并不了解，而后又在
选择排序
、冒泡排序等算法的摧残之下浅尝辄止。
这两份教程都很不错，都是从零开始，带着你从环境准备开始，一点一点地从一些简单又有意思的东西入手，让你感觉一下编程世界是什么样的，相信这两个教程可以让零基础的你喜欢上编程。期间你可能会了解到一些编辑工具，VS Code 是个不错的选择。如果你的大学老师非要让你用记事本，emm，那就随他去吧。
实践才能把知识变成技能。
有了基础以后，还需要大量的实践帮你掌握技能。
举个例子，无论用哪种语言，能做一个非常简单的 Blog 系统，或是 BBS 系统，有简单的用户登录和注册（不需密码找回）；用户发贴（不需要支持富文本，只需要支持纯文本）；用户评论（不需要支持富文本，只需要支持纯文本）。你需要从前端一直做到后端，也就是说，从 HTML/CSS/JavaScript，到后面的 Python，再到数据库。这其中需要你查阅很多知识并多多实践。
大一一个学期，时间也就那么多。消化好了这些内容，就准备好精力迎接后面的挑战吧。至此，已经进入编程正式入门阶段，下面该学习该如何编程。
编辑：鸵鸟","高数，
线性代数
之类的数学课程没有占据你们绝大部分的学习时间么？","大一多学习计算机体系基础知识，多动手编程，最好写个几千行有用的代码吧！
如果题主不是为了将来做研究，那读计算机专业的重点就在于如何提升编程能力，总结几点：
1.多动手实战，多刷题多做项目
2.学会使用搜索引擎，尤其是Google，帮你解决卡点问题
3.看经典编程书籍，看经典编程视频，b站上其实有不少
4.多看一些优秀的开源项目
讲讲我在大学是如何自学，最终毕业就加入腾讯的经历吧，希望对题主和大家有用：
用一年多时间学习了4年的知识和技能，对，我是在说我自己。
大一刚入学，因为追一个女孩惨遭拒绝，这之后开始自暴自弃，长期混迹于网吧，甚至有一次住网吧长达17天。放荡到什么程度呢？曾经玩星际争霸，连续刷了几百局，整个过程就吃泡面馒头，喝点白水。
玩到大三，突然有一天学校发给我一张：开除警告书。
看着这张死缓通知书，这个结局我并不意外，长期翘课、挂科无数。那时候水到计算机专业大三了，连一个HelloWorld都不会写。
本科就读的大学坐落在一座山中，那一天上山再下山，不断往返，完全感知不到时间的流逝。整整走了一个白昼，累得精疲力尽，瘫坐在草丛之中，看着深邃的天空和地上的花朵。
那一瞬间我突然做了一个改变自己一生的决定：与其成为游戏的消费者，不如做游戏的创造者。
于是我定下里加入游戏行业的目标。因为大学前两年全荒废了，所以大三是冲击的一年。
大三我先后学习了C语言、数据结构和算法，同时补习数计算机组成原理、计算机网络这些核心课程。
大三还养成了一个习惯：疯狂刷算法题，成为了一个算法做题家，后面没想到算法在面试中这么重要，刷算法题让我轻松拿到腾讯校招Offer。
这里也给师弟师妹们推荐一本阿里P8大佬撰写的算法笔记，这套题刷下来，进大厂非常容易：
此外，还学了一门影响我职业生涯的语言： C++。
看的第一本书就是：《
C++ Primer
》，可以说上面的每一个例子，都上机造过轮子。
随后开始啃
《Effective C++》、《
More Effective C++
》、《C++程序设计原理》、《深度探索C++对象模型》、《STL源码剖析》、《计算机网络系统方法》、《TCP/IP详解》。
除了疯狂自学，毕业的压力也很重，
但掌握的东西越多，你对未来就越笃定。
疯狂学习的过程是枯燥且伴随痛苦的，编译报各种不通过的时候让人无比抓狂，知识点学不会的时候会让你怀疑自己的智商。
曾经看过的一部分书籍：
掌握了C++之后，我还用它做了不少有趣的东西，比如：万年历、五子棋、俄罗斯方块等等，俗话说兴趣是最好的老师，建议大家在学习编码的过程中也不妨挖掘出一些有趣的东西：
我写的五子棋程序：
俄罗斯方块：
这个就稍微复杂点了，当时用了mfc
虽然简陋，但这种训练给我的编码能力带来了极大提升，还训练了程序思维。
C++学习其实有三个阶段，一般人可能需要几年时间跨越这三个阶段，而我当时真的疯狂，一天可以学习15个小时以上，这也让我在毕业之前就到了第二个阶段：
一、C/C++入门阶段
刚入门的时候我们主要是学习培养编程思维和动手能力，深刻理解面向过程和面向对象的思想方法，这对以后的程序员之路非常重要！
所以学习语言更为重要：
面向对象编程思想；类的封装，构造和析构、静态成员、对象管理；类的构造(有
参构造函数
、无参构造、拷贝构造、默认构造函数)和析构；对象动态管理、
友元函数
、友元类、操作符重载； C++编译器对象管理模型分析；类对象的动态管理(new/delete)；友元函数和友元类；运算符重载(一元运算符、二元运算符、运算符重载难点、项目开发中的运算符重载)；类的继承、多继承及其二义性、虚继承；多态(概念、意义、原理剖析、多态案例)；虚函数、纯虚函数、抽象类(面向抽象类编程思想案例)；函数模板、类模板，模板的继承。
C++类型转换；C++输入输出流(标准I/O 文件I/O 字符流I/O)；C++异常处理(异常机制、异常类型、异常变量、异常层次结构、标准异常库)；利用一些IDE开发工具：诸如Windows平台VC系列：VC++6.0(比较古老) ；Visual Studio2013, Visual Studio2015，Visual Studio2017，Visual Studio2019；Mac平台的XCode系列，还有CodeBlock，另附一些高级编辑器Notepad++, EditPlus,UE等一些开发工具的常用设置和一些常见快捷键的使用。
这个阶段推荐以下两本书：
《Essential C++》
 这是一本内容不多但很实用的C++入门书籍，强调快速上手与理解C++编程。本书主要围绕一系列逐渐复杂的程序问题，以及用以解决这些问题的语言特性展开讲解。你不只学到C++的函数和结构，也会学习到它们的设计目的和基本原理。
《C++ Primer》
 本书对C++基本概念、技术、以及现代C++编程风格进行了全面而且权威的阐述，是C++初学者的最佳指南；本书可以帮助你编写实用的程序，而无需首先精通每个语言细节。对于中高级程序员，本书也是不可或缺的参考书。
二、C/C++开发进阶
这个阶段非常刻苦的话，需要半年以上时间。
在第二阶段学习的时候，就是比较重要的了，C++开发的进阶之路，更是一个让自己找份薪水比较体面的工作的筹码。
C++进阶之STL：
STL = Standard Template Library，即
标准模板库
。这是提高开发效率的极品工具。通过学习此阶段，应掌握泛型编程技巧，理解容器类在C++语言中的应用模式，以及熟练掌握全部
STL类
的使用方法。
C++进阶之设计模式：
决定一个项目成败最重要的因素是项目总体的设计，通过本阶段的学习，可掌握面向对象编程中重要的一环，是编码前建模的技巧所在。单例模式；工厂模式；代理模式；迭代模式等，这些都是你要掌握的哦。
C++进阶之数据结构基础：
这是所有编程语言中最应该学习的部分，程序组成的基础之一。顺序存储、链式存储、循环链表；
双向链表、栈(顺序和链式)、队列(顺序和链式)；
栈的应用、树基本概念及遍历、二叉树；
排序算法、并归算法、选择、插入、快速、希尔。
这个阶段推荐以下几本书：
《
Effective C++
》和《More effective C++》
 作者是Scott Meyers。你应该熟读它们，并清楚地理解每个项目。该书围绕55条准则，每一条都介绍了一个可让你写出更好的C++程序代码的方法，并以特别设计过的例子详加讨论。
《Exceptional C++（C++编程剖析）》和《More exceptional C++》
 这两本书中都包含了40个C++编程问题，这些问题会让你磨练自己的技能，最终成为优秀的C++程序员。这些问题是Herb Sutter精心挑选，与ISO/ANSI C++官方标准相一致，帮助程序员在设计、架构和编码过程中保持良好的风格，从而使编写的C++软件更健壮、更高效。
《Inside the C++ object model（深度探索C++对象模型）》
 本书专注于C++面向对象程序设计的底层机制，包括结构式语意、临时性对象的生成、封装、继承，以及虚拟――虚拟函数和虚拟继承，帮助你理解程序的底层实现，以便写出更高效的代码。
《The design and evolution of C++（C++语言的设计与演化）》
 本书作者也是C++语言的设计者Bjarne Stroustrup，作者在书中综合性地介绍了C++的发展历史，C++中各种重要机制的本质意义和设计背景，这些机制的基本用途和使用方法，讨论了C++所适合的应用领域及其未来的发展前景，既没有忽略关键性的详情，又没有过多地陷入技术细节。
三、C++开发高级
这个阶段几乎伴随了职场后续的整个生涯，只有更精没有最精，C++高手之路，任重道远！
大四一年，我都在这个阶段，当时开始在一个小公司实习，公司给网吧做小软件。老板交给我的任务是写Windows C++界面，大三疯狂学习了一年C++，工作很快就上手了。没几天，老板说软件要赶着上线，全员一周工作六天。今天大家热议的万恶996，我10多年前就体验了。
在实习过程中我依然在疯狂学习C++经典书籍，这种训练方式也让我进步神速，也为我后面在腾讯和职场的高速发展打下来夯实的基础。
这个阶段需要掌握的一些C++技能：
C++进阶之QT开发：
掌握QT类库构架，图形界面开发模型；掌握QT开发技巧，消息机制，图形处理；掌握QT网络编程，UDP，TCP使用方式；掌握QT文件处理方式，序列化；掌握QT在windows，linux，ios，android不同平台下的移植技术
C++进阶之Windows/Linux网络服务器：
掌握Unix/Linux平台开发方式；熟练使用系统调用；熟练Unix/Linux内存管理，进程，线程调度；掌握MFC界面开发，网络编程；熟悉网络服务器开发方式，熟练编写TCP，UCP网络服务程序；掌握同步/异步IO模型在网络编程中的使用方式。
C++进阶之数据库开发：
掌握SQL语言的实用技巧。Oracle,MySQL数据库的使用方式。
如果你能熟练掌握以上列出的技能，具备解决复杂问题和技术难点的能力，而且你能独立开发一些比较复杂的功能模块，这个时候C++基本就没有太多能难到你的东西了！
仅仅一年时间，不仅开发能力突飞猛进，同时还一直在训练算法能力，曾经在北大ACM网站上疯狂刷题：
请原谅我当时年幼无知之下取的账户名
《
算法导论
》这本巨作也被我反复翻看，反复实践：
曾经的算法小抄笔记：
还记得当年为了更快的进步，跑去蹭研究生的课程，听到NP难问题不由感叹：算法世界太奇妙了。
计算机基础+C++语言+算法，这三个都被我攻克，这也是我能毕业就加入腾讯的硬核技能。
在我那个时代，线上资源并不丰富甚至是匮乏！今天各种论坛、公开课、学习资料非常丰富。最近指导师弟师妹应对秋招，我找了一些资料，
这里也顺便给学弟学妹们推荐下：
核心就是计算机底层 + 通过反复造轮子的方法学习计算机基础课，主要要攻克三个方向（攻克了会让你如虎添翼）：
一、操作系统
美国有很多优秀的操作系统公开课，比如mit6.828、哈弗OS/161。这类课程都会给你提供一个mini os壳程序，相当于一个核心组件，剩下的你可以自由发挥。比如你可以设计线程管理、文件系统等等。
相比只是看操作系统的书籍，这种学习方法的效率简直高100倍！
下面是课程官网：
国内也有一些顶尖高校也是采取类似的方式，比如清华ucore基于 Linux 0.11魔改版本
二、数据库
国内说数据库就是mysql，这点要相信我！
首先概览下mysql的知识体系：
基础：
sql语句
表结构设计
调优：
索引、慢查询优化
配置参数调优
核心原理：
InnoDb存储引擎 （包括隔离级别、事务、锁、缓存池、回滚日志等等）
Mysqld (包括连接管理、进程管理、查询缓存、查询优化、日志等等)
架构与运维：
用户与权限、安全
备份与恢复
日志
分布式与高可用
对于零基础的童鞋：
首先，学习基本的SQL语法。完成这个后，你就可以编写SQL语句了。
这一步推荐：W3Schools的 
SQL 教程
。
其次，学习数据库的主要功能和使用方法，比如用户相关或者权限相关等等。
推荐两本书：
1.《MySQL必知必会》 这本书讲的非常全，从基本概念，到查询到插入新建表，用户的管理，都有具体的例子，非常适合没有任何基础的同学来学习Mysql，总之这本书学习的方法就是：1、十分钟了解下数据库的基本概念 2、找到练手的数据库 3、对照着上面的内容去敲。本书里也有大量的内容是讲sql的，可以结合w3c的sql教程一起，有取舍地看。
2.《数据库系统概念》这本书是dba必看的。
看完这些并且实践+思考之后，可以算入门了。
接下来对于希望深入学习的童鞋：
我推荐几本书（很多大神都这么推荐），《高性能MySQL(第3版)》、 《MySQL技术内幕(第4版)》，《MySQL技术内幕 InnoDB存储引擎》，《深入理解MySQL》还有Mysql的官网。读完这些东西，再加些丰富的经验，理论上来讲就具备DBA的水平了。
十分推荐阅读
Planet MySQL
上汇总的博客，特别是
Percona's MySQL & InnoDB performance and scalability blog
.
三、计算机网络
网络知识工作后非常非常重要！
我分三个阶段来介绍：
1. 入门
第一本书 建议看
谢希仁
的《计算机网络基础》
2.进阶
然后第二本要看 《TCP/IP详解1:协议》，这个阶段需要多思考和动手网络在LINUX系统上发挥的最淋漓尽致，所以在学习的时候最好学习LINUX配合使用，学习LINUX,推荐《鸟哥的LINUX私房菜:基础篇》。
学习网络过程中,要不断抓包分析等,自己能写些简单的应用来发包更是完美。抓包工具推荐:LINUX环境下用TCPDUMP,windows环境下用 wireshark。这个阶段写习完后,已经是个小高手了。。
主要技能应该是 ： 对TCP,IP,DNS,icmp等协议应该都蛮熟了得了，dhcp/tftp/ftp等协议也应该都懂些，重点是要学会如何分析一个协议及LINUX系统的基本操作也差不多了。
3.高手阶段
这个阶段需要有一点的编程能力，指C/C++编程。主要学习的方向是协议的实现和协议的架构原理
协议的实现方面， 主要学习底层协议(指传输层及以下)的实现， 这些协议都是在操作系统层面实现的，最好的教材是《TCP/IP详解:实现》。至于网络架构这块，可以学习《计算机网络》这本书。
最后真心想说一句：千淘万漉虽辛苦吹尽狂沙始到金。
程序员这个行业不轻松，甚至可以说是很艰难，但大家只要做到：静下心来多看书、多看源码、多上机，一定能不断高速进步！
这里也给师弟师妹们推荐一本阿里P8大佬撰写的算法笔记，这套题刷下来，进大厂非常容易：
祝大家前程似锦，在编码的道路上一马平川。
要是觉得不错的话，那就帮我
@findyi
点个赞，一键三连呗，硬核码字不容易，笔芯～","早些年，网上盛传一句话
微软要求应聘程序员的应届毕业生 在大学四年间至少要写10万行代码
话虽如此，但能能在毕业时有四五万的编程量就算不错的了，在追求量的同时一定要知道：
编程一定要积累一定的代码量
但是代码质量才是最重要的
学会总结，
做一个实际的项目，才能不断的提高！！
而关于如何提高自己，你可以参考一下这两个回答：
1.关于编程如何学习，提高自身能里，C语言项目等，很值得参考学习
2.阿里云栖的回答，很多建议都很中肯","首先，对于计算机相关专业的同学来说，一定要重视C语言的学习，原因有三个方面，其一是C语言在操作系统开发、嵌入式开发和多媒体开发领域依然有广泛的应用。
其二是掌握C语言对于后续计算机专业课的学习有非常积极的促进作用，比如数据结构、编译原理等等；其三是掌握C语言也会方便后续的考研，目前也有不少学校在考研时会考察C语言。
插播一条福利，戳链接直接领取前端、Java、Python等方向专栏。
如何学习一门编程语言
截止到目前为止,编程开发语言已经有很多种,而每个程序员根据自己的学习能力不同,掌握一到几种不同的语言.
写这篇文章的目的,主要是将自己学习一门编程语言的过程和方法分享给大家,希望大家可以结合我的经历总结出适合自己学习编程语言的方法.
我是一名iOS开发工程师,所以最开始接触的语言便是Objective-C语言,是一门面向对象的动态语言,在经过一段时间的沉淀以后,目前开始进行了全栈的学习.
全栈
在这里是指前端+后端的学习.
当我接触到前端开发以后,我便整理了我要学的知识点,你别说,还挺多的东西要学呢.
首先就是作为基础的HTML+CSS+JavaScript三巨头.可能乍一看是三个语言,就可以让很多人望而却步.其实学起来一段时间以后,你又会发现并不是那么的多.再过一段时间,你会发现,想要让自己会的一门语言精湛,是需要多么长的时间磨炼和实战经验.
学习目的
每个人学习一门编程语言,都是有自己的目的.比如有人想写一个App,有人想写一个小程序,有人想写个人主页,有人想做一个大项目.也有人只是为了自己干某些事方便.
那么我的目的,说起来很多人不信,我是为了学习一门语言,增强自己的实力.我不会优先站在挣钱的角度去学一门语言.也许我不是赚大钱的料,但是我愿意融入到一门编程语言中去.
学习心态
学习心态其实和游戏心态差不多,但是游戏一局可能就个把小时,但是学习确实一个较长的过程.一旦学习心态崩了,一段时间都不想进行学习了.
学习过程中因为每个人学习能力不同,都或多或少,或快或慢会达到一个阶段的瓶颈,或者坎.良好的学习心态就是:不怕困难,不怕瓶颈,爱上不断自己寻找答案的过程.这是程序员必经的一环.
体会理解
正如上面所说,每个人学习编程语言的目的不同,有的人是兴趣,有的人就是想要高工资.每个人目的不同,所获得的动力也不同.
大多数心想高工资的人,只会停留在编程语言的使用上,而不会深究其原理.而拥有良好学习方法和兴趣的人,往往可以在编程语言的体会和理解上更上一层楼.
当然,也不乏那种确实只希望拿高工资的人,本来干着程序员,后来不研究技术,搞产品搞公司搞创业发家致富.这也是个例.
编程语言是一个工具没错,问题是看你是一个使用者,是改造者,还是创造者?看你理解和体会的程度咯.
练习
一门编程语言的学习,绝对离不开练习,一定要为自己定下目标,用所学的语言,做一个属于自己的东西.学以致用.
如何快速学习编程语言
因人而异
切入正题,一门编程语言学习的快慢,使用熟练度,处理问题的速度,都是因人而异的.那么怎么一个差异性呢.
是否有基础
是否有学习过
计算机基础
 
& C语言基础
现在大学一般都会预设这两门课程,如果你没有学过这两门课程的话,请先尝试自学这两门课,看自己是否抵触计算机,在我看来,兴趣大于学习能力.
如果你没有这两门基础的话,就不很好判断你是否适合做程序员,以及对编程开发语言的接受能力.所以先开始接触一下
计算机基础
和C语言基础吧.
是否有学习过其他语言?
如果你有系统的学习过一门编程语言的话,你应该对编程语言有一个笼统的概念,而学过和学会的区别就体现在你对该语言的掌握程度.
学过一门编程语言的话,便可以快速学会一门新语言,而可以提升多少速度根据掌握程度不同而有差异.
如果你压根就没有学过一门编程语言的话,能否学会一门编程语言,需要花多长时间就与你的天赋和努力程度挂钩.
你要做好心理准备,零基础学习一门编程语言虽然是一条比较艰辛的路,但绝不是不推荐你走.努力总会有收获,学习编程语言是绝对与投入时间成正本的事情.
是否有过其他语言的项目经验?
如果你有使用过其他语言在公司中开发过项目,那么恭喜你,如果你足够优秀,你可以很快的融入到新编程语言中,并且还会考虑到新的语言如何在工作中应用.
如果你只是在学校学过一门编程语言,或者自学,并没有项目经验,那么我推荐你先使用你学过的编程语言做一个项目,算是你对之前学过的编程语言的一个毕业设计.再进行别的编程语言的学习.
选择一门适合自己的语言
编程语言排行榜
编程语言有很多种,你可以根据排行榜排名进行各个语言的了解,不要吝啬你的百度,查一下排名靠前的编程语言都可以做些什么开发.
详细了解以后,选择一门自己要学习的编程语言,如果你是第一次进行编程语言的学习,一定要慎重选择.起点语言的难易度不同也会决定你的终点在哪里.因人而异.
了解一门编程语言,切记
不要加相关语言的开发群
,因为在你步入程序员行业之前,你并不能分辨高质量技术交流群和无质量水群以及培训机构建的群.
警惕程序员劝退师
,每个交流群都会有,他们的目的只有一个,打消所有准备入行以及想要勉强苟活在程序员行列中的人.
谨记,
除了高质量的技术交流群
,所有的群都是消遣,水水群,换个心情而已.
在
知乎
上了解一门语言的行情也不是很推荐,但至少要比群好多了,我个人看法是,如果你的兴趣可以支撑你研究一门编程语言达到一个深度,那么工作的问题你是不需要担心的,我最担心的就是你还没有怎么学,就已经想要放弃了.
顺便插播一下，慕课网近期活动开放了付费专栏免费学活动，需要的直接戳下面链接领取~
学习编程语言的特点
局限性
什么是局限性呢,尤其是你在进行第一门编程语言的学习时,因为你并未接触过这方面的知识,也没有人可以全天指导你.
你所学到的知识无非就是书本、视频提供给你的,犹如井底之蛙,只能学到现有的知识,而无法拓展和灵活使用.
举个例子,当你去旅游的时候,你是会只去一个地方,还是会先搜遍这个城市的所有景点,然后挑几个自己喜欢的进行游玩.
尽管你在学习一门编程语言时,可能已经达到个人的满负荷,但我还是想把自己在进行学习所思考的关键词告诉你.
工作当中如何应用、实战项目规范和架构、该如何灵活应用.
如果只是学习字面概念,那就好比纸上谈兵,动手做一个自己想做的项目,付出实践,就是学习语言的最好方式.
滞后性
什么是滞后性呢,比方说,可能你在进行一门编程语言的学习,书中第四章所有的内容都无法理解,在阅读到第七章时豁然开朗,突然明白了第四章所讲的东西.
当然,这也会有时间性的体现,你会发现,在你学习的过程中,三个月前对同一个概念的理解与三个月以后是不同的.
承上启下
虽然你在前期可能不懂某些概念,如果在进行大量学习后,还是无法理解,你完全可以跳过,在学习以后的知识,会有一种顿悟的感觉,这便是语言的承上启下性.
如何进行系统的编程语言学习
空口无凭,我就拿我自己学习编程语言的感受来分享给大家.下文分文两种情况进行叙述:一个是我进行第一门Objective-C语言学习的体会,一个是在有了几年经验以后再进行别的语言学习时的体会.
第一门语言Objective-C的学习感受
语法的学习
语法学习中,唯一困扰我三个月的东西就是,对象,到底是什么东西.
OC是一门面向对象的动态语言,但我前三个月虽然会创建对象,调用方法,但我根本对对象毫无概念,没有自己的理解.一个混沌的概念.
而后,在学习OC的6个月以后,大致懂了我为什么要创建对象,因为我要完成我的业务逻辑,我需要对象帮助我.在学习OC的一年后,我懂了对象存在的意义.而在从事了两年iOS开发后,看了些进阶视频后,我终于明白了,对象其实就是个指针,而指针的本质就是内存地址..(滞后性)
界面搭建
学习界面搭建时,也是为了搭界面而搭界面.
数据的传递
学习数据传递时,最令我困扰的就是循环引用,代理,block.
网络请求
网络请求类倒还是比较容易理解,这时学习的使用第三方网络请求框架,不懂它的原理和运作方式,只是会简单使用.
项目搭建
当开始了一个完整的项目搭建时,便突然豁然开朗,原来之前学习的所有东西,都是为了完成业务逻辑,搭建项目.需要自己灵活运用组合.
自我规范
当熟悉了项目搭建,并经过一段时间的工作,开始拥有了自己代码规范,约束自己,不再是为了完成业务逻辑而完成业务逻辑.
约束自己,提高自己,并提高代码质量.
项目架构
在进行大量的文章读阅以及大量第三方框架代码的学习,突然发现自己需要提升的还有很多.
首先想要优化的就是自己的项目框架,代码不够健壮,架构不够健壮,这哪里是不够健壮,这简直就是不能见人.
底层原理
在养成了个人架构和规范后,开始进行了iOS的底层学习,Runtime机制,指针等,发现了一个道理:
随着学会的东西,理解的东西越来越多,发现自己要学的东西越来越多,根本学不完.
总结
我第一门编程语言学习的时候,也下了很多功夫,做梦都在敲代码,这个过程很苦,但是我很欣慰.我也会很笨,书里的东西我都看不懂,代码也会出错,出很多知名错误,但我一直努力学习.
第二门语言的学习感受
语言特异性
有了第一门语言的基础,再进行第二门语言的学习,我会首先考虑到语言特异性.
语言特异性就是字面意思,不同的语言,会有不同的规则和差异性.
书籍的分类
学习一门编程语言的最好途径对于有基础的人就是书籍,如果你没有基础的话,最好的途径是视频没错,但是视频有些节奏过慢.
编程语言书籍大致分为5类
(入门类,工具类,实战类,高级类,圣经类)
.
切记不要盲目的读书,要循序渐进,不然失去读书的兴趣,将会失去知识获取渠道.
语言特性
每个语言都有特性,例如 动态语言、静态语言.强语言、弱语言.要搞清所学语言的语言特性.更有利于后面的学习.
语言规范
每个语言都有自己特有的规范,和系统内置函数,方法,实例.是编程人员不能替换和修改的并严格遵守的.
大体结构
每门编程语言的大体结构大致是
基础篇
1.基本语法
2.变量
3.常量
4.数据类型
5.运算符详解
6.流程控制&逻辑运算符
7.文件加载
8.错误处理
9.函数&编程思想
10.正则表达式
应用篇
1.网络请求
2.数据处理
3.编程语言内置函数
4.类定义&类别&对象定义
高级篇
1.第三方开源框架
2.底层原理
3.算法
自成体系
每本书,每个视频,每个文档,每篇文章,都是别人的见解,别人的看法.
在学习一门编程语言的过程中,大量阅读别人的资料没错,但是,一定要把别人的东西变成自己的.
将自己的理解,建造成属于自己理解和见解的一个体系,也方便与别人交流,及时改正自己看法的错误.
如何拓展自己
人脉资源
在学习一门编程语言,最需要的就是一个前辈的指导,如果只有自己,那就和游戏开荒没有任何区别.
那怎么获得这个人脉资源呢,要自己去寻找高质量的技术交流群,结识各种层次的编程语言开发者.
记住,发展的人脉资源,不要经常缠着问问题
.在没有稳定属于你的人脉资源时,不要问毫无营养的问题,要问一些有建设性的问题,值得交流学习的问题.
目前我个人知道的高质量交流群除了好友邀请的,就是通过
简书作者简介、小专栏、
知识星球
添加的群.
学习他人文章/学习方法/别人的理解.
怎么学习?如何学习?我可以这么跟你讲,如果你想学,你的时间根本不够用.你觉得我说这话闹着玩的话,那就是你还没有体会到我是怎么想的.
我目前关注的42个人当中,有一些人便是iOS领域当中的前辈,他们有一些文章便是有一定见地的,我会抽时间学习他们的每一篇文章,去其糟粕,取其精华,为我所用.
把别人的理解,别人的文章,不用复制粘贴,转为自己的理解
手册 & API
本人是Mac系统,用的Dash软件是用来查官方文档的.Windows系统可以使用
网页版Doc
手册和API是进行一门编程语言学习的最好途径.如果你的编程语言有编辑器的话,一般都是可以戳到语言定义里去的,直接学习每一个值得学习的函数、实例、方法.看看在软件/API文档中是如何定义的.
补充,
查看官方API也是进阶的最好途径
作者：筑梦师winston
链接：
https://www.
imooc.com/article/46019
来源：慕课网
本文原创发布于慕课网 ，转载请注明出处，谢谢合作","1.学好基础，吃一口成不了胖子
    计算机涉及的内容很多，把基础学好，而不是在沙子上建大厦
   急功近利，最后在上班的时候还得继续学基础，除非你想一辈子过摸摸鱼的方式
   C语言不能丢，这是基础的基础，所有的理论都用他来描述的
    学透数据结构，就会编程了，没学好这个，不算科班。
    学好操作系统，写代码的很多方式，就会明白为啥这样，因为代码都跑在操作系统之上，需要符合操作系统的规矩，特别内存管理部分，对应的很明显
   学好
编译原理
，才明白什么样的代码是高效的
   学好离散数学，组合数学，
矩阵论
等基础数学，才发现写代码的逻辑so easy。
   学语言重要不？重要，但是不是关键
   理论基础踏实了，不管什么语言，去看看 
w3school
就好
2.没有快钱，也没有快的学习方式
   想赚快钱的，最后都头破血流
   学习也一样，几天学一本书，那是不可能的
   我导师说，C++ primer他看了17遍，现在是国内不多的C++委员会的委员之一
   你去看看这本书有多厚
   所以需要把基础学踏实，理解透彻
3.贵在坚持
   上大学，最大的好处就是，没有人管你，按照自己的兴趣去学。
   别人刷短视频的时候，你在图书馆
   别人在吃鸡的时候，你在吃代码
   别人在花前月下，你在研究原理。
   学习本来就是枯燥的，如果顶不住诱惑，那你的水平和大家都一样，四年过来一看，什么都没学会。
编码功力，不是随着时间自动升级的，而是需要不停的寂寞的不停修炼。
4.多调代码，多做笔记
   看了书，还要把书上的例子在电脑上跑一次
   有时候看着很简单的事情，在电脑上就是跑不成功
   是不是怀疑电脑有问题？编译器有问题？
   其实最终发现都是自己的问题
   功力就是在一步一步试错，解决问题过程中提升的
   最好经典的问题，还可以自己写成文档，保存下来
   等你大学毕业的时候，你会发现这是非常珍贵的财富
   甚至可以卖钱，你看我就有这些资料
   不需要资料的大神，点个赞也是鼓励哈"
,,,,,,,,,,,,,,,,,,,,,
如何用尽可能少的代码画出刘看山？,期待大家的文字元素创意～希望可以附上截图和代码,"@知乎科技
 有点意思，看山决定亲自下场
害羞     ?(? ???●??? ?)? 
诶？！  Σ( ° ● °|||)
面无表情  ( ? ● ? )
不开心   (..??●??..)
哼唧       (? ? ● ? ?)
摊手     ┑(￣● ￣)┍ 
掀桌     (s?●・)s喋擤ォ
卖萌     (??●??)         
加油    (? ? ● ? )?
比心   (,,? ● ?,,) ??
print("" ?(? ???●??? ?)?"")
开个小玩笑，各位大神厉害，看山佩服  ZHI――
print( ?(? ???●??? ?)? 
print("" / Σ( ° ● °|||)"")
print(""(s?●・)s?????,,???,, ?????"")","用代码画了个3D的
刘看山
。
代码算不得少，含注释和空格有107行了。像不像就见仁见智吧，自觉，……，其实也不那么像，哈哈哈。
想要尝试的各位可以去下载开源软件OpenSCAD，支持Windows、MacOS、Linux等各种常见平台。安装包只有21MB。把代码粘贴到左右代码窗口，右侧就能看到预览。有3D打印机的各位，可以把各个零件挨个导出成STL文件并打印。模型设计时已经加了0.5mm的制造公差。模型各个零件打印过程无需支撑。
源码如下：
// File: liukanshan.scad
// Date: 2022-11-07
// Author: gashero
//耳朵
module ear() {
    translate([0,-50,0]) difference() {
        translate([0,+40,0]) intersection() {
            translate([+12,0,0])
                
sphere
(d=40,$fn=60);
            translate([-12,0,0])
                sphere(d=40,$fn=60);
        }
        cube([50,100,100],center=true);
        translate([0,0,-100/2])
            cube([100,200,100],center=true);
    }
}
//身体
module body() {
    difference() {
        hull() for(zs=[-1,+1])
            translate([0,0,zs*20])
                sphere(d=50,$fn=60);
        for(zs=[-1,+1])
            translate([0,0,zs*60])
                cube([50,50,50],center=true);
        //眼睛槽位
        for(xs=[-1,+1]) translate([xs*25,-3,+30])
            rotate([0,90-xs*15,0]) cylinder(d=8.1,h=6,center=true,$fn=30);
        //腿部槽位
        for(xs=[-1,+1]) translate([xs*14,+3,-30]) difference() {
            cylinder(d=8.4,h=15.1,center=true,$fn=30);
            translate([-xs*8/2,0,0])
                cube([8,10,20],center=true);
        }
        //胳膊槽位
        translate([0,+5,+10])
            rotate([0,90,0]) 
cylinder
(d=6.5,h=50,center=true,$fn=30);
    }
    //尾巴
    translate([0,+22,-15])
        sphere(d=15,$fn=40);
    //耳朵
    for(xs=[-1,+1]) translate([xs*12,+10,+35-0.3])
        ear();
    //鼻子
    translate([0,-15,+26])
        rotate([90,0,0]) cylinder(d=18,h=20,center=true,$fn=40);
}
//鼻子
module nose() {
    color([0.2,0.2,0.2]) difference() {
        sphere(d=18,$fn=40);
        translate([0,0,-40/2])
            cube([40,40,40],center=true);
    }
}
//眼睛
module eye() {
    color([0.2,0.2,0.2]) difference() {
        sphere(d=8,$fn=40);
        translate([0,0,-40/2])
            cube([40,40,40],center=true);
    }
}
//腿
module leg() {
    color([0.2,0.2,0.2]) difference() {
        union() {
            rotate([90,0,0]) cylinder(d=8,h=40,center=true,$fn=30);
            hull() for(xs=[-1,+1]) translate([xs*8-7,-(40/2-6/2),4])
                rotate([90,0,0]) cylinder(d=12,h=6,center=true,$fn=30);
        }
        translate([0,0,-30/2]) cube([60,50,30],center=true);
    }
}
//胳膊
module arm() {
    cylinder(d=6.0,h=9,$fn=20);
    translate([0,30/2,3.0/2]) cube([6,30,3],center=true);
    for(as=[-45,0,+45]) hull() {
        translate([0,30,0]) cylinder(d=6,h=3,$fn=20);
        translate([0,30,0]) rotate([0,0,as])
            translate([0,10,0]) cylinder(d=6,h=3,$fn=20);
    }
}
module liukanshan() {
    color(""white"") body();
    translate([0,-25,+26]) rotate([90,0,0]) nose();
    for(xs=[-1,+1]) translate([xs*(25-3),-3,+30])
        rotate([0,xs*(90-15),0]) eye();
    translate([14,+3,-35])
        rotate([90,0,90]) leg();
    mirror([1,0,0]) translate([14,+3,-35])
        rotate([90,0,90]) leg();
    for(xs=[-1,+1]) translate([xs*(50/2+6/2),+5,+10])
        rotate([180,xs*90,0]) color([0.2,0.2,0.2]) arm();
}
liukanshan();
三视图：
打印组装过程，持续更新中：
想了解OpenSCAD的可以参见以下：","写到一半我流下了悔恨的泪水：为什么我要用java
看看这public static void main(String[] args) ，这System.out.print。。。
    public static void main(String[] args) {
        String s = ""]7D8^<;>]367381:\\2;:5::4N2>2::9<B7K9835;3@K893;>V6;2n6<2k6?3i3C3I6J3C3I7I3C3J5J3C3i3C3i372:3j22893j218:3j326:3[4;:;3I3:9;7>3I4:8;3B3I4:7<3B3J63:=3B3K=B3B3N7E3B3j3?6j3;:j3:443j39263j3:173j3:173j3:272j3;362i3<;h3?8g3F4d3H5`4K7V8Q=<EYRh696m696m696m696m696m878k969k787L"", t = """";
        char f = 48;
        int n = 1, i, j;
        for (i = 0; i < 265; i++) {
            for (j = 0; j < s.charAt(i) - '0'; j++) {
                t += f;
                if (n++ % 82 == 0) t += '\n';
            }
            f = (f == 48 ? ' ' : '0');
        }
        System.out.print(t);
    }
去掉大部分空格可读性变差一截后：
public static void main(String[] args){
String s=""]7D8^<;>]367381:\\2;:5::4N2>2::9<B7K9835;3@K893;>V6;2n6<2k6?3i3C3I6J3C3I7I3C3J5J3C3i3C3i372:3j22893j218:3j326:3[4;:;3I3:9;7>3I4:8;3B3I4:7<3B3J63:=3B3K=B3B3N7E3B3j3?6j3;:j3:443j39263j3:173j3:173j3:272j3;362i3<;h3?8g3F4d3H5`4K7V8Q=<EYRh696m696m696m696m696m878k969k787L"",t="""";
char f=48;int n=1,i,j;
for(i=0;i<265;i++){for(j=0;j<s.charAt(i)-'0';j++){t+=f;if(n++%82==0)t+='\n';}f=(f==48?' ':'0');}
System.out.print(t);}
总计
465
个字符，击败了xx%的代码，而且由于java根本写不出奇技淫巧的特性（悲），代码可读性较高，真是可喜可贺
再次更新
public static void main(String[] args){
String s=""]7D8^<;>]367381:\\2;:5::4N2>2::9<B7K9835;3@K893;>V6;2n6<2k6?3i3C3I6J3C3I7I3C3J5J3C3i3C3i372:3j22893j218:3j326:3[4;:;3I3:9;7>3I4:8;3B3I4:7<3B3J63:=3B3K=B3B3N7E3B3j3?6j3;:j3:443j39263j3:173j3:173j3:272j3;362i3<;h3?8g3F4d3H5`4K7V8Q=<EYRh696m696m696m696m696m878k969k787L"",t="""";
char f=32;int n=1,i,j;
for(i=0;i<265;i++){for(j=0;j++<s.charAt(i)-48;){t+=f;if(n++%82==0)t+='\n';}f^=3;}
System.out.print(t);}
用一个异或奇技淫巧，现在是
451
个字符应该是第一了
其实就是提醒你们，
bitmap
压缩这条路并非最优。
这只狗实在太大了截不下来","写了俩小时，压缩的我已经忘记每一行东西都是啥了
总共491个字符（如果我的word文档没忽悠我）
比目前最短的 
@磊子执行力
 的650字符少一些
二更，总字符数降到了459个字符，我尝试过解码器也编起来，但是没有成功
三更，增加了原理的说明，我想起来我是怎么写出这个程序的了，某种程度上也希望一些正在学习python的初学者们能从中学习到一些奇技淫巧
四更，我灵光一现，发现了个进一步压缩编码的方法，来到448个字符
c,n,m,p,l=""#4&'`dOMQU2NrQk?5^!D6*D#kyhWKvt`QG(HM\\^v13\\ulZiguWa>%f5.ptp?x+2r4qVmFh+?4|/CHgxL[)7o~f{)v4W1=lCX$,-a#Nt\""23O$jB &~`z@vZ<:7*ua(T#e'6L^z'[v3N4z|>ZyW2RY]r4N=e,>YMJy:3Z>qYd]BY'V0.M=qVPLy&jM\\\\j~u=k^x#0Rx6'~&zQRe4#E)a5+6IkZ6o@q%ko(r^a)[@ 9l5{tokS$nI98oCp3CGkh`YS %Nd_;RNqd5JQLI9@|a5t(3IBTLyZ\""m"",0,0,print,[]
for i in c:
  n*=95;n+=ord(i)-32
while n:
  l+=[n%61];n//=61
for i in l:
  if i==60:
    m=0;p()
  else:
    p("" @""[m]*i,end="""");m=[1,0][m]
让我们简单观察一下这个程序，把它一些
语法糖
都拆解开来（语法糖就是非标准的写法，一般能让程序变得好看，但是这里只是为了省几个字符，）这里我们主要用到了两个语法糖：一个是 a,b = 0,0的赋值，一个是分号分割语句把两行代码写在同一行
还有一个技巧就是把常用的，名字很长的函数用一个变量代替，在文中就是
p=print
注意到，这里的print是没有后面的括号的，在python中代表这个东西不是print函数的结果，而是print函数本身。所以我们在如此定义之后也可以用p来输出文字
将这几点修改，并且把变量名写全之后，我们就得到了：
encodedInstruction
 
=
""@
\""
C#w:Yf9TZIa^J5Dm2Q1;6
\""
^:dq*Pp<XX#&.1C7<n<=%(zH
\\
YeI{@X2M+^$j:{cdmki
\\
Wr=;^N-e<1q1.jfeTa~Ns+rf ]5
\""
4#U[RQ&$wKHCLMX.ExP
\\
P$ YI9:Y/@V4;3mp-{VVfX)s,{KoLG,fLwi hw,2wIjX:W
\""
PK2CZ:nT;!fD
\""\""
]dRI`!L:oC
\""
Q4$~!MjIW`hjIJNc<AV
\\
UlSfZF$DPOAdns[_Nb)$)C2UZA|?j,>T&#ZcBg5i&@,nL)`JEzi5x>8`Tzfut*10O 
\\
A<2Gio.
\\
?wH""



# 解码


# 把编码过的字符串用95进制解码成一个整数



n
 
=
 
0


for
 
i
 
in
 
encodedInstruction
:

    
n
 
*=
 
95

    
n
 
+=
 
ord
(
i
)
-
32



# 编码


# 把解码的整数编码成64进制



decodedInstruction
 
=
 
[]


while
 
n
!=
0
:

    
decodedInstruction
 
+=
 
[
n
%
64
]

    
n
 
//=
 
64



# 打印


# 当碰到63时（换行符），打印下一行


# 否则，变换颜色（白变黑，黑变白），打印当前数字数量的颜色



color
 
=
 
0


for
 
i
 
in
 
decodedInstruction
:

    
if
 
i
 
==
 
63
:

        
print
()

    
else
:

        
print
(
"" @""
[
color
]
*
i
,
end
=
""""
)

        
color
=
[
1
,
0
][
color
]
代码的含义都在代码里，这里可以着重讲几个问题：
为什么使用95进制？
因为ascii字符中有含义的只有95个，其他的在我的编辑器里面都不显示成字符。如果按照严格定义的ascii编码我们其实可以用128进制，但是我想这样子代码就会充斥着乱码，这是我不想看到的
64进制是怎么来的？
首先这张图的编码来自其他答主的代码，而连续的黑或者白都会被表示成连续的数量，毕竟如果变成另一个颜色那肯定是黑变成白或者白变成黑，并不需要指明变成了什么颜色。而连续的黑或者白最大的数量是62个，加一个换行符用63表示，我们也就获得了一个区间在0-63的数组，也就是能被64进制表示
为什么有0？不是连续的黑或者白么？
因为
刘看山
有四行是从黑开始，而上一行结束肯定是黑，所以如果还按之前的逻辑变换颜色那肯定是会出现乱码，所以打印一个0个数量的白（什么都不打）那么这几行就会从黑色开始打印了
这个编码是怎么来的？
我单独写了个程序来生成这个编码，中间碰到的几个问题都是值得展开来讲的。下次更新再说
以下是第一版程序
m
 
=
 
0
;
 
o
 
=
 
ord
;
 
p
 
=
 
print
;
 
c
 
=
 
"" !
\""
#$%&'()*+,-.024579:;>?@BFKLMPTWXYZ[^""
;
s
 
=
 
""
\""
0%Pd1`CItC)(/8Xue
\""
cXfN(j=8MBd5?4BlA
%u
y]|OWDgv|H7!Y]6q
\\
*l,b%Q~DieU^`i.IPZ#ZJqeHC#BnM(
\""
^k7l2+QZ,1geC>fKe|k-/4LZo,bM(J)/p9d.*^65t;K8WU,A=2gO@kXs@M-B$1tbiPer'+g.gyfJXt:2_]6-IZ vqs_8 {`&XH>Abz2[O
\""
?<a02uku7w4!FR-BJ=q tm<ToEi%!iMHc$6.V|zkGvUjY`
\""
ic*r+E}[3_*o`%
\\
""
;
l
=
[];
n
=
0


for
 
i
 
in
 
s
:

  
n
*=
95
;
n
+=
o
(
i
)
-
32


while
 
n
!=
0
:

  
l
+=
[
n
%
40
];
n
//=
40


for
 
i
 
in
 
l
:

  
if
 
i
==
39
:

    
m
=
0
;
p
()

  
else
:

    
p
(
"" @""
[
m
]
*
(
o
(
c
[
i
])
-
32
),
end
=
""""
);
m
=
[
1
,
0
][
m
]
执行效果：
别问命名逻辑，问就是略强于纯随机
第二版程序：
c,n,m,p,l=""@\""C#w:Yf9TZIa^J5Dm2Q1;6\""^:dq*Pp<XX#&.1C7<n<=%(zH\\YeI{@X2M+^$j:{cdmki\\Wr=;^N-e<1q1.jfeTa~Ns+rf ]5\""4#U[RQ&$wKHCLMX.ExP\\P$ YI9:Y/@V4;3mp-{VVfX)s,{KoLG,fLwi hw,2wIjX:W\""PK2CZ:nT;!fD\""\""]dRI`!L:oC\""Q4$~!MjIW`hjIJNc<AV\\UlSfZF$DPOAdns[_Nb)$)C2UZA|?j,>T&#ZcBg5i&@,nL)`JEzi5x>8`Tzfut*10O \\A<2Gio.\\?wH"",0,0,print,[]
for i in c:
  n*=95;n+=ord(i)-32
while n!=0:
  l+=[n%64];n//=64
for i in l:
  if i==63:
    m=0;p()
  else:
    p("" @""[m]*i,end="""");m=[1,0][m]","泻药
记一次程序员1024比赛题目:
使用abcd元素绘制刘看山的 Ascii 图形，代码字符用量最少者获胜。
初见题目:绘制刘看山? 还最小的代码?
第一个思路就是对刘看山的图片进行二值化,再对0或255的位置填充'a','b','c','d', 见过很多大佬一行shell就搞定了,如下
curl + pic-url + | jp2a - --chars='abcd' | tr ""[a-d]"" ""[abcd]""
还有第二个要求, 代码字符量最少者胜出,  如果考虑使用外部依赖以及静态资源. 这里就需要对图片进行编码压缩,编码后字符约小越好.
由于时间问题, 我这里对刘看山图片进行二值化后存储在01数组当作, 再对连续相同01进行合并处理,达到简单的编码压缩,代码如下:
package
 
main



import
 
""fmt""



var
 
NumberData
 
=
 
[][]
int
{

	
{
0
,
 
45
,
 
1
,
 
7
,
 
0
,
 
20
,
 
1
,
 
8
},

	
{
0
,
 
44
,
 
1
,
 
12
,
 
0
,
 
11
,
 
1
,
 
14
,
 
0
,
 
1
},

	
{
0
,
 
44
,
 
1
,
 
3
,
 
0
,
 
6
,
 
1
,
 
7
,
 
0
,
 
3
,
 
1
,
 
8
,
 
0
,
 
1
,
 
1
,
 
10
},

	
{
0
,
 
44
,
 
1
,
 
2
,
 
0
,
 
11
,
 
1
,
 
10
,
 
0
,
 
5
,
 
1
,
 
10
},

	
{
0
,
 
10
,
 
1
,
 
4
,
 
0
,
 
30
,
 
1
,
 
2
,
 
0
,
 
14
,
 
1
,
 
2
,
 
0
,
 
10
,
 
1
,
 
10
},

	
{
0
,
 
9
,
 
1
,
 
12
,
 
0
,
 
18
,
 
1
,
 
7
,
 
0
,
 
27
,
 
1
,
 
9
},

	
{
0
,
 
8
,
 
1
,
 
3
,
 
0
,
 
5
,
 
1
,
 
11
,
 
0
,
 
3
,
 
1
,
 
16
,
 
0
,
 
27
,
 
1
,
 
8
,
 
0
,
 
1
},

	
{
0
,
 
8
,
 
1
,
 
3
,
 
0
,
 
11
,
 
1
,
 
14
,
 
0
,
 
38
,
 
1
,
 
6
,
 
0
,
 
2
},

	
{
0
,
 
9
,
 
1
,
 
2
,
 
0
,
 
62
,
 
1
,
 
6
,
 
0
,
 
3
},

	
{
0
,
 
9
,
 
1
,
 
2
,
 
0
,
 
59
,
 
1
,
 
6
,
 
0
,
 
3
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
57
,
 
1
,
 
3
,
 
0
,
 
10
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
25
,
 
1
,
 
6
,
 
0
,
 
26
,
 
1
,
 
3
,
 
0
,
 
7
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
25
,
 
1
,
 
7
,
 
0
,
 
25
,
 
1
,
 
3
,
 
0
,
 
6
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
26
,
 
1
,
 
5
,
 
0
,
 
26
,
 
1
,
 
3
,
 
0
,
 
10
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
57
,
 
1
,
 
3
,
 
0
,
 
10
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
57
,
 
1
,
 
3
,
 
0
,
 
7
,
 
1
,
 
2
,
 
0
,
 
1
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
58
,
 
1
,
 
2
,
 
0
,
 
2
,
 
1
,
 
8
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
58
,
 
1
,
 
2
,
 
0
,
 
1
,
 
1
,
 
8
,
 
0
,
 
1
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
58
,
 
1
,
 
3
,
 
0
,
 
2
,
 
1
,
 
6
,
 
0
,
 
1
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
43
,
 
1
,
 
4
,
 
0
,
 
11
,
 
1
,
 
10
,
 
0
,
 
2
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
25
,
 
1
,
 
3
,
 
0
,
 
10
,
 
1
,
 
9
,
 
0
,
 
11
,
 
1
,
 
7
,
 
0
,
 
2
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
25
,
 
1
,
 
4
,
 
0
,
 
10
,
 
1
,
 
8
,
 
0
,
 
11
,
 
1
,
 
3
,
 
0
,
 
7
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
25
,
 
1
,
 
4
,
 
0
,
 
10
,
 
1
,
 
7
,
 
0
,
 
12
,
 
1
,
 
3
,
 
0
,
 
7
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
26
,
 
1
,
 
6
,
 
0
,
 
3
,
 
1
,
 
10
,
 
0
,
 
13
,
 
1
,
 
3
,
 
0
,
 
3
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
27
,
 
1
,
 
13
,
 
0
,
 
18
,
 
1
,
 
3
,
 
0
,
 
6
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
30
,
 
1
,
 
7
,
 
0
,
 
21
,
 
1
,
 
3
,
 
0
,
 
9
},

	
{
0
,
 
9
,
 
1
,
 
3
,
 
0
,
 
58
,
 
1
,
 
3
,
 
0
,
 
9
},

	
{
0
,
 
6
,
 
1
,
 
6
,
 
0
,
 
58
,
 
1
,
 
3
,
 
0
,
 
9
},

	
{
0
,
 
2
,
 
1
,
 
10
,
 
0
,
 
58
,
 
1
,
 
3
,
 
0
,
 
6
},

	
{
0
,
 
1
,
 
1
,
 
4
,
 
0
,
 
4
,
 
1
,
 
3
,
 
0
,
 
58
,
 
1
,
 
3
,
 
0
,
 
7
},

	
{
1
,
 
2
,
 
0
,
 
6
,
 
1
,
 
3
,
 
0
,
 
58
,
 
1
,
 
3
,
 
0
,
 
9
},

	
{
1
,
 
1
,
 
0
,
 
7
,
 
1
,
 
3
,
 
0
,
 
58
,
 
1
,
 
3
,
 
0
,
 
9
},

	
{
1
,
 
1
,
 
0
,
 
7
,
 
1
,
 
3
,
 
0
,
 
58
,
 
1
,
 
3
,
 
0
,
 
9
},

	
{
1
,
 
2
,
 
0
,
 
7
,
 
1
,
 
2
,
 
0
,
 
58
,
 
1
,
 
3
,
 
0
,
 
9
},

	
{
0
,
 
1
,
 
1
,
 
3
,
 
0
,
 
6
,
 
1
,
 
2
,
 
0
,
 
57
,
 
1
,
 
3
,
 
0
,
 
8
},

	
{
0
,
 
2
,
 
1
,
 
11
,
 
0
,
 
56
,
 
1
,
 
3
,
 
0
,
 
2
},

	
{
0
,
 
5
,
 
1
,
 
8
,
 
0
,
 
55
,
 
1
,
 
3
,
 
0
,
 
3
},

	
{
0
,
 
11
,
 
1
,
 
4
,
 
0
,
 
52
,
 
1
,
 
3
,
 
0
,
 
5
},

	
{
0
,
 
12
,
 
1
,
 
5
,
 
0
,
 
48
,
 
1
,
 
4
,
 
0
,
 
3
},

	
{
0
,
 
14
,
 
1
,
 
7
,
 
0
,
 
38
,
 
1
,
 
8
,
 
0
,
 
4
},

	
{
0
,
 
18
,
 
1
,
 
13
,
 
0
,
 
12
,
 
1
,
 
21
,
 
0
,
 
4
},

	
{
0
,
 
23
,
 
1
,
 
34
,
 
0
,
 
6
},

	
{
0
,
 
31
,
 
1
,
 
6
,
 
0
,
 
9
,
 
1
,
 
6
,
 
0
,
 
2
},

	
{
0
,
 
31
,
 
1
,
 
6
,
 
0
,
 
9
,
 
1
,
 
6
,
 
0
,
 
3
},

	
{
0
,
 
31
,
 
1
,
 
6
,
 
0
,
 
9
,
 
1
,
 
6
,
 
0
,
 
4
},

	
{
0
,
 
31
,
 
1
,
 
6
,
 
0
,
 
9
,
 
1
,
 
6
,
 
0
,
 
3
},

	
{
0
,
 
31
,
 
1
,
 
6
,
 
0
,
 
9
,
 
1
,
 
6
,
 
0
,
 
5
},

	
{
0
,
 
31
,
 
1
,
 
8
,
 
0
,
 
7
,
 
1
,
 
8
,
 
0
,
 
3
},

	
{
0
,
 
31
,
 
1
,
 
9
,
 
0
,
 
6
,
 
1
,
 
9
,
 
0
,
 
3
},

	
{
0
,
 
32
,
 
1
,
 
7
,
 
0
,
 
8
,
 
1
,
 
7
,
 
0
,
 
4
},


}


var
 
TextData
 
=
 
[]
string
{
""a""
,
 
""b""
,
 
""c""
,
 
""d""
}



func
 
main
()
 
{

	
var
 
textIdx
 
int
 
=
 
0

	
for
 
_
,
 
numbers
 
:=
 
range
 
NumberData
 
{

		
o
 
:=
 
0

		
for
 
idx
,
 
number
 
:=
 
range
 
numbers
 
{

			
if
 
idx
%
2
 
==
 
0
 
{

				
o
 
=
 
number

				
continue

			
}
 
else
 
{

				
if
 
o
 
==
 
1
 
{

					
for
 
i
 
:=
 
0
;
 
i
 
<
 
number
;
 
i
++
 
{

						
fmt
.
Print
(
TextData
[
textIdx
%
4
])

						
textIdx
++

					
}

				
}
 
else
 
{

					
for
 
i
 
:=
 
0
;
 
i
 
<
 
number
;
 
i
++
 
{

						
fmt
.
Print
(
"" ""
)

					
}

				
}

			
}

		
}

		
fmt
.
Println
()

	
}


}


效果图
刘看山来咯
欢迎补充","代码 + 执行效果
看似很简单的一个题，实际上这个题的关键点在于「代码字符量最少」，瞬间变成了一个算法优化题。
 实现一个0??外部依赖，无网络请求拿图，无外部图片，无第三方库，纯 JS 实现版本，最终代码如下：
g
=
console
.
log
,
n
=
75
,
x
=
""画个图案""
,
s
=
[],
""0t0518080f0403031608010606040702150907060b0215090p020o0808090p090b0606020907100a0c020b041n020d041l020h031i020i020r040n020i020q060m020i020r030o020i021i020i021i020i021i020i021i020i021i020i021i020i0213030c020i0214030b020i02150409020i02170308020i02180703020i02180703030h02180505070d021j0105020b021j0106020a021j0106020b011j0106020b021i0105020c021h0302030e021g040i021f020m031b030p0316040u060u06150t1i0509051l0509051l0509051l050a041l050a041k0608061j0707071k060806""
.
match
(
/../g
).
map
(
i
=>
parseInt
(
i
,
36
)).
forEach
((
i
,
a
)=>{
new
 
Array
(
i
).
fill
(
""""
).
forEach
((
i
,
l
)=>{
s
.
push
(
a
%
2
==
0
?
x
[
l
%
4
]
:
""  ""
),
0
===
n
&&
(
g
(
s
.
join
(
""""
)),
s
=
[],
n
=
76
),
n
--
})});


 解析：
 
一. 先通过工具生成一个可用的
刘看山
图片，都使用 0 和 1 来实现
二. 通过 
bitmap
 算法压缩 0 和 1，并且将 bitmap 结果转化为 36 进制 (为了代码短)
比如上面的刘看山 0 1 图，先计算出有多少连续的 1，比如有 29，那就先记录下 29，然后有 5 个 0，则最终字符串为 
29 5 n(下一个连续 1 的数量) m(下一个连续 0 的数量) p(下一个连续 1 的数量)
再将上述的字符串 29 5 ... 转为 36 进制 (为了短)

t 5 18 8 f 4 3 3 16 8 1 6 6 4 7 2 15 9 7 6 b 2 15 9 p 2 o 8 8 9 p 9 b 6 6 2 9 7 10 a c 2 b 4 1n 2 d 4 1l 2 h 3 1i 2 i 2 r 4 n 2 i 2 q 6 m 2 i 2 r 3 o 2 i 2 1i 2 i 2 1i 2 i 2 1i 2 i 2 1i 2 i 2 1i 2 i 2 1i 2 i 2 13 3 c 2 i 2 14 3 b 2 i 2 15 4 9 2 i 2 17 3 8 2 i 2 18 7 3 2 i 2 18 7 3 3 h 2 18 5 5 7 d 2 1j 1 5 2 b 2 1j 1 6 2 a 2 1j 1 6 2 b 1 1j 1 6 2 b 2 1i 1 5 2 c 2 1h 3 2 3 e 2 1g 4 i 2 1f 2 m 3 1b 3 p 3 16 4 u 6 u 6 15 t 1i 5 9 5 1l 5 9 5 1l 5 9 5 1l 5 a 4 1l 5 a 4 1k 6 8 6 1j 7 7 7 1k 6 8 6
 上述均为准备过程，得到压缩后的字符串之后，做字符串反向解析，36 进制数转换完之后解析 bitmap 按序输出即可
 
 然后是 JS 的最大优势，混淆压缩！
 
 happy coding ~","我来卡个bug
语言：python
准备：
: 一定要用venv奥
python -m venv venv
. venv/bin/activate
pip install draw_a_liukanshan
代码：
import
 
l
还能再短吗（","print(""^  ^\n'?'"")
运行结果：","“小张，你用程序给我画一条狗。我不要过程，只要结果，下班前交过来。”
纯语音输入，代码含量为0","（要是不规定刘看山样式的话，感觉可以压缩巨多，建议确定一下刘看山的样式标准。）
三更，由于没人重画刘看山，针对rle压缩规则优化了一下刘看山。
最少字符：186字符，344字节。但是
只是改图，实际上并没有优化算法
，在别的大佬也改图之前就不比了吧。
顺便弄了最少字节版本：248字符，250字节。
看刘看山：
现在变成小刘了（笑）
最少字符实现：
t="""";for x=Int.([""??怃???}??~??~??将?M?S?h?吃?[??[??[??怅??l?????z?????????Ln?氆?]?_?漉?S?""...]);t*=' '^((x-13824)>>8)*'#'^(x&255);end;print(replace(t,r""(?<a>.{80})""=>s""\g<a>\n""))
更矮了
把之前的版本优化一下，这是最少字节数版：
t="""";f=32;for x=b""]5D7]<;>Z3:;5994M3J98<B7K8735NK873;>V692o5:3m4<3I4O4=3I4N3?3j35383j35383j34393Z5;9:3Y6;5;6I4;6<39:J675>39:K@?39;N7D3<8g3D4d3F5`4I7V8O=<EWRf696k696k878i969i787"".-48;t*=Char(f)^x;f?=3;end;print(replace(t,r""(?<a>.{80})""=>s""\g<a>\n""))
二更，中文版本搞出来了，字符数239，字节数503。
基本上是搬运工，也没搬出啥，就不放代码了。
一更：
算法思路照抄 
@徐畅
 的，针对
RLE
编码部分略微优化，然后整体用julia语言重写了一遍。
感谢大佬慷慨放码，附上回答链接：
如何用尽可能少的代码画出刘看山？
写成非交互，也就是脚本文件的话，字符数403，字节数405（因为julia异或运算用的unicode字符）
s
=
""]6D8^<;>]367381:[3;:5::4M3>2::9<B7K9835;3@K893;>V6;2n6<2k6?3i3C3I6J3C3I7I3C3J5J3C3i3C3i372:3j22893j218:3j326:3[4;:;3I3:9;7>3I4:8;3B3I4:7<3B3J63:=3B3K=B3B3N7E3B3j3?6j3;:j3:443j39263j3:173j3:173j3:272j3;362i3<;h3?8g3F4d3H5`4K7V8Q=<EYRh696m696m696m696m696m878k969k787L""
;
t
=
""""
;
f
=
32
;
n
=
1
;
for
 
i
=
1
:
265
;
global
 
f
;
for
 
j
=
1
:
Int
(
s
[
i
]
-
48
);
global
 
t
;
global
 
n
;
t
*=
Char
(
f
);(
n
+=
1
)
%
82
==
0
 
?
 
t
*=
'\n'
 
:
 
0
;
end
;
f?
=
3
;
end
;
print
(
t
)
in VSCode（巨型刘看山，一个宽屏塞不下）
但是考虑到julia的即时编译器REPL，软作用域内就不用再引入全局变量了，于是字符数来到376，字节数378，我水平挺低只会重写，应该还能再压榨一点：
s=""]6D8^<;>]367381:[3;:5::4M3>2::9<B7K9835;3@K893;>V6;2n6<2k6?3i3C3I6J3C3I7I3C3J5J3C3i3C3i372:3j22893j218:3j326:3[4;:;3I3:9;7>3I4:8;3B3I4:7<3B3J63:=3B3K=B3B3N7E3B3j3?6j3;:j3:443j39263j3:173j3:173j3:272j3;362i3<;h3?8g3F4d3H5`4K7V8Q=<EYRh696m696m696m696m696m878k969k787L"";t="""";f=32;n=1;for i=1:265;for j=1:Int(s[i]-48);t*=Char(f);(n+=1)%82==0 ? t*='\n' : 0;end;f?=3;end;print(t)
in REPL","#include
 
<stdio.h>


#include
 
<stdlib.h>


#include
 
<time.h>


#include
 
<string.h>




int
 
pic
[
50
][
8
]
 
=


{

    
{
46
,
7
,
73
,
8
},

    
{
45
,
12
,
68
,
14
},

    
{
45
,
3
,
54
,
7
,
64
,
8
,
73
,
10
},

    
{
45
,
2
,
58
,
10
,
73
,
10
},

    
{
11
,
4
,
45
,
2
,
61
,
2
,
73
,
10
},

    
{
10
,
12
,
40
,
7
,
74
,
9
},

    
{
9
,
3
,
17
,
11
,
31
,
16
,
74
,
8
},

    
{
9
,
3
,
23
,
14
,
75
,
6
},

    
{
10
,
2
,
74
,
6
},

    
{
10
,
2
,
71
,
6
},

    
{
10
,
3
,
70
,
3
},

    
{
10
,
3
,
38
,
6
,
70
,
3
},

    
{
10
,
3
,
38
,
7
,
70
,
3
},

    
{
10
,
3
,
39
,
5
,
70
,
3
},

    
{
10
,
3
,
70
,
3
},

    
{
10
,
3
,
70
,
3
,
80
,
2
},

    
{
10
,
3
,
71
,
2
,
75
,
8
},

    
{
10
,
3
,
71
,
2
,
74
,
8
},

    
{
10
,
3
,
71
,
3
,
76
,
6
},

    
{
10
,
3
,
56
,
4
,
71
,
10
},

    
{
10
,
3
,
38
,
3
,
51
,
9
,
71
,
7
},

    
{
10
,
3
,
38
,
4
,
52
,
8
,
71
,
3
},

    
{
10
,
3
,
38
,
4
,
52
,
7
,
71
,
3
},

    
{
10
,
3
,
39
,
6
,
48
,
10
,
71
,
3
},

    
{
10
,
3
,
40
,
13
,
71
,
3
},

    
{
10
,
3
,
43
,
7
,
71
,
3
},

    
{
10
,
3
,
71
,
3
},

    
{
7
,
6
,
71
,
3
},

    
{
3
,
10
,
71
,
3
},

    
{
2
,
4
,
10
,
3
,
71
,
3
},

    
{
1
,
2
,
9
,
3
,
70
,
3
},

    
{
1
,
1
,
9
,
3
,
70
,
3
},

    
{
1
,
1
,
9
,
3
,
70
,
3
},

    
{
1
,
2
,
10
,
2
,
70
,
3
},

    
{
2
,
3
,
11
,
2
,
70
,
3
},

    
{
3
,
11
,
70
,
3
},

    
{
6
,
8
,
69
,
3
},

    
{
12
,
4
,
68
,
3
},

    
{
13
,
5
,
66
,
4
},

    
{
15
,
7
,
60
,
8
},

    
{
19
,
13
,
44
,
21
},

    
{
24
,
34
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
8
,
47
,
8
},

    
{
32
,
9
,
47
,
9
},

    
{
33
,
7
,
48
,
7
},


};



int
 
main
()


{

    
int
 
i
,
 
j
,
 
run
,
 
pix
,
 
cnt
;

    
srand
(
time
(
NULL
));


    
for
 
(
i
 
=
 
0
;
 
i
 
<
 
50
;
 
i
++
)
 
{

        
for
 
(
run
 
=
 
j
 
=
 
0
;
 
j
 
<
 
8
;
 
j
 
+=
 
2
,
 
run
 
=
 
pix
 
+
 
cnt
)
 
{

            
pix
 
=
 
pic
[
i
][
j
];
  
cnt
 
=
 
pic
[
i
][
j
+
1
];

            
if
 
(
!
pix
)
 
break
;

            
for
 
(
int
 
i
 
=
 
run
;
 
i
 
<
 
pix
 
+
 
cnt
;
 
i
++
)
 
{

                
printf
(
""%c""
,
 
(
i
>=
pix
)
 
?
 
rand
()
%
77
+
48
 
:
 
0x20
);

            
}

        
}

        
puts
(
""""
);

    
}

    
return
 
0
;


}


输出效果如下(Linux):
windows 下 dev c++ 编译， 加上颜色!
#include
 
<stdio.h>


#include
 
<stdlib.h>


#include
 
<time.h>


#include
 
<string.h>


#include
 
<windows.h>




int
 
pic
[
50
][
8
]
 
=


{

    
{
46
,
7
,
73
,
8
},

    
{
45
,
12
,
68
,
14
},

    
{
45
,
3
,
54
,
7
,
64
,
8
,
73
,
10
},

    
{
45
,
2
,
58
,
10
,
73
,
10
},

    
{
11
,
4
,
45
,
2
,
61
,
2
,
73
,
10
},

    
{
10
,
12
,
40
,
7
,
74
,
9
},

    
{
9
,
3
,
17
,
11
,
31
,
16
,
74
,
8
},

    
{
9
,
3
,
23
,
14
,
75
,
6
},

    
{
10
,
2
,
74
,
6
},

    
{
10
,
2
,
71
,
6
},

    
{
10
,
3
,
70
,
3
},

    
{
10
,
3
,
38
,
6
,
70
,
3
},

    
{
10
,
3
,
38
,
7
,
70
,
3
},

    
{
10
,
3
,
39
,
5
,
70
,
3
},

    
{
10
,
3
,
70
,
3
},

    
{
10
,
3
,
70
,
3
,
80
,
2
},

    
{
10
,
3
,
71
,
2
,
75
,
8
},

    
{
10
,
3
,
71
,
2
,
74
,
8
},

    
{
10
,
3
,
71
,
3
,
76
,
6
},

    
{
10
,
3
,
56
,
4
,
71
,
10
},

    
{
10
,
3
,
38
,
3
,
51
,
9
,
71
,
7
},

    
{
10
,
3
,
38
,
4
,
52
,
8
,
71
,
3
},

    
{
10
,
3
,
38
,
4
,
52
,
7
,
71
,
3
},

    
{
10
,
3
,
39
,
6
,
48
,
10
,
71
,
3
},

    
{
10
,
3
,
40
,
13
,
71
,
3
},

    
{
10
,
3
,
43
,
7
,
71
,
3
},

    
{
10
,
3
,
71
,
3
},

    
{
7
,
6
,
71
,
3
},

    
{
3
,
10
,
71
,
3
},

    
{
2
,
4
,
10
,
3
,
71
,
3
},

    
{
1
,
2
,
9
,
3
,
70
,
3
},

    
{
1
,
1
,
9
,
3
,
70
,
3
},

    
{
1
,
1
,
9
,
3
,
70
,
3
},

    
{
1
,
2
,
10
,
2
,
70
,
3
},

    
{
2
,
3
,
11
,
2
,
70
,
3
},

    
{
3
,
11
,
70
,
3
},

    
{
6
,
8
,
69
,
3
},

    
{
12
,
4
,
68
,
3
},

    
{
13
,
5
,
66
,
4
},

    
{
15
,
7
,
60
,
8
},

    
{
19
,
13
,
44
,
21
},

    
{
24
,
34
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
6
,
47
,
6
},

    
{
32
,
8
,
47
,
8
},

    
{
32
,
9
,
47
,
9
},

    
{
33
,
7
,
48
,
7
},


};



void
 
SetColor
(
unsigned
 
short
 
fc
,
 
unsigned
 
short
 
bc
)
 
{
 
  
HANDLE
 
hCon
 
=
 
GetStdHandle
(
STD_OUTPUT_HANDLE
);
 
  
SetConsoleTextAttribute
(
hCon
,
 
(
fc
 
%
 
16
)
 
|
 
(
bc
 
%
 
16
 
*
 
16
));
 

}
 


int
 
main
()


{

    
int
 
i
,
 
j
,
 
run
,
 
pix
,
 
cnt
;

    
srand
(
time
(
NULL
));


    
for
 
(
i
 
=
 
0
;
 
i
 
<
 
50
;
 
i
++
)
 
{

        
for
 
(
run
 
=
 
j
 
=
 
0
;
 
j
 
<
 
8
;
 
j
 
+=
 
2
,
 
run
 
=
 
pix
 
+
 
cnt
)
 
{

            
pix
 
=
 
pic
[
i
][
j
];
  
cnt
 
=
 
pic
[
i
][
j
+
1
];

            
if
 
(
!
pix
)
 
break
;

            
for
 
(
int
 
i
 
=
 
run
;
 
i
 
<
 
pix
 
+
 
cnt
;
 
i
++
)
 
{

            	
int
 
color
 
=
 
rand
()
%
255
;
   
color
 
=
 
color
 
%
 
16
 
?
 
color
 
:
 
1
;

   				
SetColor
(
color
,
 
0
);

                
printf
(
""%c""
,
 
(
i
>=
pix
)
 
?
 
rand
()
%
77
+
48
 
:
 
0x20
);

            
}

        
}

        
puts
(
""""
);

    
}

    
return
 
0
;


}

","来，先上
刘看山
的截图。
而且，仔细看一下大家能发现：下面每幅图片的
文字内容都是一样的！
而之所以显示出不同的图像，仅仅是
文字的颜色
不同！
至于如何实现，非常简单。即使不会美术的小伙伴也能轻松做到！
原理就是：
程序会以图片为参考，然后提取照片的颜色，依次赋予给字符，并输出字符。
就这么简单。
甚至，
你可以用TA的照片给TA生成专属的文字图
，棒不？
实现代码如下，采用了世界上最好的语言（嘿嘿）：PHP！
$words
=
""WWW.ZHIHU.COM/PEOPLE/YEECODE|ABCDEFGHIJKLMNOPQRSTUVWXYZYEECODEWWW.ZHIHU.COM/PEOPLE/YEECODE|ABCDEFGHIJKLMNOPQRSTUVWXYZYEECODEWWW.ZHIHU.COM/PEOPLE/YEECODE|ABCDEFGHIJKLMNOPQRSTUVWXYZYEECODE|""
;


$count
=
0
;


$im
=
imagecreatefromjpeg
(
'kanshan.jpg'
);


$dx
=
imagesx
(
$im
);


$dy
=
imagesy
(
$im
);


for
(
$y
=
0
;
$y
<
$dy
;
$y
++
)


{

    
for
(
$x
=
0
;
$x
<
$dx
;
$x
++
)

    
{

        
        
$col
=
imagecolorat
(
$im
,
$x
,
$y
);

        
$rgb
=
imagecolorsforindex
(
$im
,
$col
);

        
printf
(
'<font color=#%02x%02x%02x >'
.
$words
[
$count
]
.
'</font>'
,
$rgb
[
'red'
],
$rgb
[
'green'
],
$rgb
[
'blue'
]);

        
if
(
$count
<
147
)

        
{
$count
++
;}

        
else

        
{
$count
=
0
;}

    
}

    
echo
 
""<br>
\n
""
;


}


imagedestroy
(
$im
);


OK，
我是真不会画画，但是会写程序的：程序员易哥。",┗┃? ■ ?┃┛,"不能少了Python。代码如下：
s = ""]7D8^<;>]367381:\\2;:5::4N2>2::9<B7K9835;3@K893;>V6;2n6<2k6?3i3C3I6J3C3I7I3C3J5J3C3i3C3i372:3j22893j218:3j326:3[4;:;3I3:9;7>3I4:8;3B3I4:7<3B3J63:=3B3K=B3B3N7E3B3j3?6j3;:j3:443j39263j3:173j3:173j3:272j3;362i3<;h3?8g3F4d3H5`4K7V8Q=<EYRh696m696m696m696m696m878k969k787L""
f = "" "";r = """"
for i in range(265):
    r += f*(ord(s[i])-ord(""0""))
    f = ""0"" if f == "" "" else "" ""
for i in range(0, len(r), 82):
    print(r[i:i+82])
使用异或改进一下：
s = ""]7D8^<;>]367381:\\2;:5::4N2>2::9<B7K9835;3@K893;>V6;2n6<2k6?3i3C3I6J3C3I7I3C3J5J3C3i3C3i372:3j22893j218:3j326:3[4;:;3I3:9;7>3I4:8;3B3I4:7<3B3J63:=3B3K=B3B3N7E3B3j3?6j3;:j3:443j39263j3:173j3:173j3:272j3;362i3<;h3?8g3F4d3H5`4K7V8Q=<EYRh696m696m696m696m696m878k969k787L""
r, f = """", 32
for i in range(265):
    r += chr(f)*(ord(s[i])-48)
    f ^= 3
for i in range(0, len(r), 82):
    print(r[i:i+82])
文本编辑器
统计共407字符。","众所周知，用CSS能画一切！
代码：
.liukanshan-container {
  display: inline-block;
  position: relative;
  width: 500px;
  height: 500px;
  background: #a2e0fb;
  background-size: 100%;
  overflow: hidden;
  div {
    position: absolute;
    
box-sizing
: border-box;
    &:before,
    &:after {
        position: absolute;
        content: '';
    }
  }
}
.body {
  top: 102px;
  left: 122px;
  width: 204px;
  height: 282px;
  border: 12px solid #000;
  background: #ffffff;
  
border-radius
: 0px 36px 81px 50px/45px 230px 49px 30px;
  border-top-left-radius: 0px 50px;
  border-top-right-radius: 36px 230px;
  border-bottom-right-radius: 81px 49px;
  border-bottom-left-radius: 50px 30px;
  &::before {
    bottom: 43px;
    left: -53px;
    width: 38px;
    height: 42px;
    border-radius: 50%;
    border: 12px solid #000;
    border-right-color: #fff;
    background: #fff;
  }
  &::after {
    top: 24px;
    left: 107px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    background: #000;
  }
}
.ear, .ear-2 {
  top: 64px;
  left: 121px;
  width: 0;
  height: 0;
  border-style: solid;
  
border-width
: 19px 32px;
  border-color: transparent transparent #000 #000;
  &::before {
    top: 2px;
    left: -19px;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 19px 32px;
    border-color: transparent transparent #fff #fff;
  }
}
.ear-2 {
  left: 245px;
}
.nose {
  top: 90px;
  left: 299px;
  width: 168px;
  height: 99px;
  background: #fff;
  border: 12px solid #000;
  border-left-color: #fff;
  border-top-right-radius: 50px;
  border-bottom-right-radius: 50px;
  transform: rotate(-9deg);
  &::before {
    top: 0;
    right: 0;
    width: 75px;
    height: 75px;
    background: #000;
    border-radius: 50%;
    border-top-left-radius: 20% 50%;
    border-bottom-left-radius: 20% 50%;
  }
}
.leg, .leg-2, .arm {
  top: 373px;
  left: 176px;
  width: 12px;
  height: 81px;
  border-radius: 6px;
  background: #000;
  transform: rotate(4deg);
  &::before {
    top: 67px;
    left: -6px;
    width: 12px;
    height: 26px;
    border-radius: 6px;
    background: #000;
    transform: rotate(50deg);
  }
}
.leg-2 {
  left: 242px;
  transform: rotate(8deg);
  &::before {
    left: 7px;
    transform: rotate(-75deg);
  }
}
.arm {
  top: 208px;
  left: 200px;
  height: 100px;
  transform: rotate(-31deg);
  &::after {
    top: 67px;
    left: 7px;
    width: 12px;
    height: 26px;
    border-radius: 6px;
    background: #000;
    transform: rotate(-75deg);
  }
}",print（“? ???? ????? ???“）,"请定义“画”；
请定义“
刘看山
”；
请定义“代码”。
否则就会出现：
写一行代码，打开一个现成的刘看山图片 / 数据集，直接输出；
画了一个“
奥观海
”，但是 var LIU_Kanshan := O_Guanhai，然后 draw(LIU_Kanshan)；
明明写了很多代码但是封装到外部库里面，然后 import MEGALIB、MEGALIB::draw()。","@良良良良良
 写了一个代码，其实还能更短一点
用PHP","抖个机灵
没有限制不能联网的话，其实联网下载预制的字符串比本地绘制代码要短得多
甚至代码本身也可以只是一个loader，联网加载组件执行
所以这个问题可以转换成如何用尽可能少的代码下载一个文件
首先我们先做一个
刘看山
的文本文件，就命名为1，为了尽可能缩短地址，后缀也不要了
接下来就是如何下载并输出这个文件的内容
fetch('
1
').then(r=>r.text()).then(console.log)
这是我能想到的尽可能短的js实现，文件1和运行代码的页面放在同一个网站根目录内即可
46个字符，看上去应该极限了
但还可以更激进一点
我们把上面那一行保存为另一个文件，文件名为2
fetch('2').then(r=>r.text()).then(eval)
现在砍到39个字符了，因为
eval
比console.log更短
不过既然都用eval了，不如直接把console.log(刘看山的字符串)保存为文件3，然后
fetch('3').then(r=>r.text()).then(eval)","题主来发个答非所问的小细节，在这个问题页面下拉也可以看到
刘看山
动态！"
,,,,,,,,,,,,,,,,,,,,,
写代码没激情怎么办？,大学计算机狗一枚，最近感觉写代码十分没有激情该怎么办？,"要激情是吧？
写个Hello Word 而已，要不要这么震撼？！
?
mp.weixin.qq.com/s?__biz=MjM5MzIyMDExOQ==&mid=400941252&idx=1&sn=0d98926515101df82e552720e93d6f6a&scene=2&srcid=11298yEW5zEhufnUxomV561q&from=timeline&isappinstalled=0&key=b28b03434249256b6dd232dc036965eba9fa5af2f4c25b42b8612af4a831e70cfd7b2bbd1e519c47a0413a4914f927e7&ascene=2&uin=MTE5NzM0MjgwMg%3D%3D&devicetype=android-19&version=26030f35&nettype=WIFI&pass_ticket=Gu2yYQZw0J7bETa32CsZ5prYxp8mlvBR0T8kBpRV2KNqS%2B8bUYKFz%2F9FKPftNI9R
打个广告，最近新项目来了，晚上还要加班肝代码，原来的台灯用久了发现有反光，眼睛特别酸涩，于是入手了一台Screenbar Halo屏幕挂灯，专为显示器使用者所设计。能够减少屏幕反光来护眼，此外质感和颜值非常高，推荐给大家。
这个灯还是比较能耐的，usb接口，这么点功耗能整的特别亮堂。比较对我胃口。现在晚上打游戏也不会眼睛痛。虽然我不经常在家里干活，但是有这么个灯，干活或者摸鱼都比较舒服。
广告
明基ScreenBar Halo工作学习宿舍电脑曲面显示器护眼台
天猫
￥1399.00
去购买
?","我们的征途是星辰大海
――――――――――
补充：
1）
米娜桑
快来加入haskell阵营
2）有一个非常有意思的刷题网站，刷题就跟玩游戏打怪是的，界面也非常赞。
http://www.
codewars.com/r/sReWLw","编程本身是很枯燥的，所以你要去找一些有意思的东西做。
做有意思的东西来学编程，而不是为了编程而学编程。
做有意思的东西来学编程，而不是为了编程而学编程。
做有意思的东西来学编程，而不是为了编程而学编程。
如下是我的Idea墙，从做有意思的东西开始。
GitHub - phodal/brand: Design for Fun
: 制作程序员专属Badge制作
GitHub - phodal/growth: Growth
： 成为顶尖的Web开发者的APP
完整的Web开发流程介绍
如何写好代码――重构、测试、模式
Web应用的分析和部署
遗留代码
、遗留系统的形成
每一阶段所需的技能
GitHub - phodal/vmap: GitHub most popular Chinese user in Map
： GEOJSON与ElasticSearch制作GitHub大V地图
GitHub - phodal/ionic-elasticsearch: Django ElasticSearch Ionic 打造 GIS 移动应用
 ： Django ElasticSearch Ionic 打造O2O移动应用
GitHub - phodal-archive/tile.js: a pure javascript tiled map render
： 游戏地图生成器
PC端编辑器
Web端
文本编辑器
VR应用
Slide框架
更多可以参见我的Idea列表：
GitHub - phodal/ideas: Ideas of Phodal in Practise
以及对应的ideabook: 
GitHub - phodal/ideabook: Idea in Action","我高考超常发挥，考入自己的目标学校。选专业时选高分的专业，生怕自己的分数浪费了，因为我当时也不知道哪个专业好，喜欢哪个专业，有志于从事哪个行业。完全凭感觉，这个专业分数高，一定有前途。一共选择六个专业，加上“服从调剂”，由于分数垫底，没有资格选专业，所以我被调剂到软件学院。所以内心稍微有点不高兴，这种情绪影响了我一年。
我曾有和你一样的想法，对编程提不起兴趣。大一上学期对C语言很是抗拒，现在想想，明明是很简单的数学题，当时看了就是不愿去想解决方法，因为是和编程相关的，心理有抵触。我曾一度想转专业，无奈自己大一由于没能学好基础和专业课，没有资格调剂。
到了大二，有点破罐子破摔的感觉，学习知识也是东一头西一头，从文学到地理，从小说到学术，从经济到政治，反正能逃避专业课的东西我都想尝试一下，企图发现自己的兴趣来跳出软件这个坑。一年下来，一无所获是比较中肯的自评。
大三也是浑浑噩噩的，依然在逃避编程，从专业课的选择上都在逃避编程。所以能动手操作的测试和作业都被我尽可能的避免掉了。
到了大四，只不过是又一次循环，甚至有了船到桥头自然直的想法。在我实习三个月没写过像样的代码时，我又萌生了逃避的想法，于是我离职了。紧接着我就找到了一家非软件相关的公司，我以为我跳出了这个大坑，是的，我跳出了软件这个“坑”，然后跳进了另一个坑，是不带引号的那种坑。
几个月后，我从那家公司离职了。回到家乡，我发现除了软件行业，其他行业我都干不了，我连其他行业的基本概念都不了解，连我都不相信我能胜任工作要求（由于几年的逃避，失去了自信，这真是件可怕的事情）。所以我只能找软件的工作，这一次我找了技术支持工作，你看，直到毕业快满一年了，我依然在逃避编程。我干了一年后，发现这个工作属于重复性的无技能提升的工作。但是这时我并没有醒悟，而是又拖了一年。技术支持两年后，我突然醒悟，觉得自己如果再这样下去，是要被行业淘汰的。所以我修饰着自己无开发经验的简历，想要找一份开发的工作。在我投出十几封简历后，没有收到任何目标公司的面试通知，但是很多乌七八糟的公司的电话却是不少。这让我既沮丧又恐惧。当时，也就是在一个月前，我才清醒的认识到，毕业近三年，我一直在逃避困难，已经被人落下了。此时，应届生的薪资已经无法吸引我，而按工作年限的期望薪资找工作，我连面试的机会都没有，这时我才清醒的认识到，自己选择的简单模式，已经为自己设置了陷阱，必须要选择困难模式重来一遍。该拼搏的时候选择了安逸，这笔账，生活迟早要跟你算的。
一次偶然的机会，同学内推我到他的公司笔试面试，提了一个比较满意的薪资（自己觉得是可以的），最后获得了offer，顿时感觉自己的天亮了。我的笔试和面试都不错，证明我并没有我想的那么差，而我曾认为自己就是那么差。可见，没有真正的技术，连自己都会不相信自己。这真是件可怕的事。
我曾看过关于“人最重要的能力是什么”的问题，有人说是学习的能力，有人说是自信。我觉得不是自信，盲目的自信会眼高手低，结果一事无成。我觉得也不是学习的能力，因为如果一个人不自信，是不相信自己能学习得了技术的。把这两点结合起来是最合适的，就是
相信自己有学习的能力
。一个人如果相信自己能学习得了这个技术，那从心里接受它并学习它，这时你会发现它并没有那么困难。就比如最近我看视频教的内容，自己几年前看到就头疼惧怕的特殊用法，现在想想，啊原来是这样，很多内容都比较相似，其实并不需要智商，以我的智力理解这些用法并加以运用是绰绰有余的。而恰恰是我当初的逃避，认为自己没有能力去学习掌握它，从而被简单的用法阻碍住了，就更不必提程序设计和性能优化了。我认为学好任何一门技术，都要从被动学习变为主动学习，而这个过程是要靠你自己去感悟，我们是帮不了你的。好在我在社会奔波了几年后幡然醒悟，从内心主动的接受编程。加上乐观的心态：其他技术好的人只是比我早三五年学得这些技术罢了，三五年的坚持足以弥补这些不足。
当你从内心接受它时，它也对你敞开了大门，也会接受你。现在再看当年的C语言教材，感觉很是简单。这难道是我几年来智力和理解力有所提升？不是的，只不过是我不抵触它，从心里接受了它罢了。
学习的过程是枯燥的，所以我会时不时的自我反思些勉励的话记录下来，也会吸收别人的思想来激励自己。大道理不必多讲，你需要不断的给自己打兴奋剂，因为没有哪条箴言会激励你一个星期的，否则也不会有那么多人迷茫。我建议你总结几条积极的，鼓励和勉励自己的话（不必太多，够用就好）。尽量不要用消极的鞭策的话来激励自己，因为这类话很容易让你潜意识里产生逆反心理而抵触学习。
你需要做的就是不断的重复“学习→提升→自我激励→学习”的过程，并持之以恒。
所以我在学习完教程后看到这个问题，我觉得作为过来人，有必要跟你说一下你可能会走的路。如果能对你的职业生涯有一点点好的影响，我真的倍感欣慰。","写代码本来就不应该有激情。
大学的时候写代码是为了成绩为了技术为了未来，工作了之后写代码是为了工资为了升职为了加薪。写代码从来就不是为了有激情。
公司的OS为了满足在飞机上运行的要求，进行了极其严苛的测试，基本就是写各种test和说明。
有人问我们老板说你怎么可以找到人做这么无聊的事情？老板答：Because we pay them well。
是的，在你代码跑起来的时候会很爽，在设想自己程序完成之后的样子时会很爽，找到一个bug解决的时候也很爽，但是
大部分写代码的时候是一点都不爽的
，尤其是卡住的时候。这是工作，不是娱乐。
干什么有激情？去迪士尼有激情，打LOL有激情，唱KTV有激情。
做这些富有激情的事的时候，你是要花钱的！
你是要腾出本来可以让自己未来变得更好的时间去做这些事的！你在为激情和快乐付出代价！
因此你这根本就不是什么问题，写代码没激情就对了。
如果你要靠着激情才能写出代码，或许你并不适合干这行。","写代码没激情，可能是没有融入集体学习氛围中。如果你的C++老师写了个提交作业的系统，上面有ranklist，可以查看每个同学的做题进度，你会不会有激情？
也可能是对未来比较迷茫，所以漫无目的的写代码，变得机械化从而渐渐缺少激情。
以下是几点建议：
1.成立学习小组
可以找几个志同道合的同学，一起组成一个学习小组，每次选择一个task，成员之间互相监督、帮助，一起完成，最后互相指出其他成员的优点与不足，共同进步。
2.参加ACM集训队
如果想要提高自己，可以参加一下ACM集训队，把自己置身于一个有学习氛围的环境，就会有竞争意识，出去参加竞赛，开阔一下视野。一旦你获得了奖项，对日后找工作也会很有帮助。
3.做点有意思的东西
根据自己的兴趣爱好写东西，比如写点小游戏，GitHub上有很多资源，通过这种小项目给自己带来成就感。
关注一些公众号（比如“
九章算法
”），看看有意思的东西，比如hello world的不同写法，hello world这个程序对每个计算机学生都是非常震撼的，毕竟他是入学之后写的第一个程序，hello world也意味着你踏入这个领域的一种欢迎仪式，用25种不同的编程语言写“hello world”是不是很刺激？想的高大上一点，有情怀一点，增加自己是程序员的成就感，会给写代码带来一点动力。
4.做项目
刷题没激情，跟老师做项目，有点牛逼的感觉，或者学校里的类似创新、创业项目的那种项目，在做项目的过程中学习进步，还能丰富日后的简历。
5.确定方向
在学习过程中，找到自己的兴趣点，提早确定方向，这样有利于深入学习，有了方向，要做的事情会变得很多很多。
推荐阅读
转专业找CS工作，刷题9个月拿到Bloomberg offer
狗不理变香饽饽，8个月拿到Snapchat Offer
国内本土本硕的肉身翻墙记
国内应届小硕，拿到华为校招 Offer - 学员故事分享
欢迎关注我的
微信公众号
：九章算法（ninechapter）,帮助你了解IT技术前沿，通过面试、拿到offer、找到好工作！","现在看到这种问题真想引用小岳岳的口头禅对题主说：“打死你个龟孙儿！”（；￣ェ￣）
作为一个快要毕业找工作的学了6年+机械专业现在准备放弃转行做IT的master来说…答主你是体会不到你现在CS出身，且能系统地培养编程能力……which means能找个好工作是多么的幸福幸运。（让你自己抱着C艹，算法和数据结构自己从零开始啃，还得一边刷着leetcode泥试试！）
反正现在能让我安静地撸代码真心感觉是很lucky了…
每当我撸累了，我就打开浏览器点开一个名叫“it和机械行业对比”的收藏夹，里面都是我随便百度的……简直酸爽，尽是这样婶儿的：
然后我tm就有精神了！(●°u°●)? 」……
真是…好尴尬……呀
(s°□°）s ┻━┻","第一方面
李敖有句话是
妓女不靠性欲接客 我不靠灵感写作
村上春树
有个回答是
今天不想跑，所以才去跑，这才是长距离跑者的思维方式
很多时候我们躁动不安，觉得自己对于当前做的事情缺乏激情，而言下之意是只要我有了足够激情，就能完成的特别好。
这和“我家孩子很聪明啊，就是不努力”是一回事。
大部分事情并不需要什么天赋或者激情才能完成，只要有切实可行的目标、合理的计划和风雨无阻的执行力就够了。
第二方面
很多时候我们觉得没有激情或者没有兴趣，只是因为在所做的事情上没有成就感，不能得心应手，打个不恰当的比方：玩游戏时我们最喜欢的既不是毫无挑战的幼儿益智，也不是超变态的抖m系列。最能吸引玩家的往往是有挑战性，却在能克服的难度之内。
生活中的事情也是差不多的道理，没激情，可能是因为你正在做着无趣的简单重复工作，也可能是远超你能力的任务。前者需要自己调整工作内容，后者需要加强自身基础能力。
就像《
七龙珠
》中的孙悟空，每次遇到只比自己强一些的敌人，才能在不断地战斗中让自己变得更强。","?没激情的是给别人写代码
?给自己写代码的永远有激情，开个小项目吧。
?其实激情的也就是代码前的构思，码代码只是个验证的体力活。可能写到一半就累了。这时候出去走走休息下。看看那山那水那人。","第一、逛淘宝，买一套合适的女装。
第二、穿上女装。
第三、开始写代码。
你会发现，女装写代码，专注度增加50%，亢奋度增加100%，不但有了激情，bug也少了。","最后祝您身体健康 再见
分享今菁的歌单《学霸专用，脑细胞工程背景乐》
http://
music.163.com/playlist/
7311288/5719977?userid=90309767
 (@网易云音乐)","告诉自己,这行代码五块，这行代码十块...",现在写代码都俩显示器，一个放片，一个写代码,"当你发现生活里面太多蛋痛的时候
太多没办法去控制的事情出现
你会发现能静静写码是种幸福
什么都不用想 一切都是自己迟早能把握的
这个时候
你会发现自己满满的动力@_>A","要不 ，试试这个？？？…
https://mp.weixin.qq.com/s?__biz=MjM5MzIyMDExOQ==&mid=400941252&idx=1&sn=0d98926515101df82e552720e93d6f6a&scene=2&srcid=11298yEW5zEhufnUxomV561q&from=timeline&isappinstalled=0&key=b28b03434249256b6dd232dc036965eba9fa5af2f4c25b42b8612af4a831e70cfd7b2bbd1e519c47a0413a4914f927e7&ascene=2&uin=MTE5NzM0MjgwMg==&devicetype=android-19&version=26030f35&nettype=WIFI&pass_ticket=Gu2yYQZw0J7bETa32CsZ5prYxp8mlvBR0T8kBpRV2KNqS+8bUYKFz/9FKPftNI9R
?
mp.weixin.qq.com/s?__biz=MjM5MzIyMDExOQ==&mid=400941252&idx=1&sn=0d98926515101df82e552720e93d6f6a&scene=2&srcid=11298yEW5zEhufnUxomV561q&from=timeline&isappinstalled=0&key=b28b03434249256b6dd232dc036965eba9fa5af2f4c25b42b8612af4a831e70cfd7b2bbd1e519c47a0413a4914f927e7&ascene=2&uin=MTE5NzM0MjgwMg==&devicetype=android-19&version=26030f35&nettype=WIFI&pass_ticket=Gu2yYQZw0J7bETa32CsZ5prYxp8mlvBR0T8kBpRV2KNqS+8bUYKFz/9FKPftNI9R",我推荐你连一根电线在脑后，10分钟不写代码就电一下,"你得找个女朋友，有家庭的压力。怎么？你和我一样没有（doge。
不急，不急。推荐插件 - Rainbow Fart（系统，定制化
鼓励师
）
不管你是躺着敲，坐着敲，单手敲，
卢本伟
nb与你同在，兄弟。
不过一些需要细致的代码还是不建议的，毕竟会影响思路的。",写代码遇到低潮，我一般就换种编程语言写。,代码只是工作不是生活 把激情放到生活中 把冷静留给代码,记住你写的不是代码是人民币，你不是程序员，你是印钞机。好了，现在有激情没。
,,,,,,,,,,,,,,,,,,,,,
如何入门 Python 爬虫？,None,"“入门”是良好的动机，但是可能作用缓慢。如果你手里或者脑子里有一个项目，那么实践起来你会被目标驱动，而不会像学习模块一样慢慢学习。
另外如果说知识体系里的每一个知识点是图里的点，依赖关系是边的话，那么这个图一定不是一个
有向无环图
。因为学习A的经验可以帮助你学习B。因此，你不需要学习怎么样“入门”，因为这样的“入门”点根本不存在！你需要学习的是怎么样做一个比较大的东西，在这个过程中，你会很快地学会需要学会的东西的。当然，你可以争论说需要先懂python，不然怎么学会python做爬虫呢？但是事实上，你完全可以在做这个爬虫的过程中学习python :D
看到前面很多答案都讲的“术”――用什么软件怎么爬，那我就讲讲“道”和“术”吧――爬虫怎么工作以及怎么在python实现。
先长话短说summarize一下：
你需要学习
基本的爬虫工作原理
基本的http抓取工具，scrapy
Bloom Filter: 
Bloom Filters by Example
如果需要大规模网页抓取，你需要学习
分布式爬虫
的概念。其实没那么玄乎，你只要学会怎样维护一个所有集群机器能够有效分享的分布式队列就好。最简单的实现是python-rq: 
https://
github.com/nvie/rq
rq和Scrapy的结合：
darkrho/scrapy-redis ・ GitHub
后续处理，网页析取(
grangier/python-goose ・ GitHub
)，存储(Mongodb)
以下是短话长说：
说说当初写的一个集群爬下整个豆瓣的经验吧。
1）首先你要明白爬虫怎样工作。
想象你是一只蜘蛛，现在你被放到了互联“网”上。那么，你需要把所有的网页都看一遍。怎么办呢？没问题呀，你就随便从某个地方开始，比如说人民日报的首页，这个叫initial pages，用$表示吧。
在人民日报的首页，你看到那个页面引向的各种链接。于是你很开心地从爬到了“国内新闻”那个页面。太好了，这样你就已经爬完了俩页面（首页和国内新闻）！暂且不用管爬下来的页面怎么处理的，你就想象你把这个页面完完整整抄成了个html放到了你身上。
突然你发现， 在国内新闻这个页面上，有一个链接链回“首页”。作为一只聪明的蜘蛛，你肯定知道你不用爬回去的吧，因为你已经看过了啊。所以，你需要用你的脑子，存下你已经看过的页面地址。这样，每次看到一个可能需要爬的新链接，你就先查查你脑子里是不是已经去过这个页面地址。如果去过，那就别去了。
好的，理论上如果所有的页面可以从initial page达到的话，那么可以证明你一定可以爬完所有的网页。
那么在python里怎么实现呢？
很简单
import
 
Queue



initial_page
 
=
 
""http://www.renminribao.com""



url_queue
 
=
 
Queue
.
Queue
()


seen
 
=
 
set
()



seen
.
insert
(
initial_page
)


url_queue
.
put
(
initial_page
)



while
(
True
):
 
#一直进行直到海枯石烂

    
if
 
url_queue
.
size
()
>
0
:

        
current_url
 
=
 
url_queue
.
get
()
    
#拿出队例中第一个的url

        
store
(
current_url
)
               
#把这个url代表的网页存储好

        
for
 
next_url
 
in
 
extract_urls
(
current_url
):
 
#提取把这个url里链向的url

            
if
 
next_url
 
not
 
in
 
seen
:
      
                
seen
.
put
(
next_url
)

                
url_queue
.
put
(
next_url
)

    
else
:

        
break


写得已经很伪代码了。
所有的爬虫的backbone都在这里，下面分析一下为什么爬虫事实上是个非常复杂的东西――搜索引擎公司通常有一整个团队来维护和开发。
2）效率
如果你直接加工一下上面的代码直接运行的话，你需要一整年才能爬下整个豆瓣的内容。更别说Google这样的搜索引擎需要爬下全网的内容了。
问题出在哪呢？需要爬的网页实在太多太多了，而上面的代码太慢太慢了。设想全网有N个网站，那么分析一下判重的复杂度就是N*log(N)，因为所有网页要遍历一次，而每次判重用set的话需要log(N)的复杂度。OK，OK，我知道python的set实现是hash――不过这样还是太慢了，至少内存使用效率不高。
通常的判重做法是怎样呢？
Bloom Filter
. 简单讲它仍然是一种hash的方法，但是它的特点是，它可以使用固定的内存（不随url的数量而增长）以O(1)的效率判定url是否已经在set中。可惜天下没有白吃的午餐，它的唯一问题在于，如果这个url不在set中，BF可以100%确定这个url没有看过。但是如果这个url在set中，它会告诉你：这个url应该已经出现过，不过我有2%的不确定性。注意这里的不确定性在你分配的内存足够大的时候，可以变得很小很少。一个简单的教程:
Bloom Filters by Example
注意到这个特点，url如果被看过，那么可能以小概率重复看一看（没关系，多看看不会累死）。但是如果没被看过，一定会被看一下（这个很重要，不然我们就要漏掉一些网页了！）。 [IMPORTANT: 此段有问题，请暂时略过]
好，现在已经接近处理判重最快的方法了。另外一个瓶颈――你只有一台机器。不管你的带宽有多大，只要你的机器下载网页的速度是瓶颈的话，那么你只有加快这个速度。用一台机子不够的话――用很多台吧！当然，我们假设每台机子都已经进了最大的效率――使用多线程（python的话，多进程吧）。
3）集群化抓取
爬取豆瓣的时候，我总共用了100多台机器昼夜不停地运行了一个月。想象如果只用一台机子你就得运行100个月了...
那么，假设你现在有100台机器可以用，怎么用python实现一个分布式的爬取算法呢？
我们把这100台中的99台运算能力较小的机器叫作slave，另外一台较大的机器叫作master，那么回顾上面代码中的url_queue，如果我们能把这个queue放到这台master机器上，所有的slave都可以通过网络跟master联通，每当一个slave完成下载一个网页，就向master请求一个新的网页来抓取。而每次slave新抓到一个网页，就把这个网页上所有的链接送到master的queue里去。同样，
bloom filter
也放到master上，但是现在master只发送确定没有被访问过的url给slave。Bloom Filter放到master的内存里，而被访问过的url放到运行在master上的Redis里，这样保证所有操作都是O(1)。（至少平摊是O(1)，Redis的访问效率见:
LINSERT C Redis
)
考虑如何用python实现：
在各台slave上装好scrapy，那么各台机子就变成了一台有抓取能力的slave，在master上装好Redis和rq用作分布式队列。
代码于是写成
#slave.py

current_url = request_from_master()
to_send = []
for next_url in extract_urls(current_url):
    to_send.append(next_url)

store(current_url);
send_to_master(to_send)

#master.py
distributed_queue = DistributedQueue()
bf = BloomFilter()

initial_pages = ""www.renmingribao.com""

while(True):
    if request == 'GET':
        if distributed_queue.size()>0:
            send(distributed_queue.get())
        else:
            break
    elif request == 'POST':
        bf.put(request.url)
        


好的，其实你能想到，有人已经给你写好了你需要的：
darkrho/scrapy-redis ・ GitHub
4）展望及后处理
虽然上面用很多“简单”，但是真正要实现一个商业规模可用的爬虫并不是一件容易的事。上面的代码用来爬一个整体的网站几乎没有太大的问题。
但是如果附加上你需要这些后续处理，比如
有效地存储（数据库应该怎样安排）
有效地判重（这里指网页判重，咱可不想把人民日报和抄袭它的大民日报都爬一遍）
有效地信息抽取（比如怎么样抽取出网页上所有的地址抽取出来，“朝阳区奋进路中华道”），搜索引擎通常不需要存储所有的信息，比如图片我存来干嘛...
及时更新（预测这个网页多久会更新一次）
如你所想，这里每一个点都可以供很多研究者十数年的研究。虽然如此，
“路漫漫其修远兮,
吾将上下而求索
”。
所以，不要问怎么入门，直接上路就好了：）
如果学完了爬虫你对搜索引擎还感兴趣，也欢迎阅读我正在写的教程：
我会一直更新，我自己的公号 
HiXieke 
里也会不断更新发布，欢迎关注。其它答案和文章：","看了大部分回答不禁叹口气，主要是因为看到很多大牛在回答像“如何入门爬虫”这种问题的时候，一如当年学霸讲解题目，跳步无数，然后留下一句“不就是这样推嘛”，让一众小白菜鸟一脸懵逼。。作为一个0起步（之前连python都不会），目前总算掌握基础，开始向上进阶的菜鸟，深知其中的不易，所以我会在这个回答里，尽可能全面、细节地分享给大家从0学习爬虫的各种步骤，如果对你有帮助，请点赞~
-------------------------------------------------------------------------------------------------
#我要写爬虫！
 
#Ver.1.5 
 
#Based on: Python 2.7
#Author:高野良
#
原创内容，转载请注明出处
首先！你要对爬虫有个明确的认识，这里引用毛主席的思想：
在战略上藐视：
 
“所有网站皆可爬”：
互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站
“框架不变”：
网站不同，但是原理都类似，大部分爬虫都是从 
发送请求――获得页面――解析页面――下载内容――储存内容
 这样的流程来进行，只是用的工具不同
在战术上重视：
 
持之以恒，戒骄戒躁：
对于初学入门，不可轻易自满，以为爬了一点内容就什么都会爬了，爬虫虽然是比较简单的技术，但是往深学也是没有止境的（比如搜索引擎等）！只有不断尝试，刻苦钻研才是王道！（为何有种小学作文即视感）
                              ||
                                ||
                                V
然后，你需要一个宏伟的目标，来让你有持续学习的动力（没有实操项目，真的很难有动力）
我要爬整个豆瓣！...
我要爬整个xx社区！
我要爬知乎各种妹子的联系方式*&^#%^$#
                              ||
                                ||
                                V
接着，你需要扪心自问一下，自己的python基本功吼不吼啊？
吼啊！
――OK，开始欢快地学习爬虫吧 ！
不吼？你还需要学习一个！
赶紧回去看
廖雪峰
老师的教程，
2.7（更新：现在需要了解3.x了）的。至少
这些功能和语法
你要有基本的掌握 ：
list，dict：
用来序列化你爬的东西
切片：
用来对爬取的内容进行分割，生成
条件判断（if等）：
用来解决爬虫过程中哪些要哪些不要的问题
循环和迭代（for while ）：
用来循环，重复爬虫动作
文件读写操作（open，close等）：
用来读取参数、保存爬下来的内容等
编码常识（codecs等）：
非常关键，爬虫写熟了以后遇到的各种古怪问题，很多来自于UTF-8 GBK等奇奇怪怪的编码！这个问题先做了解，后面调试时候再解决也不迟！
                              ||
                                ||
                                V
然后，你需要补充一下下面几个内容，作为你的知识储备：
（注：这里并非要求“掌握”，下面讲的两点，只需要先了解，然后通过具体项目来不断实践，直到熟练掌握）
1、网页的基本知识：
基本的HTML语言知识（知道href等大学计算机一级内容即可）
理解网站的发包和收包的概念（POST GET）
稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）
2、一些分析语言，为接下来解析网页内容做准备
NO.1  正则表达式：扛把子技术，总得会最基础的：
NO.2  XPATH：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则
参考：
XPath 教程
 
NO.3  Beautifulsoup：
美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本
官网文档：
Beautiful Soup 4.2.0 文档
 
参考案例：
 
No4. JSONpath
??抓包类的爬虫（通常是动态网页），往往需要json的加持。
jsonpath
便应运而生，和xpath一样，它是快速检索分析各种各样json文件中待抓取内容的重要方法。
更多官方文档看此：
JSONPath - XPath for JSON
                              ||
                              ||
                              V
接着，你需要一些高效的工具来辅助
（同样，这里先了解，到具体的项目的时候，再熟悉运用）
NO.1   F12 开发者工具：
 
看
源代码
：快速定位元素
分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看
NO.2  抓包工具：
 
推荐httpfox，
火狐浏览器
下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息
NO.3  XPATH CHECKER (火狐插件）：
非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：
     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考
     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如
scrapy
），还是删去避免报错
NO.4  正则表达测试工具：
 
在线正则表达式测试
 ，拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！
                              ||
                              ||
                              V
ok！这些你都基本有一些了解了，现在开始进入抓取时间，上各种模块吧！python的火，很大原因就是各种好用的模块，这些模块是居家旅行爬网站常备的――
urllib
urllib2
requests
                              ||
                              ||
                              V
不想重复造轮子，有没有现成的框架？
华丽丽的scrapy
pyspider
||
||
V
遇到动态页面怎么办？
selenium
（会了这个配合scrapy无往不利，是居家旅行爬网站又一神器!）
phantomJS（不显示网页的selenium）
puppyteer（node.js乱入hhh）
（进阶）Browsermob-proxy （利用抓包的方式进行抓取，类似
fiddler
，比较复杂，但是足够好玩，可以解决很多意想不到的问题，高阶玩法！
||
||
V
遇到
反爬虫
策略验证码之类咋整？（不想折腾的直接第四个）
PIL
opencv
pybrain
打码平台
||
||
V
然后是数据库，这里我认为开始并不需要非常深入，在需要的时候再学习即可
mysql
mongodb
sqllite
||
||
V
爬来的东西怎么用？
numpy 数据分析，类似matlab的模块，计算数据，处理矩阵
pandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）
#更高阶段↓ML！
pytorch
tensorflow
||
||
V
其他进阶技术
多线程、分布式
―――――――――――― 乱入的分割线 ―――――――――――――
然后学习编程关键的是学以致用，天天捧一本书看不如直接上手操练，下面我通过实际的例子来讲解爬虫――
比如最近，楼主在豆瓣上认识了一个很可爱的妹子，发现她一直会更新签名和日志，所以没事就会去她主页看看，但一直没有互相加好友（作为一只高冷的天蝎，怎么可以轻易加好友嘛！而且加了好友，你更新什么都会收到推送，那多没意思啊！一点神秘感都没有了！），可还是想及时获得妹子的最新动态，怎么办？
于是我就写了个70几行的python脚本，包含爬虫+邮件模块，跑在家里的一台闲置笔记本上，通过计划任务每准点抓取妹子的签名和最新文章一次，发送到我的邮箱。。嗯，其实是很简单的技术，，代码如下所示：
#
-*-
coding
:
utf
-
8
-*-
 
#编码声明，不要忘记！


import
 
requests
  
#这里使用
requests
，小脚本用它最合适！


from
 
lxml
 
import
 
html
    
#这里我们用
lxml
，也就是
xpath的方法



#豆瓣模拟登录，最简单的是
cookie
，会这个方法，
80
%
的登录网站可以搞定


cookie
 
=
 
{}
 


raw_cookies
 
=
 
''#引号里面是你的
cookie
，用之前讲的抓包工具来获得



for
 
line
 
in
 
raw_cookies
.
split
(
';'
):

    
key
,
value
 
=
 
line
.
split
(
""=""
,
 
1
)

    
cookie
[
key
]
 
=
 
value
 
#一些格式化操作，用来装载
cookies



#重点来了！用
requests
，装载
cookies
，请求网站


page
 
=
 
requests
.
get
(
'#妹纸的豆瓣主页#'
,
cookies
=
cookie
)



#对获取到的
page格式化操作
，方便后面用
XPath来解析


tree
 
=
 
html
.
fromstring
(
page
.
text
)



#
XPath解析
，获得你要的文字段落！


intro_raw
 
=
 
tree
.
xpath
(
'
//span[@id=""intro_display""]/text()')



#简单的转码工作，这步根据需要可以省略


for
 
i
 
in
 
intro_raw
:

    
intro
 
=
 
i
.
encode
(
'
utf
-
8
'
)



print
 
intro
 
#妹子的签名就显示在屏幕上啦



#接下来就是装载邮件模块，因为与本问题关联不大就不赘述啦
~




怎么样~是不是很简单~
======
v1.5更新日志：
增加一些新的技术方法，更多细节技术具体实现欢迎关注我，我会在专栏中更新
V1.2更新日志：
修改了一些细节和内容顺序","以下是我学
python爬虫
的打怪升级之路，过程充满艰辛，也充满欢乐，虽然还未打倒大boss，但一路的风景就是最大的乐趣，不是么？希望大家能get到想要的东西！
多图预警！
以下奉献一段爬取知乎头像的代码
import requests
import urllib
import re
import random
from time import sleep
def main():
    url='
知乎 - 与世界分享你的知识、经验和见解
'
    #感觉这个话题下面美女多
    headers={省略}
    i=1
    for x in xrange(20,3600,20):
        data={'start':'0',
'offset':str(x),
'_xsrf':'a128464ef225a69348cef94c38f4e428'}
        #知乎用offset控制加载的个数，每次响应加载20
        content=requests.post(url,headers=headers,data=data,timeout=10).text
        #用post提交form data
        imgs=re.findall('<img src=\\\\\""(.*?)_m.jpg',content)  
        #在爬下来的json上用正则提取图片地址，去掉_m为大图  
        for img in imgs:
            try:
                img=img.replace('\\','')
                #去掉\字符这个干扰成分
                pic=img+'.jpg'
                path='d:\\bs4\\zhihu\\jpg\\'+str(i)+'.jpg'
                #声明存储地址及图片名称
                urllib.urlretrieve(pic,path)
                #下载图片
                print u'下载了第'+str(i)+u'张图片'
                i+=1
                sleep(random.uniform(0.5,1))
                #睡眠函数用于防止爬取过快被封IP
            except:
                print u'抓漏1张'
                pass
        sleep(random.uniform(0.5,1))
if __name__=='__main__':
    main() 
结果：
公众号已开通
：挖数（ID:washu66），
推送各种数据相关的原创文章哦
对于Python的初学者，推荐这门免费公开课：
Introduction to Python Programming","呃本来只是想给题主一个传送，因为本身也是一个Python爱好者。
简单介绍一下我的那个入门教程，其实根本算不上教程，基本上算是一个学习的笔记，很多内容都是从网上整理然后自己实践得到的结果。
如果说深入学习爬虫，还是建议那本《
自己动手写网络爬虫
》，是我的启蒙教程，语法是Java的，但是思路是相通的。
Python爬虫的学习，最主要的是多摸索，多试验（哪个不是这样）。先从最简单的例子做起，比如爬取百度主页，爬取百度图片，然后正则，巴拉巴拉。
我的学习笔记可以作为一个参考的索引，里面很多东西没有深入探讨，因为毕竟当时我也只是一个小菜（现在也差不多）。
给初学者一个入门的途径，接下来的路还是要自己走^_^
至于匿名、个人习惯潜水。
继续匿了。
推荐一本朋友写的爬虫教程，崔庆才 著，Python 3网络爬虫开发实战。
利益相关：作者是我学弟。
以前写过一个爬虫入门的系列，传送：
专栏：Python爬虫入门教程
一共12篇：
[Python]网络爬虫（一）：抓取网页的含义和URL基本构成
[Python]网络爬虫（二）：利用urllib2通过指定的URL抓取网页内容
[Python]网络爬虫（三）：异常的处理和HTTP状态码的分类
[Python]网络爬虫（四）：Opener与Handler的介绍和实例应用
[Python]网络爬虫（五）：urllib2的使用细节与抓站技巧
[Python]网络爬虫（六）：一个简单的百度贴吧的小爬虫
[Python]网络爬虫（七）：Python中的正则表达式教程
[Python]网络爬虫（八）：糗事百科的网络爬虫（v0.2）源码及解析
[Python]网络爬虫（九）：百度贴吧的网络爬虫（v0.4）源码及解析
[Python]网络爬虫（十）：一个爬虫的诞生全过程（以山东大学绩点运算为例）
[Python]网络爬虫（11）：亮剑！爬虫框架小抓抓Scrapy闪亮登场！
[Python]网络爬虫（12）：爬虫框架Scrapy的第一个爬虫示例入门教程
比较入门，不过多接触一些小demo没有坏处哈","本回答针对初学者，我会用最简单的案例告诉你如何入门
python爬虫
！
想要
入门Python 爬虫
首先需要解决四个问题
熟悉python编程
了解HTML
了解
网络爬虫
的基本原理
学习使用python爬虫库
一、你应该知道什么是爬虫？
网络爬虫，其实叫作
网络数据采集
更容易理解。
就是
通过编程向网络服务器请求数据（HTML表单），然后解析HTML，提取出自己想要的数据。
归纳为四大步：
根据url获取HTML数据
解析HTML，获取目标信息
存储数据
重复第一步
这会涉及到数据库、网络服务器、HTTP协议、HTML、数据科学、网络安全、图像处理等非常多的内容。但对于初学者而言，并不需要掌握这么多。
二、python要学习到什么程度
如果你不懂python，那么需要先学习python这门非常easy的语言（相对其它语言而言）。
编程语言基础语法无非是数据类型、数据结构、运算符、逻辑结构、函数、文件IO、错误处理这些，学起来会显枯燥但并不难。
刚开始入门爬虫，你甚至不需要去学习python的类、多线程、模块之类的略难内容。找一个面向初学者的教材或者网络教程，花个十几天功夫，就能对python基础有个三四分的认识了，这时候你可以玩玩爬虫喽！
当然，前提是你必须在这十几天里认真敲代码，反复咀嚼语法逻辑，比如列表、字典、字符串、if语句、for循环等最核心的东西都得捻熟于心、于手。
教材方面比较多选择，我个人是比较推荐
python官方文档
以及
python简明教程
，前者比较系统丰富、后者会更简练。
如果想少走弯路，不妨看看一些视频课程。自制力比较差的小伙伴，跟着老师把python基础走一遍，效率非常高。
三、为什么要懂HTML
前面说到过爬虫要爬取的数据藏在网页里面的HTML里面的数据，有点绕哈！
维基百科是这样解释HTML的
超文本标记语言
（英语：
H
yper
T
ext
M
arkup
L
anguage，简称：
HTML
）是一种用于创建
网页
的标准
标记语言
。HTML是一种基础技术，常与
CSS
、
JavaScript
一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面
[3]
。
网页浏览器
可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非
编程语言
。
总结一下，HTML是一种用于创建网页的标记语言，里面嵌入了文本、图像等数据，可以被浏览器读取，并渲染成我们看到的网页样子。
所以我们才会从先爬取HTML，再 解析数据，因为数据藏在HTML里。
学习HTML并不难，它并不是编程语言，你只需要熟悉它的标记规则，这里大致讲一下。
HTML标记包含标签（及其属性）、基于字符的数据类型、字符引用和实体引用等几个关键部分。
HTML标签是最常见的，通常成对出现，比如
<
h1
>
与
</
h1
>
。
这些成对出现的标签中，第一个标签是开始标签，第二个标签是结束标签。两个标签之间为元素的内容（文本、图像等），有些标签没有内容，为空元素，如
<
img
>
。
以下是一个经典的
Hello World
程序的例子：
<!DOCTYPE html>
<html>
  <head>
    <title>This is a title</title>
  </head>
  <body>
    <p>Hello world!</p>
  </body>
</html>
HTML文档由嵌套的HTML元素构成。它们用HTML标签表示，包含于尖括号中，如
<
p
>
[56]
在一般情况下，一个元素由一对标签表示：“开始标签”
<
p
>
与“结束标签”
</
p
>
。元素如果含有文本内容，就被放置在这些标签之间。
四、了解python网络爬虫的基本原理
在编写python爬虫程序时，只需要做以下两件事：
发送GET请求，获取HTML
解析HTML，获取数据 
这两件事，python都有相应的库帮你去做，你只需要知道如何去用它们就可以了。
五、用python库爬取百度首页标题和图片
注：下文代码中的html.parser是bf的解析器
首先，发送HTML数据请求可以使用python内置库urllib，该库有一个urlopen函数，可以根据url获取HTML文件，这里尝试获取百度首页“
https://www.
baidu.com/
”的HTML内容
# 导入urllib库的urlopen函数


from
 
urllib.request
 
import
 
urlopen
 

# 发出请求，获取html


html
 
=
 
urlopen
(
""http://www.baidu.com/""
)


# 获取的html内容是字节，将其转化为字符串


html_text
 
=
 
bytes
.
decode
(
html
.
read
())


# 打印html内容


print
(
html_text
)
看看效果：
输出html内容部分截取
我们看一下真正百度首页html是什么样的，如果你用的是谷歌浏览器，在百度主页打开设置>更多工具>开发者工具，点击element，就可以看到了：
在谷歌浏览器中查看HTML
对比一下你就会知道，刚才通过
python程序
获取到的HTML和网页中的一样！
获取了HTML之后，接下就要解析HTML了，因为你想要的文本、图片、视频都藏在HTML里，你需要通过某种手段提取需要的数据。
python同样提供了非常多且强大的库来帮助你解析HTML，这里以著名的python库
BeautifulSoup
为工具来解析上面已经获取的HTML。
BeautifulSoup是第三方库，需要安装使用。在命令行用pip安装就可以了：
pip install bs4
BeautifulSoup会将HTML内容转换成结构化内容，你只要从结构化标签里面提取数据就OK了：
比如，我想获取百度首页的标题“百度一下，我就知道”，怎么办呢？
这个标题是被两个标签套住的，一个是一级标签<head><head>,另一个是二级标签<title><title>，所以只要从标签中取出信息就可以了
# 导入urlopen函数


from
 
urllib.request
 
import
 
urlopen


# 导入BeautifulSoup


from
 
bs4
 
import
 
BeautifulSoup
 
as
 
bf


# 请求获取HTML


html
 
=
 
urlopen
(
""http://www.baidu.com/""
)


# 用BeautifulSoup解析html


obj
 
=
 
bf
(
html
.
read
(),
'html.parser'
)


# 从标签head、title里提取标题


title
 
=
 
obj
.
head
.
title


# 打印标题


print
(
title
)
看看结果：
这样就搞定了，成功提取出百度首页的标题。
如果我想要下载百度首页logo图片呢？
第一步先获取该网页所有图片标签和url，这个可以使用BeautifulSoup的findAll方法，它可以提取包含在标签里的信息。
一般来说，HTML里所有图片信息会在“img”标签里，所以我们通过findAll(""img"")就可以获取到所有图片的信息了。
# 导入urlopen


from
 
urllib.request
 
import
 
urlopen


# 导入BeautifulSoup


from
 
bs4
 
import
 
BeautifulSoup
 
as
 
bf


# 请求获取HTML


html
 
=
 
urlopen
(
""http://www.baidu.com/""
)


# 用BeautifulSoup解析html


obj
 
=
 
bf
(
html
.
read
(),
'html.parser'
)


# 从标签head、title里提取标题


title
 
=
 
obj
.
head
.
title


# 使用find_all函数获取所有图片的信息


pic_info
 
=
 
obj
.
find_all
(
'img'
)


# 分别打印每个图片的信息


for
 
i
 
in
 
pic_info
:

    
print
(
i
)
看看结果：
打印出了所有图片的属性，包括class（元素类名）、src（链接地址）、长宽高等。
其中有百度首页logo的图片，该图片的class（元素类名）是index-logo-src。
[<img class=""index-logo-src"" height=""129"" hidefocus=""true"" src=""//www.baidu.com/img/bd_logo1.png"" usemap=""#mp"" width=""270""/>, <img alt=""到百度首页"" class=""index-logo-src"" src=""//www.baidu.com/img/baidu_jgylogo3.gif"" title=""到百度首页""/>]
可以看到图片的链接地址在src这个属性里，我们要获取图片链接地址：
# 导入urlopen


from
 
urllib.request
 
import
 
urlopen


# 导入BeautifulSoup


from
 
bs4
 
import
 
BeautifulSoup
 
as
 
bf


# 请求获取HTML


html
 
=
 
urlopen
(
""http://www.baidu.com/""
)


# 用BeautifulSoup解析html


obj
 
=
 
bf
(
html
.
read
(),
'html.parser'
)


# 从标签head、title里提取标题


title
 
=
 
obj
.
head
.
title


# 只提取logo图片的信息


logo_pic_info
 
=
 
obj
.
find_all
(
'img'
,
class_
=
""index-logo-src""
)


# 提取logo图片的链接


logo_url
 
=
 
""https:""
+
logo_pic_info
[
0
][
'src'
]


# 打印链接


print
(
logo_url
)
结果：
获取地址后，就可以用urllib.urlretrieve函数下载logo图片了
# 导入urlopen


from
 
urllib.request
 
import
 
urlopen


# 导入BeautifulSoup


from
 
bs4
 
import
 
BeautifulSoup
 
as
 
bf


# 导入urlretrieve函数，用于下载图片


from
 
urllib.request
 
import
 
urlretrieve


# 请求获取HTML


html
 
=
 
urlopen
(
""http://www.baidu.com/""
)


# 用BeautifulSoup解析html


obj
 
=
 
bf
(
html
.
read
(),
'html.parser'
)


# 从标签head、title里提取标题


title
 
=
 
obj
.
head
.
title


# 只提取logo图片的信息


logo_pic_info
 
=
 
obj
.
find_all
(
'img'
,
class_
=
""index-logo-src""
)


# 提取logo图片的链接


logo_url
 
=
 
""https:""
+
logo_pic_info
[
0
][
'src'
]


# 使用urlretrieve下载图片


urlretrieve
(
logo_url
,
 
'logo.png'
)
最终图片保存在'logo.png'
六、结语
本文用爬取百度首页标题和logo图片的案例，讲解了python爬虫的基本原理以及相关python库的使用，这是比较初级的爬虫知识，还有很多优秀的python爬虫库和框架等待后续去学习。
当然，掌握本文讲的知识点，你就已经入门python爬虫了。加油吧，少年！
如果你想学习使用requests + xpath，请看这篇回答：
你是如何开始能写 Python 爬虫？
1409 赞同 ・ 79 评论
回答
广告
Python 3网络爬虫开发实战
京东
￥79.00
去购买
?
广告
Python 3爬虫、数据清洗与可视化实战
京东
￥46.60
去购买
?","如果学会了python的基本语法，我认为入爬虫是很容易的。
我写的第一个爬虫大概只需要10分钟，自学的 scrapyd ,  看官方文档花了20分钟，
因为我英文不是很好，很多单词需要搜索一下。
官方文档链接 
https://
docs.scrapy.org/en/late
st/intro/tutorial.html
 ）
(scrapy 并不是入门必须的，所以你可以看完我的答案再酌情考虑 scrapy ）
再接触到了 requests , lxml ，配合基本库 urllib, urllib2 就几乎无所不能了。
后来有人推荐我用 BeatufulSoup  之类的库，但其实原理都差不多。
一、入门爬虫的干货 
0. 爬虫的基本思路 
a. 通过URL或者文件获取网页，
b. 分析要爬取的目标内容所在的位置
c. 用元素选择器快速提取(Raw) 目标内容
d. 处理提取出来的目标内容 （ 通常整理合成一个 Json） 
e. 存储处理好的目标内容 （比如放到 MongoDB 之类的数据库，或者写进文件里。） 
1. 为什么我入门爬虫那么快，我是不是在装？ 
答：我自己总结了一下，在接触爬虫之前：       
a. 我挺了解HTTP 协议（看了《HTTP权威指南》），
b. 我写过基于Flask框架的后端（大概三年前@
萧井陌
 在知乎上推荐Flask框架，然后我就自学了，用的是《Flask Web开发：基于Python的Web应用开发实战 》） 
c. 我写过前端(HTML+CSS+JS)，了解什么是DOM ，会一点jquery。 
d. 正则也是勉强够用的。 
e. 本人大学也是计算机专业，学习挺认真的。 
f. 所以算是厚积薄发。 
2. 那么毫无专业基础，也没有前后端基础的人应该怎么办？ 
答：那当然要超过半小时啦。先花点时间去大概了解以下内容： 
a. HTTP协议的请求方法，请求头部，请求数据
b. 大概了解一下什么是 cookie 
c. 学一点HTML和元素选择器 
d. 学会使用Chrome 的 开发者工具
      磨刀不误砍柴工，当然如果有人带着，这些大概1-2小时就能过到能凑合用的程度了。如果没人带，就上网搜索学习一下，也很快的，估摸最多十小时。 
ps, 阮一峰老师的技术入门博客写得很不错，除此之外，
博客园
也有很多好资源。
3. 放一个新鲜出炉的代码，看懂就能入门了：
4. Python 爬虫常用的库是哪些？入门应该掌握哪些库？
答：网上有很多相关的资料，但是我个人觉得新入门的人，不需要也不应该一下子接触所有的库。正如幼儿刚开始学说话的时候，不应该同时教普通话粤语闽南语英语。 
我个人认为，学会 requests 和 lxml ，就可以入门爬虫了。
      其他的常用库，自己搜，但注意贪多嚼不烂。 （我整理出来的被小马甲人喷了，我很不开心，所以我自己存好删了）
二、一点点涉及爬虫进阶的分界线 
0. 知乎上很多爬虫代码，一个函数几十行，是很不好的。应该尽量减少重复代码。 
1. 重要的事情说三次，
函数不是越长越好， 好代码应该简单易懂好维护！
函数不是越长越好， 好代码应该简单易懂好维护！ 
函数不是越长越好， 好代码应该简单易懂好维护！ 
(放在进阶是因为能做到这一点的爬虫代码不多，很多都一团乱麻，坑死接盘侠)
2. Scrapy + MongoDB + Redis  分布式爬虫系统其实不复杂。
a）. Redis 用来存储要爬取的网页队列，也就是任务队列 
b）. MongoDB  用来存储爬取的内容结果。
c) . Scrapy  里放爬虫crawler , 分别爬取不同的网页内容，
ps：分布式这个东西，听起来很恐怖，但是拆开了也就这样。所以不用害怕。
*************************
-----  讲事故的分割线  ----- 
************************* 
曾经在某创业公司被赶鸭子上架（我最初是一个后端程序员，现在成分有点复杂，一言难尽），要在一星期内跟一个分布式爬取各大网商（包括淘宝天猫京东等十几家网商，Scrapy + MongoDB + Redis）的数据。
当时差点吓坏我了，因为没写过爬虫。  
然后leader 给我的线索只有 基本框架是 Scrapy。 
也许是无知者无畏， 也没想到去问谁，就自己看了 Scrapy 的文档，半小时就写出来了。
后来就很顺利把分布式爬虫系统搭起来了。
还爬了谷歌、百度、Bing、 Pinterest 、Instagram 等大量和当时公司业务相关的数据。 
就这样，我做到了。
当然，加了不少班。
ps:  用很多的机器，代表需要爬取的爬取的数据量很多，但是和项目的复杂程度不一定相关。所以不要害怕。害怕也没用，需求来了，一边颤抖一边加班也要写完代码的。
pps: 你们要复制粘贴就能跑的代码
# -*- coding: utf-8 -*-


import
 
os


import
 
requests


from
 
lxml
 
import
 
html



headers
 
=
 
{

    
'Host'
:
 
'www.zhihu.com'
,

    
'Accept-Language'
:
 
'zh-CN,zh;q=0.8,en;q=0.6'
,

    
# 2017.12 经网友提醒，知乎更新后启用了网页压缩，所以不能再采用该压缩头部

    
# !!!注意, 请求头部里使用gzip, 响应的网页内容不一定被压缩，这得看目标网站是否压缩网页

    
# 'Accept-Encoding': 'gzip, deflate, sdch, br',

    
'Connection'
:
 
'keep-alive'
,

    
'Pragma'
:
 
'no-cache'
,

    
'Cache-Control'
:
 
'no-cache'
,

    
'Upgrade-Insecure-Requests'
:
 
'1'
,

    
'Accept'
:
 
'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
,

    
'User-Agent'
:
 
'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) '

                  
'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36'
,


}




def
 
save
(
text
,
 
filename
=
'temp'
,
 
path
=
'download'
):

    
fpath
 
=
 
os
.
path
.
join
(
path
,
 
filename
)

    
with
 
open
(
fpath
,
 
'w'
)
 
as
  
f
:

        
print
(
'output:'
,
 
fpath
)

        
f
.
write
(
text
)




def
 
save_image
(
image_url
):

    
resp
 
=
 
requests
.
get
(
image_url
)

    
page
 
=
 
resp
.
content

    
filename
 
=
 
image_url
.
split
(
'zhimg.com/'
)[
-
1
]

    
save
(
page
,
 
filename
)




def
 
crawl
(
url
):

    
resp
 
=
 
requests
.
get
(
url
,
 
headers
=
headers
)

    
page
 
=
 
resp
.
content

    
root
 
=
 
html
.
fromstring
(
page
)

    
image_urls
 
=
 
root
.
xpath
(
'//img[@data-original]/@data-original'
)

    
for
 
image_url
 
in
 
image_urls
:

        
save_image
(
image_url
)




if
 
__name__
 
==
 
'__main__'
:

    
# 注意在运行之前，先确保该文件的同路径下存在一个download的文件夹, 用于存放爬虫下载的图片

    
url
 
=
 
'https://www.zhihu.com/question/27364360'
  
# 有一双美腿是一种怎样的体验?

    
crawl
(
url
)
--- update@20200927 --- 
原答案写于 20170506，这三年 python添加了很多新的语言特性，scrapy 在我吐槽过后不久也开始全面支持了 py3,  py2 在 2020年初已经被官方全面下架, 知乎版本从后台到 APP以及前端也做了大量的修改,  所以，别再问我为啥上例代码跑不动了，我也懒得再改了。总之，不要总想着抄代码，要学会理解代码后自己写。","――――――最重要的话写在前面――――――
0、
新手/喜欢练习/欢迎交流/邀请/我是看着这个问题下面的答案学习的
1、带着一个目的来学爬虫。#我的目的实现了…所以我来写这个回答了。
2、
不要怂就是干
！系统学习固然好，直接写一个项目出来效果更加简单粗暴！（不过自己现在的水平写出来都是流水一般的面向过程的代码，代码的重复部分太多，正在回过头去学习面向对象编程，学习类和方法的使用。不过
我还是坚定地认为入门的时候应该直接简单粗暴地实践一个项目
）
3、
哪里不会搜哪里！哪里报错改哪里！
相信我你遇到的99%的问题都能从网上找到相似的问题，
你需要做的就是写代码！搜问题！调BUG！你搜不到解决办法的情况下，80%的情况是你搜索的姿势不对，另外20%可能需要你自己动动脑子，换个思路去做。
举个印象最深的例子。
我在统计知乎回答voters的具体情况的时候（后面会介绍）发现知乎的数据是这样发送的。
http://www.
zhihu.com/answer/152197
95/voters_profile?total=70&offset=10&follows=wAp13IyyllRUgyux1Zp3MSGySe4GNnw-AG6-yDt_MO68ywzyjX_TGN3o
什么鬼（摔）。
等到我辛辛苦苦用正则把里面的信息提出来的时候发现我得到的数据是这样的…
我的内心是崩溃的……
问题很明显是编码问题……用户那一列全部是unicode编码……转成中文就好了嘛……
我刚开始也是这么想的…当我尝试了各种encode和decode…以后整个人都不好了。
大概是这样的。我用Shell演示一下…应该能看懂。
但是我的字符串是自动获取的啊，怎么可能挨着用 u' '赋值……
于是我开始了漫长的搜索之路……在看了无数篇重复度高于百分之80的关于编码的文章后，在我都快要放弃的时候…看到了这个…
水木社区-源于清华的高知社群
 你能理解我当时内心的酸爽吗…
大概就是这样。
所以
我遇到的问题已经很奇葩了依然还是有解决办法的嘛
。Windows下面编码各种混乱，系统编码，编程时编辑器的编码，抓取网页以后网页的编码，Python2的编码，Python3的编码……新人真的很容易搞昏头。
例子不多言了。后面还有很多。
――――――正文1：我的爬虫入门，不谈学习，只聊项目（代码已贴）――――――
前面说到学爬虫需要一个目标。那我的目标是什么呢？听我慢慢讲。
前些日子我回答了一个问题
高考后暑假应该做什么事？ - 生活
 我回答这个问题的时候呢关注人数也就才刚刚过百，我的赞数也涨的很慢…
可是突然有一天呢，我发现突然就出现了一个300赞的回答…当时那个问题的关注似乎还不到300。我百思不得其解…但是我看了看那个回答的赞同和答主的主页。
大概是这样的：
然后我隐隐觉得…可能会是刷赞？当然我们不能恶意地去揣测别人，要拿数据说话，毕竟知乎现在的三零真实用户还是蛮多的，不一定都是水军的小号。
于是我一个从来没有学过爬虫的人就开始学爬虫了…然而并不一帆风顺。首先是知乎显示“等人赞同”的方式做了修改，参见
如何评价知乎新的「某某等人赞同」显示方式？ - 如何评价 X
。
其次我刚开始的时候不会维持登陆…每次抓到的数据里都有很多的“知乎用户”（也就是未登录状态下抓取不成功）。
为了行文的连贯我跳过中间学习时做的几个小爬虫…直接放我做成功的结果吧。
选取的样本回答依次为：
@段晓晨
高考后暑假应该做什么事？ - 段晓晨的回答
@EdgeRunner
高考后暑假应该做什么事？ - EdgeRunner 的回答
@孔鲤
高考后暑假应该做什么事？ - 孔鲤的回答
@Emily L
能利用爬虫技术做到哪些很酷很有趣很有用的事情？ - Emily L 的回答
@chenqin
为什么 2015 年初，上海有卫计委官员呼吁大家生二胎？ - chenqin 的回答
感兴趣的可以下载数据
getvoters.xls_免费高速下载
getvoters2.xls_免费高速下载
getvoters3.xls_免费高速下载
getvoters4.xls_免费高速下载
getvoters5.xls_免费高速下载
结论就是……没有结论。
话说我回答的那个三零用户比例也好高啊……我真的没有刷赞我保证！（话说我的赞里面要是有水军的话我会很伤心的……我一直以为是我写的好他们才赞我的QAQ）
到这里第一个项目就结束了…
这个我暂时不贴代码…代码不完善…还得有点小修改。两天内放上来。
――来贴代码――
loveQt/Zhihu_voters ・ GitHub
使用前请填写config.ini文件，cookie不用填。
依然不完善。是这样的，知乎在获取“等人赞同”的时候有一个很畸形的地方在于……答案的id很畸形。
比如我现在这个答案。
http://www.
zhihu.com/question/2089
9988/answer/49749466
当我点击“等人赞同”的时候。抓包得到请求地址。我用的是Firefox的Firebug
这个地址是这样的：
http://www.
zhihu.com/answer/152992
64/voters_profile
如果你继续往下拉，知乎会自动加载更多用户，你会得到形如这样的地址：
http://www.
zhihu.com/answer/152992
64/voters_profile?total=143&offset=10&follows=YCPQ47_p62oaS49riUMu-4sTvAQfYpoe5E2RRX9lj40vWR6E4J5W_T-U
分析这个地址的构成就会发现
/answer/这里应该是这个回答的唯一id，而这个id显然与上面的
/question/20899988/answer/49749466
是不一样的，我抓了好多个回答，结论应该是没有规律的，知乎应该是给每个问题一个id，每个问题下面的回答一个id，但是只有点赞的时候这个回答才会得到它关于voters的id……
所以我没办法实现完全的自动化…你如果想爬指定的回答，似乎得先手动抓包了 QAQ
抓包的示意如上，打开网络面板，点击“等人赞同”，找到地址中的数字就可以了。
如果你会抓包了请接着看下去。
代码的下载地址在上面的github。Python版本为2.7，希望你们会用pip安装依赖的库。
简单说几个方面。
1、知乎的登陆。我模仿了 
@egrcc
 和 
@7sDream
 的项目，使用了requests.session。
def login():
    cf = ConfigParser.ConfigParser()
    cf.read(""config.ini"")
    cookies = cf._sections['cookies']

    email = cf.get(""info"", ""email"")
    password = cf.get(""info"", ""password"")
    cookies = dict(cookies)
    global s
    s = requests.session()
    login_data = {""email"": email, ""password"": password}
    header = {
    'User-Agent': ""Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:34.0) Gecko/20100101 Firefox/34.0"",
    'Host': ""www.zhihu.com"",
    'Referer': ""http://www.zhihu.com/"",
    'X-Requested-With': ""XMLHttpRequest""
        }
    r = s.post(Login_url, data=login_data, headers=header)

在实现了登陆之后，只要使用s.get(url)得到的页面都是登陆成功的状态。
//
注意，不登陆或者登陆不成功的情况下也可以爬取数据。点赞、感谢、提问、回答的数值都能正常获取，但是会出现部分用户无法获取名称和用户地址，显示为“知乎用户”
2、获取数据
假如我们获取到了单页数据，那么使用正则可以很简单地获取到想要的数据，具体参见代码。
我们需要做的，其实是获取那些需要爬取的URL。
通过上面对于网址的分析我们可以发现，网址的组成为domain/answer/ans_id/voters_profile?total=xxx&offset=xx&...
后面那堆乱码不重要，重要的是total和offset，每次会展示出10个用户的数据，所以我们只需要获取到点赞的总数total，就可以知道需要循环多少步（total/10），注意从是0开始，不然会漏掉前十个数据。
而这也就是我在
zhihu-vote.py
中的做法。其余的部分就没有什么难度了，入门的同学应该都可以看懂。
3、改进
我们在
zhihu-vote.py
中通过构造地址的方法来，通过循环实现对所有voters_profile的遍历。但是如果我们了解json的知识的话，我们可以发现其实每个页面都是json格式的。
其中最关键的地方在于
next
。我们会发现
其实每个页面中都包含了下一页的地址！
这样我们是不是可以让爬虫每爬一页自己找到一个地址，然后自己去爬下一页呢？
可是这样做有一个问题，如何控制循环呢？
假如我们去看最后一个页面的话，会发现是这样的。
注意这里的next值为空
。
而我们知道（不知道的你现在知道了），
空字符串在作为条件判断时相当于False 
所以我写了
zhihu-voteV2.py
其中核心的改动是
Vote_url = Zhihu + 'answer/' + ans_id +'/voters_profile'
h = s.get(Vote_url)
html = h.content.encode('utf-8')
target = json.loads(html)
while target['paging']['next']:
    Vote_url = 'http://www.zhihu.com'+target['paging']['next']

这样就实现了程序每次爬取页面时从页面中获取地址，而不是人为构造地址循环。下面是原来的做法。
for num in range (0,page_num):
    Vote_url = Zhihu + 'answer/' + ans_id +'/voters_profile?total='+str(total)+'&offset='+str(num)+'0'

讲实话我不知道这两种写法哪种好，但我还是蛮高兴自己发现了第二种做法。
于是我做了一个运行时间的测试…
提车了，下一步需要做什么？ - 车海沉浮高永强的回答
 16K的赞
运行结果如下：
构造地址的办法用时451秒，第二种办法用时251秒。
……我不知道为什么方法二会比方法一快，可能是网速吧……QAQ。有了解的前辈还望告知原因…
到这里也就结束了。最后的结果是写入excel的，有知友说让我去学习csv，已经在看了，不过这次还是用的让人又爱又恨的excel。
按照惯例写To-dos：
完善Github的文档说明
想办法看能不能自动获取那个蛋疼的ans_id就不用每次都手动抓包了，selenium？我不会用啊TAT
在点赞的页面我们只能得到用户的4个数据，也就是赞同、感谢、提问、回答，有些时候我们或许想知道他的关注人数和被关注人数…然而那个得到用户的页面中去爬取了。不过想通过用户URL得到用户的具体数据是有现成的轮子的……
egrcc/zhihu-python ・ GitHub
  （PY2） 
@egrcc
 和
7sDream/zhihu-py3 ・ GitHub
（PY3） 
@7sDream
 我想办法看怎么把我现在获取答案点赞用户信息的方法pull给他们…直接调用他们的User类就ok了~
抓特别多的数据时考虑多线程和
gzip
…？接下来就要学这个了…会的话我就用了…还记得我去爬知乎赞数最高的答案…一个答案爬了30分钟…
――更新完毕，大家学习愉快，共同进步――
――
Windows 平台Py2编码问题畸形但有效解法
――
在..\Python27\Lib\site-packages\下新建
sitecustomize.py
添加代码
import sys
sys.setdefaultencoding(""utf-8"")

――――――正文2：学习路上顺便写的项目――――――
在学习路上写了许多类似test的小小项目，就不赘述了。下面贴出来三个还算有结果的。
1、抓取知乎话题下面的问题，分析容易得赞的问题
具体描述在 
第一次在知乎获得 1000 以上的赞是什么体验？ - 段晓晨的回答
 写过了。
代码在
知乎将如何应对「狗日的知乎」计划？ - 段晓晨的回答
 里面有。需要用到
7sDream/zhihu-py3 ・ GitHub
2、写完1中项目以后。我爬取了爬虫话题分类下面的所有回答。结果
爬虫话题所有问题_20150531.xls_免费高速下载
然后我从其中挑选了“关注量/回答量”较大的问题（也就是有人关注但有效回答较少）写了以下两个回答，大家可以看看。
如何使用  python  抓取  雪球网页？ - 段晓晨的回答
如何用Python抓取写一个抓取新浪财经网指定企业年报的脚本？ - 段晓晨的回答
――――――结语：谈谈学习――――――
至此我能说的就说完了。
鼓起勇气来回答这个问题，不知道自己有没有资格。毕竟自己也就才学了一周多一点。自认为还谈不上入门……因为不会的实在太多。
系统学习爬虫的思路别人讲的肯定比我好。我的经验在开头已经说过了……
不要怂就是干
！
哪里不会搜哪里！哪里报错改哪里！
如果一定要再补充写什么，贴上我之前回复知友的评论吧。
首先要带着一个目的去学，这个目的不能太复杂，不能一上来就搞那种需要模拟登陆，需要js动态实现的网站，那样你会在登陆那儿卡很久，又在js实现那儿卡很久，很容易挫伤学习积极性。比如我最初的目的就是爬知乎。知乎登陆/不登陆数据会有差别，比如抓不到某些人的数据，返回“知乎用户”这种。
有了目的，你需要一些基础知识。html是什么，标签是什么，浏览器和服务器之间通信（比如抓包）。爬虫的原理就是要把网页的源码整个下载下来，然后去里面寻找我们需要的信息。所以首先你得能获取正确的网址，然后通过配置你的程序（Headers伪装浏览器，代理防止封ip等）来成功访问网页并获取源码。…………诸如此类的基础知识，其实特别简单。你可以去找一些爬
百度贴吧
，爬煎蛋，爬
糗事百科
的例子，很容易就会上手。
有了源码你需要去里面寻找东西，比较简单的有正则表达式，更方便的有BeautifulSoup。对json解析有json。等等。
最后你可能需要一些模块化的思想。比如我在写爬知乎问题的时候，写了一些代码来让它把输出的结果自动保存到excel里…那我是不是可以把写入excel这个行为单独抽出来，定义为一个方法。以后每次遇到需要excel的地方我就拿过来改一下就能用。同样的思路，登陆过程，post数据的过程，解析数据的过程，是不是都可以自己慢慢积累为模块。就好像你有了很多乐高积木，以后再做的时候就不需要做重复的事情，直接搭积木就好~
最后感谢一下在我学习过程中参考过的别人的回答和博客。太多了无法一一列举。再次感谢。
编程是最容易获得的超能力
。你还在等什么？","个人觉得：
新手学习python爬取网页先用下面4个库就够了：（第4个是实在搞不定用的，当然某些特殊情况它也可能搞不定）
1. 打开网页，下载文件：
urllib
2. 解析网页：
BeautifulSoup
，熟悉JQuery的可以用
Pyquery
 （感谢 
@李林蔚
 的建议）
3. 使用
Requests
来提交各种类型的请求，支持重定向，cookies等。
4. 使用
Selenium
，模拟浏览器提交类似用户的操作，处理js动态产生的网页
这几个库有它们各自的功能。配合起来就可以完成爬取各种网页并分析的功能。具体的用法可以查他们的官网手册(上面有链接)。
做事情是要有驱动的，如果你没什么特别想抓取的，新手学习可以从这个
爬虫闯关网站
开始
，目前更新到第五关，闯过前四关，你应该就掌握了这些库的基本操作。
实在闯不过去，再到
这里
看题解吧，第四关会用到
并行编程
。（串行编程完成第四关会很费时间哦），第四，五关只出了题，还没发布题解。。。
学完这些基础，再去学习scrapy这个强大的爬虫框架会更顺些。这里有它的
中文介绍
。
感谢大家支持，改了改链接的格式，好看多了，呵呵
=============================
云服务器
到期，闯关不再维护了。
感兴趣的可以看
https://
github.com/heibanke/blo
g_and_jizhang/tree/master/heibanke_prj
这里lesson模块是闯关的源码，用
django
实现。","其实写爬虫是一个很微小的事情， 在
12年
和
14年
，我却单靠这2个爬虫获得了offer，所以爬虫真的算Python工程师的必修课。这2个爬虫其实都很cute，现在看起来有很多地方其实理解的不够深入，也有一些实现地方做的不好，但是毕竟是当时的我，就保留着吧。
其实拿到数据怎么用，比如做数据分析，做创业项目原始启动数据，数据可视化等等。那我就利用Web开发的优势，把数据在页面上展示出来吧。无图无真相，先上图：
这是IPhone打开看到的：
移动版的图有点糊，是因为使用了小尺寸的图片，担心太浪费读者的手机流量。
我刚爬了网易云音乐精彩评论， 其中包含了 28925 个歌手（组合）演唱的 710182 首歌曲中的 720699 条评论。它们都在这里 
云音乐评论
。
我在用随机刷着玩的时候，看到了这么一条：
AJAPKK：
阿黛尔
：你经历过绝望吗
我就点进去听了下这首
廖佳琳
版本的
Rolling in the deep
，额那一天我单曲循环了一下午的这首神曲。建议一边听一边继续向下看。
其次是发现最热的评论中薛之谦的歌曲占了好几个，好吧我得先承认，之前认为喜欢参与综艺节目的歌手歌唱的都不行，尤其薛之谦以段子手而著名。但是看到总榜之后，我还是挨个听了他的歌，觉得其实还行。
在知乎，感觉没用过Python写爬虫都不好意思和人打招呼。我想写篇爬虫的文章，所以就开始找需求，其实一开始我是准备爬豆瓣害羞组（不懂得可以搜一搜），但是连续2个深夜2点去蹲守，发现现在那几个小组不够劲爆，而且量也太少，而且担心发了文章有人举报我 ~=(??? ? ???) ，所以作罢。
上班的路上，除了看kindle，我也经常会带着耳机听网易云音乐（简称网云吧）里面收藏的歌，额，其实经常还能看到好多好玩的评论的，有辣眼睛的，有悲伤的，有总结很精辟的，有讲一些不是同年代人不会懂的。可以先预览下 
网易云音乐有哪些有趣的评论？
 和 
网易云音乐评论量最高的歌曲有哪些？在这些评论里你又发现了什么值得品味的故事？
等不及了？ 它们都在这里 
云音乐评论
， 里面有 28925 个歌手（组合）演唱的 710182 首歌曲中的 720699 条精彩评论。
这个项目地址是： 
GitHub - dongweiming/commentbox
（fork时别忘记点赞哦 ）， 使用的技术：
1. 后端： Flask + Mongoengine + Mako + requests + Redis + lxml + 
concurrent.futures
2. 前端：React + Mobx + Fetch + Material-UI + ES6 + Webpack + Babel
今天先和大家聊聊写个爬虫需要熟悉哪些知识，思路是什么，怎么实践的，欢迎关注专栏，节后我再聊后端和前端的实现， 也有使用Flask的经验。
需求分析
既然要爬整站的热门评论，就要找到「
入口」。
什么是入口呢？就是类似聚合页，比如抓知乎的全部问题和答案，我的思路是先爬 
话题广场
， 爬每个一级话题，再去爬话题下子话题，如 
教育 - 热门问答
 。 然后不断翻页就好了。由于一个问题可以有多个话题标签，需要注意缓存已爬取和正在爬取的答案页面地址，防止重复爬取。
那网云呢？评论在歌曲下，歌曲在歌手下。找到全部歌手就好了。所以先爬 
http://
music.163.com/#
/discover/artist
， 找到规律，按照歌手所在地区和首字母翻就能遍历了。
其次是预估最后的结果量。其实我这几十万的只是网云评论数据的一个小小小子集，主要是看爬取要花的时间，以及可提供存储的空间。对这个需求来说，有些歌曲都是几十万个评论，我用一台非闲置的服务器抓取，肯定一年也抓不完，
不要忘记，抓取的瓶颈不在你使用多线程，多进程或者asyncio，主要在对方对你的抓取的容忍程度以及在爬和反爬策略伤的博弈的结果。
而且我的VPS是1G内存，考虑爬取下来存入MongoDB的空间，并要给Redis预留缓存使用内存的使用量，所以我决定：
1. 每个歌手只抓取Ta最热门的50首歌曲。
2. 每首歌只要最热的前10条评论。
当时目测歌手数量在1-2w，而有些冷门歌手没有50首歌曲，或者热门评论不足，也就是大概200万条左右（理想情况下 1-2w * 50 * 10）。实际上和我预期的少了不少，但是还是让我的1G VPS捉襟见肘了... #论确定需求的重要性#
技术选型
我使用过各种解析页面的库，现在一般只使用BeautifulSoup（bs4）或者lxml，如果页面比较简单，标签写的比较严谨且需求单一或者一次性一般都用BeautifulSoup，比如豆瓣；复杂的、未来会一直都在用的选择lxml，比如淘宝这种页面被各业务线拼的模板。
我其实推荐大家好好学习xpath，这也是我选择lxml的一个原因。
那为什么要用xpath，假如你只是爬一个站，其实无所谓，假如你要爬各种同类型的网站，比如豆瓣东西的
发布东西
，它支持发布数十个网站，肯定得让抓取框架化，因为发布东西要的那些字段都是定的，比如标题，价格，商品图片，用xpath新人可以不关心它怎么运作的，只是按照xpath寻找对应的元素去获取之，几分钟就能学会如何对一个新的网站进行支持，假如使用BeautifulSoup，你要写一坨坨的解析、遍历。而
xpath
永远都是一句搞定。
接着说 concurrent.futures， 这是一个在Python 3.2 的时候就被放进标准库的模块，它高度抽象出了异步执行任务的接口，把队列的使用隐藏起来，而且多进程和多线程接口统一，对于使用来说，切换多进程和多线程很简单。这比你写一大坨的多进程或者多线程的代码要简单很多。它的
数据流
是这样的：
我们这个需求中抓取逻辑中，这样使用：
from concurrent.futures import ProcessPoolExecutor                                                                 
with ProcessPoolExecutor(max_workers=2) as executor:                                                               
    for artist_id in unprocess_artist_list():                                                                      
        executor.submit(parser_artist, artist_id)
可以把它理解成一个2个进程的
进程池
。如果你的服务器CPU个数更多，处理能力更强，不要吝啬加大这个值哦。
最后说requests。这个太有名，不用它的人可能不理解为啥都用它，它的说明是「Python HTTP Requests for Humans」，是的，其实并没有人要用它，你得自己写一大坨的代码才能支持会话，Cookie，代理等需求。对于没有自虐倾向的人来说，Python标准库提供的方案确实太底层了。我之前还特意研究了下为了这么好的东西不直接放进标准库？ 看 
Consider Requests&amp;amp;amp;#x27; Inclusion in Python 3.5&amp;amp;amp;#x27;s Standard Library ・ Issue #2424
 其中多个大神出没哦。
怎么样不被发现
1. 不要用一个IP狂爬。
所以要准备一堆可用的代理IP，如果公司有额外的比较闲的IP最好了，闲着也是闲着，在不影响正常业务的提前下，多换IP。否则就要想办法获取免费代理。我的书中这个地方有写。
2. 
勤换UA。
我看很多人喜欢在配置中列一些UA,  其实吧，可以使用 
GitHub - hellysmile/fake-useragent: up to date simple useragent faker with real world database
。其实我也推荐大家伪装成各大搜索网站的UA， 比如Google UA 有这样一些 
Google 抓取工具
，说到这里，有的网站，你添加referfer字段是搜索网站也是有用的，因为网站是希望被索引的，所以会放宽搜索引擎的爬取策略。
3. 
爬取间隔自适应
。就是已经限制了你这个IP的抓取，就不要傻傻重复试，怎么滴也得休息一会。网易云音乐操作起来比较简单，sleep一下就好了。其实sleep的间隔应该按情况累加，比如第一次sleep 10秒，发现还是被约束。那么久sleep 20秒... 这个间隔的设置已经自适应的最终效果是经验值。
4. 
验证码识别
。现在攻防让验证码技术层出不穷，其实好多都是自己写算法识别，并不开源，开源的就是tesseract，还可以借用
百度识图平台
试试。我个人还是倾其所有的做好其他的地方，不要让人家弹出验证码让我输入。
开始爬
首先一定要防止「由于异常等原因造成爬虫程序错误，重新启动还会重新爬」的尴尬。我建了一张Process表，用来存爬取的状态：开始爬取置状态为「PENDING」，抓取完成置状态为「 SUCCEEDED」（当然也有失败，比如页面解析未覆盖到情况造成的失败，之后失败的状态应该没有条目才对，否则就要去兼容）。每次抓取程序启动都会检查哪些PENDING的先抓完，抓过的直接忽略去下一个。
真的数据Model包含4个：Artist（歌手）、Song（歌曲）、Comment（评论）和User（评论人），我们感受一下抓取的过程（截取重要部分）：
def parser_artist(artist_id):                                                                                      
    create_app()  # Flask应用要先初始化                                                                                                  
    process = Process.get_or_create(id=artist_id)  # Process以歌手为单位                                                              
    if process.is_success:  # 如果已经成功直接返回了                                                                                       
        return                                                                                                                                                                                                                                                                                        
    tree = get_tree(ARTIST_URL.format(artist_id))  # 使用requests获取页面文本，转化为lxml对象                                                                
    artist = Artist.objects.filter(id=artist_id)                                                                   
    if not artist:  # 如果之前没抓过                                                                                                
        artist_name = tree.xpath('//h2[@id=""artist-name""]/text()')[0]                                              
        picture = tree.xpath(                                                                                      
            '//div[contains(@class, ""n-artist"")]//img/@src')[0]                                                    
        artist = Artist(id=artist_id, name=artist_name, picture=picture)                                           
        artist.save()                                                                                              
    else:  # 如果之前抓过，但是该歌手的歌曲没抓完                                                                                                        
        artist = artist[0]                                                                                         
    song_items = tree.xpath('//div[@id=""artist-top50""]//ul/li/a/@href')                                            
    songs = []                                                                                                     
    for item in song_items:                                                                                        
        song_id = item.split('=')[1]                                                                               
        song = parser_song(song_id, artist) # 进入抓取和解析歌手模式                                                                        
        if song is not None:                                                                                       
            songs.append(song)                                                                                     
    artist.songs = songs                                                                                           
    artist.save()  
    process.make_succeed()  # 标记歌手下的热门歌曲的热门评论抓完                              
整体就是这样。整个抓取解析的流程的代码加上空格是110行。其中的热门评论是通过API获取的，思路可见 
网易云音乐新版WebAPI分析
。
原文在这里： 
https://
zhuanlan.zhihu.com/p/22
456856
欢迎关注本人的
微信公众号
获取更多Python相关的内容（也可以直接搜索「Python之美」）：
 ","如果你仔细观察，就不难发现，懂爬虫、学习爬虫的人越来越多，一方面，互联网可以获取的数据越来越多，另一方面，像 Python这样的编程语言提供越来越多的优秀工具，让爬虫变得简单、容易上手。
利用爬虫我们可以获取大量的价值数据，从而获得感性认识中不能得到的信息，比如：
1.爬取数据，进行市场调研和商业分析。
爬取知乎优质答案，为你筛选出各话题下最优质的内容。 抓取房产网站买卖信息，分析房价变化趋势、做不同区域的房价分析。爬取招聘网站各类职位信息，分析各行业人才需求情况及薪资水平。
2.作为机器学习、数据挖掘的原始数据。
比如你要做一个推荐系统，那么你可以去爬取更多维度的数据，做出更好的模型。
3.爬取优质的资源：图片、文本、视频
爬取知乎钓鱼贴\图片网站，获得福利图片。
这些事情，原本我们也是可以手动完成的，但如果是单纯地复制粘贴，非常耗费时间，比如你想获取100万行的数据，大约需忘寝废食重复工作两年。而爬虫可以在一天之内帮你完成，而且完全不需要任何干预。
对于小白来说，爬虫可能是一件非常复杂、技术门槛很高的事情。比如有的人认为学爬虫必须精通 Python，然后哼哧哼哧系统学习 Python 的每个知识点，很久之后发现仍然爬不了数据；有的人则认为先要掌握网页的知识，遂开始 HTML\CSS，结果入了前端的坑，瘁……
但掌握正确的方法，在短时间内做到能够爬取主流网站的数据，其实非常容易实现。但建议你从一开始就要有一个具体的目标，你要爬取哪个网站的哪些数据，达到什么量级。
在目标的驱动下，你的学习才会更加精准和高效。那些所有你认为必须的前置知识，都是可以在完成目标的过程中学到的。这里给你一条平滑的、零基础快速入门的学习路径。
1.了解爬虫的基本原理及过程
2.Requests+Xpath 实现通用爬虫套路
3.了解非结构化数据的存储
4.学习scrapy，搭建工程化爬虫
5.学习数据库知识，应对大规模数据存储与提取
6.掌握各种技巧，应对特殊网站的反爬措施
7.分布式爬虫，实现大规模并发采集，提升效率
1.了解爬虫的基本原理及过程
大部分爬虫都是按“发送请求――获得页面――解析页面――抽取并储存内容”这样的流程来进行，这其实也是模拟了我们使用浏览器获取网页信息的过程。
简单来说，我们向服务器发送请求后，会得到返回的页面，通过解析页面之后，我们可以抽取我们想要的那部分信息，并存储在指定的文档或数据库中。
在这部分你可以简单了解 HTTP 协议及网页基础知识，比如 POST\GET、HTML、CSS、JS，简单了解即可，不需要系统学习。
2.学习 Python 包并实现基本的爬虫过程
Python中爬虫相关的包很多：urllib、requests、bs4、scrapy、pyspider 等，建议你从requests+Xpath 开始，requests 负责连接网站，返回网页，Xpath 用于解析网页，便于抽取数据。
如果你用过 BeautifulSoup，会发现 Xpath 要省事不少，一层一层检查元素代码的工作，全都省略了。掌握之后，你会发现爬虫的基本套路都差不多，一般的静态网站根本不在话下，小猪、豆瓣、
糗事百科
、腾讯新闻等基本上都可以上手了。
来看一个爬取豆瓣短评的例子：
选中第一条短评，右键-“检查”，即可查看源代码
把短评信息的XPath信息复制下来
我们通过定位，得到了第一条短评的XPath信息：
//*[@id=""comments""]/ul/li[1]/div[2]/p
但是通常我们会想爬取很多条短评，那么我们会想获取很多这样的XPath信息：
//*[@id=""comments""]/ul/li[1]/div[2]/p
//*[@id=""comments""]/ul/li[2]/div[2]/p
//*[@id=""comments""]/ul/li[3]/div[2]/p
………………………………
观察1、2、2条短评的XPath信息，你会发现规律，只有<li>后面的序号不一样，恰好与短评的序号相对应。那如果我们想爬取这个页面所有的短评信息，那么不要这个序号就好了呀。
通过XPath信息，我们就可以用简单的代码将其爬取下来了：
import
 
requests


from
 
lxml
 
import
 
etree



#我们邀抓取的页面链接


url
=
'https://book.douban.com/subject/1084336/comments/'



#用requests库的get方法下载网页


r
=
requests
.
get
(
url
)
.
text



#解析网页并且定位短评


s
=
etree
.
HTML
(
r
)


file
=
s
.
xpath
(
'//*[@id=""comments""]/ul/li/div[2]/p/text()'
)



#打印抓取的信息


print
(
file
)
爬取的该页面所有的短评信息
当然如果你需要爬取异步加载的网站，可以学习浏览器抓包分析真实请求或者学习Selenium来实现自动化，这样，知乎、时光网、
猫途鹰
这些动态的网站也基本没问题了。
这个过程中你还需要了解一些Python的基础知识：
文件读写操作：用来读取参数、保存爬下来的内容
list(列表)、dict(字典)：用来序列化爬取的数据
条件判断(if/else)：解决爬虫中的判断是否执行
循环和迭代(for ……while)：用来循环爬虫步骤
3.了解非结构化数据的存储
爬回来的数据可以直接用文档形式存在本地，也可以存入数据库中。
开始数据量不大的时候，你可以直接通过 Python 的语法或 pandas 的方法将数据存为text、csv这样的文件。还是延续上面的例子：
用Python的基础语言实现存储：
with open('pinglun.text','w',encoding='utf-8') as f:
    for i in file:
        print(i)
        f.write(i)
用pandas的语言来存储：
#import pandas as pd
#df = pd.DataFrame(file)
#df.to_excel('pinglun.xlsx')
这两段代码都可将爬下来的短评信息存储起来，把代码贴在爬取代码后面即可。
存储的该页的短评数据
当然你可能发现爬回来的数据并不是干净的，可能会有缺失、错误等等，你还需要对数据进行清洗，可以学习 
pandas
 包的基本用法来做数据的预处理，得到更干净的数据。以下知识点掌握就好：
缺失值处理：对缺失数据行进行删除或填充
重复值处理：重复值的判断与删除
空格和异常值处理：清楚不必要的空格和极端、异常数据
分组：数据划分、分别执行函数、数据重组
4.掌握各种技巧，应对特殊网站的反爬措施
爬取一个页面的的数据是没问题了，但是我们通常是想爬取多个页面啊。
这个时候就要看看在翻页的时候url是如何变化了，还是以短评的页面为例，我们来看多个页面的url有什么不同：
https://book.douban.com/subject/1084336/comments/
https://book.douban.com/subject/1084336/comments/hot?p=2
https://book.douban.com/subject/1084336/comments/hot?p=3
https://book.douban.com/subject/1084336/comments/hot?p=4
……………………
通过前四个页面，我们就能够发现规律了，不同的页面，只是在最后标记了页面的序号。我们以爬取5个页面为例，写一个循环更新页面地址就好了。
for a in range(5):
    url=""http://book.douban.com/subject/1084336/comments/hot?p={}"".format(a)
当然，爬虫过程中也会经历一些绝望啊，比如被网站封IP、比如各种奇怪的验证码、userAgent访问限制、各种动态加载等等。
遇到这些反爬虫的手段，当然还需要一些高级的技巧来应对，常规的比如访问频率控制、使用
代理IP池
、抓包、验证码的OCR处理等等。
比如我们经常发现有的网站翻页后url并不变化，这通常就是异步加载。我们用开发者工具取分析网页加载信息，通常能够得到意外的收获。
通过开发者工具分析加载的信息
比如很多时候如果我们发现网页不能通过代码访问，可以尝试加入userAgent 信息。
浏览器中的userAgent信息
在代码中加入userAgent信息
往往网站在高效开发和反爬虫之间会偏向前者，这也为爬虫提供了空间，掌握这些应对反爬虫的技巧，绝大部分的网站已经难不到你了。
5.学习爬虫框架，搭建工程化的爬虫
掌握前面的技术一般量级的数据和代码基本没有问题了，但是在遇到非常复杂的情况，可能仍然会力不从心，这个时候，强大的 scrapy 框架就非常有用了。
scrapy
 是一个功能非常强大的爬虫框架，它不仅能便捷地构建request，还有强大的 
selector
 能够方便地解析 response，然而它最让人惊喜的还是它超高的性能，让你可以将爬虫工程化、模块化。
学会 scrapy，你可以自己去搭建一些爬虫框架，你就基本具备爬虫工程师的思维了。
6.学习数据库基础，应对大规模数据存储
爬回来的数据量小的时候，你可以用文档的形式来存储，一旦数据量大了，这就有点行不通了。所以掌握一种数据库是必须的，学习目前比较主流的 MongoDB 就OK。
MongoDB 可以方便你去存储一些非结构化的数据，比如各种评论的文本，图片的链接等等。你也可以利用PyMongo，更方便地在Python中操作MongoDB。
因为这里要用到的数据库知识其实非常简单，主要是数据如何入库、如何进行提取，在需要的时候再学习就行。
7.
分布式爬虫
，实现大规模并发采集
爬取基本数据已经不是问题了，你的瓶颈会集中到爬取海量数据的效率。这个时候，相信你会很自然地接触到一个很厉害的名字：分布式爬虫。
分布式这个东西，听起来非常吓人，但其实就是利用多线程的原理让多个爬虫同时工作，需要你掌握 Scrapy + MongoDB + Redis 这三种工具。
Scrapy 前面我们说过了，用于做基本的页面爬取，MongoDB 用于存储爬取的数据，Redis 则用来存储要爬取的网页队列，也就是任务队列。
所以不要被有些看起来很高深的东西吓到了。当你能够写分布式的爬虫的时候，那么你可以去尝试打造一些基本的爬虫架构了，实现一些更加自动化的数据获取。
你看，这一条学习路径下来，你已然可以成为老司机了，非常的顺畅。所以在一开始的时候，尽量不要系统地去啃一些东西，找一个实际的项目（开始可以从豆瓣、小猪这种简单的入手），直接开始就好。
因为爬虫这种技术，既不需要你系统地精通一门语言，也不需要多么高深的数据库技术，高效的姿势就是从实际的项目中去学习这些零散的知识点，你能保证每次学到的都是最需要的那部分。
当然唯一困难的是，刚开始没有经验的时候，在寻找资源、搜索解决问题的方法时总会遇到一些困难，因为往往在最开始，我们去描述清楚具体的问题都很难。如果有大神帮忙指出学习的路径和解答疑问，效率会高不少。
这里真诚地推荐我们的系统化爬虫课程：
Python爬虫：入门+进阶
。清晰高效的学习路径，老师实时答疑。
――――――――――
关注公众号（datacastle2016），获取更多数据分析干货。","如何入门Python爬虫？
每个人有不同的基础，每个人有不同的学习模式
，譬如A童鞋，计算机专业985本科，有过C语言ORJava编程经验，那么他学起来Python可能也就跟着一本书过一遍语法，然后10天半个月就能用的风生水起。譬如B童鞋，普通本科生，不爱看书，看了网上什么
廖雪峰
的Python教程也是晕头转向，但是他经过几轮视频下来，也了解了大概，开始自己动手玩Python了~
没有最好的，只有适合的，下面说说我的入门过程，希望能给一些人一些帮助：
普通本科非计算机专业毕业几年了，学Python之前没有过编程经验（大学C语言不算 ），学Python之前，看过《Head first HTML和CSS》其他都是0基础。
1.了解Python
刚开始是看知乎上别人写爬虫感觉好玩，看着看着发现才那么几行代码就可以实现酷炫的效果？！于是开始了解Python，看了不少相关的问题，包括Python对比其他语言优劣对比，Python可以用来做那些事？Python开发方向之类的问题。
2.Python爬虫入门
在大概了解了Python这么编程语言后，脑子里也有了一些感性的认识，然后我发现还是爬虫比较适合入门，而且比较感兴趣，于是开始了Python学习之路，这里都是我关注收藏过的话题：
你是如何自学 Python 的？
如何入门 Python 爬虫？
 
编程零基础应当如何开始学习 Python ？
 
关于 Python 的经典入门书籍有哪些？
 
Python 应该怎么去练习和使用？
 
有哪些值得推荐的Python学习网站？
 
Python 的练手项目有哪些值得推荐？
 
看完以后，能有个大概感性的认知，然后就需要行动了，看书？看视频？直接撸代码？都行！每个人的学习模式不同！我自己先看的是廖雪峰的Python教程，看前几章感觉还行都懂，但是感觉很枯燥乏味，看到后面就云里雾里了！其实，这很正常！因为和不少工具类的书一样，上面说的大都是一些Python语法和一些标准库的用法，如果没有编程经验，那么看上去可能就会很吃力或者说觉得无聊！那么这个时候我觉得看点视频跟着老师，有人讲解会好很多！我没有看过视频，这里就不好推荐了.....
但是，如果学爬虫，我墙裂推荐的两本书：
《Head First HTML与CSS（第2版）》
Head First HTML与CSS（第2版）
《Python网络数据采集》
Python网络数据采集 (豆瓣)
 
如果我没看过第一本书，那么我学爬虫可能就会很吃力，因为爬虫要做的事情就是采集页面上的数据，页面就是HTML，如果一点HTML和CSS基础都没有，get请求post请求也搞不明白，那么爬虫是学不好的~第二本书，比较详细且接近实战，让你怎么用beautifulsoup，怎么用requests发送get请求，当然一本书不可能一次性看懂，没关系，学习是个螺旋上升的曲折的过程，新手很容易从入门到放弃，可能就是由于一本书某些章节/某个教程没看懂或者一个环境变量没配置好！但是没关系，做任何事都是【
无它，唯手熟尔
】多配置配置就清楚了，遇到不懂的多百度/知乎，就能解决90%的问题，如果能google/
stackoverflow那更好
^_^.
一边看书，就可以动手写写简单的爬虫代码了，可以去github上找，可以在知乎找，可以自己动手，爬虫代码写多了，你会遇到数据存储问题，使用list还是set还是dictionary他们都怎么用？Python怎么进行IO操作？怎么读取文件写入文件？下载的图片怎么保存？....你这时你发现需要回过头去补Python语法了！这是你可以再去看《
Head first Python》、Python官方文档
、《Dive into Python3》、《Pythonn cookbook》或者廖雪峰的Python教程，这次去看就是有针对性的看了，不会一头雾水！
3.Python从入门到入门
Python入门到现在，写的最多的就是爬虫了，还有少量的数据分析，真的还只是在入门阶段，爬虫只是Python的一个小方向，Python可以做的事情很多~其他的编程语言同样很精彩！然而编程语言都是工具，最关键的是你知道自己要做的事情！
Just do it ！Just have fun！Follow your heart
！
以下是个人写的一些Python爬虫小代码，新人可以练练手，(不规范的代码风格不要学）！
Lyon：Python―itchat实现微信自动回复
Lyon：Python命令行实现―查全国7天天气
Lyon: python命令行查询12306火车票
 
Lyon: Python―一行代码情人节画爱心表白
 
Lyon: Python多线程threading―图片下载
 
Lyon：Python―10行代码查快递
 
Lyon：用Python发邮件
Lyon：Python爬虫入门―图片下载
Lyon：用Python实现―携程机票查询
Lyon：智联Python相关职位的数据分析及可视化-Pandas&Matplotlib篇
    
个人创建了Python、Java的专栏：
欢迎Python和Java爱好者、初学者关注，一起学习共同进步~
Python入门，推荐几本书和网站教程：
《深入浅出Python》（Head first Python）
Python官方文档
《Dive into Python3》
《Pythonn cookbook》
如果对数据分析感兴趣可以看《利用Python进行数据分析》
如果对爬虫感兴趣，可以看《Python网络数据采集》
菜鸟教程：
Python 基础教程 | 菜鸟教程
廖雪峰的Python教程：
Python教程
以下两个小项目，都比较适合练手。
第一个是命令行携程机票查询，模仿的是12306火车票查询器做的；
第二个是一个智联招聘的爬虫，包括后面数据处理、分析以及用matplotlib进行了可视化。
代码都有，欢迎拿去~
以前参考别人的代码，用Python做了一个12306命令行式的火车票查询工具，感觉还挺有意思的！于是自己又做了一个类似的――携程机票查询器。
携程官网查询的效果是这样的：
Python命令行界面查询的效果是这样的：
输入出发地、目的地、乘机日期，即可看到可选的航班、机场、出发到达时间、票价等信息。
视频演示效果如下：
视频资源加载失败
程序的源码如下：
1.air_stations.py
2.airline_ticket.py
#1.air_stations.py
import re
import os
import json
import requests
from pprint import pprint

url = 'http://webresource.c-ctrip.com/code/cquery/resource/address/flight/flight_new_poi_gb2312.js?CR_2017_07_18_00_00_00'
response = requests.get(url,verify=False)
station = re.findall(u'([\u4e00-\u9fa5]+)\(([A-Z]+)\)', response.text)
stations = dict(station)
pprint(stations,indent = 4)

2.airline_ticket.py
#此程序可用于查询携程机票，查询需要指定出发日期、出发城市、目的城市！（模仿了上一个12306火车订票查询程序）
import requests,json,os
from docopt import docopt
from prettytable import PrettyTable
from colorama import init,Fore
from air_stations import stations

fromCity = input(f""{'Please input the city you want leave :'}"")
toCity = input(f""{'Please input the city you will arrive :'}"")
tripDate = input(f""{'Please input the date(Example:2017-09-27) :'}"")

init()
class TrainsCollection:
    header = '航空公司 航班 机场 时间 机票价格 机场建设费'.split()
    def __init__(self,airline_tickets):
        self.airline_tickets = airline_tickets

    @property
    def plains(self):
        #航空公司的总表没有找到，但是常见航空公司也不是很多就暂时用这个dict{air_company}来收集！
        #如果strs没有查询成功，则会返回一个KeyError，表示此dict中未找到目标航空公司，则会用其英文代码显示！
        air_company = {""G5"":""华夏航空"",""9C"":""春秋航空"",""MU"":""东方航空"",""NS"":""河北航空"",""HU"":""海南航空"",""HO"":""吉祥航空"",""CZ"":""南方航空"",""FM"":""上海航空"",""ZH"":""深圳航空"",""MF"":""厦门航空"",""CA"":""中国国航"",""KN"":""中国联航""}
        for item in self.airline_tickets:
            try:
                strs = air_company[item['alc']]
            except KeyError:
                strs = item['alc']
            airline_data = [
            Fore.BLUE + strs + Fore.RESET,
            Fore.BLUE + item['fn'] + Fore.RESET,
            '\n'.join([Fore.YELLOW + item['dpbn'] + Fore.RESET,
                       Fore.CYAN + item['apbn'] + Fore.RESET]),
            '\n'.join([Fore.YELLOW + item['dt'] + Fore.RESET,
                       Fore.CYAN + item['at'] + Fore.RESET]),
            item['lp'],
            item['tax'],
            ]
            yield airline_data

    def pretty_print(self):
        #PrettyTable（）用于在屏幕上将查询到的航班信息表逐行打印到终端
        pt = PrettyTable()
        pt._set_field_names(self.header)
        for airline_data in self.plains:
            pt.add_row(airline_data)
        print(pt)

def doit():
    headers = {
        ""Cookie"":""__utma=1.648580680.1500052197.1500052197.1500052197.1; __utmz=1.1500052197.1.1.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; StartCity_Pkg=PkgStartCity=2; _abtest_userid=b2d8ec09-8300-49f5-8c56-e5955eaebf55; adscityen=Shanghai; DomesticUserHostCity=SHA|%c9%cf%ba%a3; appFloatCnt=3; manualclose=1; _gat=1; Union=SID=155952&AllianceID=4897&OUID=baidu81|index|||; Session=SmartLinkCode=U155952&SmartLinkKeyWord=&SmartLinkQuary=&SmartLinkHost=&SmartLinkLanguage=zh; _bfa=1.1500052197098.egn3q.1.1500391644124.1500450359041.3.22; _bfs=1.3; page_time=1500052199151%2C1500052201106%2C1500052253071%2C1500052266599%2C1500052737639%2C1500053169759%2C1500053269047%2C1500053304153%2C1500391645891%2C1500391646865%2C1500391653279%2C1500391706616%2C1500391781672%2C1500391867587%2C1500391895364%2C1500392129113%2C1500392312502%2C1500392677979%2C1500450360502%2C1500450527168%2C1500450552188; _RF1=112.64.216.79; _RSG=6Ba6XNJ5wCACiIoqsdEcXA; _RGUID=a33a1535-e11a-42c6-a866-3a7db4c92b0c; _ga=GA1.2.648580680.1500052197; _gid=GA1.2.1686685369.1500391650; traceExt=campaign=CHNbaidu81&adid=index; __zpspc=9.4.1500450554.1500450554.1%231%7Cbaidu%7Ccpc%7Cbaidu81%7C%25E6%2590%25BA%25E7%25A8%258B%7C%23; _jzqco=%7C%7C%7C%7C1500391649757%7C1.719992437.1500052197549.1500450529881.1500450554792.1500450529881.1500450554792.undefined.0.0.20.20; _bfi=p1%3D100101991%26p2%3D101027%26v1%3D22%26v2%3D21; MKT_Pagesource=PC;"",
        ""User-Agent"": ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36"",
        }
    arguments = {
    'from':fromCity,
    'to':toCity,
    'date':tripDate
    }
    DCity1 = stations[arguments['from']]
    ACity1 = stations[arguments['to']]
    DDate1 = arguments['date']
    url = (""http://flights.ctrip.com/domesticsearch/search/SearchFirstRouteFlights?DCity1={}&ACity1={}&SearchType=S&DDate1={}&IsNearAirportRecommond=0&LogToken=0dc7fd99662349069c123f0a8bfcae95&rk=7.387068566272421154925&CK=51BF6E070FF329F1DDD90CEF097B4B86&r=0.5811166470511521823610"").format(DCity1,ACity1,DDate1)
    try:
        r = requests.get(url,headers = headers,verify=False)
    except:
        print(""Some Error shows in requests.get(url)"")
        exit(0)
    print(url)
    airline_tickets = r.json()['fis']
    TrainsCollection(airline_tickets).pretty_print()

if __name__ == '__main__':
    doit()

其实，此小程序还可以拓展，譬如将查询记录存到本地电脑（txt格式、或者存到数据库里）或者更厉害的还可以设置定时自动查询；还可以设置查询到自动发邮箱提醒；还可以用Python的GUI库将此程序做成桌面软件的形式。。。。
2017-09-12,by―
阳光流淌
上一篇，我用了Excel对爬虫采集到的智联招聘数据进行了数据分析及可视化，用到软件是Excel， 这一篇，我们打算完全用Python来做同样的事。用到的库有Pandas、Matplotlib。np、pd、plt分别是numpy、pandas、matplotlib.pyplot的常用缩写。
Numpy（Numerical Python的简称）是Python科学计算的基础包。它提供了以下功能：
快速高效的多维数组对象ndarray。
用于对数组执行元素级计算以及直接对数组执行数学运算的函数。
用于读写硬盘上基于数组的数据集的工具。
线性代数运算、傅里叶变换，以及随机数生成。
用于将C、C++、Fortran代码集成到Python的工具。
除了为Python提供快速的数组处理能力，Numpy在数据分析方面还有另外一个主要作用，即作为在算法之间传递数据的容器。对于数值型数据，Numpy数组在存储和处理数据时要比内置的Python数据结构高效的多。此外，由低级语言（比如C和Fortran）编写的库可以直接操作Numpy数组中的数据，无需进行任何数据复制工作。
Pandas这个名字本身源于panel data（面板数据，这是计量经济学中关于多维结构化数据集的一个术语）以及Python data analysis。pandas提供了使我们能够快速便捷地处理结构化数据的大量数据结构和函数。Pandas中用的最多的是DataFrame，它是一个面向列的二维表结构，且含有行标和列标。pandas兼具numpy高性能的数组计算功能以及电子表格和关系型数据库(如SQL)灵活的数据处理功能。它提供了复杂精细的索引功能，以便更为便捷地完成重塑、切片和切块、聚合以及选取数据子集等操作。
Matplotlib是Python中常用的可视化绘图库，可以通过简单的几行代码生成直方图，功率谱，条形图，错误图，散点图等。Seaborn、ggplot、等诸多Python可视化库均是在此基础上开发的，所以学会matplotlib的基础操作还是很有必要的！它和Ipython结合的很好，提供了一种非常好用的交互式数据绘图环境。绘制的图表也是交互式的，你可以利用绘图窗口中的工具栏放大图表中的某个区域或对整个图表进行平移浏览。
数据来源：
Python爬虫爬取了智联招聘关键词：【Python】、全国30个主要城市的搜索结果，总职位条数：18326条(行)，其中包括【职位月薪】、【公司链接】、【工作地点】、 【岗位职责描述】等14个字段列，和一个索引列【ZL_Job_id】共计15列。数据存储在本地MySql服务器上，从服务器上导出json格式的文件，再用Python进行数据读取分析和可视化。
数据简单清洗：
1.首先在终端中打开输入ipython --pylab。在Ipython的shell界面里导入常用的包numpy、pandas、matplotlib.pyplot。用pandas的read_json（）方法读取json文件，并转化为用df命名的DataFrame格式文件。（DataFrame格式是Pandas中非常常用且重要的一种数据存储格式、类似于Mysql和Excel中的表。）
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
df = pd.read_json('/Users/zhaoluyang/Desktop/Python_全国JSON.json')
#查看df的信息
df.info()
df.columns

可以看到读取的df格式文件共有15列，18326行，pandas默认分配了索引值从0~18325。还有一点值得注意的：全部的15列都有18326个非空值，因为当初写爬虫代码时设置了， 如果是空值，譬如：有一条招聘信息其中【福利标签】空着没写，那么就用字符串代替，如“found no element”。
2.读取JSON文件时pandas默认分配了从0开始的索引，由于文件'ZL_Job_id'列中自带索引，故将其替换!替换后，用sort_index()给索引重新排列。
df.index = df['ZL_Job_id']#索引列用'ZL_Job_id'列替换。
del(df['ZL_Job_id'])#删除原文件中'ZL_Job_id'列。
df_sort = df.sort_index()#给索引列重新排序。
df = df_sort
df[['工作地点','职位月薪']].head(10)

3.下面，将进行【职位月薪】列的分列操作，新增三列【bottom】、【top】、【average】分别存放最低月薪、最高月薪和平均月薪。 其中try语句执行的是绝大多数情况：职位月薪格式如：8000-10000元/月，为此需要对【职位月薪】列用正则表达式逐个处理，并存放至三个新列中。 处理后bottom = 8000,top = 10000,average = 9000. 其中不同语句用于处理不同的情况，譬如【职位月薪】=‘面议’、‘found no element’等。对于字符形式的‘面议’、‘found no element’ 处理后保持原字符不变，即bottom = top = average = 职位月薪。
q1,q2,q3,q4用来统计各个语句执行次数.其中q1统计职位月薪形如‘6000-8000元/月’的次数；q2统计形如月收入‘10000元/月以下’；q3代表其他情况如‘found no element’,‘面议’的次数；q4统计失败的特殊情况。
import re
df['bottom'] = df['top'] = df['average'] = df['职位月薪']
pattern = re.compile('([0-9]+)')
q1=q2=q3=q4=0
for i in range(len(df['职位月薪'])):
    item = df['职位月薪'].iloc[i].strip()
    result = re.findall(pattern,item)
    try:
        if result:
            try:
            #此语句执行成功则表示result[0],result[1]都存在，即职位月薪形如‘6000-8000元/月’
                df['bottom'].iloc[i],df['top'].iloc[i] = result[0],result[1]
                df['average'].iloc[i] = str((int(result[0])+int(result[1]))/2)
                q1+=1
            except:
            #此语句执行成功则表示result[0]存在，result[1]不存在，职位月薪形如‘10000元/月以下’
                df['bottom'].iloc[i] = df['top'].iloc[i] = result[0]
                df['average'].iloc[i] = str((int(result[0])+int(result[0]))/2)
                q2+=1
        else:
        #此语句执行成功则表示【职位月薪】中并无数字形式存在，可能是‘面议’、‘found no element’
            df['bottom'].iloc[i] = df['top'].iloc[i] = df['average'].iloc[i] = item
            q3+=1
    except Exception as e:
        q4+=1
        print(q4,item,repr(e))
for i in range(100):#测试一下看看职位月薪和bottom、top是否对的上号
    print(df.iloc[i][['职位月薪','bottom','top','average']])#或者df[['职位月薪','bottom','top','average']].iloc[i]也可
df[['职位月薪','bottom','top','average']].head(10)

经过检查，可以发现【职位月薪】和新增的bottom、top、average列是能对的上。其中形如‘6000-8000元/月’的有16905条、形如‘10000元以下’的 有61条、'found no element'和'面议'加起来有1360条，总数18326条，可见是正确的。
4.进行【工作地点】列的处理，新增【工作城市】列，将工作地点中如‘苏州-姑苏区’、‘苏州-工业园区’等统统转化为‘苏州’存放在【工作城市】列。
df['工作城市'] = df['工作地点']
pattern2 = re.compile('(.*?)(\-)')
df_city = df['工作地点'].copy()
for i in range(len(df_city)):
    item = df_city.iloc[i].strip()
    result = re.search(pattern2,item)
    if result:
        print(result.group(1).strip())
        df_city.iloc[i] = result.group(1).strip()
    else:
        print(item.strip())
        df_city.iloc[i] = item.strip()
df['工作城市'] = df_city
df[['工作地点','工作城市']].head(20)

检查一下，没有错误，可以进行下一步的操作了！
数据分析和可视化
从可读性来看，应该是先进行数据清洗，然后进行分析及可视化，但是实际过程中，往往是交织在一起的， 所有下面让我们一步步来，完成所有的清洗、分析和可视化工作。除了具体的公司和职位名称以外，我们还比较关心几个关键词： 平均月薪、工作经验、工作城市、最低学历和岗位职责描述，这里岗位职责描述以后会用python分词做词云图，所以目前筛选出 【平均月薪】、【工作经验】、【工作城市】、【最低学历】这四个标签，这些标签可以两两组合产生各种数据。譬如我想知道各个城市的招聘数量分布情况， 会不会大部分的工作机会都集中在北上广深？是不是北上广深的平均工资也高于其他城市？我想知道Python这个关键词的18000多条招聘数据中 对学历的要求和对工作经验的要求，以及它们分别占比多少？我还想知道平均月薪和工作经验的关系？最低学历和平均月薪的关系？ 和上一篇（Execel篇）类似，不同的是，这次我们完全用Python实现同样的操作。
1.各个城市职位数量及分布
根据猜想，北上广深，一定占据了Python这个关键词下大部分的工作机会，会不会符合28定律？20%的城市占据了80%的岗位？ 有可能！我们先用df.工作城市.value_counts()看一下究竟有多少个城市，以及他们各自有多少条工作数据？
df.工作城市.value_counts()#等价于df['工作城市'].value_counts()
#再用count()来看一下统计出来的城市数量
df.工作城市.value_counts().count()
type(df.工作城市.value_counts())#用type()查看下类型。

可以看到，明明设置的是搜索30个城市，怎么变成了40？像延边、珲春、白山。。。。是什么鬼？想了一下，这些城市是搜索关键词城市‘吉林市’时，自动冒出来的；还有95个‘found no element’，是这些职位链接本身就没有填写工作城市，为了避免干扰，要把他们统统替换成空值。用df_工作城市 = df['工作城市'].replace（）
#将原来df['工作城市']列中选定的字段替换成空值nan
df_工作城市 = df['工作城市'].replace(['found no element','松原','辽源','珲春','白山','公主岭','白城','延边','四平','通化'],np.nan)
#查看替换后各个城市职位计数
df_工作城市.value_counts()
#查看替换后城市所包含的职位总数；查看替换后的城市数量，是否等于30.
df_工作城市
#将新的[df_工作城市]列添加到df表中，留作备用
df['df_工作城市'] = df_工作城市

看了一下，没有问题，现在df_工作城市中筛选出了30个城市，合计18211条职位数据。 为了数据完整性，df表保持原样，我们用df_工作城市直接操作，进行下一步的可视化。先直接上代码和图，再一一解释下。
fig1 = plt.figure(1,facecolor = 'black')#设置视图画布1
ax1 = fig1.add_subplot(2,1,1,facecolor='#4f4f4f',alpha=0.3)#在视图1中设置子图1,背景色灰色，透明度0.3(figure.add_subplot 和plt.suplot都行)
plt.tick_params(colors='white')#设置轴的颜色为白色
df_工作城市.value_counts().plot(kind='bar',rot=0,color='#ef9d9a')#画直方图图
#设置图标题，x和y轴标题
title = plt.title('城市――职位数分布图',fontsize=18,color='yellow')#设置标题
xlabel = plt.xlabel('城市',fontsize=14,color='yellow')#设置X轴轴标题
ylabel = plt.ylabel('职位数量',fontsize=14,color='yellow')#设置Y轴轴标题
#设置说明，位置在图的右上角
text1 = ax1.text(25,4500,'城市总数:30(个)',fontsize=12, color='cyan')#设置说明，位置在图的右上角
text2 = ax1.text(25,4000,'职位总数:18326(条)',fontsize=12, color='cyan')
text3 = ax1.text(25,3500,'有效职位:18211(条)',fontsize=12, color='red')
#添加每一个城市的坐标值

for i in range(len(list_1)):
    ax1.text(i-0.3,list_1[i],str(list_1[i]),color='yellow')
#可以用plt.grid(True)添加栅格线
#可以用下面语句添加注释箭头。指向上海，xy为坐标值、xytext为注释坐标值，facecolor为箭头颜色。
#arrow = plt.annotate('职位数:3107', xy=(1,3107), xytext=(3, 4000),color='blue',arrowprops=dict(facecolor='blue', shrink=0.05))
ax2 = fig1.add_subplot(2,1,2)#设置子图2，是位于子图1下面的饼状图
#为了方便，显示前8个城市的城市名称和比例、其余的不显示，用空字符列表替代，为此需要构造列表label_list和一个空字符列表['']*23。
x = df_工作城市.value_counts().values#x是数值列表，pie图的比例根据数值占整体的比例而划分
label_list = []#label_list是构造的列表，装的是前8个城市的名称+职位占比。
for i in range(8):
    t = df_工作城市.value_counts().values[i]/df_工作城市.value_counts().sum()*100
    city = df_工作城市.value_counts().index[i]
    percent = str('%.1f%%'%t)
    label_list.append(city+percent)
#labels参数原本是与数值对应的标签列表，此处30个城市过多，所以只取了前8个城市显示。
#explode即饼图中分裂的效果explode=（0.1，1，1，。。）表示第一块图片显示为分裂效果
labels = label_list + ['']*22
explode = tuple([0.1]+[0]*29)
plt.pie(x,explode=explode,labels=labels,textprops={'color':'yellow'})
#可加参数autopct='%1.1f%%'来显示饼图中每一块的比例，但是此处30个城市，如果全显示的话会非常拥挤不美观，所以只能手动通过labels参数来构造。
#若要显示标准圆形，可以添加：plt.axis('equal')

可以看见，这个曲线下降的弧度还是挺美的，北上深杭广5个城市占据了超过60%以上的职位数。其中北京当之无愧的占据了四分之一的Python工作数量，不愧为帝都。 上海以3107条职位排名第二，可见上海虽然经济超越北京，在互联网环境和工作机遇方面还需努力！深圳作为中国的科技中心，排名第三我是没疑问的，杭州竟然超过广州排名第四！不过也可以想到，阿里巴巴、百草味等等电商产业带动了整个杭州的互联网文化！
【北上深杭广】+成都、南京、郑州，这8个城市占据了全国30座城市中，近80%的工作机会！剩下的22个城市合起来只占据了20%，果然，是基本符合28定律的。。。
2.工作经验-职位数量及分布
Python虽然是一名比较老的语言，但是在人们的印象中火起来也就最近几年，Python相关的工作对于【工作经验】是怎样要求的呢？让我们来看看！
df.工作经验.value_counts()#统计【工作经验】下各个字段的累计和

可以看见出现了一些很数字少量的字段譬如“5年以上”，“2年以上”，“1-2年”，“1年以上”等，这些标签下职位的数量都在10以内，不太具备统计意义，所以我们作图的时候不想让他们出现，必须筛选掉。 下面我们还是通过同样的步骤来清除掉此类数据。
= df['工作经验'].replace(['found no element','3年以上','1年以上','5年以上','2年以上','1-2年'],np.nan)
df_工作经验.value_counts()
df_工作经验.value_counts().sum()

现在，可以进行下一步可视化了，还是做2张图：直方图和饼图。通过这两张图可以直观地看到这么多职位中对不同工作经验的要求占比，好做到心里有数！
fig2 = plt.figure(2,facecolor = 'black')
ax2_1 = fig2.add_subplot(2,1,1,facecolor='#4f4f4f',alpha=0.3)
plt.tick_params(colors='white')
df_工作经验.value_counts().plot(kind = 'bar',rot = 0,color='#7fc8ff')
title = plt.title('工作经验――职位数分布图',fontsize = 18,color = 'yellow')
xlabel = plt.xlabel('工作经验',fontsize = 14,color = 'yellow')
ylabel = plt.ylabel('职位数量',fontsize = 14,color = 'yellow')
plt.grid(True)
text1_ = ax2_1.text(5,5600,'城市总数:30(个)',fontsize=12, color='yellow')
text2 = ax2_1.text(5,4850,'职位总数:18326(条)',fontsize=12, color='yellow')
text3 = ax2_1.text(5,4100,'有效职位:18215(条)',fontsize=12, color='cyan')

#设置子图2，是位于子图1下面的饼状图
ax2_2 = fig2.add_subplot(2,1,2)
#x是数值列表，pie图的比例根据数值占整体的比例而划分
x2 = df_工作经验.value_counts().values
labels = list(df_工作经验.value_counts().index[:5])+ ['']*2
explode = tuple([0.1,0.1,0.1,0.1,0.1,0.1,0.1])
plt.
pie
(x2,explode=explode,labels=labels,autopct='%1.1f%%',textprops={'color':'yellow'})
plt.axis('equal')#显示为等比例圆形
#设置图例，方位为右下角
legend = ax2_2.legend(loc='lower right',shadow=True,fontsize=12,edgecolor='cyan')

总共得到18215条职位。从直方图里可以明显看出工作机会集中在'不限'、'1-3年'、'3-5年', 其中工作经验要求3年以下的（【无经验】+【不限】+【1年以下】+【1-3年】）合计11501条职位，占比超过63%，看来即使是初入门者，大家的机会也还是有不少的！ (PS:最后,在df表中添加一列'df_工作经验'，以后筛选时就可以直接用了，df['df_工作经验']=df_工作经验)
3.工作经验-平均月薪
这个嘛，大家闭着眼都能想到！肯定是工作经验越久的拿钱越多了！再猜猜？无经验的和5-10年经验的收入差距有多大？这个，嘿嘿就不好猜了，让我们来看看吧！
1.第一步，要想统计工作经验和平均月薪的关系，那么我们先看看df中对应的列df.工作经验和df.average。之前我们构造了一列df_工作经验，把df.工作经验中几个样本容量小于10的值和‘found no element’全筛选掉了，故df_工作经验还能继续使用。现在，让我们看看df.average的信息。
df.average.value_counts()

可以看到，其中有1265个值是‘面议’，有95个值是‘found no element’,这些值需要替换成空值，不然会影响下一步工资的计算。
df_平均月薪 = df['average'].replace(['面议','found no element'],np.nan)

2.好了，第一步的简单数据清洗完成了，我们可以思考下一步了，现在我们想要得到的是不同工作经验字段下的平均月薪
A. 首先我需要把df_工作经验和df_平均月薪这两列元素放在一起，构造一个DataFrame用于存放df_工作经验和df_平均月薪这两列元素,且方便进一步的groupby操作。
B. 其次我需要把df_平均月薪列根据df_工作经验进行分组(用groupby),分组后我可以求得df_工作经验下各个字段的月薪的计数、最大值最小值、累加和、平均值等一系列数据。
C. 当然此处我只需要平均值。对分组后的grouped用mean()方法，就可以轻松统计分组内各项的平均值了。
df3=pd.DataFrame(data={'工作经验':df['df_工作经验'],'平均月薪':df_平均月薪})
df3.info()
grouped3 = df3['平均月薪'].groupby(df3['工作经验'])
grouped3.mean()

在进行grouped3.mean()时，我们发现报错了：DataError: No numeric types to aggregate，看一下，原来df_平均月薪列里的值都是字符型str，并不是数值型的float，因为前面的步骤没有做好，留下了这个bug，无奈我们需要对值类型做个转换。
#构造一个listi存放转化后float型的‘平均月薪’
import re
pattern = re.compile('([0-9]+)')
listi = []
for i in range(len(df.average)):
    item = df.average.iloc[i].strip()
    result = re.findall(pattern,item)
    try:
        if result:
            listi.append(float(result[0]))
        elif (item.strip()=='found no element' or item.strip()=='面议'):
            listi.append(np.nan)
        else:
            print(item)
    except Exception as e:
        print(item,type(item),repr(e))
#将df3.平均月薪列替换掉,同时给df新增一列'df_平均月薪'做备用。
df3['平均月薪'] = listi
df['df_平均月薪'] = df3['平均月薪']

#看看更新后的数据是否正确
df3['平均月薪'].value_counts()#统计每个月薪字段的个数
df3['平均月薪'][:10]#查看前10个值
type(df3['平均月薪'][1])#看看现在月薪的类型是不是浮点型
df3['平均月薪'].value_counts().sum()#看看月薪样本总数
df3['平均月薪'].mean()#看看这16966个月薪样本的平均值是多少？

可以看到，替换后的df3['平均月薪']值从str变为了可以计算的float，月薪样本总数16966个，样本的平均月薪14197元。好，现在终于OK了,让我们再回到之前的步骤：
grouped3 = df3['平均月薪'].groupby(df3['工作经验'])
grouped3.mean()

好了，完美，格式对了，数据有了，现在可以来画图了！但是再看看，还不是那么完美，数据大小排列很乱，而且小数点那么多。。。好吧，让我们再简单处理下
#新增一个平均值，即所有非空df3['平均月薪']的平均值
s3 = pd.Series(data = {'平均值':df3['平均月薪'].mean()})
result3 = grouped3.mean().append(s3)
#sort_values()方法可以对值进行排序，默认按照升序，round（1）表示小数点后保留1位小数。
result3.sort_values(ascending=False).round(1)

3.数据可视化
这次我们画一个躺倒的柱状图(barh)，用ggplot的风格来画。
matplotlib.style.use('ggplot')
fig3 = plt.figure(3,facecolor = 'black')
ax3 = fig3.add_subplot(1,1,1,facecolor='#4f4f4f',alpha=0.3)
result3.sort_values(ascending=False).round(1).plot(kind='barh',rot=0)
#设置标题、x轴、y轴的标签文本
title = plt.title('工作经验――平均月薪分布图',fontsize = 18,color = 'yellow')
xlabel= plt.xlabel('平均月薪',fontsize = 14,color = 'yellow')
ylabel = plt.ylabel('工作经验',fontsize = 14,color = 'yellow')
#添加值标签
list3 = result3.sort_values(ascending=False).values
for i in range(len(list3)):
    ax3.text(list3[i],i,str(int(list3[i])),color='yellow')
#设置标识箭头
arrow = plt.annotate('Python平均月薪:14197元/月', xy=(14197,3.25), xytext=(20000,4.05),color='yellow',fontsize=16,arrowprops=dict(facecolor='cyan', shrink=0.05))
#设置图例注释（16966来源：df2['平均月薪'].value_counts().sum()）
text= ax3.text(27500,6.05,'月薪样本数:16966(个)',fontsize=16, color='cyan')
#设置轴刻度文字颜色为白色
plt.tick_params(colors='white')

通过图表，我们可以直观地看到，Python关键词下的职位月薪是随着工作经验增长而递增的（这不是说了一句废话么？！澹 其中【无经验】的平均月薪最低，只有5842，相比之下【10年以上】经验的，平均月薪达到了恐怖的34890，约达到了【无经验】月薪的6倍之多！！！ 【1年以下】的平均月薪7579，还勉强凑合，【1-3年】的已经破万了，达到了近12000元/月的水准。最后让我们看看平均值吧，由于‘被平均’的缘故，16966条月薪样本的均值是14197元，有没有让你满意呢？
4.工作城市-平均月薪
对了，刚才说到北上广深占据了全国大部分的工作机会，那么北上广深的平均月薪如何呢？会不会也碾压小城市？让我们来看看！ 和之前的套路一样，我们还是要构造一个DataFrame，包含两列，一列是【平均月薪】，一列是【工作城市】，然后对df4进行groupby操作，还是很简单的！不过，经过上次的教训，平均月薪一定要是数值型的，str型的计算不了。
#此处df['df_工作城市']是之前经过筛选后的30个城市数据
df4=pd.DataFrame(data={'工作城市':df['df_工作城市'],'平均月薪':df['df_平均月薪']})
df4.info()
grouped4 = df4['平均月薪'].groupby(df4['工作城市'])
grouped4.mean()#查看对30个城市分组后，各个城市月薪的平均值
grouped4.count().sum()#查看对30个城市分组后筛选出的平均月薪样本数

#新增一个平均值，即所有非空df2['平均月薪']的平均值
s4 = pd.Series(data = {'平均值':df['df_平均月薪'].mean()})
result4 = grouped4.mean().append(s4)
#sort_values()方法可以对值进行排序，默认按照升序，round（1）表示小数点后保留1位小数。
result4.sort_values(ascending=False).round(1)

数据构造好了，进行下一步，可视化。
#可以通过style.available查看可用的绘图风格，总有一款适合你
matplotlib.style.use('dark_background')
fig4 = plt.figure(4)
ax4 = fig4.add_subplot(1,1,1)#可选facecolor='#4f4f4f',alpha=0.3，设置子图,背景色灰色，透明度0.3
result4.sort_values(ascending=False).round(1).plot(kind='bar',rot=30)#可选color='#ef9d9a'
#设置图标题，x和y轴标题
title = plt.title(u'城市――平均月薪分布图',fontsize=18,color='yellow')#设置标题
xlabel = plt.xlabel(u'城市',fontsize=14,color='yellow')#设置X轴轴标题
ylabel = plt.ylabel(u'平均月薪',fontsize=14,color='yellow')#设置Y轴轴标题
#设置说明，位置在图的右上角
text1 = ax4.text(25,16250,u'城市总数:30(个)',fontsize=12, color='#FF00FF')#设置说明，位置在图的右上角
text2 = ax4.text(25,15100,u'月薪样本数:16946(条)',fontsize=12, color='#FF00FF')
#添加每一个城市的坐标值
list_4 = result4.sort_values(ascending=False).values
for i in range(len(list_4)):
    ax4.text(i-0.5,list_4[i],int(list_4[i]),color='yellow')
#设置箭头注释
arrow = plt.annotate(u'全国月薪平均值:14197元/月', xy=(4.5,14197), xytext=(7,15000),color='#9B30FF',fontsize=14,arrowprops=dict(facecolor='#FF00FF', shrink=0.05))
#设置轴刻度文字颜色为粉色
plt.tick_params(colors='pink')

可以看见，Python这个关键词下，全国16946条样本的月薪平均值为14197元/月，平均月薪排名前5的城市分别是：北京、上海、深圳、杭州、广州。哎，记得之前城市―职位数分布图么？全国30个城市中，职位数排名前5 的也是这5座城市！看来北上广深杭不仅集中了全国大部分的职位数量、连平均工资也是领跑全国的！不禁让人觉得越大越强！但是在超级大城市奋斗，买房总是遥遥无期，房子在中国人的概念里，有着特殊的情节，意味着家，老小妻儿生活的地方，给人一种安全感！我们可以看到还有不少城市的平均月薪也破万了，在这些相对小点的城市中挑一个，工作安家，买房还是有希望的，哈哈！譬如南京、武汉、苏州、大连、厦门都挺好的！
5.学历-职位数量
直觉来看Python这类工作职位，应该是本科及以上经验要求居多吧？那么工作经验【不限】和【大专】的机会占比多少呢？让我们来看看！ 首先，还是用df['最低学历'].value_counts()来看一下有哪些字段，以及各个字段的统计值。
df['最低学历'].value_counts()
df_最低学历=df['最低学历'].replace(['中技','其他','高中','found no element'],np.nan)
df_最低学历.value_counts()
df_最低学历.value_counts().sum()
df['df_最低学历'] = df_最低学历 #留作备用

可以看到对于学历要求，最多的集中在大专、本科、硕士、不限还有较少量的博士和中专学历，至于中技、其他、高中则连10个都不到， 对于这些10个都不到的字段，我们还是照旧用replace语句将其排除（并没有歧视低学历的意思啊澹。
可以看到排除后还剩余6个字段，共计18119个职位，下一步，还是来经典的条形分布图和饼图！
fig5 = plt.figure(5)
ax5_1 = fig5.add_subplot(2,1,1) #可选facecolor='#4f4f4f',alpha=0.3
df_最低学历.value_counts().plot(kind = 'bar',rot=0)   #color='#7fc8ff'
#设置标题、x轴和y轴标题、图例文字
title = plt.title(u'最低学历――职位数分布图',fontsize = 18,color = 'yellow')
xlabel = plt.xlabel(u'最低学历',fontsize = 14,color = 'yellow')
ylabel = plt.ylabel(u'职位数量',fontsize = 14,color = 'yellow')
text1 = ax5_1.text(4.4,8200,u'职位总数:18119(条)',fontsize=14, color='#B452CD')
#设置坐标轴的的颜色和文字大小
plt.tick_params(colors='#9F79EE',labelsize=13)
#设置坐标值文字
list5 = df_最低学历.value_counts().values
for i in range(len(list5)):
    ax5_1.text(i-0.1,list5[i],int(list5[i]),color='yellow')
ax5_2=fig5.add_subplot(2,1,2)
xl = df_最低学历.value_counts().values
labels = list(df_最低学历.value_counts().index)
explode = tuple([0.1,0,0,0,0,0])
plt.pie(xl,explode=explode,labels=labels,autopct='%1.1f%%',textprops={'color':'#B452CD'})
plt.axis('equal')
legend = ax5_2.legend(loc='lower right',shadow=True,fontsize=12,edgecolor='#B452CD')
plt.tick_params(colors='#9F79EE',labelsize=13)

可见【本科】独占鳌头，占据了超过50%的市场！【不限】和【大专】也合计占比38%不容小觑！看起来，只要技术过硬，学历从来都不是问题！！！作为对比【硕士】占比6%，【博士】更是少到只有1%，果然稀缺到百里挑一！
6.最低学历-平均月薪
按道理学历越高，平均月薪越高，类似工作经验一样都是正相关，到底是不是呢？来看一下！构造一个DataFrame(df6), 包含两列最低学历和平均月薪，我们直接用之前构造好的df中的【df_最低学历】和【df_平均月薪】即可，然后还是熟悉的groupby(df_最低学历)
df6=pd.DataFrame(data={'最低学历':df['df_最低学历'],'平均月薪':df['df_平均月薪']})
df6.info()
grouped6 = df6['平均月薪'].groupby(df6['最低学历'])
#查看grouped6的信息
grouped6.mean()
grouped6.count()
grouped6.count().sum()
matplotlib.style.use('ggplot')
fig6 = plt.figure(6,facecolor = 'black')
ax6 = fig6.add_subplot(1,1,1,facecolor='#4f4f4f',alpha=0.3)
grouped6.mean().round(1).sort_values().plot(color = 'cyan')#在条形图上叠加一个折线图
grouped6.mean().round(1).sort_values().plot(kind='bar',rot=0)
#设置标题、x轴、y轴的标签文本
title = plt.title(u'最低学历――平均月薪分布图',fontsize = 18,color = 'yellow')
xlabel= plt.xlabel(u'最低学历',fontsize = 14,color = 'yellow')
ylabel = plt.ylabel(u'平均月薪',fontsize = 14,color = 'yellow')
#添加值标签(坐标值文字)
list6 = grouped6.mean().round(1).sort_values().values
for i in range(len(list6)):
    ax6.text(i-0.1,list6[i],int(list6[i]),color='yellow')
#设置图例注释
text= ax6.text(0,27000,u'月薪样本数:16956(个)',fontsize=16, color='cyan')
#设置轴刻度的文字颜色
plt.tick_params(colors='#9F79EE')

平均月薪14139元，可以看到学历越高果然工资越高，博士级别的更是碾压，达到了29562元。只要学历在【大专】以上，那么平均月薪都已经过万了。 BUT，重点来了，学历并不是万能的，一个【中专】学历，有超过5年经验的，工资一定超过【本科】毕业无工作经验的。所以大家看看就好，不要当真，哈哈！
7.最低学历-工作经验-平均月薪
看了前面的图表，大家都知道了，学历越高平均月薪越高，工作经验越高平均月薪越高，但是我想要看看更细粒度的情形呢？ 譬如我想知道【大学+无经验】和【大学+1-3年】工资的差别，我想看看【大专+3-5年】和【硕士+无经验】工资的对比究竟谁高？ 现在，我不知道，但是接下来让我们把这些情况用图表呈现出来，大家就会一目了然！
df7 = pd.DataFrame(data = {'平均月薪':df['df_平均月薪'],'最低学历':df['df_最低学历'],'工作经验':df['df_工作经验']})
df7.info()
grouped7 = df7['平均月薪'].groupby([df7['最低学历'],df7['工作经验']])
#查看grouped7的信息
grouped7.mean().round(1)
grouped7.count()
grouped7.count().sum()

其实我们输入type(grouped7.mean())，会发现它是一个包含了层次化索引的Series结构。其中第一层索引是【最低学历】 第二层索引是【工作经验】，数值列【平均月薪】被这两层索引所分配！下面我们开始准备可视化，还是画一个bar柱状图，不过这次画的是多列一起呈现的形式，Y轴表示职位月薪、X轴表示最低学历，在每个学历字段下，又分别添加不同工作经验的列！
grouped7.mean().round(1)[:,'1-3年']
grouped7.mean().round(1)[:,'1-3年'].sort_values()
xlist = list(grouped7.mean().round(1)[:,'1-3年'].sort_values().index)
grouped7.mean().round(1)[:,'1-3年'].reindex(xlist)
print(xlist)

grouped7.mean()将会显示各组的平均值，round（1）表示小数点保留1位。[:,'1-3年']是对层次化索引的一种操作，表示选取 grouped7.mean()中索引名字为'工作经验'下'1-3年字段'的所有值。此处构造了列表xlist，值是筛选后的'最低学历'索引， xlist将用于画条形图时X轴坐标的标签文本（表示最低学历），Y轴相对应的是平均月薪。工作经验则用条形图和图例展示。
#开始画图，设置基本参数
matplotlib.style.use('dark_background')
fig7 = plt.figure(7,facecolor = 'black')
ax7 = fig7.add_subplot(1,1,1,facecolor='#4f4f4f',alpha=0.3)
title = plt.title(u'最低学历-工作经验-平均月薪分布图',fontsize = 18,color = 'yellow')
xlabel = plt.xlabel(u'最低学历',fontsize = 14,color = 'yellow')
ylabel = plt.ylabel(u'平均月薪',fontsize = 14,color = 'yellow')
plt.tick_params(colors='cyan')

#ylist1~7分别是7种条形图的Y值列表
ylist1 = grouped7.mean().round(1)[:,'无经验'].reindex(xlist).values
ylist2 = grouped7.mean().round(1)[:,'1年以下'].reindex(xlist).values
ylist3 = grouped7.mean().round(1)[:,'不限'].reindex(xlist).values
ylist4 = grouped7.mean().round(1)[:,'1-3年'].reindex(xlist).values
ylist5 = grouped7.mean().round(1)[:,'3-5年'].reindex(xlist).values
ylist6 = grouped7.mean().round(1)[:,'5-10年'].reindex(xlist).values
ylist7 = grouped7.mean().round(1)[:,'10年以上'].reindex(xlist).values

#img1~img7分别表示7种条形图
ind = np.arange(6)#ind为x轴宽度，用numpy的array形式表示
width = 0.1#条形图的宽度，要合理设置否则太宽会摆不下
img1 = ax7.bar(ind,ylist1,width)
img2 = ax7.bar(ind+width,ylist2,width)
img3 = ax7.bar(ind+width*2,ylist3,width)
img4 = ax7.bar(ind+width*3,ylist4,width)
img5 = ax7.bar(ind+width*4,ylist5,width)
img6 = ax7.bar(ind+width*5,ylist6,width)
img7 = ax7.bar(ind+width*6,ylist7,width)

#设置X轴文本和位置调整
ax7.set_xticklabels(xlist)
ax7.set_xticks(ind + width / 2)
#设置文字说明
text1 = ax7.text(4.05,52100,u'数据来源:智联招聘',fontsize=13, color='#9F79EE')
text2 = ax7.text(4.05,50200,u'职位关键词：Python',fontsize=13, color='#9F79EE')
text3 = ax7.text(4.05,48200,u'工作城市:全国30座城市',fontsize=13, color='#9F79EE')
text4 = ax7.text(4.05,46200,u'职位数量:共计16956(条)',fontsize=13, color='#9F79EE')
#设置图例
ax7.legend((img1[0],img2[0],img3[0],img4[0],img5[0],img6[0],img7[0]), (u'无经验',u'1年以下',u'不限',u'1-3年',u'3-5年',u'5-10年',u'10年以上'),fontsize=13,facecolor='black')
#设置栅格
plt.grid(True)

最后，上一张简单词云图给大家看看，用的BDP傻瓜式制作，看看就好！
其实展开了还可以分析的东西有不少，譬如Pandas、Matplotlib的用法，譬如更多维度的分析和两两组合！ 好了，整体的先暂时分析到这，总结一下呢就是：Python+工作经验+学历+大城市 = 高薪！但是，工作经验、学历和城市其实并没那么重要， 关键要看自己的Python用的6不6，关键在于你知道自己想做什么，知道自己能做什么，知道自己做出了什么！哈哈，当你知道越来越接近这些问题的答案呢，那么我相信，薪水对你来说已经不那么重要了!（当然，高薪是必须有的！） 人生苦短，我用Python！","全文大篇干货。从零手把手教你写第一个爬虫。
首先我在初学的时候把高票答案都看了一遍，然后我说一下我的感受。
网页的源码经常会改变的！网页的源码经常会改变的！网页的源码经常会改变的！重要的事情说三遍。所以你看到的那些14年甚至15年的东西很多都是不能用的。这个不知道误导了多少的新手，我在某些14年的文章下面的评论还看到16年有人在评论说怎么怎么用不了，原因就是网站的源码改了呗。
入门爬虫其实很快，可能一个下午就够了，但是要精通非常困难。如果你有兴趣的话看完我这一篇文章，便能自己写一个爬虫了。
接下来是教程。很蛋疼的是知乎不支持markdown所以很多的东西都不能用程序源码的形式只能用普通文本的形式，大家将就一下。
       先给大家介绍一下爬虫，爬虫呢很形象，就是说你写的程序就是一个小虫子，在网页上爬啊爬，然后把自己需要的东西保存下来了。 
       需要工具：
python2
，因为是入门，所以这次用到的两个包都是python自带的
import urllib2
import re
       简单介绍一下两个包，urllib2是用来解析网站的url的，re是一个
正则表达式
模块，在这个里面我用它来当比较。
       首先我们要定义一个类，插一下话，大家最好都用你需要这个类或者变量做什么的英语来命名，这样维护这个代码，或者让别人来读你的代码的时候都方便很多。定义一个类你可以随便叫他什么，在这里我给他起个名字叫spiderMode，蜘蛛模块。他有四个属性，页，页面，能否访问，以及一个处理类，等会儿会讲到的。因为这次我们只要爬一个网页，所以页和页面其实也都可以不要，而且保证url是有效的，enable也可有可无。
class spiderMode:
       def __init__(self):
             self.page = 1

             self.pages = []
             self.enable = False
             self.sub = Sub()
接下来就是来定义我们最重要的函数啦，用函数来抓取页面。我们用最最最最简单的
糗事百科
来作为例子。那么url就定义如下
sUrl = ""
http://www.
qiushibaike.com/
""
接下来是一个我们可以说是伪装，为什么呢因为你用python去访问人家的网站人家会不开心不让你访问，所以你就要披上一层皮，这层皮我们叫headers，定义如下
userAgent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'
headers = { 'User-Agent': userAgent}
好啦，这时候我们就可以去请求访问啦，首先要request一下，这个函数的作用就是request这个url，也就是我们定义的sUrl，headers是我们的伪装。
request = urllib2.Request(sUrl, headers=headers)
之后我们就可以打开这个链接
response = urllib2.urlopen(request)
用一个变量来读这个网页这时候你可以用print来读出一下，这时候出来的就是网页的源码。
sPage = response.read()
光有源码没有用，我们需要将它转变为能够处理的格式，因为本来是utf－8的编码，因此要经过一步转码，现在unicodePage里的东西就是我们需要的网页的所有源码啦
unicodePage = sPage.decode(""utf-8"")
这时候我们就需要找到所有的我们需要的信息，我们要来分析一下网页的源码，发现所有的笑话都是这么样的格式的
<div class=""content"">
女领导把我叫到办公室，目光在我身上扫射了一遍道：“听说你还没女朋友啊，要不要给你介绍个？”<br/>听得我有点莫名其妙，一向身为工作狂她，啥时候开始八卦起来了？但内心略有一丝欢喜，慌忙的点了点头，只见其接着道：“我刚离婚，考虑下不？”……
</div>
好了我们就能写出我们的re表达式，这一句的意思是在unicodePage中找到所有的夹在那两个东西之间的信息。（.*?）表示的是任意循环一次的信息。？是表示循环一次，如果你不加？的话就会直接定位第一个<div>和最后一个</div>了，这不是我们想看到的。
myItems = re.findall('<div class=""content"">(.*?)</div>',unicodePage,re.S)
其实这时候就做的差不多的，这时候我们就可以直接输出了。但是看一下刚才的源码中有几个</br>，这是什么呢？其实是换行符，所以我们要定义一个类来去掉换行符，并且加入我们输出的时候用刀的换行符""\n""。用以下代码实现。
class Sub:
    replaceBr = re.compile('<br/>')
    def replace(self,x):
        x = re.sub(self.replaceBr,""\n"",x)

        return x.strip()
这也是我们刚才提到的sub类，可以用来整理格式。最后就是输出啦，顺便再编一个号。
num=1
        for item in myItems:

            print str(num) +'. ' + self.sub.replace(item) +'\n'
      
            num += 1
整个程序就是这么的简单，下面我贴一下完整的源码方便大家看一下。
一个爬虫就这么做好了。当然这个是最最简单的，之后怎么进阶就需要大家去思考啦。
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝我是广告＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
买了mac却不知道怎么用？关注我的
读读日报
吧，每天都有高质量的回答与文章推送，让你高效而又优雅的使用mac，如果大家有推荐与意见也欢迎私信我。
谢谢大家","排名第一的知友 
@谢科
 已经总结了一条清晰的爬虫入门到实践的路线，对于有编程基础的同学来说，无疑是指点迷津，脉络很清晰，基本上按照这个路线来，设计一个大规模的爬虫系统不成问题，但是对于初学者来说，实现起来很困难。因为爬虫是一个综合性非常强的主题，从Web服务器、HTTP协议、HTML知识、数据库知识、网络安全、图像处理、甚至是数据科学。因此作为萌新小白，有必要把通用的基础了解才好动手去实现，否则遇到的一个情况就是丈二的和尚摸不着头脑。
前几天刚好整理了一份爬虫的知识梳理，大家可以对照者找相应的书籍或者视频进行系统的学习，学习任何东西都是开头难、中间易、精通难。先想法子入了门再谈实践。
学任何一门技术，都应该带着目标去学习，目标就像一座灯塔，指引你前进，很多人学着学着就学放弃了，很大部分原因是没有明确目标，所以，在你准备学爬虫前，先问问自己为什么要学习爬虫。有些人是为了一份工作，有些人是为了好玩，也有些人是为了实现某个黑科技功能。不过 肯定的是，学会了爬虫，能给你的工作提供很多便利。
作为零基础小白，大体上可分为三个阶段去实现，第一阶段是入门，掌握必备基础知识，比如Python基础、网络请求的基本原理等，第二阶段是模仿，跟着别人的爬虫代码学，弄懂每一行代码，熟悉主流的爬虫工具，第三阶段是自己动手，到了这个阶段你开始有自己的解题思路了，可以独立设计爬虫系统。
爬虫涉及的技术包括但不限于熟练一门编程语言（这里以 Python 为例） HTML 知识、HTTP 协议的基本知识、正则表达式、数据库知识，常用抓包工具的使用、爬虫框架的使用、涉及到大规模爬虫，还需要了解分布式的概念、
消息队列
、常用的数据结构和算法、缓存，甚至还包括机器学习的应用，大规模的系统背后都是靠很多技术来支撑的。数据分析、挖掘、甚至是机器学习都离不开数据，而数据很多时候需要通过爬虫来获取，因此，作为一门专业爬虫工程师都是有很大的前途的。
那么是不是一定要把上面的知识全学完了才可以开始写爬虫吗？当然不是，学习是一辈子的事，只要你会写 Python 代码了，就直接上手爬虫，好比学车，只要能开动了就上路吧，写代码可比开车安全多了。
用 Python 写爬虫，首先需要会 Python，把基础语法搞懂，知道怎么使用函数、类、list、dict 中的常用方法就算基本入门。接着你需要了解 HTML，HTML 就是一个文档树结构，网上有个 HTML 30分钟入门教程 
https://
deerchao.net/tutorials/
html/html.htm
 够用了。然后是关于 HTTP 的知识，爬虫基本原理就是通过网络请求从远程服务器下载数据的过程，而这个网络请求背后的技术就是基于 HTTP 协议。作为入门爬虫来说，你需要了解 HTTP协议的基本原理，虽然 HTTP 规范用一本书都写不完，但深入的内容可以放以后慢慢去看，理论与实践相结合。
网络请求框架都是对 HTTP 协议的实现，比如著名的网络请求库 Requests 就是一个模拟浏览器发送 HTTP 请求的网络库。了解 HTTP 协议之后，你就可以专门有针对性的学习和网络相关的模块了，比如 Python 自带有 urllib、urllib2（Python3中的urllib），httplib，Cookie等内容，当然你可以直接跳过这些，直接学习 Requests 怎么用，前提是你熟悉了 HTTP协议的基本内容，数据爬下来，大部分情况是 HTML 文本，也有少数是基于 XML 格式或者 Json 格式的数据，要想正确处理这些数据，你要熟悉每种数据类型的解决方案，比如 JSON 数据可以直接使用 Python自带的模块 json，对于 HTML 数据，可以使用 BeautifulSoup、lxml 等库去处理，对于 xml 数据，除了可以使用 untangle、xmltodict 等第三方库。
爬虫工具里面，学会使用 Chrome 或者 FireFox 浏览器去审查元素，跟踪请求信息等等，现在大部分网站有配有APP和手机浏览器访问的地址，优先使用这些接口，相对更容易。还有 Fiddler 等代理工具的使用。
入门爬虫，学习正则表达式并不是必须的，你可以在你真正需要的时候再去学，比如你把数据爬取回来后，需要对数据进行清洗，当你发现使用常规的字符串操作方法根本没法处理时，这时你可以尝试了解一下正则表达式，往往它能起到事半功倍的效果。Python 的 re 模块可用来处理正则表达式。这里也推荐一个教程：Python正则表达式指南 
https://www.
cnblogs.com/huxi/archiv
e/2010/07/04/1771073.html
数据清洗完最终要进行持久化存储，你可以用文件存储，比如CSV文件，也可以用数据库存储，简单的用 sqlite，专业点用 MySQL，或者是分布式的文档数据库 MongoDB，这些数据库对Python都非常友好，有现成的库支持，你要做的就是熟悉这些 API 怎么使用。
从数据的抓取到清洗再到存储的基本流程都走完了，也算是基本入门了，接下来就是考验内功的时候了，很多网站都设有反爬虫策略，他们想方设法阻止你用非正常手段获取数据，比如会有各种奇奇怪怪的验证码限制你的请求操作、对请求速度做限制，对IP做限制、甚至对数据进行加密操作，总之，就是为了提高获取数据的成本。这时你需要掌握的知识就要更多了，你需要深入理解 HTTP 协议，你需要理解常见的加解密算法，你要理解 HTTP 中的 cookie，HTTP 代理，HTTP中的各种HEADER。爬虫与反爬虫就是相爱相杀的一对，道高一次魔高一丈。如何应对
反爬虫
没有既定的统一的解决方案，靠的是你的经验以及你所掌握的知识体系。这不是仅凭21天入门教程就能达到的高度。
进行大规模爬虫，通常都是从一个URL开始爬，然后把页面中解析的URL链接加入待爬的URL集合中，我们需要用到队列或者优先队列来区别对待有些网站优先爬，有些网站后面爬。每爬去一个页面，是使用深度优先还是广度优先算法爬取下一个链接。每次发起网络请求的时候，会涉及到一个DNS的解析过程（将网址转换成IP）为了避免重复地 DNS 解析，我们需要把解析好的 IP 缓存下来。URL那么多，如何判断哪些网址已经爬过，哪些没有爬过，简单点就是是使用字典结构来存储已经爬过的的URL，但是如果碰过海量的URL时，字典占用的内存空间非常大，此时你需要考虑使用 Bloom Filter（
布隆过滤器
），用一个线程逐个地爬取数据，效率低得可怜，如果提高爬虫效率，是使用多线程，多进程还是协程，还是分布式操作。","按照我的入门路径整理了一下，同时进行了一些优化，给大家做个分享。
先做个简单说明，自己写个简单爬虫是一件非常非常容易的事情，有足够的耐心连一周时间都不用就可以入门。照这篇文章练习，不出一个月你就可以非常熟练的使用各种爬虫。一点都不会错。
基础知识体系
很多人推荐书本资料，但是对于一个
简单爬虫
的使用者来说，书籍资料学习起来很慢，成本太高。不如从网上找写经典的资料看一下。
1.
专栏：Python爬虫入门教程 - 请叫我汪海
CSDN阅读量第一的爬虫专栏，创作于2014年。对于爬虫基础知识的介绍非常到位，尽管由于年代久远部分案例代码已经无法使用，但是对于新手建立自己的爬虫基础知识非常有用。
2.
专栏：Python爬虫之Selenium+Phantomjs+CasperJS - Eastmount
CSDN阅读量第二的爬虫专栏，作者一直在持续更新。最近的一篇文章发布于今年4月。相对于请叫我汪海的教程，这篇文章的在建立体系方面稍弱，但是案例和教程也非常经典。
3.
专栏：Python3爬虫之路 - fly_yr
基于Python3的爬虫实例。
4.
专栏：分布式爬虫原理与实现 - HAPPENgft
分布式爬虫的基础原理，值得一读。
实战项目练习
搭建了基本的知识体系，接下来就是应该实战了。
按照基本的练习过程，豆瓣、知乎等等是练习爬虫的重灾区。
不过现在就独立进行爬取还有点勉强，可以通过相应教程来进行锻炼。
（鉴于我入门练习的案例比较散乱，这里借用 
@路人甲
 大神介绍过的几个案例）
1. 
Python爬虫实战一之爬取糗事百科段子
2. 
Python爬虫实战二之爬取百度贴吧帖子
3. 
Python爬虫实战三之实现山东大学无线网络掉线自动重连
4. 
Python爬虫实战四之抓取淘宝MM照片
5. 
Python爬虫实战五之模拟登录淘宝并获取所有订单
6. 
Python爬虫实战六之抓取爱问知识人问题并保存至数据库
7. 
Python爬虫实战七之计算大学本学期绩点
8. 
Python爬虫实战八之利用Selenium抓取淘宝匿名旺旺
知识深化
练习过以上几个案例之后，你应该已经有相当的实战能力了。不过想要搞定所有网站还是有点难。这个阶段我的建议是了解一下常用的爬虫工具――
注意不是全部，是常用，同时是了解，不是精通。
1.
scrapy/scrapy
2.
Beautiful Soup
3.
urllib2
（其实这个超简单了...）
4.
PhantomJS
5.
CasperJS
6.
http://
docs.seleniumhq.org/
搞定这几个之后，我相信你已经是一个非常不错的爬虫高手了。
坚持！
与所有技能的学习一样，爬虫的学习最重要的不是天分，而是坚持。
我是怎么坚持下来的呢？之前的回答提过一下，这次也搬过来给大家看看吧，免得大家再找了。
比如我学爬虫的动力是什么呢？因为偶尔看到的一篇文章。
为了给题主更多的动力，我决定贡献出这篇文章： 
Python爬虫之――爬取妹子图片
 
以下内容来自上述链接，版权归作者所有。
环境：python 3.6
注：单线程版以在
安卓
的Qpython（py2.7）上运行成功
第三方库
requests:解析url 
beautifulsoup4:不会正则表达式童鞋的福音，可以容易的提取到html文件中各种标签及其属性
安装方法： 
pip install requests 
pip install beautifulsoup4
如果有错误请自行解决
目标
http://mzitu.com
 
话说回来，我半年前就开始学习py爬虫，但当时应该是兴趣不足，导致半途而废，所以说兴趣非常重要，我们的目标应该可以使大家有很大的兴趣，激励自己学习爬虫。
原理
学习爬虫，首先是要学习它的原理。打开网址（为了防止和谐我就不上图了 ），大家可以发现，一共有141页，每页都有很多套图，如果要你手动去保存，怎么操作？我想应该是这样，从第一页开始，点进第一个套图，然后保存每张图片，然后进行第二个套图……第一页完了之后第二页，从第一个套图开始，保存保存……这就是原理，当然，虽然这样能达到这个目的，但大家应该没有那么多的时间，那么我们就来学习爬虫，来替我们保存图片。
步骤
1.获取网页源码
用浏览器的F12可以看到网页的源码，但我们现在要用Python这样做。
#coding=utf-8

import requests

url = 'http://www.mzitu.com'

#设置headers，网站会根据这个判断你的浏览器及操作系统，很多网站没有此信息将拒绝你访问
header = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.204 Safari/537.36'}

#用get方法打开url并发送headers
html = requests.get(url,headers = header)

#打印结果 .text是打印出文本信息即源码
print(html.text)

如果没问题的话结果会是这样类似
......
        $(""#index_banner_load"").find(""div"").appendTo(""#index_banner"");
        $(""#index_banner"").css(""height"", 90);
        $(""#index_banner_load"").remove();
});
</script>
</body>
</html>

这些就是网页的源码了。
2.寻找所需信息
切换浏览器，右键‘查看网页
源代码
’，可以发现有很多这样的信息
<li><a href=""http://www.mzitu.com/89334"" target=""_blank""><img width='236' height='354' class='lazy' alt='我是标题我是标题我是标题我是标题我是标题我是标题' src='http://i.meizitu.net/pfiles/img/lazy.png' data-original='http://i.meizitu.net/thumbs/2017/04/89334_02b06_236.jpg' /></a><span><a href=""http://www.mzitu.com/89334"" target=""_blank"">我是标题我是标题我是标题我是标题我是标题我是标题我是标题我是标题我是标题我是标题</a></span><span class=""time"">2017-04-02</span><span class=""view"">6,788次</span></li>11

那么我们只需要提取这些东西就可以了…but:我写不出这么复杂的正则！！！没关系，我们的神器BeautifulSoup要上场了！
我们的步骤是：①将获取的源码转换为BeautifulSoup对象②搜索需要的数据
#coding=utf-8

import requests
from bs4 import BeautifulSoup

url = 'http://www.mzitu.com'
header = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.204 Safari/537.36'}

html = requests.get(url,headers = header)

#使用自带的html.parser解析，速度慢但通用
soup = BeautifulSoup(html.text,'html.parser')

#实际上是第一个class = 'postlist'的div里的所有a 标签是我们要找的信息
all_a = soup.find('div',class_='postlist').find_all('a',target='_blank')

for a in all_a:
    title = a.get_text() #提取文本
    print(title)

这样就找到了当页所有套图的标题
注意：BeautifulSoup()返回的类型是<class 'bs4.BeautifulSoup'>
find()返回的类型是<class 'bs4.element.Tag'>
find_all()返回的类型是<class 'bs4.element.ResultSet'>
<class 'bs4.element.ResultSet'>不能再进项find/find_all操作1

3.进入下载
点进一个套图之后，发现他是每个页面显示一个图片。 
比如
http://www.
mzitu.com/26685
是某个套图的第一页，后面的页数都是再后面跟/和数字
http://www.
mzitu.com/26685/2
 (第二页)，那么很简单了，我们只需要找到他一共多少页，然后用循环组成页数就OK了。
#coding=utf-8

import requests
from bs4 import BeautifulSoup

url = 'http://www.mzitu.com/26685'
header = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.204 Safari/537.36'}

html = requests.get(url,headers = header)
soup = BeautifulSoup(html.text,'html.parser')

#最大页数在span标签中的第10个
pic_max = soup.find_all('span')[10].text
print(pic_max)

#输出每个图片页面的地址
for i in range(1,int(pic_max) + 1):
    href = url+'/'+str(i)
    print(href)1

好了，那么我们接下来就是进行寻找图片地址并且保存了，右键妹纸图片，“检查”可以发现
<img src=""http://i.meizitu.net/2014/07/20140711w11.jpg"" alt=""Beautyleg 美腿写真 No.997 Dora"">11

那么这就是图片的具体地址了
那么我们的目的就要达成，保存它。
#coding=utf-8

import requests
from bs4 import BeautifulSoup

url = 'http://www.mzitu.com/26685'
header = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.204 Safari/537.36'}

html = requests.get(url,headers = header)
soup = BeautifulSoup(html.text,'html.parser')

#最大页数在span标签中的第10个
pic_max = soup.find_all('span')[10].text

#找标题
title = soup.find('h2',class_='main-title').text

#输出每个图片页面的地址
for i in range(1,int(pic_max) + 1):
    href = url+'/'+str(i)
    html = requests.get(href,headers = header)
    mess = BeautifulSoup(html.text,""html.parser"")


    #图片地址在img标签alt属性和标题一样的地方
    pic_url = mess.find('img',alt = title)

    html = requests.get(pic_url['src'],headers = header)

    #获取图片的名字方便命名
    file_name = pic_url['src'].split(r'/')[-1]

    #图片不是文本文件，以二进制格式写入，所以是html.content
    f = open(file_name,'wb')
    f.write(html.content)
    f.close()

不出意外你脚本所在的地方会有12张图片
4.批量下载
上面讲了如何下载一个套图，其实所有的套图下载只是加上两重循环。成品如下：
#coding=utf-8
import requests
from bs4 import BeautifulSoup
import os
import sys
'''
#安卓端需要此语句
reload(sys)
sys.setdefaultencoding('utf-8')
'''

if(os.name == 'nt'):
        print(u'你正在使用win平台')
else:
        print(u'你正在使用linux平台')

header = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.204 Safari/537.36'}
#
http请求头

all_url = 'http://www.mzitu.com'
start_html = requests.get(all_url,headers = header)

#保存地址
path = 'D:/mzitu/'

#找寻最大页数
soup = BeautifulSoup(start_html.text,""html.parser"")
page = soup.find_all('a',class_='page-numbers')
max_page = page[-2].text


same_url = 'http://www.mzitu.com/page/'
for n in range(1,int(max_page)+1):
    ul = same_url+str(n)
    start_html = requests.get(ul, headers=header)
    soup = BeautifulSoup(start_html.text,""html.parser"")
    all_a = soup.find('div',class_='postlist').find_all('a',target='_blank')
    for a in all_a:
        title = a.get_text() #提取文本
        if(title != ''):
            print(""准备扒取：""+title)

            #win不能创建带？的目录
            if(os.path.exists(path+title.strip().replace('?',''))):
                    #print('目录已存在')
                    flag=1
            else:
                os.makedirs(path+title.strip().replace('?',''))
                flag=0
            
os.chdir
(path + title.strip().replace('?',''))
            href = a['href']
            html = requests.get(href,headers = header)
            mess = BeautifulSoup(html.text,""html.parser"")
            pic_max = mess.find_all('span')
            pic_max = pic_max[10].text #最大页数
            if(flag == 1 and len(os.listdir(path+title.strip().replace('?',''))) >= int(pic_max)):
                print('已经保存完毕，跳过')
                continue
            for num in range(1,int(pic_max)+1):
                pic = href+'/'+str(num)
                html = requests.get(pic,headers = header)
                mess = BeautifulSoup(html.text,""html.parser"")
                pic_url = mess.find('img',alt = title)
                html = requests.get(pic_url['src'],headers = header)
                file_name = pic_url['src'].split(r'/')[-1]
                f = open(file_name,'wb')
                f.write(html.content)
                f.close()
            print('完成')
    print('第',n,'页完成')

5.升级多进程版
#coding=utf-8
import requests
from bs4 import BeautifulSoup
import os
from multiprocessing import Pool
import sys


def find_MaxPage():
    all_url = 'http://www.mzitu.com'
    start_html = requests.get(all_url,headers = header)
    #找寻最大页数
    soup = BeautifulSoup(start_html.text,""html.parser"")
    page = soup.find_all('a',class_='page-numbers')
    max_page = page[-2].text
    return max_page

def Download(href,header,title,path):
    html = requests.get(href,headers = header)
    soup = BeautifulSoup(html.text,'html.parser')
    pic_max = soup.find_all('span')
    pic_max = pic_max[10].text  # 最大页数
    if(os.path.exists(path+title.strip().replace('?','')) and len(os.
listdir
(path+title.strip().replace('?',''))) >= int(pic_max)):
        print('已完毕，跳过'+title)
        return 1
    print(""开始扒取："" + title)
    os.makedirs(path+title.strip().replace('?',''))
    os.chdir(path + title.strip().replace('?',''))
    for num in range(1,int(pic_max)+1):
        pic = href+'/'+str(num)
        #print(pic)
        html = requests.get(pic,headers = header)
        mess = BeautifulSoup(html.text,""html.parser"")
        pic_url = mess.find('img',alt = title)
        html = requests.get(pic_url['src'],headers = header)
        file_name = pic_url['src'].split(r'/')[-1]
        f = open(file_name,'wb')
        f.write(html.content)
        f.close()
    print('完成'+title)

def download(href,header,title):

    html = requests.get(href,headers = header)
    soup = BeautifulSoup(html.text,'html.parser')
    pic_max = soup.find_all('span')
    #for j in pic_max:
        #print(j.text)
    #print(len(pic_max))
    pic_max = pic_max[10].text  # 最大页数
    print(pic_max)


'''
#安卓端需要此语句
reload(sys)
sys.setdefaultencoding('utf-8')
'''


if __name__=='__main__':
    if (os.name == 'nt'):
        print(u'你正在使用win平台')
    else:
        print(u'你正在使用linux平台')

    header = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.204 Safari/537.36'}
    # http请求头
    path = 'D:/mzitu/'
    max_page = find_MaxPage()
    same_url = 'http://www.mzitu.com/page/'

    #线程池中线程数
    pool = Pool(5)
    for n in range(1,int(max_page)+1):
        each_url = same_url+str(n)
        start_html = requests.get(each_url, headers=header)
        soup = BeautifulSoup(start_html.text, ""html.parser"")
        all_a = soup.find('div', class_='postlist').find_all('a', target='_blank')
        for a in all_a:
            title = a.get_text()  # 提取文本
            if (title != ''):
                href = a['href']
                pool.apply_async(Download,args=(href,header,title,path))
    pool.close()
    pool.join()
    print('所有图片已下完')
你想更深入了解学习Python知识体系，你可以看一下我们花费了一个多月整理了上百小时的几百个知识点体系内容： 
【超全整理】《Python自动化全能开发从入门到精通》笔记全放送","从爬虫必要的几个基本需求来讲：
1.抓取
的urllib不一定去用，但是要学，如果你还没用过的话。
比较好的替代品有
等第三方更人性化、成熟的库，如果pyer不了解各种库，那就白学了。
抓取最基本就是拉网页回来。
如果深入做下去，你会发现要面对不同的网页要求，比如有认证的，不同文件格式、编码处理，各种奇怪的url合规化处理、重复抓取问题、cookies跟随问题、多线程多进程抓取、多节点抓取、抓取调度、资源压缩等一系列问题。
所以第一步就是拉网页回来，慢慢你会发现各种问题待你优化。
2.存储
抓回来一般会用一定策略存下来，而不是直接分析，个人觉得更好的架构应该是把分析和抓取分离，更加松散，每个环节出了问题能够隔离另外一个环节可能出现的问题，好排查也好更新发布。
那么存文件系统、SQLorNOSQL数据库、内存数据库，如何去存就是这个环节的重点。
你可以选择存文件系统开始，然后以一定规则命名。
3.分析
对网页进行文本分析，提取链接也好，提取正文也好，总之看你的需求，但是一定要做的就是分析链接了。
可以用你认为最快最优的办法，比如
。
然后将分析后的结果应用与其他环节：）
4.展示
要是你做了一堆事情，一点展示输出都没有，如何展现价值？
所以找到好的展示组件，去show出肌肉也是关键。
如果你为了做个站去写爬虫，抑或你要分析某个东西的数据，都不要忘了这个环节，更好地把结果展示出来给别人感受。","看了一下，大家大多都是方法论。那我来说些爬虫入门的学习路线吧：
一、基础
1、
python来袭~爬虫0010：概述
：本文详解了爬虫的几乎所有理论知识点，全面。
2、
python来袭~爬虫0020：urllib2的使用
：与文1配合食用。0030、0040链接中可自取。
3、
精通Python爬虫-01-不断前行的蜘蛛
： 本文除了定义类相关内容，附带了爬虫的现状分析，值得一看。
4、
Python3爬虫之入门和正则表达式
 ：本文带你了解几个爬虫的小测试，以及对爬虫用到的工具介绍，比如集合，队列，正则表达式。
5、
python爬虫实践――零基础快速入门（一）
： 本文告诉你Python3环境配置、安装requests和lxml、爬虫百度小试牛刀。
6、
python爬虫实践――零基础快速入门（二）爬取豆瓣电影
： 本文带你掌握爬虫的基本原理――通用框架、爬虫操作步骤、爬虫基本流程。
7、
Python爬虫框架Scrapy学习笔记原创
：Scrapy的学习，每一步都详尽。
以上文章多为系列，可连续学习，不一一概述。
二、个例
放几个有意思的例子，给你更多入门兴趣和信心：
1、
python爬虫彩票网站
2、
python爬虫下厨
房
3、
用Python告诉你深圳房租有多高
题主学了这些还不入门？
来源：
慕课网
  转载请注明出处","亲，学习是个循序渐进的过程，首先我给你介绍一个入门
Python爬虫
的框架，scrapy框架。
Scrapy概念：
Python开发的一个快速、高层次的
屏幕抓取
和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和
自动化测试
Scrapy优点
吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。
学习视频：
Python学科爬虫项目实战Scrapy框架：
视频
http://
yun.itheima.com/course/
258.html
主要讲解内容：
1、Scrapy的简介。
主要知识点：Scrapy的架构和运作流程。
2、搭建开发环境：
主要知识点：Windows及Linux环境下Scrapy的安装。
3、Scrapy Shell以及Scrapy Selectors的使用。
4、使用Scrapy完成网站信息的爬取。
主要知识点：
创建Scrapy项目(scrapy startproject)、定义提取的结构化数据(Item)、编写爬取网站的 Spider 并提取出结构化数据(Item)、编写 Item Pipelines 来存储提取到的Item(即
结构化数据
)。
源码：
https://
pan.baidu.com/s/1oAecEI
Q
 密码：ejkc
爬虫项目应用：
python
网络爬虫
第一天
https://
pan.baidu.com/s/1c3ZDJh
e
链接：
https://
pan.baidu.com/s/1jJt4cb
s
 密码：bp5n
python网络爬虫第二天
https://
pan.baidu.com/s/1bqVCaY
V
链接：
https://
pan.baidu.com/s/1htBjd1
y
 密码：wou9
Python之桌面应用开发新宠
https://
pan.baidu.com/s/1i6cBgu
5
链接：
https://
pan.baidu.com/s/1htYPC2
4
 密码：ofwh
Python之云计算开发王者-20161013
https://
pan.baidu.com/s/1qZRNJe
G
资料：
https://
pan.baidu.com/s/1jJHkBI
I
 密码：dxci
Python之微信开发神器
https://
pan.baidu.com/s/1qZauYg
k
资料：
https://
pan.baidu.com/s/1ggGALD
T
 密码：t53u
Python之爬虫开发帝王
http://
pan.baidu.com/s/1pLOHgy
Z
链接：
https://
pan.baidu.com/s/1nw2RvK
l
 密码：dumi
python之利刃2
https://
pan.baidu.com/s/1cNqtG
资料：
https://
pan.baidu.com/s/1jJc9d8
y
 密码：s8qf
python之利刃1
https://
pan.baidu.com/s/1gfXV4h
P
资料：
https://
pan.baidu.com/s/1kWqen3
L
 密码：yzlb
python之大数据开发奇兵
https://
pan.baidu.com/s/1dGoo8y
H
资料：
https://
pan.baidu.com/s/1sna9k2
D
 密码：1sa0
好了，关于Python爬虫就这么多了，有用请点个赞","想学习爬虫，第一步是要知道
爬虫是非常简单的技术
。如果不以爬虫为工作，在有python基础的情况下，估计
10天不间断的学习，就可以随心所欲抓取绝大多数你想要抓取的页面
。当然，熟练程度不敢保证，小坑可能不断，但是这些坑可能已经不是爬虫知识的范畴，而是python素养问题，通过练习爬虫来培养python素养是一个非常好的选择。
为了帮助初学者入门，也是巩固自己学到的知识，我写了一系列关于爬虫的博客。
身边已经有同学在完全没有接触过编程的情况下，通过10天看
老师的python教程掌握基础语法，然后
只看我的前4文章就可以自己从头写一个爬虫解决生活中的问题
。
这个爬虫系列博客会越写越多，下面是筛选出来的最基础的9篇，相信看完这9篇，就可以掌握爬虫的原理，应对常见的反爬手段，进行中等规模数据的抓取（万级），这样就基本上可以应对生活上或者学术上对爬虫的需求了。更重要的是，这9篇文章可以给读者带来基本的爬虫素养，使读者在看其他爬虫文章时不再吃力：第一是可以通过闲暇时间看公众号等扩大自己的爬虫知识容量；第二是当目标网页抓取难度超出自己当前知识水平时，可以看懂网上搜到的解决方案。
下面是系列博客的目录
爬虫基本原理
爬虫代码改进(一)|多字段整合存储
爬虫代码改进(二)|多页抓取与二级页面
爬虫代码改进(三)|生成器与类的使用
BeautifulSoup全面总结
beautifulsoup+json抓取stackoverflow实战
请求、响应和反爬虫
ajax动态加载网页抓取
代理IP设置
接下来我将对每一篇讲的内容进行说明
爬虫基本原理
 这是最基础的一篇，用最简单的例子让读者知道爬虫是如此简单，并了解爬虫能抓那些数据，以及对爬虫最基本、最重要的概念有清晰的认识。
爬虫代码改进(一)|多字段整合存储
爬虫代码改进(二)|多页抓取与二级页面
爬虫代码改进(三)|生成器与类的使用
这三篇不涉及更多爬虫知识（我认为那些不算爬虫知识，只是python逻辑设计上的问题），但是会以爬虫实战为导向，展示抓取多个页面、二级页面中所有想要信息的代码逻辑。但是更重要的是，通过爬虫帮助读者培养python素养，写出更优雅的代码，以后看其他人的爬虫博客时也不会因为python基础不扎实而遇到挫折。
学完这四篇你就可以抓取一些没有任何反爬措施、数据量小一点的网站了。这部分网站数量可能比较少。
请求、响应和反爬虫
 这篇文章帮助你了解了最基本的反爬虫手段（非常套路，简单地加几个参数就可以了，估计花不了很长时间），这时，你就可以爬取大多数网站了（虽然没有数据支撑，但是从我的个人经验上看，非常非常多网站都只限制了一个UA，一些互联网公司可能会设置一些奇葩的反爬手段，但是只要上网搜索一下都能找到应对方案）
ajax动态加载网页抓取
  这篇权当介绍一种非常常见的反爬措施吧
代理IP设置
  当你需要大规模抓取时，ip难免被封，知道如何设置代理，能让你在不降低抓取速度的同时，抓取任意数量的数据。这里的主要思想是，当要抓取的数据量比较大时，其实只需要花一点点钱，就几乎不需要任何技术手段，绕过抓取数量限制这道门槛。几万几十万的数据估计都可以满足；但是如果数据量过大，需要程序运行非常长的时间，购买付费代理就会比较昂贵，这时就需要自己构建代理池，这就属于爬虫进阶内容了。
上面这几篇是最核心的部分，学完就可以对爬虫脉络有一个非常清晰的认识，足以应对绝大多数情况了（当然是要自己敲里面的代码，理解这些代码才算真正的学完）
下面这个算是辅助知识
BeautifulSoup全面总结
beautifulsoup+json抓取stackoverflow实战
python中提供了很多
，熟练掌握一种是有必要的，这让你在写代码时更加得心应手，因此这里贴上了最适合初学者入门的beautifulsoup教程，和配套的练习实战。因为这部分是纯苦力活，一个工具，没有什么技术含量，不涉及爬虫理念，因此等到需要用时现场查都是来得及的，但是事先熟练掌握一个工具会比当场查更加节省时间。
最后祝大家学的愉快！","我，完全的文科生，当时学
python爬虫
 完全摸不到头绪，各种资料一顿翻，一顿学，天天面对那个小黑框敲来敲去，很无聊，最后差点因为没有成就感而放弃！
直到有一天，看到了一个极简的爬虫项目，代码不超过10行，我照着敲了敲，一运行，就能迅速出结果，久违的新鲜感又回来了
因为怕忘了，就拿张纸，把代码一句一句的抄写下来，然后反复背诵，背写，背写敲
并给朋友一句句的解释每个代码是做什么的，原理是什么，为什么要这么做
反复练习，反复敲，时间长了，就形成肌肉记忆了，只要是浏览器能看到的，差不多就都能通过网页分析，然后就能抓下来，以后面试找工作也是一个非常好的加分亮点！
然后就开始学习抓取手机app中的内容，比如抓取发小曾经发过的朋友圈内容啥的，非常有意思
总之，爬虫基础打牢，遇到其他网络相关的问题，完全就不是问题了，这是万里python 长征的第一步，也是非常重要的一步！
下面是为了题主，亲自写的一个小教程，希望对你有帮助！
其实爬虫原理很简单，无非就是找到目标网站，把看到的内容抓下来嘛！
那我们设想个场景，当看到
某不可描述的网站
有很多好看的小姐姐，想把他们的美照都存下来，以供以后做电脑和手机壁纸怎么办？
一般小白会做以下操作：
打开某网站
找到好看的小姐姐照片
一张张的，
右键 -> 图片另存为 -> 选择一个文件夹 -> 给照片取个名字 -> 存储
，以此往复，当有上万张照片时，这样一顿操作下来，没有个几天是搞不定的，枯燥又无聊，估计都会得
鼠标手
了
那么学会 Python 后怎么做呢？
分析某网站，寻找规律，确认路径
撰写 Python代码
运行写好的Python文件，几分钟就搞定了
如果题主是完全的爬虫小白，但是了解一些 Python 和 HTML 基础语法，那也是极好的
所以，引用一句 Python名言，来表达我的观点：
好了，下面就开始严肃了，想让我放不可描述的网站是不可能的，对，我摊牌了，我说的网站就是
百度老师
还是严肃一些吧，现在百度广告太多，有些小白同学难免会误入百度的深坑，如果大家没有FQ的条件的话，我还是推荐使用「
必应国际版
」，至少解决一些日常技术问题，及答案的精准性上会比百度强太多！
用它搜技术问题！
接下来设立个目标：获取 必应关于「如何入门 Python 爬虫？」的第一页的搜索结果标题和网址。
p.s.新手就别着急那个网站了，咱们先学走路，再学开车，你会了这个，那些普通的静态图片网站，你也就会了，原理都差不多的
回到正题，一般的小爬虫，可以分为三个步骤 ：
查找HTML标签里包含的我们所需要的路径信息
在 python 程序里获取 百度的 html 响应
根据第一步，按照路径，从html 响应中提取所需的内容。
是不是很简单？听不懂也没关系，跟着我一步步做就完事了
首先，爬取的网址是这个，不要弄错了
如何入门 python 爬虫? - 国际版 Bing
第 1 步：找到目标内容的路径信息
打开谷歌浏览器，把上面这个网址打开，然后在界面空白的地方点击鼠标右键，选择最后那个「检查」。用控制面板上的小检查按钮，找到我们想要的 html 标签信息。
现找到每一个条目的路径：li.b_algo
找到目标标题和链接
复制对应的路径
1.1 由上图我们可以得到：
所有内容标题的路径：h2

所有内容链接的路径：cite
通过此查找，来检查，目标内容是否是想要的
第 2 步： 用Python来模拟，对必应的请求和响应
Python 中有许多方法可以做到模拟的网络请求，我一般是使用最人性化的Python包- 
Requests
p.s.如果获取的内容链接为空，那就是必应限制了，在 Get的时候，添加一个User-agent就可以了
#导入网络请求包


import
 
requests



#模拟请求刚才的必应网址


response
 
=
 
requests
.
get
(
'https://www.bing.com/search?q=
%E
5%A6
%82%
E4%BD
%95%
E5
%85%
A5
%E
9
%97%
A8+python+
%E
7
%88%
AC
%E
8
%99%
AB
%3F
'
)



#获取必应所返回的原始Html内容


htmlcontent
 
=
 
response
.
content
第 3 步：从原始 html 内容中提取所需信息
那么如何提取信息呢？Python已经给你准备好了相应的包了 - BeautifulSoup4
按照国际惯例，安装一下
pip3 install beautifulsoup4
htmlcontent 变量包含的是最原始的HTML，也就是文本格式，Python不能直接认识它，也不能直接用步骤1里的路径去找到目标的信息， BeautifulSoup帮我们解析了这个文本并解决了这个问题，这样Python通过它就可以认识路径了，就能实现我们的目标了
#导入BeautifulSoup包


from
 
bs4
 
import
 
BeautifulSoup
 
 

### 创建一个解析 ### 


results_soup
 
=
 
BeautifulSoup
(
htmlcontent
,
'html.parser'
)
 
 

### 找到所有的条目，由于是li标签，且样式是b_algo### 


search_results
 
=
 
results_soup
.
find_all
(
""li""
,{
""class""
:
""b_algo""
})
 


### 同样的找到条目下对应的标题和链接，标题是h2标签，链接是cite标签 ### 


title_list
 
=
 
[]
 

url_list
 
=
 
[]
 

for
 
result
 
in
 
search_results
:

    
title_list
.
append
(
result
.
find
(
'h2'
)
.
text
)
 
    
url_list
.
append
(
result
.
find
(
'cite'
)
.
text
)
 
 

### 保存到CSV文件### 


import
 
pandas
 
as
 
pd
 

pd
.
DataFrame
({
'标题'
:
title_list
,
 
'链接'
:
url_list
})
.
to_csv
(
'如何入门 python 爬虫?-必应.csv'
)
 
输出结果：
以上，这个爬出来的结果表，对就可以进一步回答你的提问了，哈哈哈
最后呢，想下载图片怎么办？
试试下面这个下单个图片的代码，你自己获取图片链接，组成一个图片链接列表，然后循环下载就可以了
import
 
requests



url
 
=
 
""http://craphound.com/images/1006884_2adf8fc7.jpg""



#获取图片相应


response
 
=
 
requests
.
get
(
url
)


#判断一下状态码


if
 
response
.
status_code
 
==
 
200
:

    
# 把图片内容写入文件

    
with
 
open
(
""/Users/apple/Desktop/sample.jpg""
,
 
'wb'
)
 
as
 
f
:

        
f
.
write
(
response
.
content
)
总之，学习Python爬虫还是要项目驱动的去反复练习，才能深入理解掌握，才能在解决实际问题上做到游刃有余","对于要入门Python爬虫的小伙伴，首先需要解决四个问题：
熟悉Python编程；
了解HTML;
了解
网络爬虫
的基本原理；
学习使用Python爬虫库.
若不知道自己是否满足入门条件，也没关系，这儿两本经典的python爬虫电子书，可以下载回去先看一下：
链接：
https://
pan.baidu.com/s/1Tn8ovb
Y_1qBT0yr2nqh-iQ
 
提取码：xgf1 
爬虫作为一个程序员最能装逼的一个技能之一，应用非常广泛，比如可以给
女朋友刷票点赞、可以采集微博的热评、可以寻找知乎最好看的小姐姐、可以爬取豆瓣评分最高的电影等等等等，
python爬虫
可以应用的场景非常多，但是前提是你得会，所以我特意由浅入深整理了一些python爬虫由浅入深的教程以及项目，保证你看完之后能自己动手写爬虫，建议先点赞收藏，然后再看。
一、爬虫入门
这部分整理了爬虫的一些基本介绍以及常见的函数、库的用法，点击链接可以直接跳转。
Python爬虫入门一之综述
Python爬虫入门二之爬虫基础了解
Python爬虫入门三之Urllib库的基本使用
Python爬虫入门四之Urllib库的高级用法
Python爬虫入门五之URLError异常处理
Python爬虫入门六之Cookie的使用
Python爬虫入门七之正则表达式
Python爬虫利器一之Requests库的用法
Python爬虫利器二之Beautiful Soup的用法
Python爬虫利器三之Xpath语法与lxml库的用法
Python爬虫利器四之PhantomJS的用法
Python爬虫利器五之Selenium的用法
Python爬虫利器六之PyQuery的用法
二、爬虫进阶
这部分介绍了一些框架的安装以及用法。
Python爬虫进阶一之爬虫框架概述
Python爬虫进阶二之PySpider框架安装配置
Python爬虫进阶三之爬虫框架Scrapy安装配置
Python爬虫进阶四之PySpider的用法
Python爬虫进阶五之多线程的用法
Python爬虫进阶六之多进程的用法
Python爬虫进阶七之设置ADSL拨号服务器代理
 
三、爬虫实战
这部分是具体项目案例讲解，教你如何用爬虫开发一个使用的小项目。
Python爬虫实战一之爬取糗事百科段子
Python爬虫实战二之爬取百度贴吧帖子
Python爬虫实战三之实现山东大学无线网络掉线自动重连
Python爬虫实战四之抓取淘宝MM照片
Python爬虫实战五之模拟登录淘宝并获取所有订单
Python爬虫实战六之抓取爱问知识人问题并保存至数据库
Python爬虫实战七之计算大学本学期绩点
Python爬虫实战八之利用Selenium抓取淘宝匿名旺旺
四、高端段位实战篇
这部分整理GitHub上已经开源的python爬虫实战项目代码，不仅可以参考大佬们的代码是怎么写的，还可以在自己要开发类似功能项目的时候，直接把代码借鉴过来用，
绝对是大宝藏。
Python 岗位分析报告
Selenium介绍
抖音App视频抓包
Bilibili 用户
Bilibili 视频
Bilibili 小视频
Bing美图爬虫
B站760万视频信息爬虫
博客园(node.js)
百度百科(node.js)
北邮人水木清华招聘
百度云网盘
Boss 直聘
贝壳网找房爬虫
暗网爬虫(Go)
豆瓣读书
豆瓣爬虫集
豆瓣害羞组
豆瓣图书广度爬取
DNS记录和子域名
DHT网络磁力种子爬虫
抖音
爱丝APP图片爬虫
京东
京东搜索+评论
京东商品+评论
机票
煎蛋妹纸
煎蛋妹纸selenium版本
今日头条，网易，腾讯等新闻
计算机书籍控图书
QQ空间
QQ 群
清华大学网络学堂爬虫
去哪儿
前程无忧Python招聘岗位信息爬取分析
soundcloud
Stackoverflow 100万问答爬虫
spider163 网易云音乐爬虫
时光网电影数据和海报爬虫
tumblr
下载tumblr喜欢内容
TuShare
天猫双12爬虫
Taobao mm
Tmall 女性文胸尺码爬虫
淘宝直播弹幕爬虫(node)
天涯论坛文章
天眼查爬虫
乌云公开漏洞
微信公众号
“代理”方式抓取微信公众号文章
网易新闻
网易精彩评论
微博主题搜索分析
网易云音乐
新.网易热评
唯品会商品
ZOL 手机壁纸爬虫
知乎(python)
知乎(php)
知网
知乎妹子
自如实时房源提醒
中国大陆高校列表爬虫
游戏直播行业真的如你想象般暴利？
五一不看人人人人人人，哪儿耍合适？
大碗宽面 VS 律师函警告，情感分析吴亦凡自黑式圈粉！
没经验没学历的外教为啥能拿1.4W+的高薪？
大胆，都是哪些程序员在反对996？！
儿科医生的眼泪，全被数据看见了
用大数据扒一扒蔡徐坤的真假流量粉
北上广深租房图鉴
六万条数据全面解析，城市春节禁放烟花爆竹真的有用吗？
十万条评论告诉你，给《流浪地球》评1星的都是什么心态？
开年表情包局部富有指南，盘它！
看完这篇分析，楼下的Tony和Kevin都改名了！
回复“实习僧”CTO之换种姿势爬取实习僧网站
【20G】Kaggle数据集强势分析“绝地求生”，攻略吃鸡！
50行代码教你打造一个公众号文章采集器
《我是大侦探》到底怎么了？(上：数据爬取篇)
《我是大侦探》到底怎么了？（下：情感分析篇）
帮了个小忙|破解“实习僧”网站字体加密
“小忙”连载篇|实习僧网站数据分析
Facebook模拟登录
微博网页版模拟登录
知乎模拟登录
QQZone模拟登录
CSDN模拟登录C已恢复
淘宝爬虫C重构中
Baidu模拟登录一
果壳爬虫程序
JingDong 模拟登录和自动申请京东试用
163mailC已恢复
拉钩模拟登录C已失效
98. 
Bilibili模拟登录
好了，我只能帮你们到这里了，以上内容建议结合这两本经典的python爬虫电子书一起看，电子书下载地址：
链接：
https://
pan.baidu.com/s/1Tn8ovb
Y_1qBT0yr2nqh-iQ
 
提取码：xgf1 
广告
【限时免费】超适合小白的Python入门课程：基础知识+代码实操+辅导答疑
已失效
?
最后再送大家一个python经典开发软件
PyCharm，
PyCharm的功能很强大 ，比如：调试、语法高亮、项目管理、代码跳转、智能提示、自动完成、单元测试、版本控制等。
下载地址（包含Windows和Linux两个版本）：
链接：
https://
pan.baidu.com/s/11HvkeJ
EyiQs5yG_lJTmiUQ
提取码：feug
有用的话记得点个赞再走，感谢！"
,,,,,,,,,,,,,,,,,,,,,
编程究竟难在哪？,"例如C语言，C++,Java，好多程序语言就算学很久也可能不会，为什么这么难？有什么好方法么？","编程的难分为两类，一种是
工程
上的难，一种是
算法
上的难。
我先回答一下工程上的难：
我们做一个比较, 就是开发一个大型软件, 和设计并建造一栋摩天大楼, 究竟哪个更难, 为什么?
实际上这个比较一旦抛出, 软件开发的""难""就立马显现出来了。
摩天大楼一旦盖起，将不再，也不可能“
更新版本
”，更不可能在建筑结构上进行“
重构
”，比如一个一百层的摩天大楼，不可能说过两个月发现地方不够住，然后再加五层，又过了两个月发现某个房间的设计满足不了人们日益增长的需求，将整个房间扩大两倍，究其原因，就是因为“建筑”这个东西太不灵活了，你如果想“重构”这个摩天大楼，几乎只有一个办法：炸毁，推倒重来。
而对于软件来讲，它本身的一个灵活性，导致了它
可能
在不破坏原有的大部分功能的前提下进行一定的功能性改造，在改造的过程中，原有的一些功能模块的更改，可能导致之前的一些文件或环境， 或应用程序在这个新的版本下出现不兼容的现象，所以它要保证旧的东西在新的东西下能成功运行。
一个东西越是牵扯的东西多，越和环境耦合，和“用户”耦合越深，和“自身”耦合，和“历史”耦合越深，它的“
更新
”就越难，而“
重构
”是多次更新之后的“
必然结果
”。
这就是为什么摩天大楼几乎无法进行功能性更新，因为建筑这个东西本来就是一个“
超级耦合体
”，你改变墙壁的厚度，会减轻它的重量，但于此同时因为墙厚度降低，它本身的抗压刚度和抗扭刚度也发生了降低，所以后果可能还需要重新计算，墙里面的电线会不会因为墙的厚度改变而需要重新布线？而且不仅如此，墙的厚度还会改变房间的大小，这是它和其自身的高度耦合。
它和用户的
耦合性
也很深，因为这个房间的一些地方有可能早已住了人，原有的位置放置了很多用户的东西，比如一些很重的家具等，你对墙重新施工，就意味着你要强迫用户更改它们原有的使用习惯，甚至可能让用户原有的一些家具无法在新的版本中放进去，这是用户的耦合性。那么类比软件，比如我们都知道的excel，这个软件开发了二十多年，你在2003版的excel里编辑的，十几年历史的excel文件，你觉得可以在2018版的excel中打开吗？这听起来很不容易，但是微软做到了，这就是为什么说现在除了微软几乎没有公司有能力开发出这样的软件，原因之一就是它变态的兼容性，长达十几年的时间跨度，版本跨度，保证文件的兼容性，这本就很了不起。
所以
向前兼容
是软件开发的主要难点之一。
有时候不仅是某个功能模块的更新，随着一个”服务型“的应用不断发展，它要提供服务的用户量就会不断提升，一个典型的例子是淘宝，学过数据结构的我们知道，这世界上很多东西的复杂性并不是线性增长的，简单的例子就是排序，最优的
时间复杂度
也是nlog（n），理想世界如此，现实世界怎么可能更简单！
十年前php可以撑起淘宝的流量，而今天呢？php的性能问题恐怕让其无法再承担淘宝的亿级流量，所以只能用java重写，而这就是
重构，
重构其实就可以认为是推倒重来，代价很大，需要更换
技术栈
，但必要时不得不做。
有人说服务一万人用一台服务器，那么服务一亿人用一万台服务器就解决了，哪来那么多事，而这也正是我刚才说的，陷入了”
线性增长思维陷阱
“。
一万人的时候，可能有时候可以让系统停掉，进行一到两小时的服务器维护，这一万人也不会因为你停了服务器就有多大的损失，那一亿人呢？你的服务器集群敢断电吗？敢让网站挂掉进行网站维护吗？
所以既然要让网站每时每刻不断运行，就首先要做到
持续集成，持续部署
，对应用进行完善的
版本控制
，为了降低系统bug风险要进行完善的发布前测试，而测试又分
单元测试
和
集成测试
，缺一不可。为了防止某个地区的服务器因为突发事故，比如地震，火灾，大面积停电等事故发生宕机甚至损毁，我们需要进行服务器的
异地容灾
，那么另一个地区马上就能无缝根据原有服务器的中断镜像进行服务重建，做到服务端这边“山崩海啸”，用户端那边还能一如既往的从容淡定，感觉什么事都没发生一样。
所以，扯了这么多，我用一句话总结编程的”工程性难点”就是，
你如何在这错综复杂的耦合中，在复杂性不断增加的过程中，如何让软件有序，规范地”进化“，而不是让其肆意疯长，最后成为一坨无人能懂，无人敢碰的”屎山“
。
算法上的难明天再来答。
算法的难主要集中在两点, 一种是算法的构思和提出, 一种是提出算法之后, 用code实现出来。
个人认为算法的构思和提出最为困难，因为这部分经常要求我们将我们眼中“显然”的东西，转换成计算机语言。
比如我们现在要实现一个算法，这个算法能够识别一张图片，判断图片中是否有人脸，对于人类来讲，这是不经思索的，一眼就能看出来的，但是问题是，你自己也不知道你自己是怎么看出来的，这个判断过程，其实我们的大脑内部发生了很复杂的化学反应，但是我们却说不清，我们到底是怎么判断的，还比如判断人脸的情绪等等。
但有人说，这说明计算机比人笨，事实上完全不是这样，
计算机从来就不比人笨
，事实上比起人类能做到的事计算机做不到，计算机能做到人类做不到的事反而更多。
计算机的特点就是容错率低，但是可预测性强，确定的代码和输入就能得到确定的结果和输出。
人类的特点是容错率高，但是可预测性差，对一个东西的执行结果经常受情绪，身体状况，心态等的影响，结果常常是不确定的。
所以其实，一个系统的”
容错率
“和”
可预测性
”是个永远不可调和的矛盾，一个编程语言如果具有一定的容错率，看起来好像编程更为容易，实际上反而是灾难，bug更难发现，问题更难复现，一个运行正常的系统很有可能有一天脑子一抽输出一个错误结果, 这就是为什么几乎所有语言都有异常抛出机制, 就是为了降低容错率。
所以我们要注意一点就是，
编程困难，并不是因为计算机不够先进，不够智能，而是我们为了“可预测性”，心甘情愿地接受了这种极低的“容错率
”
，这直接导致你写程序，少打一个分号，编译错误，打错一个变量名，编译错误，数组越界，编译错误。
容错性这么低，你还指望它能接受人类这种模糊的自然语言？当然不可能了，所以它一定有自己的，语义清晰的语言。
一个语言一旦语义清晰了，语言灰度底了，它一定是逻辑性很强的，或者说，我们其实是用逻辑写代码，而不是用“感觉”或是“情感”写代码，这和我们人类理解世界的方式本来就是有区别的。
人类虽然有逻辑思维的能力，但是逻辑思维从来就不是人脑的强项，人脑的强项其实是整体感知，和一些“系统预设”的功能，比如你眼睛睁开了，投入你视网膜的光就会自动的转换成图像信息被你感知，这个过程你调用了任何逻辑思维了吗？你几乎什么感觉都没有就完成了一个极其复杂的过程。
所以我们的大脑绝大多数复杂的进程，或者说运行过程，都不能被我们逻辑性地去感知，比如你听到一首歌，这首歌给你一种很舒缓的感觉，你说你听着这首歌仿佛进入了一片天灵之地，但是这个过程，请问你进行了任何逻辑思维没有？
你就是感觉了一下而已，但是我们想让机器去做这样的“感知”，因为计算机体系的极低容错性，我们必须用我们的逻辑思维搞明白，这首歌，究竟是因为什么，它有什么样的特质，才导致了它给你这样的舒缓感觉，这样你才可能把这个过程转换成计算机语言输入到计算机中，让计算机去判断这首歌是“舒缓的“还是”狂野的“。
所以我总结一下编程在算法上的难，就是：
人类这种容错率高，可预测性差的生命，非要逼着自己去和一个容错率低的，可预测性强的这样一种”
硅基生命
“交流，不得不逼着自己用逻辑性很强的语言去和他交流, 在这个过程中我们不得不打破我们原有的感觉和感知, 对其进行逻辑解构, 这样才能让跨物种交流得以实现. 
看到这里，你一明白了，要想让两种不同的生物更好的交流，要不就是让人类变得更像计算机，要不就是让计算机变得更像人。
你想一下siri，
cortana
这种语音助手，它是不是具有一定的不可预测性？你和它说一句话，你知道他要回复你什么吗？不知道，但也正因为如此，我们让计算机变得更像人类，从而让人类这一端，可以更轻松地和计算机交流，这其实就是人工智能。
一个AI的算法模型种，往往要引入大量的参数，然后不断地输入样本，根据预测值和真值是否匹配而动态地改进这些参数，这样一个系统，容错率是低了，可预测性呢？确定的AI算法模型能得到确定的预测结果吗？
所以与此同时，你也要注意。
容错率低的，重要的事不要交给siri去做，因为它和人一样，不可预测。
考虑到这个看这个答案的同学里面肯定有一些是想要入门编程，其实入门编程的时候还是不要被这些困难吓到，可以从简单的场景入手，最近我了解到一个编程学习平台，叫做「夜曲编程」，特别适合零基础的编程同学学习，上手门槛非常低，可以直接在线完成学习：
而且还有简单的知识卡片，像背单词一样学编程：
对于零基础的同学来讲，「夜曲编程」是一个不错的学习平台，不妨试试～包括现在也能在他家的公众号回复「免费教程」然后就能拿到，免费学习的扎实课程，虽然是体验课 感觉内容还是毫不敷衍。","编程一点都不难；它只是和你十几年来在学校受的教育格格不入而已。
自小你受到的教育，总是：
1、记忆和理解一个个的知识点
2、给你一个未完成的拼图，让你把自己记忆的、某几个合适的知识点以正确的姿势放进去（超过三个就是难题，超过五个就是压轴题！）
3、好了，满分
换句话说，你从未学过创造；你只是被训练的极为擅长“填补拼图中缺失的一角”而已。
看我的这个回答：
代码是如何控制硬件的？
 
嗯，显示所有答案，你会发现另一个怼我的答案排在第一。
他说，“高票答案没有真正回答问题”，而许多许多人表示同意――而且非常反感那些装X的答案，以至于要狠狠踩上一脚。
搞笑的是，他的答案也被很多人认为“没有真正回答问题”。
终于，我知道这些人缺失的是哪一环了。于是不得不添加这么一段回复：
解释下这个抽象的0/1是如何出现/消失于电路中的。
事实上，电路中压根就没有0和1。
就好像你手机充电器的指示灯一样，当它接通电源时，指示灯亮；拔下来扔桌子上，指示灯灭。
很多人
胶柱鼓瑟
，非要在里面找“充电器是怎么知道自己有没有插到电源上的”。
但实际上，我们每个人都知道，指示灯就是盏灯而已。接到电上，它不亮也得亮；拔下电源，它想亮也亮不了。
同样的，电路中压根不存在什么0和1。我们给它插电，然后合上开关，某段电路便得到了供电――然后我们给这个状态起个名字叫高电平。
它和充电器一样，是一件死物。它压根不知道任何东西。
但我们需要知道它的状态。所以我们不得不在电路中接入指示灯（或电压表），然后根据指示灯的明灭，我们才知道电路是哪个状态。
进一步的，聪明的人类把“指示灯”做成0或1的形状，就把电路状态以一目了然的形式表现出来。
甚至于，我们还可以把它转换为屏幕上的图形/字符、音箱中的声音，从而间接的看见/听到电信号。
再说一遍：电路中不存在0和1。它们只是按基本物理规律运行而已。为了方便我们理解，我们才想办法做了一些“高级指示灯”，从而使自己能以0/1甚至汉字/图像的方式直观理解电路状态。
太多人严重缺乏这种最基础的动手能力，不知道人才是本体，这才总是傻乎乎的想找到“电子器件究竟在哪个点获得了智能”。
可笑吧？这么个幼儿园级的简单问题，得如此长篇大论才能说清楚――显然，他们甚至压根就没有把一个幼儿园级的问题表达清楚的能力。因为能说清楚他们自己就会完成思考了（这也是那个认为“高票没有解决问题”所以自己走低彻底解决了问题、然而还是有人在他的评论区疑惑“0/1怎么对应到高低电平上”的原因）。
幼儿园不解决；现在，想要教会他们，你就必须彻彻底底的掰开、揉碎，像喂两个月的婴儿那样一点点给他们喂！
实质上，这已经等于教不会了。
当然，这个问题实在太简单、太初级；大多数人在他们上幼儿园之前就已经解决掉了。
所以，读到上面那段文字，你可能无法感同身受。
那么，这段呢？
我们高中数学为什么不重视算法？高中学的数列，三角函数，求导，圆锥曲线相关问题的解法和算法有什么关系？
 
编程不难。但它要你创造。
过去你已经习惯了的、出题人准备好一切、只留下一两个缺口让你补充拼图的“思考”方式，在这个领域渣都不是。
听着，你不需要学习什么“语言”。C/C++、Java、Go、
PHP
、Python……统统用不着。
你只需要知道，程序语言有顺序分支循环三种控制结构、与或非三种逻辑――剩下的，统统靠你自己。
不。你就是再读一千本书，也甭想靠这个把“编程的技能”直接灌进你脑子里。没那好事。
相反，你必须自力更生，你必须靠着“鄙陋”的顺序分支循环和与或非以及中小学水平的数学运算支持，解决手头的一切问题。
你学的是编程，不是编程语言。
脱掉C的底裤，并不能帮你写出哪怕一个简单的鼠标驱动程序。
混知乎或其他网络论坛，总有人忍不住骂“你们码农怎么什么话题都想插一嘴？”
很遗憾。但程序员的工作，恰恰正是“理解各行各业的工作，然后把它教给电脑”。
没错。
学编程，学的甚至不是计算机本身；相反，它要求你从声学到视觉暂留、从结构力学到滤波解调……随便哪行哪业，你都要能够快速抓住重点、然后把它说的清清楚楚明明白白，这才可能把它教给计算机、让CPU代替人工作。
如果连“手电筒的原理”你都理解不了、如果连“
遥控小车
”这样简单的发明你都做不到“信手拈来”……那么，他人从液体分层原理借来的冒泡算法、从猜测的
人脑工作原理
偷来的神经网络，你又怎么可能理解？
它要求的，是“从三百五百甚至成千上万个知识点中挑选出最合适的那几个、然后用它们解决你所面对的问题”！
编程真的不难；但你从未受过解决问题的训练。
而编程，恰恰就是最最纯粹的、以精确无歧义的方式表达问题解决方案的一种工作。
不。
你甚至不知道“学习编程”就是学习“如何用电脑解决问题”，反倒学编程语言本身去了……
这种学法，怎么可能不难？
invalid s
117 次咨询
5.0
程序员、编程优秀回答者
1818507 次赞同
去咨询","@invalid s
 大佬说了关键点，这里算是做一点补充吧
编程难么？对于有些人来说确实挺难的，我在大学里见过许许多多靠背代码过程序语言专业课和二级C的同学，其中不乏优秀的同学，比C语言难100倍的模拟电子技术、
高频电子技术
、通信原理他们能考很高分，但C语言就费老牛劲。我考二级的时候带了一支笔悠哉悠哉的就过去了，看到走廊上一群拿着辅导书玩命翻的人，很是迷惑，有那么难吗……
后来我也算是略微想明白了一点，这是“学以致考”和“学以致用”的区别
编程学习跟应试教育是完全互斥的学习方式，应试教育那一套不用管理解，只管背概念-背题型-做题拿分的流程在这里是玩不转的
在应试教育模式下，你可以不懂期望、
方差
等一系列概念是如何被发明出来的，可以不懂微分方程有什么用，可以不懂
戴维南定理
、H参数等效电路拿来干啥，不理解，不影响你套题型套公式求出正确的解，拿到分。
但是对于编程来说，“不理解概念”的负面反馈是及其迅速和强烈的。因为编程没有“题型”和“公式”可以把你解决问题的过程简化成填空，编程提出的问题相对来说是很宽泛的，需要你根据脑子里的逻辑推断，利用所学编程语言的各项功能组织成代码去解决问题。当你不理解概念的来由和用途的时候，你根本就想不到用它，也解决不了问题。
比如你不理解指针，那么涉及结构体、
链表
、文件操作等知识的内容你统统都会难以理解，更别说编写程序了，面对一个空空的main函数，你都不知道要不要用指针，背了*p是指针，&p是取地址，背几行操作指针的代码，又有什么用呢。
学习编程语言就像你学习卷尺锤子扳手怎么用一样，只是学习工具使用。任何一道试题和现实中的需求，都是在考你用工具解决问题的能力，而不是你对工具本身的了解。每一行代码都是人如何使用多种工具达成一个目的逻辑过程，只要你有一行代码，甚至于一个关键字、符号不理解，你写出的程序就可能出错，而计算机是个很简单的东西，不对，就不过，不会给你步骤分。
理解每一个概念的来由、定义和用途，是学习编程语言的最基本的要求。
我自己在大学里辅导过不少C语言老大难的同学过二级，我从来不让他们刷题，而让他们拿看不懂的程序给我，我一行一行的给他们讲代码为什么这样写，查找他们知识点的缺陷，帮助他们理解，最后他们考过二级也都是凭借着用自己理解的概念写了能写出来的程序，而不是蒙到考题把背好的程序从脑子里贴上去。
另外一个重要的点就是要“用”
，这点包括很多已经工作的同学都在犯，喊着“我要学C++/Java/XXX”然后抱着一本大砖头开始啃，啃了两章就没下文了，为什么会有这种现象，学了，能懂，但不知道怎么用，不断学，却练的少，最后在迷茫中打出GG，编程语言是个蛮复杂的工具，不要指望一蹴而就，当你刚掌握还不熟练的时候，不用很快就会生疏。
为什么很多人推荐一边看
开源项目
一边做练手项目来学习，就是为了填充从“学完工具怎么用”到“用工具解决问题”之间的鸿沟。
题主说C语言难学，我不知道题主是不是还在上大学，据我身边的情况来看，国内大部分大学的C语言教学质量是很堪忧的，包括部分985。以至于身边很多同学学完C语言课程之后，居然不知道#include<stdio.h>是什么意思，不知道头文件，没听说过C标准库，不知道
函数指针
，不会多文件编程，课程设计千把行代码就一个main.cpp（是的，.cpp不是.c）。在这种环境下指望按着学校安排的课程大纲学好C语言是不现实的。
如果你C语言的基本知识都很成问题，那么请丢下编著的教材，可以去找国外教材但是不推荐大砖头，或者在网上找公开课，把学习重心放到理解概念上，我个人推荐 
C语言入门教程-C语言中文网
。
 如果你是在拿C进阶实践上产生了疑惑，那我推荐一本书 
Unix/Linux编程实践教程
 。按着这本书上的章节去一个一个实现Linux/Unix上的各种系统命令，看看“C语言除了考试还用来干嘛”，“正儿八经的C语言程序怎么写”。
C++和Java相比于C，理解
面向对象程序设计
是一道坎，这一道坎，需要你用代码堆过去，空想是没有办法理解的，做题也没有办法理解，面向对象是为了应对有规模的工程如何组织代码而提出的概念，想要理解，也应该去看看上规模的工程是怎么用的，推荐自己一边学一边做点小东西，比如用Qt做桌面应用，拿Java写点Android Demo等。","题主说程序语言学很久可能学不会，让我们理一下语言的发展过程。
机器语言
计算机的世界是 0 与 1 的世界，如果编写过机器语言，你将会有更深的体会。让我们先看下边的代码片段。  
为什么叫机器语言？这可以说很明显了，这段代码猜到下个世纪也猜不出来吧，真的是字如其名，机器才能懂的语言。
这每一条都是一条指令，这个每条指令总共是 32 位，前边 8 位可能表示这条指令是加法，后边 12 位可能是第一个加数的地址，再后边 12 位可能代表第二个加数的地址，然后结果可能保存到第二个加数的位置。
只是随便举了个例子，每条指令的规定是什么，当然就取决于硬件了，有单地址的指令，双地址的指令等等，犹记得当时
计算机组成原理
课设中，机器只提供了加法的指令，循环的指令，没有乘法的指令，3 * 5 怎么算嘞？ 当然就可以转换成 3 + 3 + 3 + 3 + 3 了，还有除法怎么办呢？依旧可以实现的，记得当时写了满满一张纸的机器指令只为实现除法，用着高级语言的我们可以说是很幸福了。
这里我们可以看到，硬件和软件之间的相互配合，硬件如果没有实现，我们可以用软件，凭借硬件已经提供的功能和我们人类强大的逻辑，实现硬件暂时没实现的功能。当然软件实现的话速度和效率方面肯定会比硬件直接实现差一些。那为什么不用硬件把加减乘除乘方开方都实现了？这硬件的开销、复杂程度太大了，在速度可以容忍的情况下，乘方开方这些还是用软件实现比较好。
汇编语言
程序员如果每天写着 10101001010 ，大概会疯掉吧。于是第一反应就是，我能不能把这些指令用英语单词表示了，之前 10101 代表
加法指令
，我直接写个 add 岂不是更好？于是汇编语言出现了，它的可读性比机器语言增加了很多，可以看下边的代码片段。  
我们终于能看懂些了，mov，loop，sub，add 等等都是见名思意，每条指令几乎和机器指令一一对应，这样只要再拥有一个类似「翻译器」的东西，把它翻译成机器语言就完全够了。
但是！！！！我们还可以看到 ax，bx 这些东西，他们是 CPU 中的寄存器，还有一些 0b800h 啥的，这些是内存的地址。可以看到我们仍旧直接面对硬件在编程，这样的好处当然是程序的速度会快一些，缺点当然是对程序员的不友好，我们只有懂了硬件才能进行编写程序，于是，面向我们程序员的高级语言渐渐诞生了。
C 语言
这可能是大多数人的入门语言了，让我们看一下它的样子。
这看起来就非常的舒服了，即使一个没有学过编程的人，基本也能猜出来这是在干什么。是的，它是在计算 1 * 2。但大家有没有想过，有了这段程序，机器看不懂呀，是的我们还需要一个能够把我们编写的 C 语言程序的代码变为机器语言的东西，我们把它叫做编译器。
编译器无非是一个软件，那么，我们用什么语言写呢？其实，在 C 语言之前，已经有了 A 语言，B 语言，我们不妨选择一个在当时用起来比较简单的 B 语言来去实现我们的编译器。等等等等，B 语言写出的程序用什么去编译成机器能够执行的程序呢？用 B 语言的编译器！！！那么 B 语言的编译器哪来的，用 A 语言写呗。
前边一段话比较绕，大家理一理。终极问题，A 语言的编译器呢？用汇编语言！！！是的，逻辑就是我们先用汇编语言写一个相对容易实现的语言的编译器，有了这个编译器我们就可以实现难度更大，更抽象语言的编译器。最终，一层一层的就实现了 C 语言的编译器。
当我们有了 C 语言的编译器，意味着我们用 C 语言写的任何程序都能够转化成机器语言去运行了。这时，我们甚至可以再用 C 语言写一个 C 语言的编译器，再用之前写好的 C 语言的编译器去编译它，一个新的编译器就诞生了，哈哈哈哈哈，好像绕口令。
知道了这些，我们现在甚至可以模仿其他语言设计的规则，然后自己实现一个编译器，然后属于你自己的语言就诞生了！当然说着简单，做起来就比较烧脑了，具体的可以去学习
编译原理
的东西。
语言分类
C 语言出现后又陆陆续续出现了很多语言，而它们的编译器也大都是用 C 语言去写，底层很多东西也去用 C 语言实现，C 语言可以说是高级语言中，离硬件最近的语言了。
编译型语言
常见的 C 语言，C++，C# 等等，这些语言都需要编译器将所有的东西翻译成机器语言，形成可执行文件，例如 windows 下的 .exe 文件，相对于
解释型语言
，编译只做一次，然后就可以多次运行了。
还有比较特殊的是 JAVA ，它的一大优势是跨平台，也就是他的代码写好以后，编译成 .class 文件， 然后只要机器里有 JAVA 虚拟机，不管你是什么操作系统，window 也好，linux 也罢，它都可以执行，所以实现了跨平台。它可以说是编译型和解释型语言的结合了，它没有直接编译成机器语言，而是先变成 .class 文件，再由 JAVA 虚拟机一条一条解释执行。但他的语法风格和 C 语言也有很大的相似之处，所以我也把它放到这里了。
解释型语言
常见的 python，JavaScript，Ruby，或者称他们为脚本语言，这种的话就是需要解释器，它是一句的一句的通过解释器将其翻译成机器语言去执行，很明显，在运行的时候，如果不做特殊的优化，它的速度肯定比不上编译型语言。
标记语言
常见的 html，xml，和上边两种完全不一样，它的作用主要是描述一些东西，然后用于显示或者传输，例如下边的 html 。
它不能做一些加减乘除的事情，它仅仅供浏览器读取，然后根据相应的语法把它显示出来。就是下边的效果。
说了这么多，我们怎么学一门语言呢？  
我认为这取决你要做什么，不同的语言其实语法大同小异，不同之处在于它们的生态圈，它们所提供的库的方便程度与类别的不同，以及它们各自的一些特性。
如果你要写一些 windows 的桌面程序，你当然可以去学习 C++，C# 等。如果你要写安卓，你当然得学习 JAVA。如果你想写一些自动化的脚本，帮助你做一些事情，你可以学 python。如果你想做一些面向硬件的编程，C 语言当然是不错的选择。
不管你最开始学的是什么语言，都不会影响到其他语言的学习。我们要把语言当成一门工具，它是为我们服务的，需要啥就学啥呗，并不需要畏难。当你用熟了一门语言后，再上手一门语言会发现很快，快则两三天，慢则一周便能游刃有余。
你知道 C 语言怎么产生的吗？ 写 UNIX 的时候，Dennis Ritchie 觉得 B语言所编译出来的核心效能不是很好，于是将 B 语言重新改写成 C 语言，再以 C 语言重新改写与编译 Unics 的核心， 最后发行出 Unix 的正式版本。是的，就是这么随便，另当代学生「头痛」的 C 语言，就是这样简简单单诞生了，惊不惊喜，意不意外。
而现在很火的 JavaScript 当时也是 Brendan Eich ，为了应付公司安排的任务，用10天时间就设计出来了。
让我们看一下最新的编程语言的热度吧，
https://www.
tiobe.com/tiobe-index/
看上边的语言，很多可能连名字都没有听过，但事实是他们在各自的领域都发挥这很重要的作用。
学一门语言，首先要明确你为什么要学它，然后再去学。为了考试？为了做一个应用？为了写一个脚本？不管怎么样，有了这个目标导向，我们就会有动力。
我学编程期间开始也觉得很难，迷茫，因为刚开始接触方向实在是太多了，之前写过我的一些想法。
给初学者的一些建议。
windliang：大学的计算机之路
53 赞同 ・ 1 评论
文章
自己做过的一些应用，大家看看可以产生一些灵感。
你是在何时感觉自己的编程水平完爆身边大多数人的？
64 赞同 ・ 43 评论
回答
下边是一个应用诞生的全过程。
windliang：小程序神奇字体的从零到一
143 赞同 ・ 20 评论
文章
下边这本书强烈大家看一下，也就是学习方法，学习任何东西的方法。
windliang：《刻意练习》有感
8 赞同 ・ 4 评论
文章
如果没什么想做的项目，可以刷一刷题。
LeetCode刷题
?
zhuanlan.zhihu.com/leetcode1024
最后总结下，我自认为不是算聪明的，记得刚开始的学习的时候，有时候一个知识点看了一遍又一遍才会理解，写一个阶乘的函数都会兴奋，但就是一点一点的积累，自学能力和网上找东西的能力越来越强，慢慢的做东西变的快了，即使自己没有接触过的东西，也不会畏难，相信自己可以做出来，只是时间的问题而已了。
你学的越多的时候，会发现不会的也越多
，自己现在离大神也好远，但此时不会在迷茫了，因为此时知道自己该做什么，要做什么了。
所以学习编程我觉得最重要的就是
兴趣
和
多做多做多做多做多做
了。","1 考虑问题不周全，这一点就是需要天份和努力双子座。程序员是一个严谨的职业，不周全的代码就会有漏洞，这种思维方式，在什么时候有过专业的训练？并没有。
2 忽视了扩展性，很多人只能尽全力实现自己当前的需求，很少有余力能考虑到未来的变更。然而写代码是一个持续的事情，总会为自己当初的错误买单。人生如此，写代码更是如此，不是么？
3 缺少测试的动力，多数人都沉浸于正确的路怎么走，在大多数人眼里，都应该按照正确的路去走，可是程序员研发出来的系统要求必须考虑什么是不允许做的，像是一个虚拟世界的规则制定者。可是谁会反复站起来看自己手里的工艺品是否完美无瑕呢？你只是程序员而不是艺术家呀。
4 对底层知识要求很高，大多数程序员无法变的更厉害，就是接触底层知识太少，一旦遇到
黑盒子
，立刻懵逼。你让他把西红柿放冰箱还好，你告诉他冰箱在2019年7月3号下午4点13分~15分出现温度升高2℃，他怎么解决呢。
5 忽视文档的同步，很多人都认为自己写的代码就是属于自己的，完全不需要交流和沟通，更不需要花点时间维护一下。这好像是，我煮了个泡面，你要我写清楚煮泡面的设计规划方案？
6 没有复用性。抽象和分层是穿透表象，分析核心的重要思维方式，不把每一个细节掰开揉碎，很难组装起来。大多人宁愿重复做无意义的事情，抱怨整天写业务代码，从来不愿意思考用什么方式能够让自己的工作更高效简单。毕竟，抱怨是容易的。
7 缺少凭空想象力，有象棋，围棋经验的人可能会清楚，多数要在自己脑袋里去推演场景。编程也是，在设计之初，对着空气要构造出来未来的样子。在上线之后，对着日志要复原出来当时的样子，是不是比警察破案还要酷？
8 缺少主动学习方法能力，大部分人仍然停留在别人教什么我学什么，不教我就应该不会，不会就别怪我的阶段。我年纪大了，我英语不好，我零基础，我没时间，我们公司用不到这么高深的框架，没有技术大牛愿意带我，公司太慢不给我时间成长。做为dws学习法的倡导者，做为主动学习的实践者，慢慢理解，对他们来说，编程实在是太难了！
我们自小都只学会知识，通过知识去间接训练自己的习惯和思维模式，然而到了工作中慢慢发现，错别字不要有，命名要统一，分解任务要明确，反馈进度要及时，做事有先明确预期再验收，是这样么？在游戏里开团才学会团队协作，在篮球场上去联系组织能力，在棋牌中模拟场景，在谈对象的时候练习包容和尊重。
这些都是编程中少不了的啊，其实不是编程难，是编程是一个
照妖镜
，照出来每一个人被隐藏起来的短板。
我觉得我能吐槽一年~也一直想办法怎么做能提升大家各种编程能力，而不是仅仅教授语法框架这些知识，欢迎关注IT修真院的知乎专栏，也许哪天我就想到了呢？","其实，做任何事情都很难，无论是编程、做营销活动、做商业计划、做融资、做一个手机的工业设计、写可以大量引流的公众号文章……
只不过编程
难的比较有性格
：
你以为你在学习编程语言，其实你在
通过编程在操控一系列资源
做工作（CPU、内存、磁盘、网络、显示器、浏览器……）。编程语言是渠道，本质上你需要更多的理解真正干活的那些东西的工作原理。编程语言本身不依靠其他依赖，是不太可能解决实际问题的。没有CPU、显示器连hello  world都输出不出来。也许编程语言的学习会花掉一些时间，但实际上需要花更多时间放在“整个机制是如何工作”这个事情上。为此，要学习的东西是呈倍数增长。
编程往往会结合业务（人类思维）和技术（机器思维）
。这两类思维的差异非常明显。著名的“让程序员：去买6个苹果回来，如果看见西瓜就买一个“就是这种问题。开发者要用人类思维去理解PM的要求，同时又要根据严谨的逻辑去将方案转化为可以实现的流程图、
状态机
。这还不包括抽象、因为成本的考虑做成取舍之类的考虑。有人说，我做纯技术（比如数据库、中间件）就不用考虑业务了。其实那时候的技术需求就是业务，比方说想让数据表可以存储json类型，中间件可以跨不同平台工作……
编程大部分时候是一种
群体工作，需要密切合作
。前端开发、后端开发、数据开发、测试、PM、设计师等一群人集体完成一件事情。一个人通杀一切的时代早已经结束了。而一群人一起工作就要协作，需要保证彼此理解一致，就需要流程、文档、协同工具等。做其他行业，比如营销策划也需要协作，不过编程里的协作因为涉及到到的信息量和精确性都很高，必须采用更复杂的工具和流程，而非几个人找个会议室开个会聊下基本上就可以解决问题。
当然，还有些领域的群体协作比编程复杂的多的多，比方说造飞机，发车登月飞船
编程因为解决问题的需要，会
用不同的方式看待这个世界，并且做独特的抽象
。这些抽象是大量实践慢慢积累的结果。比如“线程”，“文件”，”锁“，  “Object”，“Actor”，“Function”、“Future”、 “Promise“， ”Generator“，某种“模式”……，这些概念的有的有现实实体的对应关系，但是要进一步理解实际的意思还要多花一番功夫；有的压根在真实世界里就找不到对应的关系，完全是人类智慧的产物。为了理解它们需要反复实践，找到这些东西的场景，反复琢磨才能慢慢领悟。这需要耗费大量的时间和精力。
也许有人发现自己在编程过程中没有/很少遇到上面的问题，觉得编程很简单。总是能够按照类似的方式一遍又一边的写代码来赚取收入。我很遗憾，这种叫做“流水线编程工人”，永无出头之日。毕竟对你简单，对别人也同样简单。门槛对所有可能的参与者是一样的。
如果真的想跳出来，真的以编程为事业，那么并没有什么捷径可走，下定决心去学习、思考，并在痛苦中努力成长，能够做其他大部分人都做不了的事情。这个方法也同样适用于任何职业。
相关问题：","第一等级的编程难，和学英语是一样的难度：记不住单词/命令/库/best practice（这个中文应该叫什么？）。
大部分爱好者和手写代码一万行以下的，卡在这个阶段。这个没办法的，不可能有捷径解决，只有去练。相信21天学会JAVA的，和相信知乎live5小时精通雅思单词的一样蠢。
第二等级的编程难在生态，C++还好点。现在连JS都讲究生态，别说微软系和JAVA系了，从前到后一大堆，以前写JS开个notpad就可以，现在装个
nodejs
就劝退一堆人。编程的生态环境现在已经十分复杂了，这也造成了隔（语言）行如隔山的状况。
这一级主要是初级人员往中高级人员进步遇到的槛，解决方案是自己投钱投经历，把本行主要的生态环境在自己家里搭建起来，摸索摸索。
第三等级的编程难在思维。很多人语句熟悉了，生态熟悉了，脑子还是人脑。拿到一个需求，就在脑子里把中文的英文的需求，翻译成JAVA的，C的，JS的。这是阻止大约SDE2/P6这个层次往架构去的主要原因。计算机编程的一大特点就在于对自然世界的抽象，提炼和优化，而单单平等的翻译，是做不到一个好的人员的。
最后的一个编程难度在TMD和蠢货沟通上。脱离了单纯开发工程师到了技术专家的角色，你面对的是无穷无尽的蠢货的问题。“为什么再加点内存不会更快？”“为什么加一倍人开发时间不能缩短一倍？”“为什么你们的软件不能侦测到服务器死机了重启服务器？”TMD我这是JAVA好吗！重启服务器你去找Oracle ME啊，蠢货！","难在耐心。
编程甚至对智商都没什么太大要求，对耐心与认真要求才是最大的。
实现一个简单的功能，就需要小心翼翼的操作每一个变量，设计每一个函数，设计每一个模块，耐心的写每一个测试，最后细心的debug认真检查程序运行的过程。
而在学习编程的过程，也要耐心地读文档，读不懂倒回去再读或去寻求他人帮助。别人的代码一行一行的看，看不懂自己想办法跑一跑观察一下想办法搞懂。
编程并不难，难的是成为一名优秀的程序员！
程序员这个行业，是一个区隔度特别高的行业。不少人短短几年就可以成长为高级工程师、
资深架构师
、首席架构师，而另外一部分人很可能工作10年还是初中级工程师。
（文末送进大厂资料）。
程序员行业还有一个特点，优秀程序员的产出是普通程序员的好多倍，甚至是10倍！
这是因为编程不是一门「线性科学」，而是一门「
非线性科学
」。
「线性科学」，比如跑步的速度就是，世界冠军的速度也不可能是普通人的10倍。「非线性科学」是指很多种因素交汇在一起，极大增加了系统的复杂度。
程序设计和实现不是一种线性能力，像经验、编码能力、工程能力、知识、学习新知识的能力、对无用部分的识别等这些就不仅仅是线性优势，汇聚到一起会对编程产生倍增级效应。优秀的程序员能达到百万年薪，而入门级或者初中级程序员可能只能拿10万年薪。
过去11年的职场生涯，我带过过百名程序员，见过非常优秀的也见过平庸的。以下是我认为编程的8个难点：
1.牢固的基础能力
2.裸编程能力
3.调试能力
4.代码简约的能力
5.准确预测技术工期的能力
6.深度理解底层系统远离
7.把控关键设计
8.拒绝完美主义
下面我将一一展开说明，并给出我的硬核攻克建议！全文较长大约4000字，建议先点赞再细读，读完绝对有收获！
（PS：感谢大家耐心的阅读，算法是程序员的重中之重，必须攻克，大厂面试必考，顺便送一份阿里大佬刷Leetcode总结的算法笔记，如果你能吃透，那我相信80%的技术面试都会不在话下：
目录非常经典：
―
 1
―
牢固的基础能力
说实话，很多程序员只是会写代码，
计算机体系
知识非常欠缺，这会导致长期的编码生涯会遇到严重的瓶颈。
核心就是计算机底层 + 通过反复造轮子的方法学习计算机基础课，主要要攻克三个方向（攻克了会让你如虎添翼）：
一、操作系统
美国有很多优秀的操作系统公开课，比如mit6.828、哈弗OS/161。这类课程都会给你提供一个mini os壳程序，相当于一个核心组件，剩下的你可以自由发挥。比如你可以设计线程管理、文件系统等等。
相比只是看操作系统的书籍，这种学习方法的效率简直高100倍！
下面是课程官网：
国内也有一些顶尖高校也是采取类似的方式，比如清华ucore基于 Linux 0.11魔改版本
二、数据库
国内说数据库就是mysql，这点要相信我！
首先概览下mysql的知识体系：
基础：
sql语句
表结构设计
调优：
索引、慢查询优化
配置参数调优
核心原理：
InnoDb存储引擎 （包括隔离级别、事务、锁、缓存池、回滚日志等等）
Mysqld (包括连接管理、进程管理、查询缓存、查询优化、日志等等)
架构与运维：
用户与权限、安全
备份与恢复
日志
分布式与高可用
对于零基础的童鞋：
首先，学习基本的SQL语法。完成这个后，你就可以编写SQL语句了。
这一步推荐：W3Schools的 
SQL 教程
。
其次，学习数据库的主要功能和使用方法，比如用户相关或者权限相关等等。
推荐两本书：
1.《
MySQL必知必会
》 这本书讲的非常全，从基本概念，到查询到插入新建表，用户的管理，都有具体的例子，非常适合没有任何基础的同学来学习Mysql，总之这本书学习的方法就是：1、十分钟了解下数据库的基本概念 2、找到练手的数据库 3、对照着上面的内容去敲。本书里也有大量的内容是讲sql的，可以结合w3c的sql教程一起，有取舍地看。
2.《数据库系统概念》这本书是dba必看的。
看完这些并且实践+思考之后，可以算入门了。
接下来对于希望深入学习的童鞋：
我推荐几本书（很多大神都这么推荐），《高性能MySQL(第3版)》、 《MySQL技术内幕(第4版)》，《
MySQL技术内幕 InnoDB存储引擎
》，《深入理解MySQL》还有Mysql的官网。读完这些东西，再加些丰富的经验，理论上来讲就具备DBA的水平了。
十分推荐阅读
Planet MySQL
上汇总的博客，特别是
Percona's MySQL & InnoDB performance and scalability blog
.
（ps，觉得不错的，请双击点赞，笔芯～另外送大家一份非常宝贵的计算机经典书籍资料，我把大学和工作中用的经典电子书库（包含数据结构、操作系统、C++/C、网络经典、前端编程经典、Java相关、程序员认知、职场发展）、面试找工作的资料汇总都打包放在这了，
学完进大厂很容易：
我已经帮大家打包好了，点击下方链接直接获取：
三、
计算机网络
网络知识工作后非常非常重要！
我分三个阶段来介绍：
1. 入门
第一本书 建议看
谢希仁
的《计算机网络基础》
2.进阶
然后第二本要看 《
TCP/IP详解1:协议
》，这个阶段需要多思考和动手网络在LINUX系统上发挥的最淋漓尽致，所以在学习的时候最好学习LINUX配合使用，学习LINUX,推荐《
鸟哥
的LINUX私房菜:基础篇》。
学习网络过程中,要不断抓包分析等,自己能写些简单的应用来发包更是完美。抓包工具推荐:LINUX环境下用TCPDUMP,windows环境下用 wireshark。这个阶段写习完后,已经是个小高手了。。
主要技能应该是 ： 对TCP,IP,DNS,
icmp
等协议应该都蛮熟了得了，
dhcp
/tftp/ftp等协议也应该都懂些，重点是要学会如何分析一个协议及LINUX系统的基本操作也差不多了。
3.高手阶段
这个阶段需要有一点的编程能力，指C/C++编程。主要学习的方向是协议的实现和协议的架构原理
协议的实现方面， 主要学习底层协议(指
传输层
及以下)的实现， 这些协议都是在操作系统层面实现的，最好的教材是《TCP/IP详解:实现》。至于网络架构这块，可以学习《计算机网络》这本书。
―
 2 
―
裸编程能力
裸编程能力：处理程序实际实现部分的子任务，实现函数或者算法之类的能力。
听起来很简单对吧？实际上很多程序员缺失这样的能力。
不知道大家有没有见过「复制粘贴工程师」，review他们的代码甚至会发现一些网上的注释，又或者其他人的编写错误。
并不是所有程序员都具备利用必备的基本编程结构有效的实现某个产品或者某个模块。
不少工作多年的程序员甚至连一个简单算法排序都没有考虑，当然这并不影响普通工作的输出，但在面临调优或者攻坚，这类型的程序员的表现甚至比刚毕业的优秀程序员还要糟糕。
在工作中遇到过一次将代码时间复杂度降低几个数量级的情况，
在压测模拟过万人同时使用的情况下，没优化前服务端程序直接卡死，优化后能流畅的运行。
在这个复盘过程中，我发现实现这个功能的程序员缺乏基础的算法基础。for循环的嵌套，简直是触目惊心。
BAT大厂招聘高级工程师，为什么总是要求手写各种算法，恐怕也是基于考察裸编程能力。
刷算法题是提升裸编程能力的好方法，这里力荐一本经典刷题小抄，是一个阿里P8大佬的力作：
―
 3 
―
调试能力
调试能力某种程度上比编码能力更重要。
查找和解决BUG会占用程序员大量的时间。查找BUG产生的根源不是一件简单的事情，需要整体的分析和经验的沉淀，同时还需要对各种调试工具熟练应用。不少程序员，解决完一个BUG却导致了更多的隐患，没有真正把BUG产生的原因找到，只治标不治本。
对于程序员来说，掌握在合理的步骤内修复BUG，以极简的方式编写较少BUG的代码的能力，就能显著提升效率。另外在团队中担任骨干的往往都是调试能力极强的程序员，在其他成员遇到困境之时，快速定位解决问题。能否运用调试技能快速解决问题，是衡量一个程序员水平高低的重要标准。
―
 4 
―
代码简约的能力
代码的注释是否恰到好处、函数模块和类的结构是否能让其他人直接秒懂、架构的设计是否足够清晰等等，都属于程序员追求简约的范畴。
有一种炫技程序员或者架构师，喜欢简单事情往复杂了做。明明几个类能搞定的，弄出很多中间类，明明三层架构就解决的问题，生生弄出五层。简约是成败之间最为明显的分界点，事实上能做到简约的人，恰恰是深度理解了系统的复杂性。
就好比微信是一个极度简约的产品，能做到这么简约恰恰是因为
张小龙
深度理解了通信和社交产品的复杂度。
一个产品功能，有人用了500行实现，你写了几千行。多出来的代码有价值吗？不仅没有价值，还会对未来接手代码的人有很大的困扰。
less is more，简单就是美，这话说的真没错。
看看Google、Facebook等公司的源码，找不到太多多余的代码和结构。无论是代码层面、类层面还是架构层面，都做到了恰如其分、恰到好处。
不要多写一行无用的代码！
―
 5 
―
准确预测技术工期的能力
老板想了个idea授意产品经理估工期。产品经理原型都没画出来，只有个大概想法，就找技术排工期。
这个时候，技术的内心大概多了几道菜式：清蒸产品经理、红烧产品总监、油炸CTO。其实准确预测技术工期是程序员一项非常重要的能力。
为什么这么说？只有具备这项能力，才能让开发工作游刃有余、可进可退。事实上锻炼这种能力也并不困难，拿移动端开发来说，一个idea大概对应多少个页面多少个
逻辑类
，是能够估算出来的，以此为基础完全可以估出大概时间。更不用说产品文档出来之后的预测，会更为精准。
那么预测技术工期的意义在哪呢？
首先在没有出文档之前的估计，可以作为给老板的重要判断武器。做任何功能一定会投入研发力量，而往往研发力量是最宝贵的，如果在idea出来之后就能大概知道工期，对于做什么不做什么的判断，意义重大。产品文档出来之后的精确工期呢？对控制风险和进度把控非常有帮助，这个时候的精确排期其实对风险点的估计、资源协调的能力都有很高要求。准确预测的过程其实就是风险预判的过程。
―
 6 
―
深度理解底层系统原理
处理复杂任务或解决复杂BUG时，具备深厚的底层系统知识非常重要。
比如数据结构、网络协议、操作系统相关知识，等等。程序的很多问题都是源于对计算机工作原理的误解，即使是使用高级语言开发的程序也一样。另外，一些更偏应用层的架构或框架，基础一定是更底层的系统。
了解了底层原理，我们才能看穿眼花缭乱的技术背后的东西，不被层出不穷的新技术所累。
比如Docker技术兴起，改变了CI/CD的方式，推动了
云原生
技术的发展。那么Docker到底是什么东西呢，其底层无外乎：CGroups进行资源限制、Namespace对进程视图修改、
rootfs
为容器进程提供隔离后执行环境的文件系统。
了解了Docker的底层原理，才能在实际工作中更好的驾驭Docker。
再举个应用场景的例子
：一提到分布式锁问题，大多数同学想到的方案是基于Redis的Master-Slave模式来实现。这个实现方案行不行？分布式锁本质是一个CP需求，基于Redis的实现是一个AP需求，乍一看基于Redis的实现是无法满足的。
脱离业务场景来谈架构都是耍流氓。
从技术战略的需求层面来看，如果分布式锁在极端情况下获取锁的不一致，社交业务场景能够接受，那么基于Redis的实现是完全可行的。
如果业务是交易场景，分布式锁在极端情况下获取锁的不一致性无法接受，
那么基于Redis的实现方案是不可行的。在锁强一致性的场景下，需要采取基于CP模型的
etcd
等方案来实现。
做出以上判断，需要深度理解底层系统原理。缺乏了这种理解，无法做出正确的架构抉择，也自然会对工作造成不利影响。
―
 7 
―
严格把控关键设计
无论是大的系统还是小的模块，一定都有最关键的功能。要在最关键功能上投入大量设计时间，才能规避开发过程中的各种坑。
程序员非常不情愿看到的一种情况是，需要在一些无关紧要的功能上浪费大量的时间，但你又不得不去将这个无关紧要的功能实现，因为它牵扯着这个项目的主要功能。
这种时候，就需要反思，在顶层设计的时候是否考虑周全。
详细而缜密的顶层设计能够减少上述情况的发生，降低模块间的
耦合性
。
必须意识到每一个细小的模块都有可能成为项目的瓶颈。
对于项目而言，最终的目标是合理的时间做最大的产出，实施重点就应该放在项目最主要的模块上。
拿设计IM功能来说，一个IM系统最重要的核心模块，一定是通信部分。
将通信部分的各种设计搞定，其他锦上添花的方面都可以后续慢慢补充，例如客户端交互、好友关系等等。
―
 8 
―
拒绝完美主义
完美主义包含两种情况，一种是追求极致性能的工程师文化、还有一种是个人性格使然。
无论哪一种，过分追求完美都会对业务交付产生影响。完美主义会影响程序员的心态，过于担心外部评价或过于追求内心的安全，反而会导致设计上的过度和偏差。
程序员真正产生价值一定需要和业务结合，业务交付的及时性、健壮性、简洁性、可持续性一定是首先需要考量的事情。
一定不能出现偏袒设计而牺牲生产力的情况。
不少创业公司上来就谈中台战略，并花大量研发力量去实践，最终中台没做好基础的业务保障也出问题了。
在我看来，这也是追求完美主义的一种体现，诚然有一个类似阿里那样的能给各业务线赋能的中台是一个美好的愿望，但很多时候连业务方向都要多变，追求这种赋能无异于空中楼阁。前几天我的读者群又有创业者在谈AI中台，我只想说既然是创业，咱能不能先MVP？等业务用户量更大了，再来追求更漂亮的实现？
推荐一本书：人月神话，看完后相信能杜绝很多人的完美主义：
《
人月神话
》探索了达成一致性的困难和解决的方法，强调杜绝完美主义。既有很多发人深省的观点，又有大量
软件工程
的实践，为每个复杂项目的管理者给出了自己的真知灼见大型编程项目深受由于人力划分产生的管理问题的困扰。
另外，计算机专业多刷算法题好处多多，算法厉害的人进大厂非常容易，这里推荐一本BAT大佬的算法笔记：
作者：findyi 链接：
https://www.
zhihu.com/question/2250
8677/answer/1693247154
码字不易，硬核码字更难，希望大家不要吝啬自己的鼓励，给我 ：
@码农出击
一个点赞，鼓励下我！","看了问题的描述，提问者想问的应该是“为什么编程入门这么难？”
那么答案就很简单了，学习曲线陡峭，从零基础到做出来一个看得过去/可以炫耀的项目作品，要掌握的东西太多，间隔的时间太久。
第一节课配置环境，第二节课 Hello World，第四节课打印九九乘法表…… 这些内容就算你实现了，又有多少成功的喜悦呢？能唤起你拍照留念发朋友圈的冲动吗？
到了第六节课后，朋友来找你，
――今天学啥了？           
 ――学了字符串的拼接和切片...
――能干啥呀？有用吗？ 
――我也不知道能干啥。应该有用吧…
――来，带你吃鸡。        
――emmm…… 好吧，来。
于是大厦轰然倒塌，一切灰飞烟灭。
一个能持续给你正反馈的系统，才是能让人坚持下去的良性循环系统。
游戏公司深谙此道，落地能捡枪，捡枪能杀人，杀人能舔包，环环紧扣。半个小时，塞给你十几个甚至几十个爽点。吃到鸡了，还贴心地提供一键分享到朋友圈功能。
而学编程，你靠自律坚持半小时学会了操作字符串，全程没有爽点，也不知道可以用在哪里，更没有冲动去和朋友们分享你刚才所学。
MIT 媒体实验室为小朋友们设计的 Scratch 就解决了这个问题，每行代码是一块积木，拖动几个积木块到窗口里，卡通角色立刻就能动起来，不同积木块对应不同动作，反馈实时高效。
两节课下来，小朋友已经可以用 for 循环控制猫咪走出太空步，而你的 for 循环，只能在控制台里打印等差数列。
你靠自律和坚持学到数组和面向对象，能做的依然只是换着花样做数学题和打印字符串，根本满足不了成就感和虚荣心。
实时而持续的 “学以致用” 才能支撑你走得更远。
不过，对于想学编程的普通人而言，Scratch 实在是太低龄和幼稚了。我推荐同样来自MIT 媒体实验室的编程语言 Processing。
Processing 创立之初的目标就是教育，就是帮助人们学习编程。
a>所以创始人选择的切入角度非常好，用代码画画。毕竟数不如表，字不如图，人们对图像更敏感，图片的表现力天生就比文字高两个数量级。
b>另外，考虑到编程第一步配置环境就会劝退很多人，Processing 把编辑器编译器等等打包成集成开发环境，简而言之，就是下载后开箱即用，无需进行任何配置。
c> Processing 本质上就是简化版的Java，语法也用的是简化版的 Java 语法，所以入门之后可以无缝转 Java（其实熟悉
之后，转任何语言都容易得多）。同时，背靠Java 大树好乘凉，Java 的一切包类库都可以导入进来，使得Processing 是一个完整的开发工具，而不像 Scratch 一样仅仅是个玩具。
第一节课后你能用 10 行代码画出这样的图案。同样是练习 for 循环的使用，画赛博朋克风比打印数列有意思多了。
第二节课后你就能风格化处理图像。
用数组知识做的魔性动画
等学到 class ，70行代码画出飞线涂鸦。
整个学习过程中，你不必要告诉自己“今天所学将来肯定有用，再坚持一下”，而是每个知识点都可以作为新武器，和之前的武器排列组合创造出更多可能性，帮你画出更炫酷的图案和动画。学习之后立刻挥洒创意画出来，作品分享出去获得来自朋友和陌生人的点赞，这种持续的正反馈会让你欲罢不能。
我当初在学习过程中，常常感到沮丧的，并不是学不会，而是恨自己审美和创意不足。同样是手里的这些武器，为啥别人画出来的就这么惊艳，我怎么想不到这么好的点子。工具简单，创意难得。
持续的正反馈会让你对编程有兴趣，而有了兴趣之后，后面的一切就是水到渠成了。
编程重要性毋庸多言，乔布斯奥巴马等等一大票名人都在鼓励人人学编程。当然，并不是每个人都适合编程，但适不适合只有试过才知道。而 Processing 的伟大之处，是解决了入门时的枯燥无聊，给了每个人一个超低成本的试错机会。
如果你犹豫了，心动了，就点击下面的链接吧，也记得关注我，带给你更多的 Processing 文章。
https://www.
processing.org/download
/
  官网下载Processing，开源免费。
https://www.openprocessing.org
   大量学习者在这里分享他们的习作，源码公开。","难在耐心。
编程甚至对智商都没什么太大要求，对耐心与认真要求才是最大的。
实现一个简单的功能，就需要小心翼翼的操作每一个变量，设计每一个函数，设计每一个模块，耐心的写每一个测试，最后细心的debug认真检查程序运行的过程。而在学习编程的过程，也要耐心地读文档，读不懂倒回去再读或去寻求他人帮助。别人的代码一行一行的看，看不懂自己想办法跑一跑观察一下想办法搞懂。
现代人们习惯于快节奏的生活，做很多事缺耐心和毅力，心也不静。有很多人甚至连吃饭都没耐心，而编程这项活动却是世界上最需要耐心的事之一。所以很多人说难，是因为大多人没有耐心，没有极客精神。
极客精神
就是耐心，对困难问题的耐心。面对难题非但不放弃，反而很兴奋。这些都是技术大牛的特质，也是我们常说的天才。
现代编程有了高级语言，其实已经简化了太多。我有时候没耐心了，就去想想几十年前，前人的
打孔编程
，插线编程。他们需要的耐心比我们现代要多几十倍，但他们把火箭送上了天。再想想自己有python，Go什么的，却没有什么大成就，就意识到了自己还要培养耐心。","其实我没学之前也觉得难，等学了一段时间之后我觉得挺简单。
之后一直都觉得编程根本就没有什么难的点，真正难的地方，都不属于编程的部分。大部分跟我说难的人，基本上都是不想学，不认真的，他们只是不想去思考而已。
直到我碰上了一个学生。。。他其实学习蛮认真的，很积极，很愿意问问题，但是他真的是一个让我体会到绝望感的学生。。。那个时候一点点编程里的基础概念，我用了可能七八种不同方式和角度来解释，连旁边来问问题顺便听了一点的几个学生都已经搞明白了，他还是不能理解。。。最终我只能放弃了。。。我在内心建议他换个专业吧。。。
那次之后我仔细考虑过编程里面到底有没有难点。我的结论是，有的。但是编程里真正的难点，按理来说在之前的教育里应该已经被训练和克服了。编程用到的最基础的
思想工具
其实基本都可以从最基础的数学教育里学习到。除非你当初学数学的方式不正确，否则小学应该就能获得基础的思想工具来编程了。
编程在思想上有两个难点，一个是要懂得抽象，另一个是逻辑要严密清晰。
所谓抽象，拿个最基础的例子来说。最早期开始学习数学的时候，我们会教，如果你有两个苹果，然后妈妈给了你两个苹果，你现在就有四个苹果啦！这里其实就已经隐含了关于如何进行抽象的教育了，把具体的苹果，抽象为抽象的数，忽略了苹果的绝大多数特征，只保留它关于数量上的特征。编程里时常要使用类似这种抽象的方式，提炼出需要的部分，然后在
编程范式
的框架里表达出来。如果始终无法理解两个苹果跟数字2有什么关系......那真的没法编程了。
另外一个是逻辑上必须严密清晰。日常生活里很多经验性的认知往往是直观和混沌的，我们在描述的时候往往是不清晰的，而且我们已经习惯了这种表述和认知方式。编程的时候不能那样去认知，必须有严密清晰的逻辑。打个比方，我不知道你们有没有经历过，但是我妈逻辑特别不清晰。比如说我开车，问她在哪里停，她会跟我说，在前面停。我会问她，在前面哪里，可不可以给一个大致的距离评估，或者给一个标志性建筑，或者你跟我约好停之前多久喊停。她就会很不耐烦......
如果是懂得如何抽象思考，并可以判断出怎样的表述是逻辑清晰准确严谨的人，是不会觉得编程难的。尤其是在现代软件工具的帮助下，编程本身是非常简单的，因为可以分解成一步步来进行，心智负担特别小。比什么下棋啊，数学啊，算法啊，那种需要大脑承载大量信息进行推理，分析判断的问题要简单多了。","1. 难在思路的构建
你学了很多语法，很多 API，但是当给你一个实际问题，让你通过编程实现，不是简单地罗列 API 即可完成，而是需要你对问题进行分析，理清解决问题的逻辑，然后再通过各种算法、数据结构和 API 等进行编程实现。
2. 做出来容易，做好难
当你解决了思路构建的难点，解决了一个问题，但是你是否使用的最好的方法，这就是所谓的做出来容易，做好难。
写的程序能够解决问题且没有 bug 是基本要求。这里的做好不是指功能正确，而是写的程序容易理解，能够很容易让其他接手的程序员（水平不差）看懂为什么这么写。
正确是
现在
怎么写不会挖坑害
将来
的人，
现在
怎么写能让别人
1年后
看你代码时候不可能理解错你现在的意图，
现在
怎么写能在别人
将来
犯错的时候提示他你错了。
编程是给未来的未知人讲故事
，你无法知道将来这个人是谁，他都懂什么，他经历过什么，这个系统将来已经是什么样子了。我们需要在这种无知，缺乏信息的情况下做决定，从千万种把这件事做出来的方法里，选出你觉得最能把这个故事给讲好的那种方式，把故事写下来。
编程是一种沟通，用程序跨越时空之沟通则是一门属于程序员的特有的艺术 
―― 
阿莱克西斯
3. 规范性好，有良好的可扩展性
并且程序的可扩展性，规范性高，后期维护难度小。整体功能实现的过程中，各种情况考虑规范。
其实学习编程和学习其他内容一样，没有什么太大差别。心态放好，用对方法，你就能够学好。重要的是学知识的人是什么样子，而不是学的是什么。
在这给你一些学习编程的建议，希望对你有用。
1. 让编程成为一个习惯
想要培养一项技能的最好的办法，就是将他融入到我们的生活并成为我们的爱好。其实说白了，就是让这个爱好成为一个习惯，一天不去做这件事情，都会觉得少了什么。在不知不觉中，这个习惯会像滚雪球一样积累起来。
对我来说，养成这种习惯首先就是要对“拖延症”说不。比如，你想锻炼下自己的写作能力时，但是没有好看的本子，没有好的灵感，没有安静的环境....总之就是找各种理由一拖再拖，最后就不了了之了。
为自己设定一下，每周拿出几天，每天拿出几个小时，编程学习就这样慢慢步入正轨。
2. 将每天的学习过程拆分成小块
对待编程学习，我们没必要像健身狂人那样一口气做到筋疲力尽。与其直接编程2小时，我们完全可以先做40分钟、然后休息5分钟，整个过程重复4次。很明显，40分钟这样的短周期更容易坚持也不会带来多少压力。
不过这样的方式应该配合更为灵活的执行思路。如果你感觉状态很好，而40分钟才刚刚完成热身，那就继续做下去并努力让自己抓住这种状态。向大家推荐蕃茄工作法，这是种学习新型技能的良好机制，推荐各位认真了解。
3. 学好基础知识
在确定好学习方向和
之前，你可以多做尝试，学不同的语言。但是当你学到一定程度，知道自己对哪个方向更感兴趣的时候，就不要广撒网了，一定要专注于你所选择的领域，做深做精。认真系统化地学习相关语言知识。当然，这不是让你就知道看书，你要看书的同时结合项目实践，进而对自己的掌握程度得到反馈，知道自己哪里不足，再继续学习，如此反复，详见第四点。
4. 学练结合，从做项目中找知识漏洞
当你选好方向，认真学习基础知识后，学习一部分的知识，就结合项目做一些实践，已明确自己哪里不足。并且做项目能增加学习乐趣，给自己提供一些正反馈，让学习变得有趣，让自己有足够的动力继续学习。
5. 阅读别人的代码
学习编程不能闭门造车，经过这几年的编程学习，我认为想要提升编码水平的最佳途径就是多看、多写。看别人的代码，看一些程序员大佬写的代码，看一些标准库的源码，仔细思考他们的编程思维和编程方式，以提升自己的编程思维和编程方式。阅读别人的代码也确实是快速提升代码水平的一个技巧。
6. 寻找良师益友
学习编程的一个很好的方法就是和其他的程序员交谈。这不仅能够帮助我们多获得一种思维方式，同时也能够以更为愉悦的感受完成学习任务。至于内容没有特定的要求，可以是你正在学习的东西，也可以是你认为很酷的东西，更可以是你正在工作的东西。这样做可能会让你学到很多关于库，服务，编程语言和模式方面的知识。但是，最重要的是，你能了解到其他人是如何看待编程的。
7. 写技术文章
如果大家学习了一种新的编程概念，但不能确定自己是否已经真正掌握，可以写技术博文加以检验。或者是在
网站上搜索，找找是否有人提出了类似的问题，然后给出您自己的答案。如果答案不对，那么讨论的过程能够有效加深理解。这样的过程，能给我们带来宝贵的经验，同时也能帮助他人。
值得提醒的一点，别因为自己刚刚涉及编程而有所顾虑。罗马不是一天建成的，出色的程序员也是一样。只要您对问题有所了解，就不妨给出自己的答案――无论对错，这都将成为一次宝贵的经历。
8. 保持耐心
对于人生来说，其中任何目标的实现都离不开耐心。编程学习就如其它任何学习任务一样，都需要反复努力并投入大量时间。
在这个过程中，你一定会经历高潮与低谷――别被这些曲线影响了心情。接受已经发生的一切，并尽可能避免其中不好的部分。就像打高尔夫球一样，我们的手感总在不断浮动，但只要坚持到底，你最终总能成为一个大神呢~
我的其他相关回答：
怎么学好数据结构？
程序员如何提高生产力？
初级程序员，该如何提高？
如何才能做一名自由职业者？
程序员上班有什么提高效率技巧？
如何学习编程？顺便介绍些好的网站",面试,"回答这个问题之前，先说一段我在腾讯当码农的经历吧。
那时候还是2008年，我加入腾讯做开发工作，部门是QQ GAME下的QQ游戏大厅。
刚工作总是兴奋的嘛，培训了一周后领导就交给了我一个任务，做QQGAME的换肤功能，现在这种换肤功能已经很强大了，彼时还是比较新鲜。
用C++做了个换肤接口，原理很简单：控制Draw函数，传入颜色(rgb)和透明度(
阿尔法
)参数，改变绘制的颜色。
先做了一个demo，运行良好之后，开始在UI基类UILogic中加入换肤接口，大概就用了四天，写了2000行代码，自测完美，然后就喊领导交活了。
结果被领导骂得狗血淋头：架构不合理、耦合情况严重、边界情况没考虑、代码运行效率低、代码不够优美、注释不清晰、没同步产出文档、代码没遵循部门格式。。。
为了解决这些问题整整又花了2周，领导才勉强满意，，，，，结果提测后，被测试又测出来各种千分之几概率的bug，为了解这些bug真的是差点没给我整出高血压。
又花了一周，测试通过，上线后测试又各种报线上bug，电脑机型、操作系统版本适配问题，整的头都大了。。
经过这一役，我才开始明白编码究竟难在哪里。。
1.实现并不难，框架设计非常难
2.提测并不难，debug是真的难
3.上线并不难，解决线上bug是真的难
4.效率优化真的难
5.架构和实现都做到优美，真特么难
6.写文档言简意赅，真特么难
也感谢入职腾讯就遇到一个严苛的领导，让我知道了编程难在哪，也让我知道了如何成为一名
高级工程师
。
编码犹如盖一栋摩天大楼，架构就是地基和钢筋，如果框架设计这步就错了，这个楼盖得再漂亮最后也得坍塌，算法和数据结构就是电梯，如果不行各种出问题，大楼的人没法上班。文档就是这栋楼的指示牌，也得重视起来，严格的自测和测试就是抗震能力，不合格以后一个地震，人和楼都没了。。。
单纯的编码过程，反而如同搬砖的过程，并没有太高的难度。
功夫都在诗外呀！
接下来，重点说下如何成为一名优秀的程序员：
1.夯实计算机体系基础知识
说实话，很多程序员只是会写代码，计算机体系知识非常欠缺，这会导致长期的编码生涯会遇到严重的瓶颈。
核心就是计算机底层 + 通过反复造轮子的方法学习计算机基础课，主要要攻克三个方向（攻克了会让你如虎添翼）：
一、操作系统
美国有很多优秀的操作系统公开课，比如mit6.828、哈弗OS/161。这类课程都会给你提供一个mini os壳程序，相当于一个核心组件，剩下的你可以自由发挥。比如你可以设计线程管理、文件系统等等。
相比只是看操作系统的书籍，这种学习方法的效率简直高100倍！
下面是课程官网：
国内也有一些顶尖高校也是采取类似的方式，比如清华ucore基于 Linux 0.11魔改版本
二、数据库
国内说数据库就是mysql，这点要相信我！
首先概览下mysql的知识体系：
基础：
sql语句
表结构设计
调优：
索引、慢查询优化
配置参数调优
核心原理：
InnoDb存储引擎 （包括隔离级别、事务、锁、缓存池、回滚日志等等）
Mysqld (包括连接管理、进程管理、查询缓存、查询优化、日志等等)
架构与运维：
用户与权限、安全
备份与恢复
日志
分布式与高可用
对于零基础的童鞋：
首先，学习基本的SQL语法。完成这个后，你就可以编写SQL语句了。
这一步推荐：W3Schools的 
SQL 教程
。
其次，学习数据库的主要功能和使用方法，比如用户相关或者权限相关等等。
推荐两本书：
1.《
MySQL必知必会
》 这本书讲的非常全，从基本概念，到查询到插入新建表，用户的管理，都有具体的例子，非常适合没有任何基础的同学来学习Mysql，总之这本书学习的方法就是：1、十分钟了解下数据库的基本概念 2、找到练手的数据库 3、对照着上面的内容去敲。本书里也有大量的内容是讲sql的，可以结合w3c的sql教程一起，有取舍地看。
2.《
数据库系统概念
》这本书是dba必看的。
看完这些并且实践+思考之后，可以算入门了。
接下来对于希望深入学习的童鞋：
我推荐几本书（很多大神都这么推荐），《高性能MySQL(第3版)》、 《MySQL技术内幕(第4版)》，《MySQL技术内幕 InnoDB存储引擎》，《深入理解MySQL》还有Mysql的官网。读完这些东西，再加些丰富的经验，理论上来讲就具备DBA的水平了。
十分推荐阅读
Planet MySQL
上汇总的博客，特别是
Percona's MySQL & InnoDB performance and scalability blog
.
三、计算机网络
网络知识工作后非常非常重要！
我分三个阶段来介绍：
1. 入门
第一本书 建议看
谢希仁
的《计算机网络基础》
2.进阶
然后第二本要看 《TCP/IP详解1:协议》，这个阶段需要多思考和动手网络在LINUX系统上发挥的最淋漓尽致，所以在学习的时候最好学习LINUX配合使用，学习LINUX,推荐《鸟哥的LINUX私房菜:基础篇》。
学习网络过程中,要不断
抓包分析
等,自己能写些简单的应用来发包更是完美。抓包工具推荐:LINUX环境下用TCPDUMP,windows环境下用 wireshark。这个阶段写习完后,已经是个小高手了。。
主要技能应该是 ： 对TCP,IP,DNS,icmp等协议应该都蛮熟了得了，dhcp/tftp/ftp等协议也应该都懂些，重点是要学会如何分析一个协议及LINUX系统的基本操作也差不多了。
3.高手阶段
这个阶段需要有一点的编程能力，指C/C++编程。主要学习的方向是协议的实现和协议的架构原理
协议的实现方面， 主要学习底层协议(指传输层及以下)的实现， 这些协议都是在操作系统层面实现的，最好的教材是《TCP/IP详解:实现》。至于网络架构这块，可以学习《计算机网络》这本书。
顺便送大家一份硬核计算机经典书籍，我把大学和工作中用的经典电子书库（包含JAVA、数据结构、操作系统、C++/C、找工作面试题等）打包在一起了，这套资源是伴随我从学生一路成长为腾讯高级开发工程师，360技术总监的打包全套，非常宝贵：
点击下方链接直接获取：
2.裸编程能力
裸编程能力：处理程序实际实现部分的子任务，实现函数或者算法之类的能力。
听起来很简单对吧？实际上很多程序员缺失这样的能力。
不知道大家有没有见过「复制粘贴工程师」，review他们的代码甚至会发现一些网上的注释，又或者其他人的编写错误。
并不是所有程序员都具备利用必备的基本
编程结构
有效的实现某个产品或者某个模块。
不少工作多年的程序员甚至连一个简单算法排序都没有考虑，当然这并不影响普通工作的输出，但在面临调优或者攻坚，这类型的程序员的表现甚至比刚毕业的优秀程序员还要糟糕。
在工作中遇到过一次将代码时间复杂度降低几个数量级的情况，
在压测模拟过万人同时使用的情况下，没优化前服务端程序直接卡死，优化后能流畅的运行。
在这个复盘过程中，我发现实现这个功能的程序员缺乏基础的算法基础。for循环的嵌套，简直是触目惊心。
BAT大厂招聘高级工程师，为什么总是要求手写各种算法，恐怕也是基于考察裸编程能力。
这里送题主和大家一本阿里P8大佬撰写的算法笔记，是他刷Leetcode总结的经验，整整 300 道 LeetCode 上的题目，并且都给出了最优解：
看看这本书的目录，简直绝了！
3.调试能力
调试能力某种程度上比编码能力更重要。
查找和解决BUG会占用程序员大量的时间。查找BUG产生的根源不是一件简单的事情，需要整体的分析和经验的沉淀，同时还需要对各种调试工具熟练应用。不少程序员，解决完一个BUG却导致了更多的隐患，没有真正把BUG产生的原因找到，只治标不治本。
对于程序员来说，掌握在合理的步骤内修复BUG，以极简的方式编写较少BUG的代码的能力，就能显著提升效率。另外在团队中担任骨干的往往都是调试能力极强的程序员，在其他成员遇到困境之时，快速定位解决问题。能否运用调试技能快速解决问题，是衡量一个程序员水平高低的重要标准。
4.代码简约的能力
代码的注释是否恰到好处、函数模块和类的结构是否能让其他人直接秒懂、架构的设计是否足够清晰等等，都属于程序员追求简约的范畴。
有一种炫技程序员或者
架构师
，喜欢简单事情往复杂了做。明明几个类能搞定的，弄出很多中间类，明明
三层架构
就解决的问题，生生弄出五层。简约是成败之间最为明显的分界点，事实上能做到简约的人，恰恰是深度理解了系统的复杂性。
就好比微信是一个极度简约的产品，能做到这么简约恰恰是因为
张小龙
深度理解了通信和社交产品的复杂度。
一个产品功能，有人用了500行实现，你写了几千行。多出来的代码有价值吗？不仅没有价值，还会对未来接手代码的人有很大的困扰。
less is more，简单就是美，这话说的真没错。
看看Google、Facebook等公司的源码，找不到太多多余的代码和结构。无论是代码层面、类层面还是架构层面，都做到了恰如其分、恰到好处。
不要多写一行无用的代码！
5.准确预测技术工期的能力
老板想了个idea授意产品经理估工期。产品经理原型都没画出来，只有个大概想法，就找技术排工期。
这个时候，技术的内心大概多了几道菜式：清蒸产品经理、红烧产品总监、油炸CTO。其实准确预测技术工期是程序员一项非常重要的能力。
为什么这么说？只有具备这项能力，才能让开发工作游刃有余、可进可退。事实上锻炼这种能力也并不困难，拿移动端开发来说，一个idea大概对应多少个页面多少个逻辑类，是能够估算出来的，以此为基础完全可以估出大概时间。更不用说产品文档出来之后的预测，会更为精准。
那么预测技术工期的意义在哪呢？
首先在没有出文档之前的估计，可以作为给老板的重要判断武器。做任何功能一定会投入研发力量，而往往研发力量是最宝贵的，如果在idea出来之后就能大概知道工期，对于做什么不做什么的判断，意义重大。产品文档出来之后的精确工期呢？对控制风险和进度把控非常有帮助，这个时候的精确排期其实对风险点的估计、资源协调的能力都有很高要求。准确预测的过程其实就是风险预判的过程。
6.深度理解底层系统原理
处理复杂任务或解决复杂BUG时，具备深厚的底层系统知识非常重要。
比如数据结构、网络协议、操作系统相关知识，等等。程序的很多问题都是源于对
计算机工作原理
的误解，即使是使用高级语言开发的程序也一样。另外，一些更偏应用层的架构或框架，基础一定是更底层的系统。
了解了底层原理，我们才能看穿眼花缭乱的技术背后的东西，不被层出不穷的新技术所累。
比如Docker技术兴起，改变了CI/CD的方式，推动了
云原生技术
的发展。那么Docker到底是什么东西呢，其底层无外乎：CGroups进行资源限制、Namespace对进程视图修改、rootfs为容器进程提供隔离后执行环境的文件系统。
了解了Docker的底层原理，才能在实际工作中更好的驾驭Docker。
再举个应用场景的例子
：一提到
分布式锁问题
，大多数同学想到的方案是基于Redis的Master-Slave模式来实现。这个实现方案行不行？分布式锁本质是一个CP需求，基于Redis的实现是一个AP需求，乍一看基于Redis的实现是无法满足的。
脱离业务场景来谈架构都是耍流氓。
从技术战略的需求层面来看，如果分布式锁在极端情况下获取锁的不一致，社交业务场景能够接受，那么基于Redis的实现是完全可行的。
如果业务是交易场景，分布式锁在极端情况下获取锁的不一致性无法接受，
那么基于Redis的实现方案是不可行的。在锁强一致性的场景下，需要采取基于CP模型的etcd等方案来实现。
做出以上判断，需要深度理解
底层系统原理
。缺乏了这种理解，无法做出正确的架构抉择，也自然会对工作造成不利影响。
7.严格把控关键设计
无论是大的系统还是小的模块，一定都有最关键的功能。要在最关键功能上投入大量设计时间，才能规避开发过程中的各种坑。
程序员非常不情愿看到的一种情况是，需要在一些无关紧要的功能上浪费大量的时间，但你又不得不去将这个无关紧要的功能实现，因为它牵扯着这个项目的主要功能。
这种时候，就需要反思，在顶层设计的时候是否考虑周全。
详细而缜密的顶层设计能够减少上述情况的发生，降低模块间的
耦合性
。
必须意识到每一个细小的模块都有可能成为项目的瓶颈。
对于项目而言，最终的目标是合理的时间做最大的产出，实施重点就应该放在项目最主要的模块上。
拿设计IM功能来说，一个IM系统最重要的核心模块，一定是通信部分。
将通信部分的各种设计搞定，其他锦上添花的方面都可以后续慢慢补充，例如客户端交互、好友关系等等。
8.拒绝完美主义
完美主义包含两种情况，一种是追求极致性能的工程师文化、还有一种是个人性格使然。
无论哪一种，过分追求完美都会对业务交付产生影响。完美主义会影响程序员的心态，过于担心外部评价或过于追求内心的安全，反而会导致设计上的过度和偏差。
程序员真正产生价值一定需要和业务结合，业务交付的及时性、健壮性、简洁性、可持续性一定是首先需要考量的事情。
一定不能出现偏袒设计而牺牲生产力的情况。
不少创业公司上来就谈中台战略，并花大量研发力量去实践，最终中台没做好基础的业务保障也出问题了。
在我看来，这也是追求完美主义的一种体现，诚然有一个类似阿里那样的能给各业务线赋能的中台是一个美好的愿望，但很多时候连业务方向都要多变，追求这种赋能无异于
空中楼阁
。前几天我的读者群又有创业者在谈AI中台，我只想说既然是创业，咱能不能先MVP？等业务用户量更大了，再来追求更漂亮的实现？
推荐一本书：
人月神话
，看完后相信能杜绝很多人的完美主义：
《人月神话》探索了达成一致性的困难和解决的方法，强调杜绝完美主义。既有很多发人深省的观点，又有大量
软件工程
的实践，为每个复杂项目的管理者给出了自己的真知灼见大型编程项目深受由于人力划分产生的管理问题的困扰。
祝大家前程似锦，在编码的道路上一马平川。
要是觉得不错的话，那就帮我
@findyi
点个赞，一键三连呗哈哈哈，周末码字不容易","难在心急。。。。。。。。。。。。
真的，都太心急了。。。。。。。。
就像学数学，加减法小学的时候，要天天练习，才能在学乘除法，乘除法也要写好多题，才能学方程。。。。。。。。
其实编程正常来说，也是这个道理，数据结构和基础算法（不说那些太难的，就说排序的那几种简单的）都没学会，然后就开始学掉包。。。。
以前有非专业的人想学编程，我给推荐的，一般都是多花点时间，刷刷数据结构和算法的基础题，然后看看怎么操作文件，读写，最后在看看TCP UDP的代码，别起手，就上什么numpy pandas，mysql ,redis，掉包urllib库。。。。。。。
但大部分人，根本就静不下心来，感觉人家百度上的代码，用这个库，可能就2 3行就OK了，为什么我要听你的，自己手撸呢。。。。。。
没什么办法，那就愿意掉包，就掉呗， 人家包里面，为什么传这些参，参数类型为什么是这个，都不懂，纯靠背，纯考提示写，出了BUG，自己还不懂，继续百度，百度半天还不懂，在去问人，其实都是基础的问题的，过一段时间没人愿意解答了，自己也就坚持不下去了。。。。。。。
剩下的，也有智商逻辑的问题，的确，业务逻辑太复杂，有的人搞不明白，几层嵌套就完蛋。。。。。。",我觉得难的是写文档，做ppt，吹牛逼。,"说个真实的案例。
我上学期做计算机网络课程设计，用Java，写一个QQ的主要功能。我是完全模仿QQ的，实现了私聊公聊加好友，传文件的功能。用了2个月，当然是断断续续在做，因为还有其他课程。
现在回头看一看工程，代码量不大，也涉及不到高深的算法，但是还用了很长时间，为什么？
因为需要用到Java swing，许多界面需要去学习，这玩意老师又不交。还有一些细节问题，比如如何在关闭聊天界面后，再打开该界面，之前的聊天记录还在？这些东西占据了我开发的绝大部分时间，实际的核心功能实现起来反而比较容易。
再说刚刚做完的一个iOS大作业，不好意思的说，没做完，只实现了部分功能。服务器用vapor，我不会用，因为常用navicat mysql。客户端就是swift去写，同样的，功能很简单，也就是数据库增删查改，但是比如swift的界面下拉列表怎么处理？要知道如
http://
asp.net
平台都是封装好的dropdownlist，xcode可没有这些东西，都需要用代码去写。同学拖界面，segue的坑被踩了，一天调不出来，我1分钟就搞定了。不是说我比同学强，而是这个坑我以前踩过，理解了它的原理，故而解决起来容易。
还有iOS语言的坑，比如字符串startwith方法和hasprefix方法有啥不一样？我用后者就可以得到想要的结果，用前者就不行。
看看上面两个案例，都是我最近的真实情况。实际上，普通的编程并不难，就是经验而已。入门是艰难的，因为你需要了解语言特性，转换计算机的思维方式。但是一旦你知道某个功能应该怎么写代码，就不难了。但是往往这个代码需要你平时的积累。
剩下的比如算法的难题，工程的难题，我认为大部分也是经验的问题。只要别入swift这么年轻的语言的坑，像Java，c++，解决方案有很多。面试鹅厂，我问开发的时候需要自己写的代码很多么，面试官说其实大部分库都是现成写好的。
所以说，编程实际上不很难，写过一个工程，其他相似的工程就很快了。但是由于学习的时候有许多方面涉及不到，而开发的时候这些又是基础，所以现学现卖，就比较难了。","“编程一点都不难，它只是和你十几年来在学校受的教育格格不入而已。”
今天就和大家好好聊聊“
编程究竟难在哪
?”
一、难在我们从未接受过解决问题的训练
从小到大，我们受到的教育终极目的是有一个：考取理想的学校。每一张张考卷都是一个个堆砌起来的知识点：三角函数，解析几何，数列，函数…...这么多知识点，你需要做的是背下它们，或者说的更高级一点，理解它们。即便是强调思辨和分析的“文科类”，也可以靠死记硬背答题模板拿分，就连作文都要有统一的标准。
记得有一年考试，题目是对
冰心
的一首小诗写评论：
“墙角的花，当你孤芳自赏的时候，世界就变小了。”
出题老师原意是让大家批判孤芳自赏，但有同学偏偏赞美孤芳自赏，赞美这种洁身自好的精神。而这种文章要一律判作不及格。
年纪尚小的我们甚至都来不及怀疑“为什么这个学生说得没有道理？为什么所有的人都只能有一样的价值观呢？”因为千万军挤独木桥，保险起见的我们只需要按照所理解下来的知识，将一块块碎片，根据正确而万能的模板拼好，才容易拿下满分。我们非常擅长理解和记忆，并井井有条地套公式。这一切，到了学编程这里，
统统不奏效
。我们接受了十几年的应试教育，为了最大化公平，考试必须有一套清晰的标准。正是如此，我们更看中重应试技巧而非知识本身，学习变成了追求标准答案，求知变成了死记硬背。绝大部分人，难以形成系统的学习方法论的意识，以至于很多人一旦脱离试卷，在社会中面对实际问题的时候，完全没有一套行之有效的方法论支撑其解决问题。 
而编程的核心，不是编程，不是语法，甚至不是算法或数据结构本身，恰恰是
如何分解问题
――发现规律建立解决问题模型，映射到合适的数据结构和算法上，最后才根据算法写程序实现。
二、
难在我们从未学过创造
清华大学前校长陈吉宁曾提过一个观点：
清华大学里有很多“A型学生”，但未来社会最需要的是“X型学生”。“A型学生”，指的是传统观念里的“好学生”，他们的成绩总是能得“A”。“X型学生”与之不同，他们的成绩并不一定拔尖，但愿意承担创新风险，勇于尝试新鲜事物。
两者最重要的差别，
在于创造力
。
可是我们连作文还不敢写得太跳，生怕阅卷的是个老古董，大笔一挥，让你再考一年。创造力，更是我们在学校想都不敢想的事。绝大部分学生的思维，早已在填鸭式的教学中，变成了一个只会收纳外部知识的容器，根本无法用所学的东西创造出任何东西来。
所以，当我们开始学编程，面对“
Hello world.
”这个等着我们创造的世界，其实是非常茫然的。
因为编程没有“题型”和“公式”能把你解决问题的过程简化成填空，编程提出的问题基本都是空而泛，需要你根据脑子里的逻辑推断，利用所学编程语言的各项功能组织成代码，来解决问题。
整个世界的运转，都是靠你的大脑想象出来的。这是编程的难。
但是，只要你明知其中不易，仍有一腔骁勇，你可以尝试在编程的世界中，保持“实验者心态”，不断探索自己的想法，质疑自己的假设，从所犯错误中学习宝贵的经验，就一定能在编程的魔法世界中得到更多宝藏。
如果你看过《
乐队的夏天
》，那么在参赛的三十一支乐队中，你一定会被其中一支叫做“刺猬”的乐队所打动。
刺猬乐队的子健，他是台上的狂躁主唱，台下的学霸码农。
即使每天都在和冰冷的数字打交道，但作为程序员的他，体内有被保护得非常好的创造力，使得他拥有满腔的诗意与细腻的内心，更可以谱写出令人折服，引人共鸣，充满无限色彩的音乐作品。
三、
难在我们从未需要如此深刻了解世界
学编程，往往学的也不仅仅是计算机本身，而是将各行各业，结构力学，生物细胞，光学声学……等千百万个行业，抓住它们的重点，迅速理解并且教给CPU，让它代替人类工作。
尤其是身处信息时代，计算机是信息处理的核心，商业、农业、工业、教育等，都被计算机技术推动着进步，
如果能知道计算机是怎么做到这一切的，即知道这里蕴含的编程思维是什么，才能给个人在所处行业的发展带来帮助
。否则，就只能浮于表面地应用现成软件而已。
这是编程的第三难。应试教育标准化的课堂，正好背离了这点。从前的课堂里，为了实现教学效益化，将课程进行了划分。遗传学被归入了生物课，概率这个概念被归入了数学教育，然而遗传学实际上是对概率的应用。同理，物理明明需要应用代数和微积分，它却与这两门课程脱节，成了独立的学科。仿佛每个知识只存在于真空中，于外界事物毫无关联。这些划分限制了学生的理解，让学生对世间万物运行规律的理解产生了偏差。
于是，为了了解每个“独立”的知识，我们接收各种各样精细化加工的知识：推演好的理论、公式，讲义、ppt、难点总结、高分模板，我们无需知道这些公式是怎么推导出来的，只要运用公式去解题就好了。
四、
最后
所以，你说编程难吗？编程一点都不难，
用电脑听得懂的语言，告诉它帮你做你想要做的事情，只要认真学，谁都可以。
难就难在，""学以致考""和""学以致用""是不一样的；记忆和创造是不一样的；学好学科和理解世界是不一样的。
当然，并非要彻底否定应试教育。在中国教育资源极其不平均、经济文化撕裂的大生态下，以考试为目的的教育，提供了一套非常清晰的评判标准，通过分数这个显性的指标来筛选和划分学生群体，选拔出社会精英，可能是当下最公平的取舍了。
只是时代在不断的发展，无论是学校，家长还是孩子，都应该反思一下现在的所接受的教育形式，如何发挥出每一个孩子的个性，让他们成长为更好的人――学编程的过程会给你提供答案。","现有很多答案道出了大众进入编程领域难在哪里。换句话说，就是入门的难点。
我补充一下对于驰骋在编程战场上的人来说，真正的难点在哪里。
关于这一点，或许每一位将军的看法不同，但我比较赞成这句话：
There are only two hard things in Computer Science: cache invalidation and naming things.
 -- Phil Karlton
翻译过来就是：计算机科学有两大难点――缓存失效和命名。
出处
bliki: TwoHardThings
?
martinfowler.com/bliki/TwoHardThings.html
至于为什么这么说，一言难尽，领悟的人自然懂得，没领悟的人要么是还没达到境界，要么是已经超越此境界了，当然也有自以为超越了此境界其实还没达到境界的……
好了，我要继续这周还没完成的工作了――想想我接下来要写的这个模块应该叫什么名字……","其实不是太能理解所谓 好多语言就算学很久也可能不会 的说法……
――――――――――――――――――――――――――――――――――
声明变量、函数、类、接口、常量
顺序、循环、判断
赋值、调用、实例化、继承、实现(接口)、引用、反射
除此之外一门语言还有什么东西呢……
为什么会很难学会呢？
比如 php（
https://www.
zhihu.com/question/3907
8661/answer/109436356
）
――――――――――――――――――――――――――――――――――
我觉得很多人觉得编程难……大概是难在不知道怎么处理问题吧……
面对一个问题的时候，怎么去分析他、怎么去拆分层次，怎么把每个层次写成程序。
这其中就涉及到了很多思想的问题，而和语言无关了……
算法、
设计模式
、数据结构、面向过程/对象/切面 、数据驱动……
环境、外部依赖调用、协议 、数据库、缓存、分布式、大数据……"
,,,,,,,,,,,,,,,,,,,,,
身为程序员碰到最奇葩的需求是怎样的？,"镜像问题：身为设计师碰到最奇葩的需求是如何的？
身为设计师碰到最奇葩的需求是如何的？
8444 关注 ・ 813 回答
问题","就最近，部门老大找到我：你，做个微信小游戏吧。
我：啥样的？
老大：emmmm，反正你就做个微信小游戏吧，现在这个火
我：？？？？？？(黑人问号脸)
读了几天文档，靠着面向搜索引擎完成了，居然还得到了老大的肯定。
为了庆祝一下，当天我就奢侈了一把，找了家附近的麦当劳：你好，我要一份麦当劳。","1 某领导：从本月开始，网站响应时间每个月减少0.5秒，计入技术部KPI。
  我：？？？？？负数响应时间咋做到？？？？
2 某领导：我们网站故障率太高，下个月开始正常运营时间要达到99%以上！！！
  我：哦，上个季度一共宕机30分钟，看来还有很多额度可以用啊。
3 某领导：这个视频，剪辑成四部分，第一部分让人免费看，第二部分要回答问题才能看，第三部分弹出页面让用户填写邮箱，我们发个邮件给他，让他在邮件里点开才能看，第四……
  我已经无视下面的话了，哪个受虐狂用户会看到第四部分啊？你以为你放的是毛片吗？
另外我发现不光我这，别的回答也有类似的评论：
“说这些之前不妨想想他是怎么成为你的领导的”
我知道有些鸡汤总说：“存在即合理”、“走到这个位置的人必有可取之处”。
但被洗脑的人从来不自己思考一下，这个“可取之处”你是能学还是能练啊？
然后勤学苦练弯道超车升上高位报复回去？？？
这是网络小说看多了还是国产都市剧看多了呢
那我举几个例子，鸡汤众练一下吧。
我某个领导，是老板的妈，谁来学一下？
某领导，有从龙之功，跟了老板二十多年，都没提过涨工资，谁来练一下？
讲点实际生活中的段子，大家乐呵一下就算了。
那些灌了两口鸡汤就四处阴阳怪气的人，我实在是不待见。","有一天公司老大找我，说：“给app做个功能吧。”
“好的，需要添加什么功能呢？”
“玩过知乎吗？”
我谨慎地点了点头，说：“玩过。”
“嗯，玩过就好，知乎有个推荐功能用过吧？”
听到这里，突然有种不好的预感，但我还是乖乖地回答道：“嗯，这个功能挺好用的。”
“既然你用过的话，就给咱们的app文章部分也增加一个推荐功能吧！”
我用满怀惊讶又不敢否定的语气回答道：“嗯，行。是所有的文章都在要应用到推荐范围里吗？”
这时，老大不耐烦地说道：“就是推荐功能吗，你又不是没用过，要做成什么样，参照知乎的就可以了嘛！这事就交给你了。”
我对老大的语气早已习以为常。然后又问了句，“就我一个人做吗？”
老大用很肯定的表情点了点头，“对，就你一个人做就行了，这又不难。”
“可是。。”，我还想再说些什么，但老大已经转身离开，连给我辩驳的机会都不给，只留下我一人在风中凌乱。","讲两个真事儿。。
先交代背景：
曾经呆过一家小公司，做一个Web系统，主要工作内容是伺候某官府的老爷们，那帮老爷年龄基本都大了，有些Windows基本操作都困难。。
需求1：
某天一位老爷打电话过来。。。
老爷：你们网站上下载的Word文档怎么没有后面的？
我：（一脸蒙圈） 请问什么后面的？
老爷：就是文件下载下来，名字后面的那个。
我：请问您指的是文件的扩展名吗？就是Word文件结尾上的.doc？
老爷：对对对，就是那个。
我：这个可能是因为您系统设置了不显示扩展名导致的，如果想显示，可以在“文件夹选项”，..........（此处省略N字）
老爷：你TM怎么那么多废话，问题给你说清楚了，赶紧解决一下。
电话挂断。
后来，我纠结良久，默默的改了下载文档的链接，在
.doc
后面又加了一个
.doc
，后来你会看到目录里有一堆
“
***.doc.doc
”
。。
需求2：
某页面有个很普通的“人员信息录入”的表单，很普通很正常的那种。
老爷们觉得不好看，但是又说不清具体哪里不好看。(不好看 * 1)
来来回回各种改UI，各种改交互，风格。N多版本过去。老爷们还是觉得不好看。(不好看 * N)
想让老爷们提供个好看的例子，也一直提供不出来。
后来项目领导拜访老爷们，进行了正常和非正常的公关后，才请教清楚了这个问题，理由很雷人。
老爷们觉得“姓名”的文本框是个方框，不愿意把自己的名字填在方框里，因为只有狗带的人名才放在方框里。
最后终于在干掉了文本框边框，只留下方一条线后，顺利交付了这个功能。","客户：做个百度几千块够不够？
程序员：不够的！
客户：一万够了吧?
程序员：不够的!
客户：就那么几个页面，我做一个淘宝也只才几千块，你是不是坑我?
程序员：你找到了可以做的麻烦介绍给我，我也想做一个。。。","当时还在大学里，接了个私活，给一小公司做个库存管理系统
做完验收通过后，我把源代码，工具，安装包，文档等刻了张光盘给那边的老板，说这里面是源码安装包和文档，很重要哈，我自己很快要毕业了，后面自己电脑里不一定会留这些，你们要注意保存好，别弄丢了。
老板第二天上午又来找我了，说光盘拿回加里的DVD上没法播放，里面的文档和代码没法看，想想办法
文档也不多，我就直接在自己的打印机上打出来给他了，结果他还不走
我就问他还有啥事
他说文档是可以看了，代码没法看呢，厂里有小伙子想学，要不你把代码也弄一下让我能看？
我说可以，然后就写了个小工具，把源代码包里的内容按照名称，路径等导入到了word里面，因为前后端代码没有做分离，生成了前后端源码，和配置文件和数据库脚本等数百个word文档，然后把这些个word文档都拷贝到U盘里，然后告诉他说你拿回去在电脑里可以用office就可以看了，不用装IDE，不过如果要改代码的话，还是要装开发环境，用IDE来进行二次开发。
然后老板就走了，我以为就结束了
晚上我下楼吃饭，结果看到老板扛了个蛇皮袋往他的摩托车上捆扎，看到我就给我打招呼，我说你这袋子里装的什么呀，这么沉。他嘿嘿一笑：我把你给我的源代码都打印出来了，里面还有一袋子…
――――――
其实完全没有说那个老板怎么怎么样的意思，那一辈人的心思其实是非常朴实的，就是我花了不小的一笔钱买你的软件，总得让我看到点什么，就一张光盘确实不踏实，打印出来了看的那么多沉甸甸的两大袋子，就觉得心里踏实，值了。那时候四十多五十的人用电脑打字都是
二指禅
，他自己想一下要是自己去敲这么多文字估计要好几年。
但其实绝大部分代码都是开源组建或者自动生成的，那时候js也没有压缩，看起来几千行的一个代码文件其实只是css，或者一个js的日历控件，或者一个sql的初始化数据什么的，写业务逻辑的业务代码和核心代码也就四五万行，二次开发的话真正要看的也就一万行左右的代码，再看api就好了。
心里是很敬重那一代人的，踏踏实实的做生意，即使是一个完全不懂得行业，也要想办法弄懂一些。","电梯软件设计。
有一次接到一个电话：“胃，赵工哈？我们这里有块电路板不小心烧了，您看看改改软件能给改好不。”
？？？","实习公司有一个甲方提供的外包管理系统
老板想要该系统中的一个数据
但是这个数据甲方在系统中是加密存储的
不提供给我们公司
领导:那个运维啊，你来把他的系统破解了，要不把他服务器黑了也行。给你一天时间，搞不搞得定。","8.25更，虽然之前也发过一两个回答但都沉了，还算是个小透明吧，所以这次能破4k我真的很谢谢大家的喜爱，。
愿有脑洞的人不被世俗压垮。
我觉得应该把这个回答列为评论比回答精彩系列。
个人表示超级喜欢这种头脑风暴的，一个脑洞引发的无数脑洞。评论里手电的那个点子我觉得比这个还秀了。
看到评论区大体上风起和谐我也就很欣慰了  
原文如下
说一个奇葩的idea啊，大一那年学校里让报互联网+比赛一个奇葩同学出的奇葩idea。
他问我们导师共享单车算不算互联网+，导师说算的算的。ok，于是他感到思如泉涌，也决定搞一个共享新模式――――共享座机！！！！
没有，你没有看错，共享座机！！！！
当时他提出来的时候大家没觉得有什么不妥。觉得还算个中规中矩的idea。于是导师也同意了，他就开始各种搜集资料，写市场需求，写前景，材料都写的差不多了，突然有人来问
――你们怎么盈利啊？
――和共享单车一样啊，扫码啊。
――用什么扫啊？
――你脑残吧，当然用手机扫了。
――哦，打扰了。
于是那人呵呵一笑，转身而去，十分潇洒(当然，是我加的镜头)
然后我同学还问我怎么了？有什么不对的？那个人有病吧。
后来那个奇葩知道问题所在以后，气的没把自己电脑砸了，又气又乐。","当初刚毕业进公司做网站，给政府部门搞个门户网站，他们居然要搞个网上商城…
尼玛还要跟淘宝那样的…
那你们干脆去淘宝开店好吗…
最后简单搞了个购物车…
弄了个淘宝的接口…
然后又来了……
搞个论坛…
给他们的所谓会员吹逼用…
又考虑政治敏感…
又怕别人瞎发表什么不和谐言论搞的自己吃鳖…
要求敏感字过滤…
时间要求还特别急…
就我一个人开发…
得了…
我一顿忽悠…
百度贴吧建了个贴吧…
管理员给您…
您随便玩…","可能有点偏题，一朋友的号让我挂几天，然后……嗯，50的需求（没骂娘，但心里快憋出一口老血）
嗯，整体框架好歹总要有的吧？
数据库好歹也要有一个吧？
扫码响应后台提示总要有吧？
后台管理账号应该不能少吧？
设备种类，办公区，办公室，工位总要架构保存一下吧？
不考虑美工因数，这些活从数据库构库到码代码功能实现，我觉得如果是像我能吃不能干的这种人没有半天时间是下不来的。但他的需求是50搞定……","收到这个多赞惊呆了。故事的结尾是，我拔下了自己家里电脑的4G内存，给阿姨组了6G。我自己本身是8+4的组合。当然没收阿姨钱，毕竟是邻居。
***************
华丽丽的分割线
*************
真事。去年过年回家，领居阿姨敲我家门。
阿姨：听你妈妈说你很会电脑啊。
我：会一点点吧。
阿姨：我电脑特别卡，你能帮你看看嘛吗？
我看了一下，发现东西很乱，配置也很老了，2G内存装个64位的win8，也不知道是哪个坑给装的机（台式）。我看着处理器还是个i3，觉得还行，升级下应该就可以。
我：阿姨，你这个内存太小了，升级下，硬盘升级成固态的也会快很多，您再看看您有没有什么重要的东西， 备份一下，我给你重装个系统。
阿姨：这个要多久能弄好啊。
我：准备好的话半个小时就可以了。
阿姨：半小时就能弄好啊，那你帮阿姨弄一下吧，这要是搬到电脑城至少要50块钱吧。半小时阿姨就不留你吃午饭了啊。
我：.....","不请自答。
多年前，刚入行时的事情，一个sencha touch的项目，运行于IPAD。
光标点到输入框里是会闪烁的。
然后，我的甲方说，我觉得它闪的有点慢，让他闪快点......
年幼的我一脸懵逼，不知所措。
--------------------------------  补充  ------------------------------
有人评论问最后怎么解决的。 
当然是把他拽到厕所打了一顿啊...  哈哈哈哈哈 
开玩笑啦。   沟通了一下，他就打消这个念头了。
补充另外一个好玩的事儿，我同事遇到的。
某项目UAT日常例会。
甲方：“xxx功能有问题，和我想的不一样。”
我同事：“不好意思，这个问题我们排查过，是因为浏览器不支持。”
甲方：“浏览器是谁做的。”
我同事：“谷歌。”
甲方：“谷哥是谁，把他给我叫来！”
我同事 ---->>
---------------------------------  我好像是分割线  ------------------------------------
讲了两个工作中遇到的小事，得到这么多赞，挺开心的。
评论里，有人觉得好玩，有人觉得我胡扯，有人来探讨技术，有人要强行装一波13......
大家开心就好。
故事是真的，这点我可以保证。至于技术细节，还是别问我了。 毕竟我已经好多年不写代码了。不过，我依然觉得程序员是世界上最有意思的职业。",是时候祭出这张图了,"接手替硬件部门写的一个系统，同事离职了，烂摊子到了我的头上。
下午两点。刚从
svn
下好代码，连数据库文档都没来得及看，硬件部门老大过来拍了一下我的肩膀，“就麻烦你做了，我出去了。”
我不明觉厉，只能点了点头。
下午三点。硬件部门老大打了个电话过来，“升级没有?”
升级?wtf?怎么都是普通话，我却听不懂。
三点-五点陆陆续续接了无数个他的电话，“搞完了没有，还有多久?”“现场一群人等着呢”“客户都要生气了”
当时我弄懂事情真相之后，手一抖键盘都差点摔了。
终于体会到关谷神奇说的，出版社通知了发行商通知了记者，就是没有通知作者下周出版漫画，这是一种多可怕的情景。
两点下好代码，没有咨询过你做新需求要多久，直接就去见客户演示产品了，这心得多大。","   之前公司领导，突发奇想找了我们三个开发人员商量，想要把没有建筑高程数据的地图影像通人工智能算法，识别太阳光照的阴影，识别出所有建筑，并计算出所有建筑的长宽高，然后用3D模型替换掉，变成三维的场景。讲的那个叫激情澎湃呀。前景多么敞亮。
  当时我心一草原的草泥马，谷歌就缺你这么一个产品经理，给你五个人你就能绘出整个宇宙。
  但是呢，居然让我带头做这件事。好吧，陪太子读书的活给我了。我盯了一下午地图，心里在想，我要是做出来，谷歌地图，百度地图，高德地图......都得倒闭，不行，我不能那么缺德。
  然后第二天，新来一个地理科学专业的实习生。然后我们领导转念一想，这个专业对口，可能分分钟做出来。然后我们领导又把大纛交给他了。这才对嘛，这么伟大而又具有创造性的软件需要交给可爱的实习生。
  然后过年后我和实习生相继辞职。","做了10多年的BIOS和FW。某一天一亲戚打电话给我，说他有个朋友公司做了块板子，固件一直又问题，让我帮他重写一套，改天请我吃饭。我一听就觉得不妙，婉拒了，跟他说我已经两年多没写过代码了，可以介绍一个朋友给他，专门做外包的。
后来做外包的朋友跟我吐槽，亲戚的朋友带了一块工控板，让他重写个BIOS。我朋友看了之后，给了个友情价，8万，对方一脸懵逼的问，写个程序还要钱？","说一个同学的经理。
我这个同学做android 的。
在指纹识别还是苹果一家独大，其他Android厂商还未进入指纹时代的时候。
他的产品经理跟他说：“我们的应用要加上屏幕指纹之别功能！”
我同学一脸懵逼，问产品经理：“有样子么？可以想办法仿一个。”
产品经理：“应该很简单的，等下我给你发一个”
几分钟以后，我同学收到一个App，装上，运行。
屏幕上出现了一个类似这样的界面（当时我同学给我看的那个图找不到了，随便找了个类似的）
图侵删
然后手指按在屏幕上，会有一个扫描的动画效果，然后APP就打开了，
产品经理说：“这不就是指纹识别么！应该挺好做的”
我同学：“..............”
2018-6-21日更新
昨天跟我的那个同学吃饭去了。
据说那个做指纹识别的产品经理已经离职了，换了个一样有想法的产品经理
产品经理：“你能不能让这个App（他们公司的一个外包项目）有5%几率闪退？”
我同学：“为什么？现在稳定运行不是挺好的么？”
产品经理：“你是不是傻，项目有瑕疵才能管甲方要钱继续修改！”
后来据说又圈了不少钱，然后把强制闪退的代码去掉了就完事了....
其实想回来，某雷，某度的VIP下载加速不是也是类似套路么。
2018-7-1更新
今天跟另外一个做Java兼DBA的同学聊了下奇葩的PM，这个同学（简称G吧）也给我讲了一个他那的段子。
有一天PM找到他：“XX那个项目，有个数据要改。”PM递给他一个U盘“这里有个Excel，有十几条数据，给插到数据库里就行。”
G同学：“你确定是插进去就行吗？”
PM：“对，插到数据库里就行”
G同学花了十几分钟搞定了数据，几分钟后PM电话追过来：“你这个数据还没改好啊？！”
G同学一脸懵逼：“改了啊，这几条数据都插进去了啊。”
PM：“那原来的数据怎么还在啊！”
G同学……WTF……然后花了20分钟跟PM解释什么叫叫插入，什么叫替换
2018-7-10更新
几天没看赞已经500+了？让我有点受宠若惊。第一次获得这么多赞
集中回答几个评论中的问题
1、你们怎么都那么关心那个G...那个啥是吧...真的不是我污，我写的时候真心没有意识到这个，好吧好吧，我承认是我污了，还好我同学姓氏第一个字母是G，他要是姓纪，姓金...那画面美得我不敢想象，但是我就是不改！你们来咬我啊。
2、关于闪退那个段子的真实性，我也是听说来的，具体是不是杜撰的我也不知道。这个曾经的确是听著名的一个段子，但是段子传广了，就慢慢的成了部分无良产品经理的圈钱手段。现在业内的确有一些无良的公司在这么干。至于有不少人是怎么通过验收的，要知道很多公司的产品验收是做的很水的， 而且不少外包公司结了帐就不管了。
3、直接修改线上数据。其实在不少小的项目或者例如某些
规则引擎
的参数，在检查数据没有明显问题，是可以直接上线的。一个本来可能最多百十来用户的产品，你说搞测试，备份，热发布那一套...会不会有点大炮打蚊子的感觉？再说我也没说人家没做测试啊，没说人家把数据改到哪去啊，不要把自己的幻觉当成现实，谢谢。
好了问题先回答到这，说一个我自己的经历
大概是4年钱，我在一家国企的软件部门工作，当时公司接了另一个国企的网站翻新工作，分配到了我们的部门，因为原始网站是asp做的，需要全站翻新。
开这个项目过了几天，美工兼前端的妹子回家生孩子去了。然后作为一个萌新的我就莫名奇妙的兼起了前端的工作（还要妹子当时把设计都做完了）
当时甲方要求我们以天为单位，发布到一个对外的地址上，他们的工程师要实时查看我们的工作进度，并及时反馈问题。（这个就是你们最喜欢的超级负责的验收工程师）
然后你们常见的GIF就出现在了我这里，每半个到一个小时我就能接到一个电话，跟我说logo往左调点，大点，字体大点，黑点，...bulabula各种。
就是这种感觉
到这里还没完，在我受了他两周的电话轰炸以后，突然有一天没给我打电话，我还挺意外。
结果第二天我接到一个电话我彻底疯了
甲方：“你们这个页面做的有问题啊。我这看着怎么乱码啊？”
我：“应该不会啊，前天您不是还让我调样式呢么？也没有乱码啊。”
甲方：“但是我现在看的就是满屏的乱码！”
我吓得赶紧打开网站看看，即使清了缓存还是正常的：“您好，我这里看着是正常的啊。请请问您现在用的什么浏览器？”
甲方：“IE”
我：“哪个版本？”
甲方：“我看看啊...IE7”
我：“不好意思，这个项目是不兼容IE7及以下版本的。”
甲方：“那不行啊，XP怎么办？”
我：“您可以试试360浏览器的兼容模式”
甲方：“不行，你们就得给我兼容IE7”
我：“那可能比较困难，您为什么要兼容IE7？是在什么场景下有这个需求？”
甲方：“因为我的领导用的是XP，只会用IE7，所以必须兼容！”
我当时心里一万只草泥马狂奔而过：“.........稍后我们产品经历会给您回电话....”
后来，产品经理跟他们谈了好几天，最后还是同意给他们改兼容性，貌似是同意又给加了些钱。倒是非专业前端的我，加了2周的班，才给他们搞定了绝大多数的兼容性问题。
2018-7-18更新
我去，一周没看直接过了1.1K？慌得一批啊！第一次拿到过200赞（一个咨询转IT行业好不好的问题）！
但是我看了下评论...你们都是在关注G...咳...是么？这个真的不是你们想的那个东西...人家姓“郭”，来看我的口型G~U~O~guo。但是！原答案我就是不改~！
心声（误）：改了去哪圈那么多赞....
按道理说，收了那么多赞，应该再更几个段子...嗯...我检索一下我的大脑...貌似没那么多有趣的段子了。说一个不算多有意思的故事吧。
工作中我们收到的多数奇葩需求，一般源自于神游太空的产品经理，脑洞大开的甲方，还有一批就是审美异常的领导们。
向我这种小公司的程序员，一般都是当爹又当妈，除了不用管设计，剩下的从前端到后端，从架构到服务器都得管。
很久之前给一个郭嘉某政府部门做了一个网站，带一个人工服务的功能。这个功能直接用QQ的外链，比较简单。
一开始美工妹子设计的类似知乎网页右下角这个“建议反馈”这种定位元素。整个网站的风格也是扁平化设计（貌似事这么叫，如果说错了，美术专业的不要打我）。设计的至少我公司这边觉得还挺好看。
可是人家领导看了以后，觉得，一看不清楚，二不够显眼。让给改成满屏飘动的那种，然后把图标改成一个客服的头像....没错就是你们想的那种，都快看吐了的那个客服大姐满屏飘，明显感觉就是三流网站的套路。但是，人家领导喜欢啊。
美工妹子听完需求，就崩溃了...没办法，我自己瞎鼓捣鼓捣，给搞出来了。
后来又陆陆续续提了一堆的界面需求，诸如这个字不够明显改成初号金黄色啊。这个说明出现一次不够啊，出现3、4次啊...等等...反正改到最后，这个网站的感觉保持的一种非常诡异的效果。呃...想象一下
easyui
和bootstrap元素共存的感觉...
以至于后来面试去我都不好意思跟人家说这个网站的UI是我做的...（其实也没必要说，毕竟面的是后端）
2018-7-19更新
回答被同学看见了……果然程序员的圈子不大……用人家的段子就得提下人嘛，是吧 
@刘志远
 ","强势置顶补充！
嗯……本来名字已经打码了，后来这位顾客实在太凶了，所以拿出来给大家看一下，希望广大同行遇到此人快快退散
人类！互相伤害啊！哈哈。此回答只是为了给各位同行图个乐，加班之余过来吐槽，切莫上纲上线。
==============================
这个我必须要强答一波！
在淘宝接外包有3年多了，说实话程序猿干活凭手艺，做事凭良心。一个需求多少钱多长时间，实打实的告客户，有时候我自己多要100都觉得是不是要多了。
事情起因是，有一天我预订手办要结尾款，15号发工资，当天13号晚上，手办补款750，手头722.5，就差一点，当时想着找同事借一百就过去了，正好有个学生在淘宝咨询我要做个小游戏。
聊了半天说是要做个三消类的游戏，需求说了一堆，还挺要个样，一问给多少钱，说50…
对，你没看错，和热评那同行一样的价格！50！这大哥厉害啊，50块就敢提一堆需求还要明天就做完，谁给你的勇气？梁静茹么？
奇葩的是我特么接了！
这价钱也就对得起我去网上找个现成的大概替换下素材的份。
结果交活的时候这人直接说当时说是要两个游戏，还带个打飞机类型的游戏！还特么要源码！
大哥，两个项目都给你源码，再送您50个窜天猴，送您上西天怎么样？
最后？最后给了我个差评啊，还说我服务态度不好，呵呵，要服务好您去吃海底捞啊，有钱哪都好。
本人UE4和Unity项目大大小小在淘宝接了不少，3万的单子也没见过有这位50兄的自信，在下真是佩服
还是那句话，程序这东西，凭手艺吃饭，多少钱干多少活，程序真没你50兄想的那么容易。
==============================
更新一波，就在 刚刚！又遇到一个奇葩的需求！
放上截图供各位体会
名字打码了，以上信息真实可靠，绝无虚假
==============================
2018年7月6日再来更新一波
这位同学，你要是连文档都不会看，就别做编程和引擎的工作了。出门左转的饭店刷盘子的工作真的挺适合你的。
名字我就不打码了，希望各位看到此人速速退散，免得惹上一身麻烦。
打油诗出处：
==============================
竟然破100赞了，一只小程序猿不胜惶恐！
感谢各位大佬和有意向学unity的同行，希望能和大家多多交流技术，共同进步。
在这集中解答一下，当时补款就差一点钱，满脑子想的都是我能和我的二次元老婆团聚了，完全忘记项目风险这个问题，实在是不应该！希望各位同行能再给我一次重新做一只好程序猿的机会，我绝对不会再因为二次元老婆扰乱市场了_(：3 」∠ )_
附上一张同事帮我拍的无毛黑呆供各位兴趣相投的程序猿共同瞻仰
==============================
竟然破1K赞了，小小程序员何德何能，让同行如此抬爱。
感觉这个回答可以做成日常淘宝外包避坑手册，造福广大同行。
最后，本人在知乎申请了一个专栏，用来分享平常做项目遇到的一些坑和开发中有用的东西。注意！我的专栏不提供源代码和项目下载！想要代码就自己照着我的图敲一遍，对自己编程是有所提高的！
以下帮各位隔离开烦人的广告
…
…
…
…
…
…
…
…
…
…
…
…
…
…
…
…
…
…
…
…
…
_(：3 」∠ )_都说是隔离开广告了，真的没东西了…","多年前碰到一个“投资人”。
我看你骨骼清奇，定非凡人。
这样吧，跟我一起干一番大事业，我有一个idea，你呢发挥你的特长，我们一起把它做出来。
放心，我会用现金投资，你只管莽足劲干。。。省去千言万语。。。两万块钱，我们一起实现一个“淘宝”你看怎么样
以上就是我碰到的最奇葩的需求：两万块钱实现一个淘宝。
真人真事，11年的事。相信就差一个程序员这样的故事每天都在不同的角落里发生着。
最后，爱护程序员人人有责！！！"
,,,,,,,,,,,,,,,,,,,,,
如何系统地自学 Python？,"本题已加入圆桌
数据分析入门指南
，更多数据分析内容，欢迎关注圆桌>>>
零基础情况下，想学一门语言。另 《Python 编程入门经典》这本书怎么样，是否值得看？","0709更：
上周旁听了一个大学学长组织的线上Python交流会，里边不乏充斥着各位行业大牛，讲的内容确实精彩，可能对于Python经验5年+的人来说，是受益匪浅，欢迎程度极高，恨不得跳出屏幕来表示赞同，毕竟很多提到的问题，我在工作中也很常见，但是作为资历一般的程序员，有一些理解起来还是有些困难，评论区里同时也还有另外一种声音：
听不懂啊，还可以再细讲一些吗？
刚毕业，刚开始学Python，可以说说入门的吗？
走了走了，零基础满脸懵……
太难了，放弃Python了
我很能理解“另一种声音”，我当初也是自学Python，刚开始的时候，我连循环结构和分支结构都搞不明白谁是谁，去找有经验的人问，结果问了几回人家就烦了，所以，学习这种事，还是得靠自己。
根据我自己的经验来说，想从零开始学Python，以后也确实想找相关的工作，基本是下边这三种方式：
继续上学。报个这方面的专业，学上两三年，老师就在身边，有啥不懂的问题，直接办公室走一趟，毕业的时候去找工作不成大问题；
看书自学。这块可以看看我之前推荐的GitHub【Python百天之路】-骆昊，对细节把握很到位！
在网上找视频课自学。你可以利用碎片时间去学，时间上会更节省，我为了苦学Python大概买了十多门课吧。
读研读博这件事时间成本比较高，我对自己没有完全的自信，所以我思考再三，还是决定踏入社会浪潮了。（但是对于学习能力强，本科也比较优秀的学生，非常建议继续读研读博，未来踏入社会起薪会非常高，我现在身边就有两个博士大神，我只能膜拜了。。。）
进入社会之后，我基本就是买书和看视频自学，这回给你们来个全方位安利：
一、网站推荐
1、Python 
Python初学者的法宝，如果你想下载Python，最好还是在这个网址去下，不要想着用一些不明来源的安装包。在这里，你不仅可以下载各种版本的Python源代码和安装程序，更有各种文献资料、Python交流社区，还会告诉你Python的最新行情，不得不感叹，这功能太强大！
2、菜鸟教程
站内的知识点很全面，无论你想学习哪种领域，都可以轻松在这里找到合适的资料。
3、Codecademy
这个学习网站很大的优势就是在浏览器上直接编写代码，轻松解决了初学者程序环境安装的困扰。
4、Coursera
如果你英文比较好，交流没有问题的话，比较推荐这个网站。这是一个课程学习网站，内容涵盖编程各个领域，目前已经和200+所大学合作课程，还可以在线读学士、硕士学位。
5、CSDN
如果说你的英文是难题，给你推荐CSDN，是国内老牌程序员社区，里边有各领域博文、资料、课程，基本很多专业问题都可以在这里查。
二、书籍推荐
1、《笨办法学Python》
如果是初学Python的话，没有什么编程基础，还是比较适合从这本开始学的。整体是以习题的方式开始引导初学者学习编程。
2、《Python Cookbook》
这本书既有知识点的详细讲解，又有更多高阶用法的延伸，对于已经有一定基础但是掌握不牢的同学来说，无疑是值得拥有的好书。
3、《流畅的Python》
这本书对于Python的高级用法探究很深入，涵盖了数据结构、对象、并行与并发、元编程等多个方向。
三、课程推荐
其实，除了学习网站和书籍，我还在网易云课堂、51、慕课、CSDN学院买了不下10套关于Python入门的课，在得到也买了时间管理课。
我自己的话，因为我是想进行系统学习，也想节省一些学习时间，加上我也比较懒，非得有人督促着才能坚持不懈，所以我选了CSDN的Python训练营。
最近正在学习Python的进阶领域-AI，这回同样参与了一个训练营，深刻感受到监督使人进步！不为别的，也是希望自己以后的工作范围更广，也能跟上时代的脚步。
也许有人会问：“你干嘛把自己逼得那么紧，安安稳稳的不就很好了吗？”
作为一个人，如果长期处于一个舒适安逸的环境，慢慢就会被这种安逸笼罩，变得懒惰，原本拥有的能力也会逐步减弱，当有一天危险来临，所在的舒适圈被打破，连生存下去都是个难题！
所以，为了好好活下去，要不跳出舒适圈，要不就扩大你的舒适圈。
跳出舒适圈，意味着你要彻底离开现在的区域，也许是换个城市、换个工作、甚至换个行业，让自己重新拥有危机感，让新环境逼着你去成长；扩大舒适圈，就是让自己能生存的舒适范围更大，主动学习、提升你的能力。
我选择的是从零开始全方向提升，因为我想着，既然要痛苦，就直接痛苦这一次。上边就是我学过的系统课，内容很全，不过价格也相对更贵。
如果有的同学目前是打算一步一步慢慢来，或者之前已经有一些基础，只是想突破单个方向，下边这几门课程我也在刚接触Python的时候买来学的，价格更便宜，内容却丝毫不打折扣，是比较值得学习的！
1、基础知识
如果是毫无基础可言，甚至不知道如何下载Python， 比较推荐齐伟老师的《8小时Python零基础轻松入门》或者是
董付国
的《Python可以这样学》。细节全面，适合小白入门。
2、爬虫
这回是偏基础点的，之前也分享过两门，都可以进行参考。
3、数据分析
我买过两类数据分析课，零基础入门和多方位学习，现在直接发出来，也是为了方便不同需求的同学。
4、机器学习
说起人工智能讲的好的老师，必说
唐宇迪
（感觉真的霸榜各个学习平台）。
他是计算机的博士，好像还参与了挺多国家级项目，我听过几次他的课和直播，老师的讲课风格很幽默，经常会举例子，让你更清晰的搞懂知识点，我觉得自己是在学习中享受。
（基础知识配实战，这样学习起来相对也更容易）
今天先说到这里，下回我会跟大家细说这回学AI心酸与快乐，满心干货！
我的目标是进阿里，祝我幸运进阶！
更新：
有很多朋友私信问我Python学习有没有什么好的资料，我给大家找了几门不错的免费课，想学的可以看看。
《Python入门教程》
《Python初级入门精讲》
《Python爬虫开发》
《Python实战编程》
《1小时掌握Python爬虫+高效学习法则》
――――――――――――――――――――――――――――――――
更新：说明几个事
1.很多小伙伴纠结于这个一百天的时间，我觉得完全没有必要，也违背了我最初放这个大纲上来的初衷，我是觉得这个学习大纲还不错，自学按照这个来也能相对系统的学习知识，而不是零散细碎的知识最后无法整合，每个人的基础以及学习进度都不一样，没有必要纠结于一百天这个时间，甭管你是用三个月还是用一年来学习这些东西，最后学到了不就是收获吗？何必纠结于这一百天，觉得这一百天学习不完我就放弃了呢？（另，项目后面没有更新完，大家可以按照这个框架去学习，没有更新完的大家可以自行找资料。）
2.还有小伙伴说这是广告，那请这位项目创作者看见这条“广告”给我打钱。真的很没劲，这个项目多少人知道，在github上也非常火，火有火的道理，对于一些学习者来说的确很有参考价值。谁打广告不找个几万分的大V，来找我这个小弟弟？
更搞笑的还有说我是成都某机构培训老师？本人坐标北京谢谢，也不是什么老师，只是一名普普通通的程序员。自认为我的水平还担不起什么老师。
下面是原文：
Github上位名叫骆昊 (jackfrued) 的资深程序员，为大家规划了一条从“从新手到大师”的百天之路！我觉得这个模式你可以参考一下。
现在已经有5w+星了！
给初学者的几个建议：
Make English as your working language.
Practice makes perfect.
All experience comes from mistakes.
Don't be one of the leeches.
Either stand out or kicked out.
先附上github地址：
下面是这个一百天计划里面的学习框架，我在这里放上来。
Day01~15 - 
Python语言基础
Day01 - 
初识Python
Python简介 - Python的历史 / Python的优缺点 / Python的应用领域
搭建编程环境 - Windows环境 / Linux环境 / MacOS环境
从终端运行Python程序 - Hello, world / print函数 / 运行程序
使用IDLE - 交互式环境(REPL) / 编写多行代码 / 运行程序 / 退出IDLE
注释 - 注释的作用 / 单行注释 / 多行注释
Day02 - 
语言元素
程序和进制 - 指令和程序 / 
冯诺依曼机
 / 二进制和十进制 / 八进制和十六进制
变量和类型 - 变量的命名 / 变量的使用 / input函数 / 检查变量类型 / 类型转换
数字和字符串 - 整数 / 浮点数 / 复数 / 字符串 / 字符串基本操作 / 字符编码
运算符 - 数学运算符 / 赋值运算符 / 比较运算符 / 逻辑运算符 / 身份运算符 / 运算符的优先级
应用案例 - 
华氏温度
转换成摄氏温度 / 输入圆的半径计算周长和面积 / 输入年份判断是否是闰年
Day03 - 
分支结构
分支结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图
if语句 - 简单的if / 
if-else结构
 / if-elif-else结构 / 嵌套的if
应用案例 - 用户身份验证 / 英制单位与公制单位互换 / 掷骰子决定做什么 / 百分制成绩转等级制 / 分段函数求值 / 输入三条边的长度如果能构成三角形就计算周长和面积
Day04 - 
循环结构
循环结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图
while循环 - 基本结构 / break语句 / continue语句
for循环 - 基本结构 / range类型 / 循环中的分支结构 / 嵌套的循环 / 提前结束程序
应用案例 - 1~100求和 / 判断素数 / 猜数字游戏 / 打印九九表 / 打印三角形图案 / 猴子吃桃 / 百钱百鸡
Day05 - 
构造程序逻辑
基础练习 - 水仙花数 / 
完美数
 / 五人分鱼 / 
Fibonacci数列
 / 回文素数
综合练习 - Craps赌博游戏
Day06 - 
函数和模块的使用
函数的作用 - 代码的坏味道 / 用函数封装功能模块
定义函数 - def语句 / 函数名 / 参数列表 / return语句 / 调用自定义函数
调用函数 - Python内置函数 / 导入模块和函数
函数的参数 - 默认参数 / 可变参数 / 关键字参数 / 命名关键字参数
函数的返回值 - 没有返回值 / 返回单个值 / 返回多个值
作用域问题 - 局部作用域 / 嵌套作用域 / 全局作用域 / 内置作用域 / 和作用域相关的关键字
用模块管理函数 - 模块的概念 / 用自定义模块管理函数 / 命名冲突的时候会怎样（同一个模块和不同的模块）
Day07 - 
字符串和常用数据结构
字符串的使用 - 计算长度 / 下标运算 / 切片 / 常用方法
列表基本用法 - 定义列表 / 用下表访问元素 / 下标越界 / 添加元素 / 删除元素 / 修改元素 / 切片 / 循环遍历
列表常用操作 - 连接 / 复制(复制元素和复制数组) / 长度 / 排序 / 倒转 / 查找
生成列表 - 使用range创建数字列表 / 生成表达式 / 生成器
元组的使用 - 定义元组 / 使用元组中的值 / 修改元组变量 / 元组和列表转换
集合基本用法 - 集合和列表的区别 / 创建集合 / 添加元素 / 删除元素 / 清空
集合常用操作 - 交集 / 并集 / 差集 / 对称差 / 子集 / 超集
字典的基本用法 - 字典的特点 / 创建字典 / 添加元素 / 删除元素 / 取值 / 清空
字典常用操作 - keys()方法 / values()方法 / items()方法 / setdefault()方法
基础练习 - 跑马灯效果 / 列表找最大元素 / 统计考试成绩的平均分 / Fibonacci数列 / 
杨辉三角
综合案例 - 双色球选号 / 井字棋
Day08 - 
面向对象编程基础
类和对象 - 什么是类 / 什么是对象 / 面向对象其他相关概念
定义类 - 基本结构 / 属性和方法 / 构造器 / 析构器 / __str__方法
使用对象 - 创建对象 / 给对象发消息
面向对象的四大支柱 - 抽象 / 封装 / 继承 / 多态
基础练习 - 定义学生类 / 定义时钟类 / 定义图形类 / 定义汽车类
Day09 - 
面向对象进阶
属性 - 类属性 / 实例属性 / 属性访问器 / 属性修改器 / 属性删除器 / 使用__slots__
类中的方法 - 实例方法 / 类方法 / 静态方法
运算符重载 - __add__ / __sub__ / __or__ /__getitem__ / __setitem__ / __len__ / __repr__ / __gt__ / __lt__ / __le__ / __ge__ / __eq__ / __ne__ / __contains__
类(的对象)之间的关系 - 关联 / 继承 / 依赖
继承和多态 - 什么是继承 / 继承的语法 / 调用父类方法 / 方法重写 / 类型判定 / 多重继承 / 
菱形继承
(钻石继承)和C3算法
综合案例 - 工资结算系统 / 图书自动折扣系统 / 自定义分数类
Day10 - 
图形用户界面和游戏开发
使用tkinter开发GUI
使用pygame三方库开发游戏应用
“大球吃小球”游戏
Day11 - 
文件和异常
读文件 - 读取整个文件 / 逐行读取 / 文件路径
写文件 - 覆盖写入 / 追加写入 / 文本文件 / 二进制文件
异常处理 - 异常机制的重要性 / try-except代码块 / else代码块 / finally代码块 / 内置异常类型 / 异常栈 / raise语句
数据持久化 - CSV文件概述 / csv模块的应用 / JSON数据格式 / json模块的应用
Day12 - 
字符串和正则表达式
字符串高级操作 - 转义字符 / 原始字符串 / 多行字符串 / in和 not in运算符 / is开头的方法 / join和split方法 / strip相关方法 / pyperclip模块 / 不变字符串和可变字符串 / StringIO的使用
正则表达式入门
 - 正则表达式的作用 / 元字符 / 转义 / 量词 / 分组 / 零宽断言 /贪婪匹配与惰性匹配懒惰 / 使用re模块实现正则表达式操作（匹配、搜索、替换、捕获）
使用正则表达式 - re模块 / compile函数 / group和groups方法 / match方法 / search方法 / findall和finditer方法 / sub和subn方法 / split方法
应用案例 - 使用正则表达式验证输入的字符串
Day13 - 
进程和线程
进程和线程的概念 - 什么是进程 / 什么是线程 / 多线程的应用场景
使用进程 - fork函数 / multiprocessing模块 / 进程池 / 进程间通信
使用线程 - thread模块 / threading模块 / Thread类 / Lock类 / Condition类 / 线程池
Day14 - 
网络编程入门和网络应用开发
计算机网络基础 - 计算机网络发展史 / “TCP-IP”模型 / IP地址 / 端口 / 协议 / 其他相关概念
网络应用模式 - “客户端-服务器”模式 / “
浏览器-服务器
”模式
基于HTTP协议访问网络资源 - 网络API概述 / 访问URL / requests模块 / 解析JSON格式数据
Python网络编程 - 套接字的概念 / socket模块 / socket函数 / 创建TCP服务器 / 创建TCP客户端 / 创建UDP服务器 / 创建UDP客户端 / SocketServer模块
电子邮件 - SMTP协议 / POP3协议 / IMAP协议 / smtplib模块 / poplib模块 / imaplib模块
短信服务 - 调用短信服务网关
Day15 - 
图像和文档处理
用Pillow处理图片 - 图片读写 / 图片合成 / 几何变换 / 色彩转换 / 滤镜效果
读写Word文档 - 文本内容的处理 / 段落 / 页眉和页脚 / 样式的处理
读写Excel文件 - xlrd模块 / xlwt模块
生成PDF文件 - pypdf2模块 / reportlab模块
Day16~Day20 - 
Python语言进阶
常用数据结构
函数的高级用法 - “一等公民” / 高阶函数 / Lambda函数 / 作用域和闭包 / 装饰器
面向对象高级知识 - “三大支柱” / 类与类之间的关系 / 垃圾回收 / 魔术属性和方法 / 混入 / 元类 / 面向对象设计原则 / GoF设计模式
迭代器和生成器 - 相关魔术方法 / 创建生成器的两种方式 /
并发和异步编程 - 多线程 / 多进程 / 异步IO / async和await
Day21~30 - 
Web前端入门
用HTML标签承载页面内容
用CSS渲染页面
用JavaScript处理交互式行为
jQuery入门和提高
Vue.js入门
Element的使用
Bootstrap的使用
Day31~35 - 
玩转Linux操作系统
操作系统发展史
和Linux概述
Linux基础命令
Linux中的实用程序
Linux的文件系统
Vim编辑器的应用
环境变量和Shell编程
软件的安装和服务的配置
网络访问和管理
其他相关内容
Day36~40 - 
数据库基础和进阶
关系型数据库MySQL
关系型数据库概述
MySQL的安装和使用
SQL的使用
DDL - 数据定义语言 - create / drop / alter
DML - 数据操作语言 - insert / delete / update / select
DCL - 数据控制语言 - grant / revoke
相关知识
范式理论
 - 设计二维表的指导思想
数据完整性
数据一致性
在Python中操作MySQL
NoSQL入门
NoSQL概述
Redis概述
Mongo概述
Day41~55 - 
实战Django
Day41 - 
快速上手
Web应用工作原理和HTTP协议
Django框架概述
5分钟快速上手
使用视图模板
Day42 - 
深入模型
关系型数据库配置
管理后台的使用
使用ORM完成对模型的CRUD操作
Django模型最佳实践
模型定义参考
Day43 - 
静态资源和Ajax请求
加载静态资源
用Ajax请求获取数据
Day44 - 
表单的应用
表单和表单控件
跨站请求伪造和CSRF令牌
Form和ModelForm
表单验证
Day45 - 
Cookie和Session
实现用户跟踪
cookie和session的关系
Django框架对session的支持
视图函数中的cookie读写操作
Day46 - 
报表和日志
通过HttpResponse修改响应头
使用StreamingHttpResponse处理大文件
使用xlwt生成Excel报表
使用reportlab生成PDF报表
使用ECharts生成前端图表
配置日志和Django-Debug-Toolbar
Day47 - 
中间件的应用
什么是中间件
Django框架内置的中间件
自定义中间件及其应用场景
Day48 - 
前后端分离开发入门
返回JSON格式的数据
用Vue.js渲染页面
Day49 - 
RESTful架构和DRF入门
Day50 - 
RESTful架构和DRF进阶
Day51 - 
使用缓存
网站优化第一定律
在Django项目中使用Redis提供缓存服务
在视图函数中读写缓存
使用装饰器实现页面缓存
为数据接口提供缓存服务
Day52 - 
文件上传和富文本编辑
文件上传表单控件和图片文件预览
服务器端如何处理上传的文件
富文本编辑器
概述
wangEditor的使用
Day53 - 
短信和邮件
常用短信网关平台介绍
使用螺丝帽发送短信
Django框架对邮件服务的支持
Day54 - 
异步任务和定时任务
网站优化第二定律
配置消息队列服务
在项目中使用celery实现任务异步化
在项目中使用
celery
实现定时任务
Day55 - 
单元测试和项目上线
Python中的单元测试
Django框架对单元测试的支持
使用版本控制系统
配置和使用uWSGI
动静分离和Nginx配置
配置HTTPS
Day56~60 - 
实战Flask
Day56 - 
Flask入门
Day57 - 
模板的使用
Day58 - 
表单的处理
Day59 - 
数据库操作
Day60 - 
项目实战
Day61~65 - 
实战Tornado
Day61 - 
预备知识
并发编程
I/O模式和事件驱动
Day62 - 
Tornado入门
Tornado概述
5分钟上手Tornado
路由解析
请求处理器
Day63 - 
异步化
aiomysql和aioredis的使用
Day64 - 
WebSocket的应用
WebSocket简介
WebSocket服务器端编程
WebSocket客户端编程
项目：Web聊天室
Day65 - 
项目实战
前后端分离开发和接口文档的撰写
使用Vue.js实现前端渲染
使用ECharts实现报表功能
使用WebSocket实现推送服务
Day66~75 - 
爬虫开发
Day66 - 
网络爬虫和相关工具
网络爬虫的概念及其应用领域
网络爬虫的合法性探讨
开发网络爬虫的相关工具
一个爬虫程序的构成
Day67 - 
数据采集和解析
数据采集的标准和三方库
页面解析的三种方式：正则表达式解析 / XPath解析 / CSS选择器解析
Day68 - 
存储数据
如何存储海量数据
实现数据的缓存
Day69 - 
并发下载
多线程和多进程
异步I/O和协程
async和await关键字的使用
三方库aiohttp的应用
Day70 - 
解析动态内容
JavaScript逆向工程
使用Selenium获取动态内容
Day71 - 
表单交互和验证码处理
自动提交表单
Cookie池的应用
验证码处理
Day72 - 
Scrapy入门
Scrapy爬虫框架概述
安装和使用Scrapy
Day73 - 
Scrapy高级应用
Spider的用法
中间件的应用：下载中间件 / 蜘蛛中间件
Scrapy对接Selenium抓取动态内容
Scrapy部署到Docker
Day74 - 
Scrapy分布式实现
分布式爬虫的原理
Scrapy分布式实现
使用Scrapyd实现分布式部署
Day75 - 
爬虫项目实战
爬取招聘网站数据
爬取房地产行业数据
爬取二手车交易平台数据
Day76~90 - 
数据处理和机器学习
Day76 - 
机器学习基础
Day77 - 
Pandas的应用
Day78 - 
NumPy和SciPy的应用
Day79 - 
Matplotlib和数据可视化
Day80 - 
k最近邻(KNN)分类
Day81 - 
决策树
Day82 - 
贝叶斯分类
Day83 - 
支持向量机(SVM)
Day84 - 
K-均值聚类
Day85 - 
回归分析
Day86 - 
大数据分析入门
Day87 - 
大数据分析进阶
Day88 - 
Tensorflow入门
Day89 - 
Tensorflow实战
Day90 - 
推荐系统
Day91~100 - 
团队项目开发
第91天：
团队项目开发准备
软件过程模型
经典过程模型（瀑布模型）
可行性分析（研究做还是不做），输出《可行性分析报告》。
需求分析（研究做什么），输出《需求规格说明书》和产品界面原型图。
概要设计和详细设计，输出概念模型图、物理模型图、类图、时序图等。
编码 / 测试。
上线 / 维护。
敏捷开发（Scrum）- 产品所有者、Scrum Master、研发人员 - Sprint
产品的Backlog（用户故事、产品原型）。
计划会议（评估和预算）。
日常开发（站立会议、番茄工作法、结对编程、测试先行、代码重构……）。
修复bug（问题描述、重现步骤、测试人员、被指派人）。
评审会议（Showcase）。
回顾会议（当前周期做得好和不好的地方）。
补充：敏捷软件开发宣言
个体和互动
 高于 流程和工具
工作的软件
 高于 详尽的文档
客户合作
 高于 合同谈判
响应变化
 高于 遵循计划
角色：产品所有者（决定做什么，能对需求拍板的人）、团队负责人（解决各种问题，专注如何更好的工作，屏蔽外部对开发团队的影响）、开发团队（项目执行人员，具体指开发人员和测试人员）。
准备工作：商业案例和资金、合同、憧憬、初始产品需求、初始发布计划、入股、组建团队。
敏捷团队通常人数为8-10人。
工作量估算：将开发任务量化，包括原型、Logo设计、UI设计、前端开发等，尽量把每个工作分解到最小任务量，最小任务量标准为工作时间不能超过两天，然后估算总体项目时间。把每个任务都贴在白板上面，白板上分三部分：to do（待完成）、in progress（进行中）和done（已完成）。
项目团队组建
团队的构成和角色
说明：谢谢付祥英女士绘制了下面这张精美的公司组织架构图。
编程规范和代码审查（flake8、pylint）
Python中的一些“惯例”（请参考
《Python惯例-如何编写Pythonic的代码》
）
影响代码可读性的原因：
代码注释太少或者没有注释
代码破坏了语言的最佳实践
反模式编程（意大利面代码、复制-黏贴编程、自负编程、……）
团队开发工具介绍
版本控制：Git、Mercury
缺陷管理：
Gitlab
、
Redmine
敏捷闭环工具：
禅道
、
JIRA
持续集成：
Jenkins
、
Travis-CI
请参考
《团队项目开发》
。
项目选题和理解业务
选题范围设定
CMS（用户端）：新闻聚合网站、问答/分享社区、影评/书评网站等。
MIS（用户端+管理端）：KMS、KPI考核系统、HRS、CRM系统、供应链系统、仓储管理系统等。
App后台（管理端+数据接口）：二手交易类、报刊杂志类、小众电商类、新闻资讯类、旅游类、社交类、阅读类等。
其他类型：自身行业背景和工作经验、业务容易理解和把控。
需求理解、模块划分和任务分配
需求理解：头脑风暴和竞品分析。
模块划分：画思维导图（XMind），每个模块是一个枝节点，每个具体的功能是一个叶节点（用动词表述），需要确保每个叶节点无法再生出新节点，确定每个叶子节点的重要性、优先级和工作量。
任务分配：由项目负责人根据上面的指标为每个团队成员分配任务。
制定项目进度表（每日更新）
第92天：
Docker的使用
第93天：
数据库设计和OOAD
概念模型和正向工程
UML（统一建模语言）的类图
通过模型创建表（正向工程）
python manage.py makemigrations app python manage.py migrate
物理模型和反向工程
PowerDesigner
2.通过数据表创建模型（反向工程）
python manage.py inspectdb > app/models.py
第94天：
网络API接口设计
第95天：
使用Django开发项目
项目开发中的公共问题
数据库的配置（多数据库、主从复制、数据库路由）
缓存的配置（分区缓存、键设置、超时设置、主从复制、故障恢复（哨兵））
日志的配置
分析和调试（Django-Debug-ToolBar）
好用的Python模块（日期计算、图像处理、数据加密、三方API）
REST API设计
RESTful架构
理解RESTful架构
RESTful API设计指南
RESTful API最佳实践
API接口文档的撰写
RAP2
YAPI
django-REST-framework
的应用
项目中的重点难点剖析
使用缓存缓解数据库压力 - Redis
使用消息队列做解耦合和削峰 - Celery + RabbitMQ
第96天：
软件测试和自动化测试
单元测试
测试的种类
编写单元测试（unittest、pytest、nose2、tox、ddt、……）
测试覆盖率（coverage）
项目部署
部署前的准备工作
关键设置（SECRET_KEY / DEBUG / ALLOWED_HOSTS / 缓存 / 数据库）
HTTPS / CSRF_COOKIE_SECUR / SESSION_COOKIE_SECURE
日志相关配置
Linux常用命令回顾
Linux常用服务的安装和配置
uWSGI/Gunicorn和Nginx的使用
Gunicorn和uWSGI的比较
对于不需要大量定制化的简单应用程序，Gunicorn是一个不错的选择，uWSGI的学习曲线比Gunicorn要陡峭得多，Gunicorn的默认参数就已经能够适应大多数应用程序。
uWSGI支持异构部署。
由于Nginx本身支持uWSGI，在线上一般都将Nginx和uWSGI捆绑在一起部署，而且uWSGI属于功能齐全且高度定制的WSGI中间件。
在性能上，Gunicorn和uWSGI其实表现相当。
虚拟化技术（Docker）
性能测试
AB的使用
SQLslap的使用
sysbench的使用
自动化测试
使用Shell和Python进行自动化测试
使用Selenium实现自动化测试
Selenium IDE
Selenium WebDriver
Selenium Remote Control
测试工具Robot Framework介绍
第97天：
电商网站技术要点剖析
第98天：
项目部署上线和性能调优
MySQL数据库调优
Web服务器性能优化
3.代码性能调优
多线程
异步化
4.静态资源访问优化
云存储
CDN
第99天：
面试中的公共问题
第100天：
英语面试
作者：骆昊 (jackfrued)
来源：github
github地址：
https://
github.com/jackfrued/Py
thon-100-Days
公号：聊聊Python，感兴趣的可以来找我玩，一起来聊聊Python这点事~
希望能帮到你","【实体书】
Python 3版本的实体书：
《自学Python 编程基础、科学计算及数据分析 第2版》(李金)【摘要 书评 试读】- 京东图书
，京东/淘宝/当当等各平台均可购买，喜欢实体书的可以看看，内容不完全一致。
【Python 3版本】
Python 3版本的笔记已更新完成，链接：
Github：
Nbviewer：
目录：
ch00-Python2与3的核心区别
00-01Python2和3的核心区别
ch01-Python介绍
01-01Python简介
01-02IPython解释器
01-03Jupyter Notebook
01-04脚本模式与解释器模式
ch02-Python基础
02-01Python演示
02-02数字
02-03字符串
02-04索引和切片
02-05列表
02-06可变与不可变类型
02-07元组
02-08字典
02-09集合与不可变集合
02-10Python赋值机制
02-11判断
02-12循环
02-13函数
02-14模块与包
02-15文件读写
02-16异常与警告
02-17常用内置函数
ch03-Python进阶
03-01函数进阶
03-02迭代器与生成器
03-03装饰器
03-04上下文管理器
03-05变量作用域
ch04-Python面向对象编程
04-01面向对象简介
04-02方法与属性
04-03继承与复用
04-04公有、私有、特殊以及静态方法和属性
04-05多重继承
ch05-Python标准库
05-01模块sys：系统相关
05-02模块os：与操作系统进行交互
05-03模块re：正则表达式
05-04模块datetime：日期时间
05-05模块json：处理JSON数据
05-06模块glob：文件模式匹配
05-07模块math：数学
05-08模块random：随机数
05-09模块pathlib：路径操作
ch06-NumPy模块
06-01NumPy模块简介
06-02数组基础
06-03数组广播机制
06-04数组操作
06-05数组的读写
06-06数组索引进阶
06-07随机数组
ch07-Matplotlib模块
07-01Matplotlib模块简介
07-02基于函数的可视化操作
07-03基于对象的可视化操作
07-04图像中的文本处理
ch08-SciPy模块
08-01SciPy模块简介
08-02插值模块
08-03概率统计模块
08-04优化模块
08-05线性代数模块
ch09-Pandas模块
09-01Pandas模块简介
09-02一维数据结构Series对象
09-03二维数据结构DataFrame对象
09-04Pandas对象的索引
09-05缺失值的处理
09-06数据的读写
ch10-一些好玩的应用
10-01获取必应桌面壁纸
【Python 2.7版本】
Python 其实挺简单的，也挺强大的。
我用 Python 做科学计算，自学一年，也记了一年的笔记。
笔记链接（基于Python 2.7）：
Github：
Nbviewer：","是否非常想学好 Python，一方面被琐事纠缠，一直没能动手，另一方面，担心学习成本太高，心里默默敲着退堂鼓？
幸运的是，Python 是一门初学者友好的编程语言，想要完全掌握它，你不必花上太多的时间和精力。
Python 的设计哲学之一就是
简单易学
，体现在两个方面：
语法简洁明了：相对 Ruby 和 Perl，它的语法特性不多不少，大多数都很简单直接，不玩儿玄学。
切入点很多：Python 可以让你可以做很多事情，科学计算和数据分析、爬虫、Web 网站、游戏、命令行实用工具等等等等，总有一个是你感兴趣并且愿意投入时间的。
废话不多说，学会一门语言的捷径只有一个： 
Getting Started
? 起步阶段
任何一种编程语言都包含两个部分：硬知识和软知识，起步阶段的主要任务是掌握硬知识。
硬知识
“硬知识”指的是编程语言的语法、算法和数据结构、编程范式等，例如：变量和类型、循环语句、分支、函数、类。这部分知识也是具有普适性的，看上去是掌握了一种语法，实际是建立了一种思维。例如：让一个 Java 程序员去学习 Python，他可以很快的将 Java 中的学到的面向对象的知识 map 到 Python 中来，因此能够快速掌握 Python 中面向对象的特性。
如果你是刚开始学习编程的新手，一本可靠的语法书是非常重要的。它看上去可能非常枯燥乏味，但对于建立稳固的编程思维是必不可少。
下面列出了一些适合初学者入门的教学材料：
廖雪峰
的 Python 教程
Python 中文教程的翘楚，专为刚刚步入程序世界的小白打造。
笨方法学 Python
这本书在讲解 Python 的语法成分时，还附带大量可实践的例子，非常适合快速起步。
The Hitchhiker’s Guide to Python!
这本指南着重于 Python 的最佳实践，不管你是 Python 专家还是新手，都能获得极大的帮助。
Python 的哲学：
用一种方法，最好是只有一种方法来做一件事。
学习也是一样，虽然推荐了多种学习资料，但实际学习的时候，最好只选择其中的一个，坚持看完。
必要的时候，可能需要阅读讲解数据结构和算法的书，这些知识对于理解和使用 Python 中的对象模型有着很大的帮助。
软知识
“软知识”则是特定语言环境下的语法技巧、类库的使用、IDE的选择等等。这一部分，即使完全不了解不会使用，也不会妨碍你去编程，只不过写出的程序，看上去显得“傻”了些。
对这些知识的学习，取决于你尝试解决的问题的领域和深度。对初学者而言，起步阶段极易走火，或者在选择 Python 版本时徘徊不决，一会儿看 2.7 一会儿又转到 3.0，或者徜徉在类库的大海中无法自拔，Scrapy，Numpy，Django 什么都要试试，或者参与编辑器圣战、大括号缩进探究、操作系统辩论赛等无意义活动，或者整天跪舔
语法糖
，老想着怎么一行代码把所有的事情做完，或者去构想圣洁的性能安全通用性健壮性全部满分的解决方案。
很多“大牛”都会告诫初学者，用这个用那个，少走弯路，这样反而把初学者推向了真正的弯路。
还不如告诉初学者，学习本来就是个需要你去走弯路出 Bug，只能脚踏实地，没有奇迹只有狗屎的过程。
选择一个方向先走下去，哪怕脏丑差，走不动了再看看有没有更好的解决途径。
自己走了弯路，你才知道这么做的好处，才能理解为什么人们可以手写状态机去匹配却偏要发明正则表达式，为什么面向过程可以解决却偏要面向对象，为什么我可以操纵每一根指针却偏要自动管理内存，为什么我可以嵌套回调却偏要用 Promise...
更重要的是，你会明白，高层次的解决方法都是对低层次的封装，并不是任何情况下都是最有效最合适的。
技术涌进就像波浪一样，那些陈旧的封存已久的技术，消退了迟早还会涌回的。就像现在移动端应用、手游和 HTML5 的火热，某些方面不正在重演过去 PC 的那些历史么？
因此，不要担心自己走错路误了终身，坚持并保持进步才是正道。
起步阶段的核心任务是掌握硬知识，软知识做适当了解，有了稳固的根，粗壮的枝干，才能长出浓密的叶子，结出甜美的果实。
? 发展阶段
完成了基础知识的学习，必定会感到一阵空虚，怀疑这些语法知识是不是真的有用。
没错，你的怀疑是非常正确的。要让 Python 发挥出它的价值，当然不能停留在语法层面。
发展阶段的核心任务，就是“跳出 Python，拥抱世界”。
在你面前会有多个分支：科学计算和数据分析、爬虫、Web 网站、游戏、命令行实用工具等等等等，这些都不是仅仅知道 Python 语法就能解决的问题。
拿爬虫举例，如果你对计算机网络，HTTP 协议，HTML，文本编码，JSON 一无所知，你能做好这部分的工作么？而你在起步阶段的基础知识也同样重要，如果你连循环递归怎么写都还要查文档，连 BFS 都不知道怎么实现，这就像工匠做石凳每次起锤都要思考锤子怎么使用一样，非常低效。
在这个阶段，不可避免要接触大量类库，阅读大量书籍的。
类库方面
「Awesome Python 项目」：
vinta/awesome-python ・ GitHub
这里列出了你在尝试解决各种实际问题时，Python 社区已有的工具型类库，如下图所示：
vinta/awesome-python
你可以按照实际需求，寻找你需要的类库。
至于相关类库如何使用，必须掌握的技能便是阅读文档。由于开源社区大多数文档都是英文写成的，所以，英语不好的同学，需要恶补下。
书籍方面
这里我只列出一些我觉得比较有一些帮助的书籍，详细的请看豆瓣的书评：
科学和数据分析：
?「集体智慧编程」：
集体智慧编程 (豆瓣)
?「数学之美」：
数学之美 (豆瓣)
?「统计学习方法」：
统计学习方法 (豆瓣)
?「Pattern Recognition And Machine Learning」：
Pattern Recognition And Machine Learning (豆瓣)
?「数据科学实战」：
数据科学实战 (豆瓣)
?「数据检索导论」：
信息检索导论 (豆瓣)
爬虫：
?「HTTP 权威指南」：
HTTP权威指南 (豆瓣)
Web 网站：
?「HTML & CSS 设计与构建网站」：
HTML & CSS设计与构建网站 (豆瓣)
... 
列到这里已经不需要继续了。
聪明的你一定会发现上面的大部分书籍，并不是讲 Python 的书，而更多的是专业知识。
事实上，这里所谓“跳出 Python，拥抱世界”，其实是发现 Python 和专业知识相结合，能够解决很多实际问题。这个阶段能走到什么程度，更多的取决于自己的专业知识。
? 深入阶段
这个阶段的你，对 Python 几乎了如指掌，那么你一定知道 Python 是用 C 语言实现的。
可是 Python 对象的“动态特征”是怎么用相对底层，连自动内存管理都没有的C语言实现的呢？这时候就不能停留在表面了，勇敢的拆开 Python 的黑盒子，深入到语言的内部，去看它的历史，读它的源码，才能真正理解它的设计思路。
这里推荐一本书：
「Python 源码剖析」：
Python源码剖析 (豆瓣)
这本书把 Python 源码中最核心的部分，给出了详细的阐释，不过阅读此书需要对 C 语言内存模型和指针有着很好的理解。
另外，Python 本身是一门杂糅多种范式的动态语言，也就是说，相对于 C 的过程式、 Haskell 等的函数式、Java 基于类的面向对象而言，它都不够纯粹。换而言之，编程语言的“道学”，在 Python 中只能有限的体悟。学习某种编程范式时，从那些面向这种范式更加纯粹的语言出发，才能有更深刻的理解，也能了解到 Python 语言的根源。
这里推荐一门公开课
「编程范式」：
斯坦福大学公开课：编程范式
讲师高屋建瓴，从各种编程范式的代表语言出发，给出了每种编程范式最核心的思想。
值得一提的是，这门课程对C语言有非常深入的讲解，例如C语言的范型和内存管理。这些知识，对阅读 Python 源码也有大有帮助。
Python 的许多最佳实践都隐藏在那些众所周知的框架和类库中，例如 Django、Tornado 等等。在它们的源代码中淘金，也是个不错的选择。
?  最后的话
每个人学编程的道路都是不一样的，其实大都殊途同归，没有迷路的人只有不能坚持的人！
希望想学 Python 想学编程的同学，不要犹豫了，看完这篇文章，
Just Getting Started  ！！！","我是真正零基础开始学Python的，从一开始的一窍不通，到3个月后成功搭建了一个动态网站（没有用任何框架）。相比于计算机大牛，我更加知道一个小白将会遇到什么坑，遇到哪些难点。我把我的学习过程写在下面，并附上在每个阶段的学习资料，希望对零基础的Python学习者有所帮助。
注：本文只做经历分享，不是技术探讨。
---
在知乎上常常看到想要转行IT，或者是想学习编程但不知如何开始的朋友。回答这类问题的人往往只是列出书单资源然后给出一个大致的方向。有些朋友一开始就扎入了理论学习的汪洋大海，从苦读类似《算法导论》开始，能够坚持读下来的寥寥无几，学习的积极性也被不断的挫败感消磨的所剩无几。
一直以来，编程对我而言是一种「黑魔法」般的存在。今年
阿里月饼门
，当很多人都参与到是非之争的时候，我更加着迷于程序员区区几行代码的脚本所展现出的威力，对于外行而言，这是超乎他们想象之外的某种能力――为什么我守在电脑面前盯着秒针然后拼命点击鼠标都不一定能抢到的礼物，程序员只需要提前花5分钟写3行代码就轻松搞定？
所以，我的心底深处一直都想变成这样的一位魔法师。今年的8月，刚好工作上想要开发一个基于微信的英语学习网站，借此机会，我决定好好学习一下编程。在此之前，我所有关于程序的知识仅仅来源于两部分，一是本科时期的C语言必修课，现在已经忘的一干二净，不过好歹我从中明白编程是怎么回事；第二部分是大概两年前由于工作关系学的一些Python，不过只是皮毛，现在忘的七七八八。
简单说，我的目标是建立一个网站，不过这个网站是动态的，也就是说它能识别谁登陆，然后对不同的人显示不同的内容。而当时的现实是，我完全不明白网页是如何显示出来的？譬如每个人登陆知乎的时候看到的是定制化的页面，后台是如何基于每个ID来组织出不同的页面的？所有我们看到的问题，回答，参与的评论在背后的服务器上是以一种什么样的形式存在的？又比如为什么有些页面只能在微信端打开，在电脑上就会出错？（不知道你有没有发现这一点）
当时我的心中充满了无数个类似的问号？当然如果你也是小白，一定有着同样的疑问。
好处是一开始就明确了学习的目的：Web建站。所以我的学习方案基本就是通过做项目学习，哪里不懂就解决哪里，边做边学习，不断推进。另外，由于知道很多成功的网站在用Python做服务器开发，比如知乎，所以我就自然选择了Python。
于是我就开始了我充满着挫败感和成就感的编程之路……
从8月到12月的四个月里，除去本来的工作，为了学习质量，我会保证平均每天4个小时的学习时间，周末也不例外。另外，所有的文档，问答都尽量看英文的，这可以帮你剩下大量的时间。12月13日，我做的网站上线了，3天时间大概有5000人访问了这个网站，我有时在后台看着日志，不免有些心潮喷涌，我想把自己的经验写下来，希望对于那些有心学习编程但无从下手的朋友提供一些帮助和鼓励。
1. 我的自学编程之路
1）基础
刚开始的时候，我对搭建网站一无所知。为了给自己迅速建立一个框架，我在Google上面泡了整整一天，了解了HTML，CSS，JavaScript，Ajax，jQuery，React，SQL，服务器脚本等等知识，不求精通，只是了解每一项技术是干嘛的，另一方面建立起了一个学习的roadmap，这样大概知道做一个Web App需要哪些知识，分别学习的主次顺序。重点推荐两个资源：
Python基础知识：
Learn Python the Hard Way
Web App基础知识：@
张秋怡
的
答案
写的通俗易懂，极力推荐。
有了这个
roadmap
，我明白了前端三大必须掌握技能HTML，CSS和JavaScript，花了大概10天左右把W3Schools上的教程全部过了一遍，然后试着写了几个网页，感觉自己写的很没有底气。于是根据知乎和豆瓣上的推荐，买了《JaveScript DOM》和《Head First HTML与CSS》，边看书边把例子过了一遍。
W3Schools: 
www.w3schools.com/
JavaScript：
JavaScript DOM编程艺术
HTML & CSS : 
Head First HTML与CSS（第2版）
前端是需要慢慢学习的，在看完上面的资料后，虽然能写出来一些挺漂亮的页面，但是我自己知道很多都是不符合标准的，更不要说代码风格什么的。这只能通过不断地积累和增加代码量来提高。由于明白服务器端需要耗费自己大量的时间，所以在发现自己能够按照构思勉强实现网页之后，我就把学习中心放到了服务器端上。不过每天还是会抽空写一写网页，避免手生。
2）服务器端
最先了解的是HTTP协议，也就是浏览器和服务器之间是如何通信的。也就是当你在浏览器里键入网址按下回车直到网页显示在你浏览器的这个过程中，浏览器和浏览器之间发生了什么事情。这是很有意思的内容，我是以读小说的心情了解了这部分内容。了解这部分后，你就会明白类似为什么有时候会有404页面？在百度搜索框里键入的搜索词是如何提交到百度服务器的？为什么重新登录知乎的时候就不用再输入密码了？之类的问题了。
HTTP协议学习资料：
In Introduction to HTTP Basics
@Vamei
的博客：
协议森林
了解了HTTP协议之后，我就多少有些入迷了。看似神秘难懂的现象其实原理并不复杂，你反而会被吸引。接下来就进入到我投入时间最多的部分了――后端开发。记得当时了解Web开发的MVC（Model-View-Controller）模式后，有一种心血喷涌的感觉，觉得太有意思了（程序员别喷，我就是这么没见过世面）。我们以知乎为例子来说明MVC是个啥：
每个人的主页都是相同的布局和风格，例如最上面的菜单搜索栏，颜色分割，左边显示动态等，右边是个人信息等，然后具体的内容却因人而异――每个人的头像，名字，动态都是不一样的。那么知乎是如何保证每一个人看到的都是自己的主页呢？
你可以把这个相同的布局想象成一个模板，里面有一个个空格子，当你用你的账户登陆页面时，想象你的电脑里有无数个小人根据你的账号从知乎后台的数据库里取出你的头像，动态，认证信息等等内容，然后对应着模板上规定好的位置，把对应的内容填进去。这些小人的动作实在是太快了，以至于你觉得这是在瞬间完成的。
上面所说的模板就是MVC中的V，是View的缩写，负责显示。这样做的好处在于，如果知乎有一天突然想改变一下个人主页的风格，那么只需要改变这一个模板，然后几千万注册用户的主页就相应的变化了，因为模板是公用的，是不是省了很多事情？（早期的Web开发可不是这样哟，你可能要一个个用户去改，非常麻烦。）
而这些小人除了摆放内容，它们真正负责的是业务逻辑，我们把他们叫做Controller，也就是MVC中的C。例如当你登陆的时候，这些小人要检查你的用户名是不是准确的，如果准确，它们要去数据库里取出你请求的信息等，如果用户名错误，它们要拦截住你的登陆。它们的职责还有很多，无法一一列举。在实际中，这些小人做的事情其实就是Python（或者其它脚本语言）做的事情。
最后，MVC中的Model其实就是传给View的数据，包括上面的头像，用户名，动态等因人而异的数据。这些数据在知乎服务器上是以数据库表格（table）的形式存在的，你可以把它们想象成很多不同的excel表格，不同的表格储存着不同的信息，有些记录着知乎用户的个人信息，有些记录着回答，有些记录着评论等等，而这些表格之间又彼此联系，当你在知乎的不同网页间跳转的时候，上面说的那些小人就根据你的要求，组合对应的表格取出对应的数据，然后把他们放到模板对应的空格里，发送给浏览器。然后浏览器根据你写的CSS，用不同的颜色，大小等等，将数据很漂亮的显示出来。
这样做的好处是什么呢？虽然你最终在浏览器里看到的是一个完整的页面，但是在后端逻辑上它们都是区分开的――模型（M），视图（V）和控制器（C）的区分就保证了较高的可维护性――我可以随时修改主页的显示并看到效果，同样我可以随时加入一些业务逻辑。
如果你的学习坚持到这里了，首先要恭喜你。其次你可能已经知道一些非常成熟的Python Web框架了，例如Django，Flask等等，并且你可能看到了很多小白教程教你直接使用，毕竟大部分人可能觉得没有必要重复造轮子。
本来为了省事，我也打算直接用框架。我是在设计数据库的时候，当时在看SQLAlchemy文档，觉得相对自己的项目SQLAlchemy太过复杂，所以我决定自己写自己的ORM（名词不懂没关系），这对于当时的我来说是一件难度非常大的事情。于是我投入了极大的精力每天都在看关于SQL和Python相关的教程和资料，
Python核心编程（第二版） 
给了我很大的启发。在自己完成了ORM后，又写了URL处理函数，同样没有用任何现成的Web框架。
现在回头看，我认为这一段时间的造轮子是提升编程能力最快的时候。比如为了写ORM，就必须去花很多时间学习SQL，去了解Python里面的metaclass，而如果用一个现成的框架，我很有可能偷懒不去关注某些细节。而不出问题还好，一旦出问题，我就只能跪。另外，造轮子迫使我在开始的时候就构思整个框架，因为我必须尽可能的考虑到所有的情况，于是就会不断的强迫自己完善知识体系，和别人的代码作对比从而改进自己的，这个过程充满了无尽的挫败感，但是得来的成就和快乐也是无可比拟的。
SQL书籍：
Sams Teach Yourself MySQL in 21 Days
Python：
Python核心编程（第二版）
Github上的优质Python资源：
CodementorIO/Python-Learning-Resources
过程中还牵涉到部署，我的网站是跑在Linux上的。关于部署网上有非常多的优质教程，一搜一大把。这里就不再赘述。
这些是我学习大致路线，当然过程中充满着小的磕磕绊绊，虽然网站上线了，貌似运行还比较顺利，但是如果以一个程序员的标准来要求自己，自己依然非常菜鸟。不过我并没有以前那样惧怕技术了，就像你明白魔术的背后的原理后，会更多的思考原理本身。
2. 自学编程需要注意的问题
很多人都推荐小白第一门语言选Python，因为语法简单。这句话只说了一半，Python确实容易上手，对初学者的门槛很低。但我发现，
对于小白真正的门槛在于系统知识，这就和用什么语言完全没有任何关系了。
例如很多人学完了Python的语法，觉得确实简单，但是转头去用Python标准库的时候，却发现自己连文档都看不懂。标准库提供了Python和其它系统功能的接口，最终实现了Python和系统之间的互动。读标准库需要系统知识，比如操作系统，数据库，进程和线程，socket编程，网络协议等等，这些对于编程小白来才构成很高的门槛，但是只有学会这些，才能真正发挥出Python的威力来。
这也是我觉得自己的经历对小白是有价值的一个原因。因为设计一个动态的网页是一个很不错的练手Project。建立网页（Web App）会逼迫你了解从你在浏览器里键入地址按下回车到网页显示在浏览器的过程中，浏览器，网络，服务器都干了些什么。具体到技术上面，你不得不去学习前端的HTML，CSS和JavaScript，后端的脚本，数据库，操作系统等。也就是说，这个过程能够促使你去主动学习上面提到的系统知识，如果你再做另外一个项目，你就不会像现在这样无从下手，而有能力去进行一些技术性的探讨，所以我认为这是一个非常好的练手项目。
1）一定要空出时间补充理论知识
很多人会强调learn by doing，边做项目边学习，这也是我自己采用的方式。在这种方式中，你不断犯错，改正……学习效率非常高。但是，很多人走了极端，最后的结果就是不注意理论知识的学习。你会发现自己Google的能力越来越高，但是真实的编程能力并没有得到提升。如果有这种情况，你需要反思一下。
一种可能是你太过于依赖各种成熟的框架，结果编程就变成了用「胶水」去粘合不同的框架完成需求。就好比你的Web App用了SQLAlchemy，虽然自己不太懂SQL，但是网站跑的也还不错。这时候如果数据库出现了问题，那你就只能跪了。
另外一种可能是你完全沉浸在做项目中，忽略了学习理论知识。做项目虽然充满困难，但回报是强烈的成就感，很容易沉浸其中。我觉得这是极其错误的。首先半路出家的程序员都没有经过系统的学习，没有形成自己的知识体系，如果你不懂数据结构，算法复杂度，操作系统这些理论，那么你能达到的高度就极其有限。所以，在每天做项目的同时，一定要保证抽出一定的时间，恶补理论知识。这部分的书单在豆瓣和知乎上都有很多总结，可以自行搜索。
2）不要太纠结于无意义的问题，比如什么框架好，XX语言比XX语言好啦这种问题。前期确定了练手项目，就去专心积累代码量，积累基础知识。那些你现在还看不懂的炫酷技术你慢慢也就能明白是怎么回事了，反而没有基础，再炫酷的框架对你而言都是天书。
3）学会发问。好问题是建立在你自己已经实践或者思考的基础上问出来的，这是对自己的负责，也是对别人的尊重。不要一遇到困难就喜欢直接上网搜索：「这个问题是怎么回事啊？」，「我不明白你能不能帮我看看……」。
4）学好英语。
THE END
最后，给自己打个广告，如果学英语，一定要关注我。","最近，GitHub上一个关于Python的工程完工了。
一个名为“暮晨”的贡献者，把一个非常有趣的Python项目，翻译成了中文版。
这个项目是《What the f*ck Python!》，专门介绍 Python 里面那些奇奇怪怪的语言坑。
关于项目
项目的主体构成部分就是示例，一共分为5个部分，分别是：
Strain your brain!/大脑运动!
Appearances are deceptive!/外表是靠不住的!
Watch out for the landmines!/小心地雷!
The Hidden treasures!/隐藏的宝藏!
Miscellaneous/杂项
以上，总计51个示例。
每一个示例的结构都是一样的，以“Mutating the immutable!/强人所难”为例：
首先，会给出代码：
some_tuple
 
=
 
(
""A""
,
 
""tuple""
,
 
""with""
,
 
""values""
)


another_tuple
 
=
 
([
1
,
 
2
],
 
[
3
,
 
4
],
 
[
5
,
 
6
])
然后，给出Output（ Python version）：
>>> some_tuple[2] = ""change this""
TypeError: 'tuple' object does not support item assignment
>>> another_tuple[2].append(1000) # 这里不出现错误
>>> another_tuple
([1, 2], [3, 4], [5, 6, 1000])
>>> another_tuple[2] += [99, 999]
TypeError: 'tuple' object does not support item assignment
>>> another_tuple
([1, 2], [3, 4], [5, 6, 1000, 99, 999])
然后，对意外输出的结果进行简短的描述，在这个示例中，就是：
我还以为元组是不可变的呢…
接下来，就会对示例进行说明，简要叙述发生了什么以及为什么会发生。如有必要, 也会举例说明。
在这个示例中是这样的：
引用
https://
docs.python.org/2/refer
ence/datamodel.html
不可变序列 不可变序列的对象一旦创建就不能再改变。(如果对象包含对其他对象的引用，则这些其他对象可能是可变的并且可能会被修改; 但是，由不可变对象直接引用的对象集合不能更改。)
+= 操作符在原地修改了列表. 元素赋值操作并不工作, 但是当异常抛出时, 元素已经在原地被修改了。
有些地方，贡献者还会给出译注，比如整个示例中就是：
对于不可变对象, 这里指tuple, +=并不是原子操作, 而是extend和=两个动作, 这里=操作虽然会抛出异常, 但 extend 操作已经修改成功了。
其他还有50个示例，等你来看~
怎么使用？
当然，要学习一下怎么使用这个资源。项目贡献者在用法部分表示，最好依次阅读下面的示例。
然后，在阅读每一个示例的时候，这样做：
仔细阅读设置例子最开始的代码。
阅读输出结果。
确认结果是否如你所料。
确认你是否知道这背后的原理。
如果不知道, 深呼吸然后阅读说明 (如果你还是看不明白, 别沉默！可以提问题)。
如果知道, 给自己点奖励, 然后去看下一个示例。
此外，还可以在命令行阅读 WTFpython，有 pypi 包 和 
npm
 包(支持代码高亮)，不过都是英文版的。
关于作者
这个项目的原作者，是一个名为Satwik Kansal的印度小哥。
GitHub上的介绍称，在深度学习和
去中心化
应用方面是一个“老司机”。
目前，英文版资源，标星已经8.3k了。
传送门
中文版：
https://
github.com/leisurelicht
/wtfpython-cn
英文原版：
https://
github.com/satwikkansal
/wtfpython
- 完 -
最后，了解更多前沿科技，请关注我们的知乎号：
量子位
?
www.zhihu.com/org/liang-zi-wei-48/activities","如果你一直想学Python，但是不知道如何入手，那就别犹豫了。这篇文章就是为你写的。
疑问
随着数据科学概念的普及，Python这门并不算新的语言火得一塌糊涂。
因为写了几篇用Python做数据分析的
文章
，经常有读者和学生在留言区问我，想学习Python，该如何入手？
我经常需要根据他们的不同情况，提出对应的建议。这样针对性虽强，但效率不高。这个问题，我还是写出来，让更多的人一同看到吧。
有几位出版社的编辑，给我发私信，鼓励我赶紧写一本Python教材出来。
我暂时还没有写Python基础教程的计划。因为在我看来，现有的学习资源
已经足够好
了。
有现成的资源和路径，为什么许多人依然在为学Python犯愁呢？
因为学习有个效率问题。
Python语法清晰明快，简单易学。这是Python如此普及的重要原因。但是，选择合适的Python学习方式，需要跟你自身的
特性
相结合。
人群划分的标准是什么？不是你是否计算机相关专业，也不是你是否已经工作，而是一个重要的指标――你的
自律
能力。
你可能觉得我说的话没有信息含量。自律能力强，学得更好，地球人谁不知道？
可是，自律不够强的人，难道就注定什么也不能学了？
当然不是。
每个人的性格都有不同的特点，没有绝对的高下之分。不信你听听
刘宝瑞
先生的相声《日遭三险》，就明白了。
自律能力也是这样。只要你能清楚认识自己，就能以更高效的方法来学习新知识和技能。
下面我们分类探讨一下，不同自律能力的人，该如何学Python，才能更高效。
路径I
咱们先从自律能力
最差
的人说起。
这样的同学，往往是三分钟热度。偶然受到了刺激，发奋要学习Python，以便投入数据科学的事业中。
他会立即跑到图书馆或者书店抱回来一本《
X天从入门到精通Python
》的书开始啃。结果X天还没到，就顺利跑完了从入门到放弃的全过程。
你没能坚持下来，自己肯定是有责任的。但是最大的问题，在于过度
高估
自己的自律能力。
这样的同学，我推荐你到Coursera平台上，按部就班学习一门非常好的MOOC――“Programming for Everybody”。
推荐这门课，是因为课程质量真是太好了。
首先是教材好。这本教材的来源是有故事的。
先是 Allen B. Downey 写了一本开放书籍 “Think Python: How to Think like a Computer Scientist”。
这本书在Amazon上的评价是这样的：
Charles Severance觉得这本书写得太好了，想把它作为教材。于是征得作者同意，大篇幅借鉴了这本书的内容架构，编写了一本 “Python for Informatics”。
Charles写作这本书的时候，同时开放推出了iBook格式。里面就包含了自己的授课视频，供学生直接观看学习。
后来，Charles用这本书扩展，做成了一门MOOC。2015年上线不久，硅谷资深工程师就都争相学习。
Charles深谙课程迭代的技艺。他不断添加内容，完善课程体系，将一门课发展成一个专项课程(Signature Track)，并且将教材升级为 “Python for Everybody: Exploring Data In Python 3”
在目前全球MOOC口碑榜上，Charles的这门课一直名列前茅。
这个专项课程深入浅出讲解Python本来就很简单的语法，而且还用数据科学的一些基础工作任务，带动你去使用Python语言写简单项目。这种扎实的训练过程可以增强你的信心，激发兴趣。
对于自律程度低的同学来说，下面这个特性
更重要
――一切工作都有时限。
Coursera上的课程，每周的任务很明确。练习题正确率如果不能达到80%，就不能过关。到了截止日期，如果你不能完成全部练习和课程项目，就拿不到证书。
老师在前面引领你，助教在旁边督促你，平台用时间表提醒你，论坛上的同学们在用同侪压力推挤你……
想偷懒？想三天打鱼两天晒网？很难。
路径II
如果你的自律能力中等偏上，那么你可以选择的面就宽了。
这里我给你推荐另一个MOOC平台，叫做Datacamp。
我第一次接触Datacamp，是在2015年初。那时我在Coursera上选修杜克大学的统计学课程 “Statistical Inference”，配套的练习就在Datacamp上。
当时这个平台就给我留下了非常深刻的印象，因为代码的运行都采用了云环境。学习者不需要在本机安装任何环境，一个支持HTML5标准的浏览器就能带给你完整的学习体验。
对初学者来说，这种入门方式太好了。要知道，许多人的学习热情，就是被环境配置和依赖软件包安装的坑埋掉的。
两年之后，Datacamp已经迭代得更为强大。你可以打开首页的Data Scientist with Python这个学习路径，查看其中已经提供的20门课程。
这些课程涵盖了从Python基础，到数据处理，直至人工智能和深度神经网络的方方面面。
所有的课程设计，都是短小精悍的。一般不超过4个小时，就可以完成某一主题的学习。这样你学起来毫不费力，可以在相当短的时间内获得反馈（练习题自动评分）和成就感（证书）。
这个平台的课程，进度完全由学习者
自己掌控
。所以我把它归纳为适合有一定自律能力的学习者。
它既可以给你即时的回馈，让你时刻了解自己所处的位置进度，不会迷失方向，又能充分体验自主学习的乐趣。
Datacamp的课程，一般都是第一部分免费开放。后面部分购买后才能解锁学习。如果你对自己的学习能力和毅力有信心，可以购买一个完整时间段（例如一年）的课程。在此期间，所有平台上的课程，你都可以学习，并且可以在通过后获取证书。这样的购买方案本身已经有优惠，而且每年都会有特定时段的大幅打折促销，非常划算。建议放到购物车里面多关注。
这是我在Datacamp拿到的深度学习框架Keras课程证书。确实只需要几个小时的时间就能学完。成就感还是蛮强的。
路径III
前面提到的课程费用不菲。Coursera上每门课平均价格在49美元左右。对来自发展中国家的学生群体，Coursera可以提供助学金。你可以根据自己的需求如实填写申请表，来获得资助。
对于自律能力强的同学来说，你的选择可以变得非常简单直接――可以用最受推崇的教材，自己看书学习。
最受推崇
的教材，其实是没有的。正如西谚有云：
 One man’s meat, is another man’s poison.
这个世界上，就没有哪件东西大家都说好。但口碑非常好的教材是存在的，例如这本起了个怪名字的《笨办法学Python》(Learn Python the Hard Way)。
千万不要被名称迷惑，望文生义觉得这是一本糟糕的Python入门教程。
恰恰相反，这本书的设计，非常适合人们的认知规律。
我们学东西，由浅入深，由易到难，逐步递进。如果一味追求新知，那么之前学的东西会很快遗忘。如果总是原地打转，会带来枯燥和无聊的感觉。还记得高三做的那一年卷子吧？
好的教科书，应该在每一个章节给学习者提供新的知识和内容，提出足够的挑战。但是挑战性不能高到让学习者产生挫败感而放弃。同时也不能忽视在后续内容中把前面所学知识改换面目不断螺旋上升式重复出现。只有这样才能巩固所学，让学习者感受到基础知识的作用，增强学习的愉悦感。
这么说有些抽象，实际上有一本英语教材非常符合上述认知规律。就是我在课堂上和文章里反复推荐过的这一套教材：
《
笨办法学Python
》也是一本这样的书。你需要做的就是把书打开，同时打开一个好用的代码编辑器，开始按书中要求敲代码、运行代码、改代码……
下图是我当初学习时，照着这本书敲的代码。
书中对Python基础内容训练的完备性，至今
无出其右
者。
顺便说一句，这本书有中文版哦。所以如果你英语不好，完全不用担心。
嘱咐一句，英语真该好好学。拓宽的不仅是你的眼界，也增加了你可能获得的机会。考虑到仔细阅读这部分的读者都是自律性很强的人，我就不用多说了。
挑战
三条基本的Python入门路径讲完了。通过对自己自律能力的清晰理解，相信你可以找到一种适合自己逐渐学习和掌握Python的方式。
但是完成了读书和听课，是不是就完事大吉了？
当然不是。
许多人在这里犯了错误。他们以为拿到了证书，或学完了教材，就算是真正掌握了Python。然后把这门语言丢弃在一旁，去刷美剧和小说了。
相信我，你会
遗忘
的。
如果你对于长期不接触的东西从不遗忘……去医院检查一下吧。
大部分人的记忆模式，都是这个样子的：
若不加以干涉，不出一个星期，你就能把学到的新知识几乎忘光。
如果你不希望自己辛苦学来的Python知识被如此轻易浪费掉，怎么办？
实践
你应该实践。
实践Python技能，未必一定要找个世界500强企业的核心技术部门，“996”工作N年才能完成。
你可以从生活中寻找各种有趣的问题，然后思考能否用Python编程来解决它。
我真正觉得自己
初步掌握
了Python，就是在完成了我的第一个github项目之后。
项目非常简单，就是用Python作为
胶水语言
，把一系列工具连接在一起。可以把Markdown撰写的内容随心所欲一键变化成各种格式。
格式包括而不限于：
PDF/LaTeX;
Word;
Bitcron文稿;
MarkEditor文稿；
MWeb文稿；
Bear文稿；
TextBundle（可以导入MindNode, Ulysses等）;
Reveal.js幻灯;
发布版本Markdown（图片一键至
七牛图床
）;
本地版本Markdown（简书等远程Markdown同步图片至本地)；
Day One日记。
其中部分功能我正陆续发布在github公开项目中，地址在
这里
。相应地，我也
撰文
做了介绍。
这个小项目，我从2014年开始做。实话实说，现在回头看当时的代码，简直惨不忍睹。但是如果你逐渐对自己的代码有了这种感觉，证明你在进步。
不要指望自己一出手就能写出
完美的
代码，要把“迭代”两个字时刻装在心里。这样你才能容忍自己的笨拙，不断提高。正如古人说的那句：
 勤学似春起之苗，不见其增，而日有所长。
我在做这个项目的过程中，曾经遇到了中文编码、隐私信息存储、文件名空格处理、绝对与相对路径、发布流程划分、功能解耦合、Web图片地址附带参数……等等一系列的问题。
通过回顾用git版本控制工具记载下来的日志，以及版本对比功能，你可以清楚看到自己是在何时利用什么方法解决了这些问题。然后别忘了，给自己工具箱里的新增小技能打个勾。
一个个小问题逐渐被你攻克的时候，你才能真正感受到所学技能的价值，并且点滴积累自信。
王树义
8 次咨询
5.0
南开大学 情报学博士
88118 次赞同
去咨询
讨论
你学会Python了吗？你是用什么方法学会的？可否把你的学习心得体会分享给大家？对本文推荐的资源和路径，你有什么不同的意见，或者更好的建议？欢迎留言，记录下你的思考，我们一起交流讨论。
喜欢请点赞。还可以微信关注和置顶我的公众号
“玉树芝兰”(nkwangshuyi)
。
如果你对数据科学感兴趣，不妨阅读我的系列教程索引贴《
如何高效入门数据科学？
》，里面还有更多的有趣问题及解法。","首先，我个人是参加过培训的，我是因为自学的进度非常慢，而且太考验自律了，本人综合对自己的了解才选择的培训。当然我也还是蛮赞同自学的，不过要根据自己的实际需求和情况来决定，毕竟自学的时间要长，在有些问题上解决上也要慢很多，如果时间充裕自律相对较好的还是可以选择自学的，下面是我的整理过的一篇文章，希望能对想要学习的伙伴有一些帮助吧~
之前有一个回答被好多人看到，就有很多伙伴私信我说要了解学习python的一些事情，有的刚刚毕业，有的不是理科生，有的是工作了想转行，基本都是零基础，该怎么学习，其实我还是想说，python的话是相对入门比较简单的，零基础也是完全没有问题的，不过如果想要参加培训的话我个人建议可以自己先找一些线上课程自学一下，现在网上的课程也非常的多，这里个人可以多寻找两个机构的课程自己先自学一下，一是可以感受一下各个机构的课程教学风格与质量，二是可以感受一下课程难度自己能否理解接受，三是可以判断一下自己是否感兴趣，其实无论是参加培训还是自学，都还是比较需要自己的自学能力的，毕竟还是那句话，师傅领进门修行在个人，也不能完全依靠老师教了你就成神了，当然名师出高徒也是有道理的，不过名师自来都是带勤奋的，有天赋的，毕竟名师也是靠这两样才成为名师的，咱们都是普通人还是自己多吃点苦勤奋一点为好，我认为老师只是在我们学习路上，传道，授业，解惑的人。
我是参加过培训的哈，我整理了一下我参加的培训班一些免费课程和资料，我放在这里，有需要的伙伴可以参考学习一下哈。
（声明：我不是广告哈，我只是个人参加了这个培训，有人说好也有人说不好的，但是对于我个人来讲觉得还是挺不错的，也很适合自学阶段的人来学习，这个每个人的认同不一样，无关谁的对与错哈，毕竟每个机构都有好评差评，就像小学初中，一个班级还有学习好的学习差的，这个希望大家可以理解哈）
我也整理过一篇文章是我学习python准备的一个经历，大家感兴趣的可以看一下。
首先自学肯定是要先学会安装python，下面附带python安装包的下载
python各种版本的安装包
Python 2.7 for Windows
 
Python 2.7 for Mac
 
Python 3.6 for Windows
 
Python 3.6 for Mac
 
PyCharm 2017.2.3 for Windows
 
PyCharm 2018.1 for Mac
安装步骤可查看原贴：
初学 Python 需要安装哪些软件？
初级基础部分
Python入门教程完整版（懂中文就能学会）
视频下载
配套资料（提取码:w61i）
2019年python入门必备指南
视频下载
配套资料（提取码:4jp5）
进阶部分
python进阶深入浅出
视频+配套资料（提取码：3fdh）
框架
6节课入门Flask框架web开发
配套资料（提取码：fbwr）
Django视频教程_Django入门视频教程
视频下载
配套资料（提取码：r446）
高阶
6节课掌握Python
爬虫
视频下载
配套资料（提取码:8pdk）
4天快速入门Python数据挖掘
视频下载
配套资料（提取码：6222 ）
4天学会python
量化交易
视频+配套资料（提取码：tvtp）
最简单快速入门Python机器学习
视频下载
配套资料（提取码：lnv1）
Python深度学习之神经网络
视频下载
配套资料（提取码：a4n3）
Python|360°解读机器学习经典算法
视频下载
配套资料（提取码：j843 ）
3天带你玩转Python深度学习
视频下载
配套资料（提取码：94hm）
python爬虫热点项目
视频下载
配套资料（提取码：8pdk）
人工智能
0基础小白也能学会的人工智能   
视频下载
配套资料（提取码：9kml ）
超系统掌握人工智能机器学习算法
视频下载
配套资料（提取码：yqa1）
---------------------------------------------------------------------------------------------
2020年1月11日 18：21 更新
有很多伙伴私聊我说自学的问题，这里我分享一个自学的思路吧
学习python，首先根据自己零基础的情况下，为什么学习Python作为核心问题，进行了一个自我定位以及目标定位，我认为只要有一个目标，那么就找方法去打成目标就行了。
完全零基础，选择学习Python主要还是因为看到大家都说Python是相对简单，比较好入门IT行业的，而目的也是希望学习完Python可以找到一份相应的工作。
当然，也有很多人可能已经从事其他编程工作，但是想要学习Python以来丰富自身，提升自身的核心竞争力，我觉得这样应该会比我这类完全零基础的学习要容易快速的很多，
我也搜查了一些学习方法的问答帖子，里面也看到很多推荐的学习方法，有推荐书籍的，有推荐网课的，我开始认为，看书应该是比较好的选择，因为著作成书籍，表明内容上是相对有一定的权威和系统的，同时，想到从小都是书本学习，这更能让我信服，于是我就购买了书籍，开始了我的学习计划，可是，在半强迫自己的情况下，我看了三天半书籍实在是看不下去了，
是的，三天半还是强迫自己看的，
原因一，看书真的太乏味了，看着看着就会心不在焉，总是走神。原因二，这个时候我对代码没有概念，有些文字都要读两三遍才会理解意思，越难理解就越不想看书，这种感觉就是上学时我看数学，英语书一模一样的感觉。很显然，看书学习是不适合我了，
看书不行，于是我就想着还是找网上的视频教程学习吧，上网一搜，真的是各家机构的教程也是琳琅满目，还真的让我不知道从哪开始学起了，这个时候真的是想有一位前辈可以给我指点一下迷津，告诉我应该先学什么，再学什么，哪些是重点知识，哪些是了解就好，就是可以给我一些学习的建议，于是我想那我可以先加入一些技术学习交流群，在里面应该可以认识到一些学习的人，于是我就开始大量的搜索加入学习群，于是在里面开始咨询学习方法，但是，这个时候我又发现，我好像一张白纸，我想问一些问题，可是我不知道该怎么问，我也只能问大家都是怎么学习得，群内的朋友也都还很热情，也和我说了很多学习方式，不过我发现每个人都有各自的学习方式，各自都有各自的理论和优势，在那么多的方法面前我再一次的有些混乱，又不知道哪一方法适合我，于是，我想到千人千面，每个人有每个人的想法，我咨询的人越多，获取的信息越多可能我就会越乱，于是我决定，
那我就要借鉴看到的这些信息，来整理一套自己的方式，不一定对，但是可能这更适合我自己。
于是，我并没有先着急的就找教程视频来直接学习，我现在想知道就是，应该先学什么，掌握哪些知识之后，再学什么，我觉得我应该先整理一套相对看上去系统的教程，虽然我最希望可以找到一个人给我一些这类的指引，但是奈何没有找到，那就只能自己去整理了，我根据我买的书籍目录，以及查了一些培训机构的学科介绍，教程大纲内容，进行了一个统计对比，发现其实学习的内容路径也还是有它一定的规律，那我就整理了一份知识点的目录学习路径，我按照我整理的这个学习路径上的知识点目录去查找对应的教程，这样就整理了一套自己的学习资料，整理学习路径和教程，利用了我比较多得时间，不过整理好了那么就可以开始学习了。
但在查找教程的时候，又走了一些弯路，我当时只想到只要按照我整理的这个目录找到对应的教程就好了，可是在学习的时候，还是觉得知识点之间的衔接有些杂乱无章，而且每一个知识点都是不同机构课程风格不同得教程视频，这让我学上去有些别扭，而且有的老师讲的我很喜欢听，有的就不是很喜欢，于是，我就又想，那我就找我喜欢这个老师的课程就好啦，可是我找了两三天，同一个老师的教程是非常难找到公开的全套教程，这个我想也可以理解，老师也可能没时间和精力来从零开始录制全套教程，而且老师也是要工作赚钱养家生活的，于是我想那我可以找同一个机构的教程吧，这样也能最起码是课程风格一致，于是我就找到了我我认为课程比较好得教程机构，又将我的学习资料重新的整理替换了一下，果然我觉得学习感觉好了一些，而且我又找到他们的客服，要到了他们课程的一些配套资料，这对我学习来说起到了更加的有效帮助。
最后，在学习完我整理的学习知识教程之后，又遇到了一个瓶颈，就是学习完知识点内容，掌握的也是七七八八，之后又不知道该怎么做了，不知道自己学习的有没有达到可以找工作的条件，于是我又查询了一些资料，可一些招聘信息，了解的一些信息主要要求说是需要项目经验，需要一些项目功能技术的掌握，那我的理解就是，已经掌握了基础知识，企业招聘人员需要掌握一些项目技术能力，去帮助解决处理问题，也就好像，
假设Python有100个技术框架，但是一个企业只用到其中30个，那如果你的学习掌握正是他们用的这30个，那么你不会那另外的70个也可以，只不过你学习掌握的越多，你的条件符合范围和就业机会也就越大，
我按照我的这个大致理解，我就仔细了解了一下Python主要可以从事哪些方向，我就根据我比较喜欢的方向看了一下招聘信息，然后根据上面的普遍要求，进行了学习。最后就整理包装了一下简历，尝试着投简历找工作，当然面试也并不是顺利，刚开始的面试是还慌乱，面试也是没有任何结果，不过我是在每次面试中总结经验，收集好面试问题，回来在好好准备，为下一次面试做知识储备，就这样我面了试大概有将近二十家，终于也是找到了一个算是实习岗位的工作，我想着先做着，这个时候应该先到企业中去学习一些真实的项目经历比较重要。
最后我总结一下我学习过程中我认为比较重点的内容把
首先，学习我们要有一个清楚的自我认识，是为了找工作，还是为了辅助工作来增加自己的竞争力，也就是要有一个明确的目标。
如果是完全零基础学习，我建议开始不要先看书，原因上面我也有说了，这个时候看书完全看不进去，里面的知识点也很难理解的，虽然我们从小就接受书本教育，可是前提也都是要有老师讲解的，不是我们自己看书就可以的。
然后，就是要寻找一套适合自己的学习方式，最好还是自己整理一套适合自己的学习资料，因为只有自己最了解自己，这里可能会花费比较长的时间，但是这会让你在之后的学习上节省很多时间，让你事半功倍。
最后，如果在选择视频教程的时候，尽量选择一个老师的教程（但是很难实现）最差也要尽量选择同一家机构的教程，因为这样在课程设计和课程风格上相对比较统一。然后在学习的过程中，最好是根据视频课程老师的进度，自己做学习笔记，这样的好处，一是，在今天学习完，明天你可能就只记得一个大致概念了，俗话说，好记性不如烂笔头，做笔记会让自己印象更深刻，二是，在之后你想要回头复习的时候，也会让你有一个清晰的复习思路。当学习完一个阶段知识的时候，感觉视频老师讲解的内容有些浅，这时候可以看一些优秀的书籍，因为你觉得老师讲的浅，说明你的学习理解的非常好，这时候看一些书可以起到很大的提升作用。
至于找工作面试的事情我就不详细的写了，手敲了这么多，有点累了，最后希望我的建议可以对想要学习的伙伴有一点点帮助吧。","我以往学过很多种编程语言，唯独python学了以后迅速进入应用阶段，用起来得心应手。这里除了python本身易学易用外，我寻找到学习路径上的结点，然后发现了我熟练使用python的一个重要结点。
我在2005年开始从《简明Python教程》入门。随后做过一些千行上下的小程序。随后也想大部分人一样开始迷茫python有啥用。迷茫时继续看书，读了《Python2.1宝典》，并记录了21.2万字的笔记。这也是我所有笔记中篇幅最大的。我字数过7万字的也只有12篇而已。python大类是204万字。
没有编程经验，而希望从Python入门学编程的同学，在学习如下列出的Python库之前，还是需要先把基础学好的。推荐一下
夜曲编程
的Python入门课。
他们的免费教程适合学习预算较少的同学，通过20天完成Python基础入门知识的学习。如果学习预算比较宽裕，可以尝试付费课程，会有代码题练手，也有专门助教解答学习中遇到的问题。
点击关注后回复【夜曲入门1】即可获得Python入门完整免费教程，学习编程更轻松！
广告
【夜曲编程】0基础小白编程入门第一课，百词斩出品！点击领取
而这本书对我后续影响深远，解释了好多个初学者关心的问题。比如程序如何组织，python有哪些好用的库，python适合做哪些程序，如何写界面、服务器、数据存储等等。大家可以看看我笔记记录的目录，有些没有子目录的是没看的：
目录
1   认识Python
1.1   启动Python解释程序
1.2   用变量和表达式进行试验
1.2.1   袖珍计算器
1.2.2   变量
1.3   定义函数
1.4   运行Python程序
1.5   循环和控制
1.5.1   整除
1.5.2   循环
1.5.3   采用if语句的分支
1.5.4   中断和继续
1.6   列表和元组
1.6.1   元组
1.6.2   切片和切换
1.7   词典
1.8   读写文件
1.9   样例程序：字频率
1.10   加载及使用模块
1.11   创建类
1.11.1   一些快速对象术语
1.11.2   对象定位、Python风格
1.11.3   访问类成员
1.11.4   示例：点类
1.12   推荐的阅读资料
2   标识符、变量和数字类型
2.1   标识符和运算符
2.1.1   保留字
2.1.2   运算符
2.2   数字类型
2.2.1   整型
2.2.2   长整型
2.2.3   浮点数
2.2.4   虚数
2.2.5   处理数字类型
2.3   给变量赋值
2.3.1   简单的赋值语句
2.3.2   多个赋值
2.3.3   扩充赋值
3   表达式和字符串
3.1   表达式
3.1.1   比较数字类型
3.1.2   复合表达式
3.1.3   复合表达式
3.1.4   运算符的优先顺序
3.2   字符串
3.2.1   字符串文字
3.2.2   处理字符串
3.2.3   比较字符串
3.2.4   Unicode字符串文字
3.3   在简单类型之间进行转换
3.3.1   转换为数字类型
3.3.2   转换为字符串
4   第四章 高级数据类型
4.1   采用序列组合数据
4.1.1   创建列表
4.1.2   创建元组
4.2   处理序列
4.2.1   采用算术运算符连接和重复
4.2.2   比较和成员资格测试
4.2.3   访问序列中的某部分
4.2.4   采用for...in进行循环
4.2.5   使用序列实用程序函数
4.3   使用附加的列表对象特征
4.3.1   附加运算
4.3.2   列表对象方法
4.4   用词典映射信息
4.4.1   创建并添加到词典
4.4.2   访问和更新词典映射
4.4.3   附加的词典运算
4.5   理解引用
4.5.1   对象身份
4.5.2   计算引用的数目
4.6   复制复合对象
4.6.1   浅副本
4.6.2   深副本
4.7   标识数据类型
4.8   处理数组对象
4.8.1   创建数组
4.8.2   在类型之间转换
4.8.3   数组方法和运算
5   控制流
5.1   用if语句做出决策
5.2   使用for循环
5.2.1   for循环的剖析
5.2.2   循环示例：给字符串编码
5.2.3   ranges和xranges
5.2.4   中断、继续和else子句
5.2.5   在中途换马
5.3   使用while循环
5.4   抛出和捕获异常事件
5.4.1   扩散异常事件
5.4.2   处理异常事件
5.4.3   有关异常事件的更多信息
5.4.4   定义和产生异常事件
5.4.5   用finally进行清除
5.5   用断言进行调试
5.5.1   Python中的断言
5.5.2   触发断言
5.6   示例:Game of Life
6   程序组织
6.1   定义函数
6.1.1   通过对象引用传递
6.1.2   有关参数的所有信息
6.1.3   任意参量
6.1.4   应用：从元组中传递参量
6.1.5   带有一点功能性的编程
6.2   用模块为代码分组
6.2.1   布局模块
6.2.2   获取模块的清单
6.3   导入模块
6.3.1   导入时还会发生什么现象
6.3.2   重新导入模块
6.3.3   外来的导入
6.4   定位模块
6.4.1   Python路径
6.4.2   编译文件
6.5   理解作用域规则
6.5.1   是局部还是全局
6.5.2   列出名字空间的内容
6.6   将模块组合为包
6.7   按计划编译和运行
7   面向对象的Python
7.1   概述面向对象的Python
7.2   创建类和实例对象
7.2.1   创建实例对象
7.2.2   有关访问属性的更多信息
7.3   从其他类中派生新类
7.3.1   多继承
7.3.2   创建定制的列表类
7.3.3   创建定制的字符串类
7.3.4   创建一个定制的词典类
7.4   隐藏私有数据
7.5   识别类成员
7.6   重载标准行为
7.6.1   重载的基本功能
7.6.2   重载数字运算符
7.6.3   重载序列和词典运算符
7.6.4   重载按位运算符
7.6.5   重载类型转换
7.7   使用弱引用
7.7.1   创建弱引用
7.7.2   创建代理对象
8   输入和输出
8.1   打印到屏幕
8.2   访问键盘输入
8.2.1   raw_input
8.2.2   input
8.3   打开、关闭及定位文件
8.3.1   open
8.3.2   文件对象信息
8.3.3   close
8.3.4   文件位置
8.4   写文件
8.5   读文件
8.6   访问标准I/O
8.7   使用类似文件的对象
9   处理字符串和正则表达式
9.1   使用字符串对象
9.1.1   设置字符串格式的方法
9.1.2   更改字符串大小写的方法
9.1.3   字符串格式测试(is方法)
9.1.4   字符串搜索方法
9.1.5   字符串处理方法
9.2   使用字符串模块
9.2.1   字符种类
9.2.2   杂项函数
9.3   定义正则表达式
9.3.1   正则表达式的句法
9.3.2   反斜线和未处理的字符串
9.3.3   字符组和其他反斜线魔数
9.3.4   不贪婪的匹配
9.3.5   扩展
9.3.6   创建和使用正则表达式对象
9.3.7   使用正则表达式对象
9.3.8   在不编译的情况下应用正则表达式
9.4   使用匹配对象
9.4.1   group([groupid,...])
9.4.2   groups([nomatch])
9.4.3   groupdict([nomatch])
9.4.4   start([groupid]),end([groupid]),span([groupid])
9.4.5   re,string,pos,endpos
9.5   把字符串当作文件处理
9.6   为文本编码
9.6.1   使用Unicode字符串
9.6.2   读写非ASCII字符串
9.6.3   使用Unicode数据库
9.7   设置浮点数的格式
9.7.1   fix(number,precision)
9.7.2   sci(number,precision)
10   处理文件和目录
10.1   检索文件和目录信息
10.1.1   逐点方法
10.1.2   I-want-it-all方法
10.2   建立并仔细分析路径
10.2.1   联接路径部件
10.2.2   把路径分为几块
10.2.3   路径的其他修改工具
10.3   列出目录及其匹配文件名
10.4   获得环境和参量信息
10.4.1   环境变量
10.4.2   当前工作目录
10.4.3   命令行参数
10.5   示例：递归的grep实用程序
10.6   复制、重命名及删除路径
10.6.1   复制和链接
10.6.2   重命名
10.6.3   删除
10.7   创建目录和临时文件
10.8   比较文件和目录
10.9   处理文件描述符
10.9.1   通用文件描述符函数
10.9.2   管道
10.10   其他的文件处理技巧
10.10.1   任意访问文本文件中的信息行
10.10.2   使用内存映射文件
10.10.3   重复处理几个文件
11   使用其他操作系统服务
11.1   执行shell命令和其他程序
11.2   产生子进程
11.2.1   popen函数
11.2.2   spawn函数
11.2.3   fork
11.2.4   进程管理和终止
12   存储数据和对象
12.1   数据存储概述
12.1.1   文本与二进制对比
12.1.2   压缩
12.1.3   字节次序(Endianness)
12.1.4   对象状态
12.1.5   目的地
12.1.6   在接收端
12.2   加载并保存对象
12.2.1   采用pickle进行转换
12.2.2   marshal模块
12.3   示例：通过网络移动对象
12.4   使用类似数据库的存储
12.5   转换到C结构或从C结构转换回来
12.6   把数据转换为标准格式
12.6.1   Sun的XDR格式
12.6.2   其他格式
12.7   压缩数据
12.7.1   zlib
12.7.2   gzip
13   访问日期和时间
13.1   在Python中告知时间
13.1.1   滴答
13.1.2   时间元组
13.1.3   秒表时间
13.2   时间格式之间的转换
13.3   解析及打印日期时间
13.3.1   有趣的格式
13.3.2   解析时间
13.3.3   定位
13.4   访问日历
13.4.1   打印月历和年历
13.4.2   日历信息
13.4.3   闰年
13.5   使用时区
13.6   允许两位数字的年
14   使用数据库
14.1   使用基于磁盘的词典
14.2   DBM示例：跟踪电话号码
14.3   基于磁盘的高级词典
14.3.1   dbm
14.3.2   gdbm
14.3.3   dbhash
14.3.4   使用BSD数据库对象
14.4   访问关系数据库
14.4.1   连接对象
14.4.2   事物处理
14.4.3   游标对象
14.5   示例：""类似声音的""查询
14.6   检验相关的元数据
14.7   示例：创建审计表
14.8   DB API的高级特征
14.8.1   输入和输出大小
14.8.2   可重新使用的SQL语句
14.8.3   数据库的库信息
14.8.4   错误层次
15   联网
15.1   联网背景
15.2   处理地址和主机名
15.3   与低层套接字通信
15.3.1   创建和撤消套接字
15.3.2   连接套接字
15.3.3   发送和接收数据
15.3.4   使用套接字选项
15.3.5   转换数字
15.4   示例：多点传送的聊天应用程序
15.5   使用SocketServers
15.5.1   SocketServer族
15.5.2   请求处理程序
15.6   处理Web浏览器请求
15.6.1   BaseHTTPRequestHandler
15.6.2   SimpleHTTPRequestHandler
15.6.3   CGIHTTPRequestHandler
15.6.4   示例:形成处理程序CGI脚本
15.7   在不使用线程的情况下处理多个请求
15.7.1   asyncore
16   理解Internet协议
17   处理Internet数据
18   分析XML和其他标记语言
18.1   标记语言基础知识
18.1.1   标记用于元文本
18.1.2   标记规则
18.1.3   名字空间
18.1.4   处理XML
18.2   分析HTML文件
18.2.1   HTMLParser方法
19   使用Tkinter
19.1   Tkinter简介
19.2   创建GUI
19.2.1   用部件建立界面
19.2.2   部件选项
19.3   部件布局
19.3.1   packer选项
19.3.2   网格选项
19.4   示例：Breakfast按钮
19.5   使用常见选项
19.5.1   颜色选项
19.5.2   大小选项
19.5.3   行为选项
19.6   搜集用户输入
19.7   示例:打印奇特的文本
19.8   使用文本部件
19.9   建立菜单
19.10   使用Tkinter对话框
19.10.1   文件对话框
19.11   实例：文本编辑器
19.12   处理颜色和字体
19.12.1   颜色
19.12.2   字体
19.13   绘制图形
19.13.1   画布部件
19.13.2   处理画布项
19.14   使用计时器
19.15   实例：反弹图片
20   使用高级Tkinter部件
20.1   处理事件
20.1.1   创建事件处理程序
20.1.2   绑定鼠标事件
20.1.3   绑定键盘事件
20.1.4   事件对象
20.2   实例：绘图画布
20.3   高级部件
20.3.1   列表框
20.3.2   标尺
20.3.3   滚动条
20.4   实例：颜色方案定制程序
20.5   创建对话框
20.6   支持拖放操作
20.7   使用光标
20.8   设计新部件
20.9   其他的Tkinter功能
20.10   其他的部件
20.11   学习更多内容
21   用wxPython建立用户界面
21.1   介绍wxPython
21.2   创建简单的wxPython程序
21.3   选择不同的窗口类型
21.3.1   管理窗口
21.3.2   非管理窗口
21.4   使用wxPython控件
21.4.1   常用控件
21.4.2   树形控件
21.4.3   编辑器控件
21.5   控制布局
21.5.1   指定坐标
21.5.2   筛选器
21.5.3   布局限制
21.5.4   布局算法
21.6   使用内置对话框
21.7   设备相关内容绘图
21.8   添加菜单和快捷键
21.9   访问鼠标和键盘输入
21.10   其他的wxPython特性
21.10.1   剪贴板、拖放和光标
21.10.2   图形
21.10.3   日期和时间
21.10.4   字体
21.10.5   HTML
21.10.6   打印
21.10.7   其他
22   使用Cruses
23   建立简单的命令解释程序
24   播放声音
24.1   声音文件基础
24.2   播放声音
24.2.1   在Windows上播放声音
24.2.2   在SunOS上播放和记录声音
24.3   测试音频文件
24.4   读取和编写音频文件
24.4.1   用aifc来读取和写入AIFF文件
24.4.2   用sunau读取和写入au文件
24.4.3   用wave读取和写入WAV文件
24.4.4   实例：倒转音频文件
24.4.5   读取IFF大块数据
25   图像处理
25.1   图像基础
25.2   识别图像文件类型
25.3   在颜色系统间转换
25.3.1   颜色系统
25.3.2   从一种系统转换到另一种系统
25.4   处理原始图像数据
25.5   使用Python图像库
25.5.1   检索图像信息
25.5.2   复制与转换图像
25.5.3   使用带有Tkinter的PIL
25.5.4   裁剪和调整图像尺寸
25.5.5   修改像素数据
25.5.6   其他PIL功能
26   多线程
26.1   理解线程
26.2   执行、跟踪和终止线程
26.2.1   使用thread模块来创建线程
26.2.2   使用threading模块开始和停止线程
26.2.3   线程状态和threading下的信息
26.2.4   在threading下找到线程
26.2.5   等待线程完成
26.3   避免并发问题
26.3.1   Thread锁定
26.3.2   threading锁定
26.4   防止死锁
26.5   实例：从多个URL下载
26.6   转入线程化代码
26.7   将线程与队列编织在一起
26.8   技术要点：并发是如何发生的
26.9   更多信息
27   调试、配置和优化
27.1   调试Python代码
27.1.1   开始和停止调试程序
27.1.2   检查状态
27.1.3   设置断点
27.1.4   运行
27.1.5   Aliases
27.1.6   调试技巧
27.2   使用docstrings工作
27.3   自动测试
27.3.1   使docstrings和代码同步
27.3.2   单元测试
27.4   发现瓶颈
27.4.1   配置代码
27.4.2   使用Profile对象
27.4.3   校准配置程序
27.4.4   定制统计
27.5   常见优化技巧
27.5.1   排序
27.5.2   循环
27.5.3   I/O(输入/输出)
27.5.4   字符串
27.5.5   线程
27.6   扔掉废物-回收站
27.6.1   引用记数和Python代码
27.6.2   引用记数和C/C++代码
28   安全与加密
28.1   密码检查
28.2   在限制环境中运行
28.2.1   rexec沙盒
28.2.2   使用要塞类(class fortress)
28.3   创建消息指纹
28.3.1   MD5
28.3.2   SHA
28.3.3   其他用途
28.4   使用20世纪40年代的加密方法
29   编写扩展模块
30   嵌入Python解释程序
31   数值计算
32   使用NumPy
33   解析和解释Python代码
34   创建全世界可用的应用程序
34.1   国际化和本地化
34.2   为多种语言准备应用程序
34.2.1   NLS示例
34.2.2   这一切的含义
34.3   与地域相关输出的格式化
34.3.1   修改地域
34.3.2   与地域相关的格式化
35   定制导入行为
36   分布模块和应用程序
37   Windows平台
37.1   使用win32all
37.1.1   数据类型
37.1.2   错误处理
37.1.3   找到自己所需要的
37.2   示例：使用某些Windows API
37.3   访问Windows注册表
37.3.1   用win32all访问注册表
37.4   示例：设定IE主页
37.4.1   键的创建、删除和定位
37.4.2   示例：键的递归删除
37.4.3   其他注册表函数
37.4.4   用_winreg访问注册表
37.5   使用msvcrt goodies
37.5.1   控制台I/O
37.5.2   其他函数
38   Unix兼容模块
就是这样一本老掉牙的书，帮助我迅速把python用到了众多领域。其关键不在于老，而是这本书列出了很多库，让读者知道这些库能解决什么问题，并拓展读者的思路。在python-cn邮件列表里，大家的一个常见话题也是某个需求不知用什么模块搞定。
所以，对于希望系统学习python的同学。python语言本身的内容很少。想要让python发挥更大作用，就需要了解更多的库。有如下几个办法：
1、python标准库的文档，每个模块都把简介看完，这会涉及上百个模块。
2、去
http://
python.org
网站，会看到各个应用领域的推荐框架，把每个框架的hello world都跑通。
3、常见书籍的目录在各大网上书店是公开的，多去收集整理目录中提到的模块，去了解其用途。
如上三个步骤可能要花掉几十甚至一百多小时。带来的收益也会非常可观，当你需要做某个事情时会发现有足够多的python积木，等着你来搭建起整个系统。","在别的地方看到大神总结，供参考。
热门资源博客 Mybridge AI 比较了 18000 个关于 Python 的项目，并从中精选出 45 个最具竞争力的项目。我们进行了翻译，在此一并送上。
这份清单中包括了各不相同的 20 个主题，以及一些资深程序员分享使用 Python 的经验，值得收藏。Mybridge AI 的排名结合了内部机器评估的内容质量和各种人为因素，包括阅读次数和阅读时长等。
对于 Python 的初学者，我们推荐以下这些课程：
REST API：使用 Python，Flask，Flask-RESTful 和 Flask-SQLAlchemy 构建专业的 REST API ［12,602 个推荐，4.6 / 5 星］
链接：
https://www.
udemy.com/rest-api-flas
k-and-python/
算法交易：用于财务分析和算法交易的 Python，主要学习包括 numpy，pandas，matplotlib，quantopian，finance ［8,077 个推荐，4.6 / 5 星］
链接：
https://www.
udemy.com/python-for-fi
nance-and-trading-algorithms/
年度开源 Python 项目 ［平均 4,078 星］
链接：
https://
medium.mybridge.co/30-a
mazing-python-projects-for-the-past-year-v-2018-9c310b04cdb3
机器学习年度最佳文章
链接：
https://
medium.mybridge.co/lear
n-to-build-a-machine-learning-application-from-top-articles-of-2017-cdd5638453fc
Python 算法
1.回顾 Python 交互式编码中所要面对的挑战（算法和数据结构）
本文对算法编码和数据结构中的问题提出了简单易懂又切实可行的方案。
作者：Donne Martin；［github－11811 星］链接：
https://
github.com/donnemartin/
interactive-coding-challenges
2. Python 中算法和数据结构的最小样本
如何让 Python 中的数据结构和算法最小、最干净？
作者：keon；［github－10271 星］链接：
https://
github.com/keon/algorit
hms
3.最重要的 Python 算法--Pygorithm
Pygorithm 是一个纯 Python 风格编写的模块，通过导入所需的算法，获得相应的代码、时间复杂性等。这是一个开始学习 Python 编程的好方法，能够帮助初学者学习并实现 Python 中所有算法。
作者：Satwik Kansal；［github－3156 星］链接：
http://
pygorithm.readthedocs.io
/en/latest/
Python 综合指南
4. 一个有趣又鲜为人知的 Python 代码片段集合―wtfPython
作者：Satwikkansal；［github－4,933 星］链接：
https://
github.com/satwikkansal
/wtfPython
Python 的脚本结构
5.一个关于如何从 Python 脚本到打包项目的标准化指南
作者：Courtesy of Vicki链接：
http://
veekaybee.github.io/201
7/09/26/python-packaging
Python 中的列表
6.Python 列表生成器的教程
在这份教程中，你将能够学习到如何在 Python 中有效地使用列表生成器来创建列表，替换(嵌套) for 循环以及使用 map(), filter(), reduce() 函数等。
文章首先简单回顾了 Python 中列表的基本概念，并与 Python 中其他的数据结构进行比较。接着讲解了列表生成器的学习。文章还讲解了 Python 列表背后的数学知识，创建列表生成器的方法，以及如何在 for 循环或 lambda 隐函数中重写它们。
作者：Karlijn Willems链接：
https://www.
datacamp.com/community/
tutorials/python-list-comprehension
Python 中的类
7.如何使用 Dunder (Magic、Special) 方法来丰富你的 Python 类
Dunker 是 Python 中的一种特殊方法，通过双下划线开始和结束的形式存在，例如 __init__ 来丰富类的预定义方法。
作者：Dan Bader链接：
https://
dbader.org/blog/python-
dunder-methods
Python 中的网页抓取
8.如何使用 Python 中的 Scrapy、SQL 和 Matplotlib 等库进行网页抓取，并获取网页数据分析
你可以通过这篇文章学习到网页爬取知识，并用于实践中。
作者：ScrapingAuthority链接：
http://www.
scrapingauthority.com/p
ython-scrapy-mysql-and-matplotlib-to-gain-web-data-insights/
9.高级的网页抓取教程：绕过“403 禁止”，验证码等问题
作者：Evan Sangaline链接：
http://
sangaline.com/post/adva
nced-web-scraping-tutorial/
10.掌握 Python 的网页抓取技巧来获取你所需要的数据
作者：Lauren Glass 和 Hackernoon链接：
https://
hackernoon.com/masterin
g-python-web-scraping-get-your-data-back-e9a5cc653d88
Python 中的自动化操作
11.如何使用 Twilio、Python 和 Google 自动化婚礼的进程
作者：Thomas Curtis链接：
https://www.
twilio.com/blog/2017/04
/wedding-at-scale-how-i-used-twilio-python-and-google-to-automate-my-wedding.html
12.如何用 Python 在 Medium 上找到有趣的人
作者：Radu Raicea 和 freeCodeCamp。链接：
https://
medium.freecodecamp.org
/how-i-used-python-to-find-interesting-people-on-medium-be9261b924b0
Python 中的 Bot
13.制作 Reddit+Facebook 的信息箱
作者：Yasoob Khalid链接：
https://
pythontips.com/2017/04/
13/making-a-reddit-facebook-messenger-bot/
15.我在 Instagram 上用 Python 写的
开源机器人
（让我拥有了 2500 个粉丝，所花的服务器成本只有 5 美元）
作者：TimG链接：
https://
medium.freecodecamp.org
/my-open-source-instagram-bot-got-me-2-500-real-followers-for-5-in-server-costs-e40491358340
Python 中的电子表格
15.权威指南：Python 的 Excel 教程
通过这个教程，你可以了解如何使用 Python 读取和导入 Excel 文件，如何将数据写入这些电子表格。
作者：Karlijn Willems链接：
https://www.
datacamp.com/community/
tutorials/python-excel-tutorial
16.Python 和 Googgle 电子表格
作者：Brent Schooley链接：
https://www.
youtube.com/watch?
v=vISRn5qFrkM
Python 中的金融应用
17.Python 中的金融：算法交易
这是一份 Python 与金融应用的教程，在此你能学习到算法交易的基本知识及相关内容。
作者：Karlijn Willems链接：
https://www.
datacamp.com/community/
tutorials/finance-python-trading
18.Python 中的金融教程―股票价格及相关数据介绍
作者：Harrison Kinsley链接：
https://www.
youtube.com/watch?
v=2BrpKpWwT2A
19.用 Python 分析加密货币市场
比特币市场是如何表现？加密货币价值突然出现高峰和低谷的原因是什么？不同 altcoins 市场是不可分割的或基本独立的？ 我们如何预测接下来会发生什么？
这篇文章将简单地介绍如何使用 Python 来分析加密货币。文章通过一个简单的 Python 脚本来检索，分析和可视化不同加密货币上的数据。在这个过程中，文章还将揭示这些波动剧烈的市场行为以及一个有趣的演变趋势。
作者：Patrick Triest链接：
https://
blog.patricktriest.com/
analyzing-cryptocurrencies-python/
Python 中的区块链
20.学习并构建一个区块链
毫无疑问，区块链这项新颖的技术是计算的奇迹。区块链技术的出现引发了新的全数字货币，如比特币和莱特币，而这些货币并非由中央当局发行或管理。区块链也以 Ethereum 这样的技术形式革命化了分布式计算，并引入了智能合约等有趣的概念。
这篇文章将会帮助你学习并理解区块链的工作原理。通过这篇教程，你将学习到一个功能强大的区块链，并掌握它们的工作流程。
作者：Daniel van Flymen 和 Hackernoon链接：
https://
hackernoon.com/learn-bl
ockchains-by-building-one-117428612f46
21.如何构建一个最小的区块链
本文将用少于 50 行的代码（Python2）来创建一个最简单、最小的区块链。
作者：Gerald Nash链接：
https://
medium.com/crypto-curre
ntly/lets-build-the-tiniest-blockchain-e70965a248b
Python 中的视频合成
22.用 Python 构建一个视频合成器
视频合成器是利用音频输入来创建视觉信号的设备，自上世纪 60 年代以来，已有很长的历史。
这篇文章将用 Python 编写一个基本的视频合成器，并使用 aubio 进行 Onset 目标检测。
作者：Kirk Kaiser链接：
https://www.
makeartwithpython.com/b
log/video-synthesizer-in-python/
Python 的性能
23.用 Python 处理每秒 100 万个请求
用 Python 每秒能够达到 100 万个请求吗？为了节省服务器价格，最近很多公司正在从 Python 向其他编程语言中迁移。但实际并不需要。
Python 社区最近在性能提升方面做了很多工作。CPython 3.6 通过新的字典提高了整体解释器的性能。由于引入了更快的调用约定和字典查找缓存，CPython 3.7 将会更快。
对于数字处理任务，你可以使用 PyPy 进行代码编译。你还可以运行 NumPy 的测试套件，该测试套件现在已经改进了 Python 与 C 语言扩展的整体兼容性。在随后的更新版本中，PyPy 预计将与 Python 3.5 兼容。
作者：Pawe? Piotr Przeradowski。链接：
https://
medium.freecodecamp.org
/million-requests-per-second-with-python-95c137af319
24.Python 很慢，但我不在乎”
这篇文章将介绍一些关于 Python 中 asyncio 的内容，并讨论有关 Python 速度的问题。
作者：Nick Humrich链接：
https://
hackernoon.com/yes-pyth
on-is-slow-and-i-dont-care-13763980b5a1
25.Python 中的缓存：如何缓存函数的结果
文章将介绍一种快捷的方法来加速 Python 记忆代码。你将看到何时以及如何运用 Python 记忆代码。记忆代码优化你的程序，在某些情况下会加速你的代码运行。
链接：
https://
dbader.org/blog/python-
memoization
Python 中的 Django 框架
26.七步骤带你完整地学习 Django
Django 是用 Python 编写的一个 Web 框架。这篇文章是介绍 Django 基础知识的系列教程，共分为七个部分，将分别从安装，准备开发环境，模型，视图，模板，URL 到更高级的主题（如迁移，测试和部署）出发，详细探讨所有的基本概念。
作者：Vitor Freitas链接：
https://
simpleisbetterthancomplex.com
/series/2017/09/04/a-complete-beginners-guide-to-django-part-1.html
27.使用 Django 构建 REST API 的测试驱动方法：第一部分
这篇文章将介绍如何利用 Django 来构建一个 REST API 的测试驱动，并详细介绍了每个步骤。
作者：Jee Githinji Gikera 和 Scotch Development链接：
https://
scotch.io/tutorials/bui
ld-a-rest-api-with-django-a-test-driven-approach-part-1
Python 中的 Flake
28.OI’List 规则
这篇博文中我们将介绍 Flake8（pyflakes，
pycodestyle
 和 mccabe）中的每个规则及相对应的示例。
链接：
https://
lintlyci.github.io/Flak
e8Rules/
29.使用 Python 和 Flask 开发 RESTful API
本文包括以下几部分：
为什么用 Python？
什么是 Flask？
引导 Flask 应用程序
用 Flask 创建一个 RESTful 端点
用 Python 类映射模型
用 Marshmallow 进行序列化和反序列化对象
Dockerizing Flask 应用程序
用 Auth0 保护 Python API
作者：Bruno Krebs链接：
https://
auth0.com/blog/developi
ng-restful-apis-with-python-and-flask/
Python 中的 Numpy
30.从 Python 到 Numpy
本文通过一种新颖的方式，向量化地集中讲解了如何从 Python 迁移到 Numpy 的学习。另外，本文还包括一些很少提到的使用技巧。
链接：
http://www.
labri.fr/perso/nrougier
/from-python-to-numpy/
31.探索 Python 每种工具包的行长度
本文探索了 Python 的流行包，如 NumPy，SciPy，Pandas，
，Matplotlib，AstroPy 等。
作者：Jake VanderPlas链接：
http://
jakevdp.github.io/blog/
2017/11/09/exploring-line-lengths-in-python-packages/
Python 中的 NashPy
32.NashPy 教程―建立并找到一种简单的游戏平衡
博弈论是用来研究理性主体之间的战略互动：当双方试图采用对各自最有益的方式来完成某件事情时，对双方互动行为的研究。这篇文章将采用 Python 中的 NashPy 来研究这种双方博弈的互动行为。
链接：
http://
nashpy.readthedocs.io/e
n/latest/tutorial/
Python 中的
马尔可夫过程
33.用 Python 模拟 Chutes 和 Ladders
这篇文章将通过 Chutes 和 Ladders 游戏的例子，建立模型并阐述马尔可夫过程的原理。整个分析过程附有 Python 源码，感兴趣的读者可以尝试一下。
作者：Jake VanderPlas链接：
http://
jakevdp.github.io/blog/
2017/12/18/simulating-chutes-and-ladders/
Python 中的数据分析
34.用 Python 分析美国联邦政治行为
科学、政治、个人意见和社会政策的交集可能呈现相当复杂的情况。思想和学科的交汇点通常充斥着有争议的观点和基于信仰但缺乏经验证据的议程。这时，数据科学在这方面就显得特别重要，因为它提供了一种以实际事实为基础的考察世界的方法，能够深入了解我们今天所面临的一些最重要的问题。
这篇文章我们将用 Python 来分析美国联邦政府的一些政治行为，深入了解政治背后所隐藏的故事。
作者：Patrick Triest链接：
https://
blog.patricktriest.com/
police-data-python/
35.用 Python 分析 1000+ 的希腊葡萄酒
作者：Florents Tselai链接：
https://
tselai.com/greek-wines-
analysis.html
36.如何用 Python 生成 FiveThirtyEight 图
这篇文章将用 Python 的 matplotlib 和 pandas，来学习并查看 FiveThirtyEight（FTE）可视化的核心部分，并教会你使用 Python 来为自己的数据进行可视化。
作者：Josh Devlin链接：
https://www.
dataquest.io/blog/makin
g-538-plots/
37.使用 Apache Spark 和 Python 为 8000 万 Amazon 产品进行评价打分
作者编写了一个简单的 Python 脚本，将亚马逊产品评论数据集中的每类评分数据进行整合，并对这些 Amazon 产品评论数据进行分析打分，以发现用户的喜好。
作者：Max Woolf链接：
http://
minimaxir.com/2017/01/a
mazon-spark/
38.使用 Python 进行地理空间分析
作者：Matthew Rocklin链接：
https://
matthewrocklin.com/blog
//work/2017/09/21/accelerating-geopandas-1
39.星球：从太空中了解亚马逊，来自 Kaggle 头奖获奖者的采访
文章采访了 Kaggle 的“星球：从太空中了解亚马逊”竞赛的获奖者，内容包括他如何使用 11 个微调的
卷积神经网络
，标签关联的结构模型，以及如何避免
过拟合现象
等。
作者：Edwin Chen链接：
http://
blog.kaggle.com/2017/10
/17/planet-understanding-the-amazon-from-space-1st-place-winners-interview/
Python 入门
40.从零开始学习 Python
Python 的创建者 Guido van Rossum 曾说过，“Python 是一个高级编程语言，其核心设计理念是让代码具有高度的可读性和简单的语法，程序员可以用几行代码表达自己的想法。”
作者：TK链接：
https://
medium.freecodecamp.org
/learning-python-from-zero-to-hero-120ea540b567
41.重要的 Python 练习清单
这篇文章列出了一些重要的练习项目，包括 Python 语言本身和标准库的练习。文章中还有 Python 中不同主题模块的知识。
作者：Ynon Perek链接：
https://www.
ynonperek.com/2017/09/2
1/python-exercises/
42.API 的设计原则：先思考再编码
API 是定义应用程序接口的通用术语，换句话说，就是用户（人或机器）与程序的交互接口。在 Web 开发世界中，API 通常是一个网站，其中包含一系列端点，用于响应客户端请求和结构化文本数据。这篇文章将告诉你为什么以及如何设计一个正确的 API，如何将自己的思想植入到 API 的设计中来构建属于你自己的 API。
作者：Jonatas Baldin链接：
https://www.
ckl.io/blog/api-design-
think-first-code-later
43.Python 机器学习指南
本文将通过清晰地解释和有效的练习，来帮助你深度理解相关的机器学习算法。
作者：Conor Dewey链接：
https://
medium.freecodecamp.org
/the-hitchhikers-guide-to-machine-learning-algorithms-in-python-bfad66adb378
44.如何学习 Python 编程：6 位经验丰富的 Python 开发者分享了他们的观点
对于当下热门的 Python 语言，有太多的教程、书籍、视频和博客文章资源，然而如此多的冗余资料，你该如何选择最佳的方式开始你的 Python 学习之旅呢？这篇文章列出了 6 位 Python 专家分享的学习经验，相信这对于迷茫中的你来说，将受益匪浅。
链接：
https://
coolpythoncodes.com/bes
t-way-learn-python-programming
45.如何用 Python 实现强大的数据分析
Python 是数据分析的最佳编程语言，这得益于它自带的依赖库。依赖库能够存储，操纵数据，并从数据中获得核心信息，因而在数据科学领域被广泛使用并展现出强大的功能。本文介绍了 Python 在数据科学领域的应用历史以及最新发展。
作者：Jake VanderPlas链接：
https://www.
youtube.com/watch?
v=9by46AAqz70","计算机专业的博士训练生来回答一下，python用了好几年了，也可以算做从零开始学的，据我的经验来看很多同学在学习完python的基本语法后，都会面临着接下来我该干什么的困境！
这是一篇非常详细的，覆盖了Python从入门到后期的全套方法论和相关资料，建议收藏后查阅。
另外我作为从本科到现在读博一直是计算机专业，其间也接触过很多的其他专业同学，或是想转行，或是想给自己增加一门技能，都咨询过如何学习python这个话题。通过这个问题，我也将之前的思路理一遍，同时也希望给想要自学python的同学一个完整的教程。
Python是一门怎么样的语言，为什么很多人都推荐？
Python是一种重要的编程语言，它在数据科学，Web开发，软件工程，游戏开发，自动化等领域得到了广泛的应用。但是学习Python的最好方法是什么？
学习Python时，挑战最大的事情就是所有学习网站的枯燥生硬。比如说你想学习如何使用Python进行网站制作，但几乎每个网站都让你花很长时间学习枯燥乏味的Python语法，然后进阶到下一步。
这种不匹配使学习Python对新人来说非常令人生畏。
拿下面这个例子来说
这段代码来自Django的教程，一个流行的Python网站开发框架。经验丰富的Python程序员会觉得这很简单啊。
但是，
即使是看似简单的几行代码也会让新人明显感觉不适。例如，为什么某些行缩进？
django.http
是干嘛用的？括号中的东西又是干嘛用的？
小朋友是否有很多的问号？
问题在于你需要了解Python语言的构建基块才能写出有趣的东西。但大多数教程都假定您需要学习 所有的 Python语法，然后才能开始做任何有趣的事情。当您真正想做的是分析数据，建立网站或创建无人机时。这就是导致你的动机消退的原因。
所以根据我的理解，学习Python的有效方法是将学习基础知识与构建有趣事物相结合。宗旨就是花尽可能少的时间来学习基础知识，然后立即投入到自己感兴趣的事物中。
步骤1：找出促使你学习Python的动机
在开始在线学习Python之前，问自己为什么要学习它。这是因为这将是一个漫长而痛苦的过程。没有足够的动力，你可能无法坚持到最后。
弄清楚动机的好处是可以帮助你弄清楚最终目标，以及一条学习起来轻松有趣的路线。在准备学习Python时，不用有一个确切的项目，一个你感兴趣的领域就可以。例如：
机器学习 
人工智能 
网站制作
游戏类
数据处理与分析
硬件/传感器/机器人
自动化工作脚本
python可以做的不止这些
步骤2：学习基本语法
不幸的是，这一步不能被跳过。在深入你的兴趣领域之前，学习Python语法的基础知识是必要的。但不用花很多时间，因为可以在实战中反复练习。
这里有一些很好的资源可以学习基础知识：
W3C schools
：这上面有详尽的Python语法介绍，同时也包含了进阶的教程
夜曲编程
：根据朋友0基础学Python的经验来看，很多人刚学一门完全新技能的时候很容易感到枯燥，或者坚持不下去。推荐夜曲编程也是因为这个教程非常有趣，激发兴趣在初级阶段尤为重要。这个课是百词斩出的，也有百词斩的特点，就是充分利用图像化内容来帮助理解，打破你对编程的恐惧感。而且他们是
在线代码编辑器
（省了安装本地环境、调试的时间），可以直接上手敲代码，刷题的感觉还不错。手机端就可以上课，电脑端进行代码实操。
如果大家有兴趣的话可以先尝试下免费的课程，只需要关注【夜曲编程】发送【免费教程】， 就可以体验了。
在对编程有一个大致了解后，可以去报名更完整详细的入门课和进阶课。我大致地看了一下，有很多类别，比如说爬虫课，数据分析，办公效率化等等。可以根据自己的需求进行选择。
我认为这个学习软件的优点如下：
1 交互式学习，在线的代码编辑器可以让小白无需安装环境就可以进行学习
2 合理的课程安排，每天只需要15-20分钟，利用碎片时间学习
3 课程设计的非常科学，很多课程以有趣生动的形式进行教授。
4 随时随地学习，手机/电脑/ipad都可以学。
?在这个竞争压力大的时代，多学一门技能就多一份竞争力，编程也不是遥不可及的东西，轻松愉快的学习是可以做到的。
Python语言上手较为简单，学习难度适中，同时也有利于增加就业竞争力，也能再日常的工作生活中切实的提升工作效率。
感兴趣的同学关注【
夜曲编程】
， 发送【免费教程】， 就可以体验免费课程。如果觉得还不错可以去报名
更完整的入门课和进阶课。
另外，请注意：
学习Python 3
，而不是Python2。需要鉴别的是线上有很多“学习Python”资源仍旧已python 2为基础。
步骤3：进行结构化项目练习
学习完基本语法后，就可以开始自己做项目了。具体项目是一种学习的好方法，因为它可以运用自己的知识和反复帮助你熟练基础知识。要记住，编程这东西，一旦不用，能力会急速下降。
但是，这时侯有网上也充斥着很多的资源，让人难以选择。因此，通常最好使用以及制作好的成体系的结构化的项目，可以一步步的引导你完成整个项目。网上很多资源都提供了结构化的项目，这些项目既可以让你从感兴趣的东西开始，又可以避免陷入学习困境。
下面介绍一些不错的项目：
数据科学/机器学习
Dataquest-
 交互式的教学基于Python的数据科学。分析一系列有趣的数据集，从CIA文件到NBA球员数据。最终将构建复杂的算法，包括神经网络和决策树等。
Python for Data Analysis
  ― Python数据分析的优质项目。
Scikit学习文档
 ― Scikit学习是主要的Python机器学习库。它具有一些出色的极其详尽的文档和教程。
CS109-
 这是哈佛的课程，讲授使用Python进行数据科学。他们在线上有一些
项目和全部资料
 。
行动应用程式
Kivy指南
 ― Kivy是开源Python函式库，用于开发行动应用程序和其它采用自然用户界面的多点触控应用软件。它可以在Android，iOS，Linux，OS X和Windows执行。采用MIT授权条款，Kivy是自由并且开源的软件。
网站制作
Flask教程
 ― Flask是Python的流行Web框架。这是一个入门教程。
Bottle教程
 ― Bottle是另一个适用于Python的Web框架，同样是入门教程
如何使用Django进行网站制作
 ―使用Django（复杂的Python网络框架）的指南。
游戏类
Codecademy
  ― 指导你完成几个简单的游戏。
Pygame教程
 -Pygame是一个流行的Python游戏制作库。
使用Python发明自己的计算机游戏
 -本书将引导您逐步了解如何使用Python制作多个游戏。
Pygame制作游戏的示例
硬件/传感器/机器人
将Python与Arduino
 结合使用 -了解如何使用Python控制连接到Arduino的传感器。
使用Raspberry Pi学习Python
  - 使用Python和Raspberry Pi构建硬件项目。
使用Python学习机器人
 - 学习如何使用Python构建机器人。
Raspberry Pi Cookbook-
 学习如何使用Raspberry Pi和Python构建机器人。
自动化工作的脚本
使用Python自动执行无聊的工作
 -了解如何使用Python自动执行日常任务。
步骤4：自行探索Python发展路线
一旦完成了一些结构化项目，就可以独自开发项目了，以继续更好地学习Python。在这个阶段会遇到很多的困难，绝大多数的问题都可以在以下得到解答：
StackOverflow-
 一个社区问答站点，人们可以在其中讨论编程问题。
CSDN
 - 中文
技术论坛
Google-
 每个有经验的程序员中最常用的工具。尝试解决错误时非常有用。
Python文档
 -在Python上查找参考资料的好地方。
一旦对掌握了上述技巧，就可以开始发展自己的项目。可以从自己感兴趣的事情开始。例如，在学习编程后不久，我做的就是简单的数据分析，进行一些走势的分析等。
以下是寻找有趣项目的一些技巧：
扩展您以前处理的项目，并添加更多功能。
查找要贡献的
开源项目
。
查找他人制作的项目，然后查看是否可以扩展或改编它们。 
Github
 是找到这些的好地方。
浏览其他人的博客文章以找到有趣的项目构想。
考虑可以使您的日常生活更加轻松的工具，比如自己做一个爬虫小工具。
最好启动一个小项目，然后慢慢的增加功能，直到完成一个中型甚至大型项目。
如果实在没有什么想法，下面有一些项目可以参考：
数据科学/机器学习项目
可以预测居住地的天气的算法。
预测股市的工具。
自动汇总新闻文章的算法。
移动应用项目
跟踪你每天走多远的应用程序。
发送天气通知的应用程序。
基于位置的实时聊天。
网站项目
一个可以帮助您计划每周饮食的网站。
一个记笔记的平台。
Python游戏项目
一个基于位置的手机游戏，您可以在其中捕获领土。
您可以编程解决难题的游戏。
硬件/传感器/机器人项目
传感器可监控您的房屋温度，并让您远程监控房屋。
更智能的闹钟。
自动驾驶机器人，可检测障碍物。
工作自动化项目
自动执行数据输入的脚本。
从网上抓取数据的工具。
步骤5：继续从事更艰巨的项目
不断增加项目的难度和范围。
可以尝试以下建议：
尝试教新手如何构建你之前制作的项目，借此巩固编程能力。
尝试扩展你的项目，让它可以处理更多数据或者还是可以处理更多流量。
尝试使程序运行更快。
尝试将自己的作品商业化。
总结：
Python是一种非常有趣且有益的语言，我认为只要找到合适的动机，任何人都可以熟练掌握它。
文末，别忘记这门优秀的图形化python课程，不仅可以直接在网页上写python，还有配有有图形化的内容帮助你快速理解那些较为晦涩的内容，
关键的是现在的免费课程已经出了
，还不来赶紧试试：
可以关注<夜曲编程>公众号，回复<免费教程>，试用免费编程课
夜曲编程
?
np.baicizhan.com?utm=zhihu&source=5
平凡：编程语言项目大全 - PBL(Project based Learning) - 包含全部主流语言
882 赞同 ・ 15 评论
文章
想自学一种编程语言，各种编程语言都有什么区别？
60 赞同 ・ 4 评论
回答","我不喜欢一上来就推荐一堆参考资料的东西，那只会让初学者更迷茫。
好比一个婴儿，你告诉他学会走路的方法有100种，他只会变的对走路毫无兴趣，他要的只是一种最有效的学会走路的办法，而不是100种。 
同样的，下面介绍的是我之前刚开始自己学习python的1种方法，只需要1种就可以了。  
第1步，基础入门
 
很多人喜欢搞一本厚厚的书来看，虽然看完了但是还不会
用Python
，这是最大的悲哀。 伤心吧？难过吧？ 其实，你只需要，看菜鸟教程网站的这个教程就足够了，网站地址： 
Python3 教程 | 菜鸟教程
如果你是刚开始学习编程的新手，没看懂，多看几次就会了。虽然这个过程会很乏味，但是对于你建立牢固的编程思维是必须的。
如果不想看文字教程的，可以看这个视频教程，非常的通俗易懂：
小白救星：原来Python如此简单
这一阶段的辅助工具：
 当你看到无法理解的代码或者概念时，可以将代码复制到下面这个网站，它会将你的代码用图形化的方式显示出来，便于你理解：
http://www.
pythontutor.com/visuali
ze.html#mode=edit
  
如果你不知道代码在内存中是如何运行的，不妨把它拷贝到Tutor里可视化执行一遍，加深理解。 举个栗子 ，比如你在学习Ptyhon中的字典数据结构，但是不太理解这个概念，那么你就可以将书中代码输入，然后点击下面红框汇中的按钮。
就会运行处以下的图形结果，对着图形理解概念，不要太爽哦。
第2步：数据分析进阶
 
上面第1步已经打好了Python编程的基础，现在进入数据分析的学习阶段。推荐一本书《利用Python进行数据分析》就够了，这本书在豆瓣评分是8.5分。
看到书里涉及到到当统计概率知识看不懂的时候，这时候反过来再学习统计概率的知识。 很多人错误的学习方式是，先学习统计概率，再去学习数据分析编程工具（Excel，Python，R）。最后抱怨太难了，学不会。
 这其实学习方法是错误的。这是为什么呢？
 有两个原因：
 1）因为很多统计概率讲的都是复杂的数学公式，却不讲统计概率在生活中如何应用的。这样造成的结果就是你学习了很多，但是也忘记了很多。 
2）统计概率知识大多数时候是理论基础，如果不结合数据分析工具（Excel，Python，R）来使用，你肯定学不会。
 比如你学习了
四分位数
的理论，但是如何在实际中使用的，你不会数据分析的工具，你当然不会用了。 
但是如果你会数据分析的工具，实际操作就一行代码，四分位就计算出来了。你当然兴奋了，一高兴学习兴趣也就上来了。
所以，我的建议，也是正确的学习方式是：先学习基础的数据分析工具用法，当遇到统计概率知识的时候，再来补这个知识，边学习边用数据分析工具实现一遍。
   
如果不想看文字教程的，可以看这个视频教程，非常的通俗易懂：
小白救星：原来Python如此简单
3. 数据分析高级-统计概率知识
 
统计概率知识学习其实很简单，只是很多老师和书把这个东东讲复杂了。学会下面图中的知识，你就可以学会统计概率了：
简单解释下，上面的图。  如果你的学习目的是：提高认知，将统计概率应用在生活中，用于指导你面对重大决策时做出最好的选择，你的应该看《赤裸裸的统计学》这本书就够了。
 如果你的学习目的是：学习大数据的基础知识：统计概率，希望成为数据分析师，实现升职加薪的目的，那你的学习参考书是《
深入浅出统计学
》或者《商务与经济统计》。
 《深入浅出统计学》适合没有任何统计概率基础的人学习，这本书足够有趣和简单。
 如果你之前上学学习过一些统计概率的课，但是最后还是把课堂学的内容还给了老师，你应该选择看《商务与经济统计》这本书来重新巩固你的基础知识。
 学会高级知识，你就不再是一个苦逼的搬砖了，而且会帮助你实现年薪增幅的目标。
如果不想看文字教程的，可以看这个视频教程，里面讲的统计知识非常的通俗易懂：
小白救星：这样学统计真简单
 
4. 学习遇到困难，去哪找帮助？
 只要是学习就会遇到困难，遇到困难怎么办呢？ 
1）首先，你需要使用某搜索引擎查找问题（你知道我说的不是百度），一般都能查到你问题的答案。学会用英文搜索真的很重要。 
2）利用某搜索引擎查不到答案的话，当然是找前辈们帮忙了。不过问了不一定有人回复，为了解决这个问题，你可以找我加入学习群，一起交流。 
3）最后记住，学习Ptyhon的目的，不是为了学一门编程语言而去学习一门编程语言，你的出发点应该是要完成什么项目，带着目标去学习。
参考资料：科普中国专家猴子作品合集
《Excel数据分析和数据思维》视频
《Power BI数据分析》视频
《SQL从入门到进阶》视频
《Python数据分析从入门到进阶》视频","非科班出身的数据分析师，python自学，自觉小有所成，简单介绍一下学习计划吧
python的入门其实只需要掌握几个关键点就行，新手要先学会安装环境、了解数据结构、函数这些东西，再配合实操进行实践，基本就可以入门了。
一、了解环境
二、了解数据结构
三、了解基本函数
四、了解Nuypm计算包
――――――正文警告！！――――――
一、环境
Python的编写环境，用Anaconda足矣。Anaconda是专业的数据科学计算环境，已经集成绝大部分包和工具，不需要多余的安装和调试。
Python版本建议3.0以上，不要选择2.7的版本，否则你会被无尽的中文编码问题困扰。
Anaconda在官网下载，选择最新版本，约400MB。
完成安装后，Win版本会多出几个程序，Mac版本只有一个Navigator导航。数据分析最常用的程序叫Jupyter，以前被称为IPython Notebook，是一个交互式的笔记本，能快速创建程序，支持实时代码、可视化和Markdown语言。
点击Jupyter进入，它会自动创建一个本地环境localhost。
点击界面右上角的new，创建一个python文件。
开始你的Python
界面上部是工具栏，编辑撤回运行等，下面是快捷操作，大家以后会熟悉的。页面正中便是脚本执行的地方，我们输入自己第一行代码吧：
（我就不用hello world）灰色框是输入程序的地方，回车是换行，shift+回车执行灰色区域的代码，它的结果会直接在下面空白处出现。这就是Jupyter交互式的强大地方，将Python脚本分成片段式运行，尤其适合数据分析的摸索调整工作。
这里的print叫函数，和excel的函数同理，是程序执行的主体，负责将输入转化成输出（函数留在下一篇细讲）。这里将hello qinlu这段文字输出。新手可能会奇怪为什么要加引号，这种用引号括起来的文字在程序中叫字符串。
Python是一门计算机语言，它的逻辑和自然语言不一样，编程语言的目的是执行任务，所以它不能有歧义。为了规避各种歧义，人们创造了语法规则，只有正确的语法，才能被转换成CPU执行的机器码。
先了解Python语法中的数据类型。计算机最开始只被用于数值运算，后来被赋予了各种丰富的数据类型。
上面两个是小学生都会的四则运算，在计算机语言中可没有那么简单。它涉及了两个数值类型，整数int和浮点数float。整数和浮点数在计算机内部存储的方式是不同的，我们不用知道具体原理，明确一点，整数运算是永远精确的，浮点运算则可能有误差。
两种数据类型也可以互换，通过int函数和float函数。
有了数值，必然有文本，程序中叫字符串，用英文引号括起来表示。单引号和双引号没有区别，所以""qinlu""和'qinlu'是等价的，引号是边界，输出的时候不会包含它。当字符串内本身包含引号时，也不影响使用。
需要注意的是，不论单引号还是双引号，一旦混用很容易出现错误。因为程序并不知道它是字符串的边界还是符号。
解决方法有两种，一种是使用三引号，三引号代表整体引用，而且包含换行。第二种是引号前面加\，它是转义字符，表示这个引号就是单纯的字符。
三引号也可以用来注释，通常是大段的文字解释，如果一句话，我们更习惯用#，#后面的内容均不会作为程序执行。
时间是特殊的数值类型，它将结合datetime模块讲解。
还有两个常见的数据类型，布尔值和空值。布尔值是逻辑判断值，只有True和False。
布尔值在IF语句和数据清洗中经常使用，利用其过滤。布尔值能和布尔值运算，不过这里是and、not、or作为运算符，Ttue and True = True，False and True = False，False and False = False，not True = False，True or False = True等。
空值是一个特殊的值，表示为None，None不等于0，0具有数学意义而None没有，None更多表示该值缺失。
整数，浮点数，字符串，布尔值，空值就是Python常见的数据类型。Python3对中文的支持比较友好，所以大家可以用中文作为字符串试一下print。
数据类型构成了变量的基础，变量可以是任意的数据类型。想要用变量，必须先赋予变量一个值，这个过程叫赋值。
我首先给a赋予了一个整数值1，然后改变它为字符串abc，变量在Python中没有固定的数值类型，这是Python最大的优点，所以它在数据分析中很灵活。这也是它被称为动态语言的原因，相对应的叫静态语言。
Python是大小写敏感的语言，所以a和A是有区别的，这点请牢记。另外变量名尽可能使用英文，不要拼音，英文的可读性是优于拼音的。
变量有两种拼写风格，一种叫驼峰，一种叫下划线，以用户ID为例。驼峰命名法为userId，以一串英文词语user和id组成变量，第一个词语的首字母小写，第二个词语开始的首字母均大写。下划线命名法为user_id，全部小写，用_分割单词。
一个变量的值可以被赋予另外一个变量，如果b变量之前有另外一个值，那么会被1覆盖。呈从上而下的执行关系。
初看a = a + 1好像有逻辑问题，其实这涉及到了程序执行的先后顺序，程序是先计算a+1的值得到2，然后将其赋予(覆盖)了a。等号右边的计算先于左边，这是从右到左的逻辑关系。
有变量，自然有常量，常量是固定不变的量，可是在Python中没有真正意义的常量，一切皆可变，它更多是习惯上的叫法，即一旦赋值，就不再改变了。
Python的基础数学运算符号有+,-,*,/,//,%。前面四个就是加减乘除，其中除法的结果一定是浮点数。后面两个符号是除法的特殊形式，//代表除法中取整数，%代表除法中取余数。
到这里，新手部分已经讲解完成。再来讲讲数据结构。
二、数据结构
Python一共有三大数据结构，它是Python进行数据分析的基础，分别是
，list数组以及dict字典。本文通过这三者的学习，打下数据分析的基础。
1、数组
数组是一个有序的集合，他用方括号表示。
num就是一个典型的数组。数组不限定其中的数据类型，可以是整数也可以是字符串，或者是混合型。
数组可以直接用特定的函数，函数名和Excel相近。
sum是求和，len则是统计数组中的元素个数。
上述列举的函数是数组内整体元素的应用，如果我只想针对单一的元素呢？比如查找，这里就要用到数组的特性，索引。索引和SQL中的索引差不多，都是用来指示数据所在位置的逻辑指针。数组的索引便是元素所在的序列位置。
注意，索引位置是从0开始算起，这是编程语言的默认特色了。num[0]指数组的第一个元素，num[1]指数组的第二个元素。
我们用len()计算出了数组元素个数是5，那么它最后一个元素的索引是4。若是数组内的元素特别多呢？此时查找数组最后一位的元素会有点麻烦。Python有一个简易的方法，可以用负数表示，意为从最后一个数字计算索引。
这里的num[4]等价于num[-1]，num[-2]则指倒数第二个的元素。
再来一个新问题，如何一次性选择多个元素？例如筛选出数组前三个元素。在Python中，用：表示范围。
num[0:3]筛选了前三个元素，方括号左边是闭区间，右边是开区间，所以这里是num[0]，num[1]和num[2]，并不包含num[3]。这个方法叫做切片。
上述是索引的特殊用法，[0:]表示从第0个索引开始，直到最后一个元素。[:3]表示从第一个元素开始，直到第3个索引。
负数当然也有特殊用法。[-1:]表示从最后一个元素开始，因为它已经是最后一个元素了，所以只返回它本身。[:-1]表示从第一个元素开始到最后一个元素。num[-2:-1]和num[-3:-1]大同小异。
数组的增删查
我们已经了解数组的基本概念，不过仍旧停留在查找，它不涉及数据的变化。工作中，更多需要操纵数组，对数组的元素进行添加，删除，更改。
数组通过insert函数插入，函数的第一个参数表示插入的索引位置，第二个表示插入的值。
另外一种方式是append，直接在数组末尾添加上元素。它在之后讲到迭代和循环时应用较多。
如果要删除特定位置的元素，用pop函数。如果函数没有选择数值，默认删除最后一个元素，如果有，则删除数值对应索引的元素。
更改元素不需要用到函数，直接选取元素重新赋值即可。
到这里，数组增删改查已经讲完，但这只是一维数组，一维数组之上还有多维数组。如果现在有一份数据是关于学生信息，一共有三个学生，要求包含学生的姓名，年龄，和性别，应该怎么用数组表示呢？
有两种思路，一种是用三个一维数组分别表示学生的姓名，年龄和性别。
学生属性被拆分成多个数组，利用索引来表示其信息，这里的索引有些类似SQL的主键，通过索引查找到信息。但是这种方法并不直观，实际应用会比较麻烦，更好的方法是表示成多维数组。
所谓多维数组，是数组内再嵌套数组，图中表示的是一个宽度为3，高度为3的二维数组。此时student[0]返回的是数组而不是单一值。这种方法将学生信息合并在一起，比第一个案例更容易使用。
如果想选择第一个学生的性别，应该怎么办呢？很简单，后面再加一个索引即可。
现在尝试快速创建一个多维数组。
[0]*3将快速生成3个元素值为0的数组，这是一种快捷操作，而[row]*4则将其扩展成二维数据，因为是4，所以是3*4的结构。
这里有一个注意点，当我们想更改多维数组中的某一个元素而不是数组时，这种方式会错误。
按照正常的想法，martix[1][0]将会改变第二个数组中的第一个值为1，但是结果是所有数组的第一个值都变成1。这是因为在matrix = [row] * 4操作中，只是创建3个指向row的引用，可以简单理解成四个数组是一体的。一旦其中一个改变，所有的都会变。
比较稳妥的方式是直接定义多维数组，或者用循环间接定义。多维数组是一个挺重要的概念，它也能直接表示成矩阵，是后续很多算法和分析的基础（不过在pandas中，它是另外一种形式了）。
2、元组
tuple叫做元组，它和数组非常相似，不过用圆括号表示。但是它最大的特点是不能修改。
当我们想要修改时就会报错。
而选择和数组没有差异。
元组可以作为简化版的数组，因为它不可更改的特性，很多时候可以作为常量使用，防止被篡改。这样会更安全。
3、字典
字典dict全称dictionary，以键值对key-value的形式存储。所谓键值，就是将key作为索引存储。用大括号表示。
图中的'qinlu'是key，18是value值。key是唯一的，value可以对应各种数据类型。key-value的原理不妨想象成查找字典，拼音是key，对应的文字是value（当然字典的拼音不唯一）。
字典和数组的差异在于，因为字典以key的形式存储和查找，所以它的查询速度非常快，毕竟翻字典的时候你只要知道拼音就能快速定位了。对dict数据结构，10个key和10万个key在查找对应的value时速度没有太大差别。
这种查找方式的缺点是占用内存大。数组则相反，查找速度随着元素的增加逐渐下降，这个过程想象成程序在一页页的翻一本没有拼音的字典，直到找到内容。数组的优点是占用的内存空间小。
所以数组和字典的优缺点相反，dict是空间换时间，list是时间换空间，这是编程中一个比较重要的概念。实际中，数据分析师的工作不太涉及工程化，选用数组或者字典没有太严苛的限制。
细心的读者可能已经发现，字典定义时我的输入顺序是qinlu，lulu，qinqin，而打印出来是lulu，qinlu，qinqin，顺序变了。这是因为定义时key的顺序和放在内存的key顺序没有关系，key-value通过hash算法互相确定，甚至不同Python版本的哈希算法也不同。这一点应用中要避免出错。
既然字典通过key-value对匹配查找，那么它自然不能不用数组的数值索引，它只能通过key值。
如果key不存在，会报错。通过in方法，可以返回True或False，避免报错。
dict和list一样，直接通过赋值更改value
能不能更改key的名字？不能，key一旦确定，就无法再修改，好比字典定好后，你能修改字的拼音么？
dict中删除key和list一样，通过pop函数。增加key则是直接赋予一个新的键值对。
dict的keys和values两个函数直接输出所有的key值和value值。如果要转换成数组，则再外面嵌套一个list函数
items函数，将key-value对变成tuple形式，以数组的方式输出。
字典可以通过嵌套应用更复杂的数据格式，和NoSQL与JSON差不多。
基础的数据类型差不多了，更多函数应用大家可以网上自行查阅文档，这块掌握了，在数据清洗过程中将会非常高效，尤其是读取Excel数据时。当然不要求滚瓜烂熟，因为后面将学习更加强大的Numpy和Pandas。
三、基本函数
1. 函数是什么
函数（Functions）是指可重复使用的程序片段。它们允许你为某个代码块赋予名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用（Calling）函数。
在 Python 中，函数可以通过关键字 def 来定义。这一关键字后跟一个函数的标识符名称，再跟一对圆括号，其中可以包括一些变量的名称，再以冒号结尾，结束这一行。随后而来的语句块是函数的一部分。
在定义函数时给定的名称称作“形参”（Parameters），在调用函数时你所提供给函数的值称作“实参”（Arguments）。
2. 调用函数
要调用一个函数，需要知道函数的名称和参数。函数的参数只是输入到函数之中，以便我们可以传递不同的值给它，并获得相应的结果。
Python 内置的常用函数包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数。用input()读取用户的输入：
因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python 提供了int()函数来完成这件事情：
函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：
如果函数调用出错，一定要学会看错误信息。
3.定义函数
在 Python 中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。
在 Python 交互环境中定义函数时，注意 Python 会出现...的提示。函数定义结束后需要按两次回车重新回到>>>提示符下：
如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python 解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）。
定义一个什么事也不做的空函数，可以用pass语句：
def nop():
 pass
pass语句什么都不做，实际上它可以用作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。
pass还可以用在其他语句里，比如：
if age >= 18:
 pass
缺少了pass，代码运行就会有语法错误。
数据类型检查可以用内置函数isinstance()实现。
Python 的函数返回多值其实就是返回一个tuple；Python 函数返回的是单一值时，返回值仍然是一个tuple。但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值。函数可以同时返回多个值，但其实就是一个tuple。
函数执行完毕也没有return语句时，自动return None。
4.函数的参数
Python 的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。
4.1 位置参数：
power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。
4.2 默认参数：
对于一些函数来说，你可能为希望使一些参数可选并使用默认的值，以避免用户不想为他们提供值的情况。默认参数值可以有效帮助解决这一情况。你可以通过在函数定义时附加一个赋值运算符=来为参数指定默认参数值。要注意到，默认参数值应该是常数。更确切地说，默认参数值应该是不可变的。
n = 2 是默认参数
定义默认参数要牢记一点：默认参数必须指向不变对象。且只有那些位于参数列表末尾的参数才能被赋予默认参数值，意即在函数的参数列表中拥有默认参数值的参数不能位于没有默认参数值的参数之前。
4.3 可变参数：
有时你可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通过使用星号来实现。即传入的参数个数是可变的。
我们声明一个诸如 *param 的星号参数时，从此处开始直到结束的所有位置参数（Positional Arguments）都将被收集并汇集成一个称为param的元组（Tuple）。
类似地，当我们声明一个诸如 **param 的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个名为 param 的字典（Dictionary）。
4.4 关键字参数：
如果你有一些具有许多参数的函数，而你又希望只对其中的一些进行指定，那么你可以通过命名它们来给这些参数赋值――这就是关键字参数（Keyword Arguments）――我们使用命名（关键字）而非位置来指定函数中的参数。
关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
举个例子，扩展函数的功能。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。
和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：
4.5 命名关键字参数：
如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义函数并调用：
和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。
命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错。
使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python 解释器将无法识别位置参数和命名关键字参数，即缺少 *，city和job被视为位置参数。
4.6 参数组合：
在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用。
但是参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。虽然可以组合多达 5 种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。
通过一个tuple和dict，你也可以调用函数：
对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。
5. 递归函数
如果一个函数在内部调用自身本身，这个函数就是递归函数。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
通过下面的代码可以查看你的电脑最大算到多少：
解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中。Python 标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题
四、了解Mumpy包
Python数据分析绝对绕不过的四个包是
numpy、scipy、pandas还有matplotlib
。
numPy是Python数值计算最重要的基础包，大多数提供科学计算的包都是用numPy的数组作为构建基础。专门用来处理矩阵，它的运算效率比列表更高效。
1、NumPy 的 ndarray：多维数组对象
numpy的数据结构是n维的数组对象，叫做ndarray。可以用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。
创建并操作多维数组：
ndarray对象中所有元素必须是相同类型的，每个数组都有一个shape和dtype。
shape ：表示各维度大小的元组
dtype ：说明数组数据类型的对象
2、创建 ndarray：一种多维数组对象
创建数组最简单的办法就是使用 array 函数，它接受一切序列型对象（包括其它数组），然后产生一个新的NumPy数组（含有原来的数据）。
np.array会尝试为新建的这个数组推断出一个较为合适的数据类型，这个数据类型保存在一个特殊的dtype对象中。
zeros 和 ones 也分别可以创建指定大小的全 0 或全 1 数组，empty 可以创建一个没有任何具体值的数组（它返回的都是一些未初始化的垃圾值）：
arange是 Python 内置函数range的数组版，np.arange返回间隔均匀的一些值。
3、ndarray 的数据类型
dtype（数据类型）是一个特殊的对象，它含有 ndarray 将一块内存解释为特定数据类型所需的信息。
需要知道你所处理的数据的大致类型是浮点数、复数、整数、布尔值、字符串，还是普通的 python 对象。当需要控制数据在内存和磁盘中的存储方式时，就得了解如何控制存储类型。
可通过ndarray的astype方法显示地转换其dtype：
若将浮点数转换成整数，则小数部分将会被截断。
若某字符串数组表示的全是数字，可用astype将其转换为数值形式：
这里没写 np.float64 只写了 float，但是NumPy会将 Python 类型映射到等价的dtype上。
数组的dtype的另一个用法：
int_array变成了和calibers一样的浮点型数组
用简洁类型的代码表示dtype：
u4(unit32)：无符号的 32 位（4个字节）整型。
调用astype无论如何都会创建出一个新的数组（原始数据的一份拷贝）。
浮点数只能表示近似的分数值，在复杂计算中可能会积累一些浮点错误，因此比较操作只在一定小数位以内有效。
4、数组和标量之间的运算
数组：可对数据执行批量运算（不用编写循环即可）。这通常叫做矢量化(vectorization)。
大小相等的数组之间，它们之间任何的算术运算都会应用到元素级（每个元素都做这个运算了），数组与标量的算术运算也是。
不同大小的数组之间的运算叫做
广播(broadcasting)
。
5、索引和切片
数据不会被复制，任何修改都直接改了原数组。
如果仅是要一份副本，则用 .copy()。
对二维数组单个元素的索引：
这两种方式等价。
若arr2d[2]，则输出的是一维数组[7,8,9]。
2*2*3的数组（2组2行3列）：
6、布尔型索引
需要先引入：
from
 numpy.random 
import
 randn
或将代码改成：data = np.random.randn(7, 4)
布尔型数组的长度必须跟被索引的轴长度一致。每个名字对应 data 数组一行。
对条件进行否定的两种方式：
组合应用多个布尔条件，可使用&、|等布尔算术运算符
通过布尔型索引选取数组中的数组，将总是创建数据的副本，即使返回一模一样的数组也是一样。
通过布尔型数组设置值：
通过一维布尔数组设置整行或列的值：
7、花式索引
指利用整数数组进行索引。
np.
empty
((8,4))
Return
 a 
new
 
array
 of given shape 
and
 type, without initializing entries.
for i in range(8):
arr[i] = i
Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step
为了以特定顺序选取行的子集，只需传入一个用于指定顺序的整数列表或 ndarray，使用负数索引会从末尾开始选取行（最后一行是 -1）。
一次传入多个索引组，返回一个一维数组：
取整列的两种方法，相当于给列排了顺序：
花式索引跟切片不一样，总是将数据复制到新数组中。
数组转置和轴对换
转置返回的是源数据的视图，不进行任何复制操作。数组有 transpose 方法，还有一个 T 属性来完成转置：
8、高维数组
Transpose 要一个轴编号：
arr是 2 组 2 行 4 列的数组，transpose的参数表示shape的形状，对于这个例子来说，即2[0]、2[1]、4[2]，transpose(1,0,2)转置后变为2[1]、2[0]、4[2]，看起来仍是 2 组 2 行 4 列的形状，但数组内的元素经过转换后索引已经改变，也要遵循（1，0，2）的顺序。如转置前的数组arr[0,1,0]索引值为 4，转置后的数组arr'[1,0,0]，索引值才为 4。其它同理。
ndarray 的 swapaxes 方法接受一对轴编号且返回源数据的视图：
转置后的数组arr.T为 4[2] 组 2[1] 行 2[0] 列数组，swapaxes(1,2)就是将第二个维度（中括号内数字）和第三个维度交换，即转换为 2 组 4 行 2 列。
9、通用函数：快速的元素级数组函数
通用函数（即 ufunc）是一种对ndarray中的数据执行元素级运算的函数，就是一些简单函数。
利用数组进行数据处理
用数组表达式代替循环的做法，通常被称为矢量化。NumPy 数组将多种数据处理任务表述为数组表达式。
np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的（x, y）对。
将条件逻辑表述为数组运算
np.wherea函数是三元表达式x if condition else y的矢量化版本。
np.where的第二个和第三个参数不必是数组，传递给where的数组大小可以不相等，甚至可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。
用where表述出更复杂的逻辑：（where的嵌套）
用于布尔型数组的方法
有两个方法any和all。
10、排序
多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort：
顶级方法np.sort返回的数组已排序的副本，就地排序则会修改数组。
唯一化以及其他的集合逻辑
np.unique找出数组中的唯一值并返回已排序的结果
np.in1d用于测试一个数组的值在另一个数组的情况。
说到python，很多人熟悉又陌生，想学但是又不知道该从哪下手，今天我就来给大家聊聊python课程，职场人和大学生尤其注意了，增加竞争力的干货知识点来了！
觉得python学习难，是因为没有反复练习，一般都是看完就扔，以及各个知识点之间并没有联系，在此我推荐一个夜曲编程，十分适合0基础的同学。
下面我就来说说，我在学习夜曲python学习课程的时候，觉得不错的一些点：
1、课程设置很清晰，循序渐进，由基础到变量，再到运算等；
概念学习过程中穿插趣味选择题，概念学习结束后有代码练习题（课程内含，非百题 
斩），每天学完后有知识总结，随时学随时巩固+复习。
2、对每个代码包括空格和标点符号在内的小细节进行反复测试和练习，用形象的图片来比喻抽象的概念，使代码几乎深深刻入脑海。
3、配套中设置的题目，很接近日常工作和生活需求，虽说和工作中遇到的有差别，但是便于平时调用时候的编程思维的搭建；学完课程缺乏编程练习――【百题斩】，共100道课后习题，及时反馈，practice makes perfect 
体验课都不到半杯奶茶，一定是物超所值的，同时如果想进行系统的学习，那么Python入门课Pro（付费正式课） 也可以尝试，现在凭23年高考准考证”购正价课就可以有【大学不挂科-六门课程】听说这个活动是限时的，看到的赶紧去！！
先说到这里，后面还有很多内容会继续更新！
本文转载自网络，侵删！","1.第一 python入门基础：这些都是基础，基本概念必须清楚！
学习Python需要掌握如下基础知识以及相关技能。
1.Python基础知识（变量、语句、数据类型、数值类型、字符串、布尔类型、列表、字典、元组、条件语句、循环语句、函数、装饰器、面向对象、网络socket、爬虫）
2.Python基础库（模块、包、系统模块、三方模块）
3.python文件处理（读、写、执行、）
4.python字符统计
5.python数据排序
2.学习方法：万虐终成神！敲代码，解决BUG才是学习，无数次的看视频不是学习，至少不会学好。
只记Python基础语法，却没什么鸟用。就像幼儿园，老师在黑板上写的‘肉’字，记住这个字咋写，一笔一划的记住，只需要半天，但是把这个词和你平时吃的东西绑定，以至于后面你想到这个字，就流口水，需要日常的重复训练。
同理：无方向的看书，看视频也没什么用，其实可以通过直接实战来上手，比如：
文件操作
字符排序
网络编程
错误的学习方法：
很多人在学习Python的时候常常会犯下面一种情况：
买一本厚厚的
编程指南
，逼自己看完，记住每个语法，闭门看书三个月，吃透一本书，最后一行代码也写不出来。
正确的学习方法：
编程就像骑自行车，买一本<<骑自行车大全>>是没有什么用的。
正确姿势：掌握最基础的姿势，就可以骑上车出发了，实际联系几天，摔几跤，基本就学会了。
3.自我进行测评：基础门槛，不过需要找原因并解决。
很多朋友反馈：Python基础语法都学会了，但不知如何写项目进阶？
1.List，Dict特性倒背如流，就是无法写出实际的项目。
2.各种书籍也看，写不出东西。
3.各种视频也看，写不出东西。
4.各种大会也去，名词高大上，但是没学到具体的技能。
对自我进行检测：
1.给你一个字符串“come baby,python rocks!” 如何统计里面字母o出现的次数！
思路：遍历字符串，定义一个变量，每次o出现，都+1
2.给你一个字符串“come baby,python rocks!” 如何统计这里面所有字母出现的次数！（普通变量肯定无法完成。）
思路：需要使用字典这类复杂的数据结构处理，字母当key，出现的次数当value，每个key出现，对应的value+1
3.给你一个字符串“come baby,python rocks!” 如何统计这里面字母出现次数的前三名！
思路：排序，取出前三
后续扩展练习：
1.给你一个字符串“come baby,python rocks!” 怎么统计出现次数前三的字母。
2.一个nginx日志文件，怎么统计IP出现次数前三的url。
3.一个nginx日志文件，统计IP出现前三后，如何存入MySQL数据库。
4.存入MySQL中的日志文件，如何输出给浏览器端显示。
5.如何美化前端表格等等。
4.重要学习部分：python库怎么学
模块
将多个代码块（按功能）定义到同一个文件中。别的文件中使用时则先导入模块，在调用模块内变量或函数。
模块命名要符合python变量的命名规范
1.建议全小写英文字母和数字
2.避免与常用模块或第三方模块名称冲突
控制模块内代码在使用python mod.py时执行，在导入时不执行
1.通过Global内变量__name__进行判断
2.当以python mod.py运行脚本时__name__变量为__main__字符串
3.当以模块导入时__name__为模块名称字符串
包
将不同模块文件放在不同文件夹内，包文件夹下面需要有__init__.py文件用以声明该文件为Python包。
使用时需要从包内导入模块后调用模块中变量和函数。
常用系统模块：
os,sys,time,datetime,urllib,xml,json,email,csv,collections,math,zipfile,trafile,
hashlib
常用三方模块：
requests,
pyquery
,django,flask,mysqlclient,paramiko,redis,lxml,dateutils,ipaddr,netaddr
模块学习方法：
1.先知道有没有
2.用的时候在查
内置工具：dir、help
搜索引擎：google、百度
5.再说一个python目前一个热点：python Web应用（python全栈）
1.Python基础入门（入门、数据类型、条件表达、循环语句）
2.Python基础进阶（文件操作、函数、装饰器、模块、面向对象、网络编程）
3.Python前端知识（Html、Css、Js、Jquery、Bootstrap、）
4.Python高级用法（Django、Flask、数据库操作、MVC、ORM、Admin、template）
5.Python项目实战（电商项目、爬虫项目、常用组件、运维项目、代码调优）
6.Python高级进阶（数据算法、代码规范、面试技巧）
重要：多抄、多写、多想、多问、多看、多听、多说
1.学习编程就是为了解决实际的问题，把自己在工作或学习中的重复工作程序化
2.谷歌和度娘
3.加入
开源社区
（多看、多分享、多交流）
4.参加培训辅导（仔细听课、跟上课堂学习，有问题做记录，课后查阅资料或请求他人）
5.善于记录笔记，不断总结，查漏补缺。
6.python前景之一：大数据分析
1.python基础入门（入门、数据类型、条件表达、循环语句）
2.python基础进阶（文件操作、函数、装饰器、模块、面向对象、网络编程）
3.python数据采集：（外部数据源导入分析&爬虫自己采集数据源分析）
4.数据分析：（各种库，如Pandas库，Numpy库必备数据库）
5.数据可视化：（matplotlib库）
重要：实用即可，最具价值，切莫花哨不适用
7.python前景之二：机器学习
直接看应用吧：看起来是个云端的概念
1.计算机视觉
典型的应用包括：人脸识别、车牌识别、扫描文字识别、图片内容识别、图片搜索等等。
2.自然语言处理
典型的应用包括：搜索引擎智能匹配、文本内容理解、文本情绪判断，语音识别、输入法、机器翻译等等。
3.
社会网络分析
典型的应用包括：用户画像、网络关联分析、欺诈作弊发现、热点发现等等。
4.推荐
典型的应用包括：
虾米音乐
的“歌曲推荐”，某宝的“猜你喜欢”等等。
学习路线：
数学基础：微积分、线性代数、概率与统计、典型算法
2.编程语言、工具和环境:python
python有着全品类的数据科学工具，从数据获取、数据清洗到整合各种算法都做得非常全面。
网页爬虫: scrapy
数据挖掘: 
pandas：模拟R，进行数据浏览与预处理。
numpy：数组运算。
scipy：高效的科学计算。
matplotlib：非常方便的数据可视化工具。
机器学习: 
scikit-learn：远近闻名的机器学习package。未必是最高效的，但是接口真心封装得好，几乎所有的机器学习算法输入输出部分格式都一致。而它的支持文档甚至可以直接当做教程来学习，非常用心。对于不是非常高纬度、高量级的数据，
scikit-learn
胜任得非常好(有兴趣可以看看
sklearn
的源码，也很有意思)。
libsvm：高效率的svm模型实现(了解一下很有好处，libsvm的系数数据输入格式，在各处都非常常见)
keras/TensorFlow：对深度学习感兴趣的同学，也能很方便地搭建自己的神经网络了。
自然语言处理: 
nltk：自然语言处理的相关功能做得非常全面，有典型
语料库
，而且上手也非常容易。
交互式环境： 
ipython notebook：能直接打通数据到结果的通道，方便至极。强力推荐。
3.编程语言、工具和环境:R
R最大的优势是开源社区，聚集了非常多功能强大可直接使用的包，绝大多数的机器学习算法在R中都有完善的包可直接使用，同时文档也非常齐全。常见的package包括：RGtk2, pmml, colorspace, ada, amap, arules, biclust, cba, descr, doBy, e1071, 
ellipse
等等。另外，值得一提的是R的可视化效果做得非常不错，而这对于机器学习是非常有帮助的。
4.其他语言
相应资深程序员GG的要求，再补充一下Java和C++相关机器学习package。
Java系列
WEKA Machine Learning Workbench 相当于java中的scikit-learn
其他的工具如 Massive Online Analysis（MOA）、MEKA 、 Mallet等也非常有名。
C++系列
mlpack，高效同时可扩充性非常好的机器学习库。
Shark：文档齐全的老牌C++机器学习库。
8.相关学习文档资料：目前比较好的文档还是英文，国内资料没有可以加我的学习群473391225，自己去下载。
----------------------------------------------------------------------------------------------
2018/05/25更新：开发文档资源整理（一）
环境管理
管理 Python 版本和环境的工具
p：非常简单的交互式 python 版本管理工具。
官网
pyenv：简单的 Python 版本管理工具。
官网
Vex：可以在虚拟环境中执行命令。
官网
virtualenv：创建独立 Python 环境的工具。
官网
virtualenvwrapper：virtualenv 的一组扩展。
官网
包管理
管理包和依赖的工具。
pip：Python 包和依赖关系管理工具。
官网
pip-tools：保证 Python 包依赖关系更新的一组工具。
官网
conda：跨平台，Python 二进制包管理工具。
官网
Curdling：管理 Python 包的命令行工具。
官网
wheel：Python 分发的新标准，意在取代 eggs。
官网
包仓库
本地 PyPI 仓库服务和代理。
warehouse：下一代 PyPI。
官网
 
Warehouse：PyPA 提供的 PyPI 镜像工具。
官网
 
bandersnatch
devpi：PyPI 服务和打包/测试/分发工具。
官网
localshop：本地 PyPI 服务（自定义包并且自动对 PyPI 镜像）。
官网
分发
打包为可执行文件以便分发。
PyInstaller：将 Python 程序转换成独立的执行文件（跨平台）。
官网
dh-virtualenv：构建并将 virtualenv 虚拟环境作为一个 Debian 包来发布。
官网
Nuitka：将脚本、模块、包编译成可执行文件或扩展模块。
官网
py2app：将 Python 脚本变为独立软件包（Mac OS X）。
官网
py2exe：将 Python 脚本变为独立软件包（Windows）。
官网
pynsist：一个用来创建 Windows 安装程序的工具，可以在安装程序中打包 Python本身。
官网
构建工具
将源码编译成软件。
buildout：一个构建系统，从多个组件来创建，组装和部署应用。
官网
BitBake：针对嵌入式 Linux 的类似 make 的构建工具。
官网
fabricate：对任何语言自动找到依赖关系的构建工具。
官网
PlatformIO：多平台命令行构建工具。
官网
PyBuilder：纯 Python 实现的持续化构建工具。
官网
SCons：软件构建工具。
官网
交互式解析器
交互式 Python 解析器。
IPython：功能丰富的工具，非常有效的使用交互式 Python。
官网
bpython：界面丰富的 Python 解析器。
官网
ptpython：高级交互式Python解析器， 构建于
python-prompt-toolkit
 之上。
官网
文件
文件管理和 MIME（多用途的网际邮件扩充协议）类型检测。
imghdr：（Python 标准库）检测图片类型。
官网
mimetypes：（Python 标准库）将文件名映射为 MIME 类型。
官网
path.py：对 os.path 进行封装的模块。
官网
pathlib：（Python3.4+ 标准库）跨平台的、面向对象的路径操作库。
官网
python-magic：文件类型检测的第三方库 libmagic 的 Python 接口。
官网
Unipath：用面向对象的方式操作文件和目录。
官网
watchdog：管理文件系统事件的 API 和 shell 工具
官网","这个问题其实很简单，相信十多年从来经验的我，跟我这篇文章来，系统性的学会Python 是几周的事。不长，也不需要你怎么努力。
学会 Python 首先要有一个准确的目标，你要求系统性掌握，那就要定义好系统性这个模糊的词汇到一个精确的分解目标。然后学习、练习，再总结一下就好了。
但是我不想再自己写了。已经是人工智能时代，我想你学会的应该是一个思想：如何借助人工智能来学习。一个方法：如何使用人工智能来学习。一个工具：选择那个人工智能。
我们就借助 
kimi.mooonshot.cn
 （如果方便建议使用 chatgpt 或者 
gemini
 更好一些吧）这个人人都能使用到的工具来完成这个任务吧。
分解目标，可以这样提问。
做为一个精通 Python 的专家，请给一个想系统性学习 Python 的人，一个清晰的目标分解，都要按先后顺序掌握那些知识。 请认真考虑后，一步步给出来。
在这里你得到了所有的 Python的系统性知识。而且结构清晰无比，
基础知识、进阶知识、高级应用。这几项是你必须掌握的。
实用库和框架，你要看自己的实际应用场景来考虑分别掌握一下。
项目实践，这个没有什么好说的了。你可以继续练习使用啊。
看到这儿，你有没有想过，
这个 kimi 或者 chatgpt、 gemini 是怎么回事
，这么好用的大语言模型，我能掌握吗？掌握 Python 、系统性的掌握 Python 后，还需要什么？我要告诉你答案：大语言模型才是未来，它不仅能帮助你学习，还是你未来工作中必须使用的工具、知识甚至是伙伴。所以你要及时的掌握它。你看上面就是我用它来辅助学习 Python 的方法。
学到这里，你对Python的知识已经掌握的差不多了，那么对就业找工作来说就够了吗？就亲身经历而言，你必须一定要接着学大模型，因为现在Python太卷了，会的人太多，但凡不想当底层牛马，兢兢业业几年后被裁掉，你就得跟上时代潮流，AI是不可阻挡的，所以未来不会AI的人一定会被会AI的人淘汰！
好在现在学习 AI 的资源很多，但这些资源也参差不齐，自己鉴别起来比较麻烦，建议大家直接去看
知乎知学堂
的 AI 大模型公开课，我前段时间刚看，非常不错，课里有最新的 AI 理论与应用落地，课程里关于
Transformer
的原理、使用
Fine-Tuning
进行模型微调的技术对我的帮助很大，可以说是卷赢同事卷赢上下游的利器， 入口我给大家要过来了，现在还是免费的，点下面链接直接听就可以??
??技术岗高薪必学：AI大模型技术原理+应用开发+模型训练
￥0.00
就业无忧
大模型其实不难，大佬讲解的也很通俗易懂，全程带你从理论到实践，深度讲解大模型，如果你懂点Python，那这节课对你来说学起来会很轻松！
另一个很重要的点：
学习与练习，还是继续回到 Python 的系统学习上来。现在你有了全套的系统性 Python 的知识划分，要怎么学习呢？还是继续用 
Kimi
 吧。
学习方法可以这样问：
请给我一个例子，或者几个例子，讲解一下 Python 的 OOP 的概念及注意事项
练习，就可以这样。
我写了一个 Python 的类，它对吗？有什么问题，请指出来。
 class Person:
   def __init__(self, name):
      self.name = name
   def talk(self, content):
     self.content = content
     return ""you are a good man""
看到了吗？仅仅是如何使用，你就拥有了一个专家级别的老师、辅助导、甚至是助手，只要你思想不懒惰，你就可以拥有战术上的勤快了。它不是我们梦寐以求的快乐学习吗？
你看，至少我相信在这儿，你已经得到了使用人工智能辅助学习的优势：
个性化学习
自适应学习环境
数据驱动学习
即时反馈和评估
资源丰富且易于获得
促进创新思维
终身学习的支持
总结反馈
这你也没有想过要怎么用人工智能来完成吧。把你所有的问题记录放到一个 word 或者 txt 文件里，然后这样问：
请根据我的问题历史文件，提供一下我在 Python 方向要怎么继续学习
奇迹发生了：
看到这儿了，你真的不想再创造一个奇迹？把大语言模型掌握了？
AI大模型全栈工程师
的课程，就是你的未来！
??技术岗高薪必学：AI大模型技术原理+应用开发+模型训练
￥0.00
就业无忧
 添加微信助手，还能领上课用到的资料，和一些好用的AI工具。对于学习大模型来讲非常有用的！","有关Python学习，小编在此将《
技术协会-Python与设计模式系列课程》分享给各位同学：
 
0、Python与设计模式--前言-博客-云栖社区-阿里云
1、Python与设计模式--单例模式-博客-云栖社区-阿里云
2、Python与设计模式--工厂类相关模式-博客-云栖社区-阿里云
3、Python与设计模式--建造者模式-博客-云栖社区-阿里云
4、Python与设计模式--原型模式-博客-云栖社区-阿里云
5、Python与设计模式--代理模式-博客-云栖社区-阿里云
6、Python与设计模式--装饰器模式-博客-云栖社区-阿里云
7、Python与设计模式--适配器模式-博客-云栖社区-阿里云
8、Python与设计模式--门面模式-博客-云栖社区-阿里云
9、Python与设计模式--组合模式-博客-云栖社区-阿里云
10、Python与设计模式--享元模式-博客-云栖社区-阿里云
11、Python与设计模式--桥梁模式-博客-云栖社区-阿里云
12、Python与设计模式--策略模式-博客-云栖社区-阿里云
13、Python与设计模式--责任链模式-博客-云栖社区-阿里云
14、Python与设计模式--命令模式-博客-云栖社区-阿里云
15、Python与设计模式--中介者模式-博客-云栖社区-阿里云
16、Python与设计模式--模板模式-博客-云栖社区-阿里云
17、Python与设计模式--迭代器模式-博客-云栖社区-阿里云
18、Python与设计模式--访问者模式-博客-云栖社区-阿里云
19、Python与设计模式--观察者模式-博客-云栖社区-阿里云
20、Python与设计模式--解释器模式-博客-云栖社区-阿里云
――――――――――――――――――――――――――――――――――
另外在实践方面，这里有三个爬取实践内容推荐给楼主和各位小伙伴练练手：
1、[
] Selenium定向爬取PubMed生物医学摘要信息
文章地址：
http://
click.aliyun.com/m/1000
307345/
 本文主要是自己的在线代码笔记。在生物医学本体Ontology构建过程中，我使用Selenium定向爬取生物医学PubMed数据库的内容。         PubMed是一个免费的搜寻引擎，提供生物医学方面的论文搜寻以及摘要。
2、[python爬虫] Selenium爬取
内容及用户信息
文章地址：
http://
click.aliyun.com/m/1000
307346/
在进行自然语言处理、文本分类聚类、
、舆情分析等研究中，通常需要使用新浪微博的数据作为语料，这篇文章主要介绍如果使用Python和Selenium爬取自定义新浪微博语料。因为网上完整的语料比较少，而使用Selenium方法有点简单、速度也比较慢，但方法可行，同时能够输入验证码。希望文章对你有所帮助~
3、[python爬虫] Selenium定向爬取
海量精美图片
文章地址：
http://
click.aliyun.com/m/1000
307347/
在进行自然语言处理、文本分类聚类、推荐系统、舆情分析等研究中，通常需要使用新浪微博的数据作为语料，这篇文章主要介绍如果使用Python和Selenium爬取自定义新浪微博语料。因为网上完整的语料比较少，而使用Selenium方法有点简单、速度也比较慢，但方法可行，同时能够输入验证码。","作为一个靠Python为生的小小码农，必须要来推荐！
对于初学者，我一直说一句话：
零基础学习 Python，视频为主，书籍为辅，多敲代码。
我不太清楚题主提这个问题是干啥，如果题主想要以后从事 Python 方面的工作，首先我们得知道大概有哪些工作岗位，这样可以根绝岗位需求做出针对性的学习。
如果以后是想从事 Python 相关的工作，那你大概率会在以下但不仅限于以下岗位中选择：
Web 应用开发
：服务器端的编程，具有很丰富的 Web 开发框架，如 Django，能够快速完成一个网站的开发和 Web 服务，比如 Google，豆瓣等。
数据分析
：Python 被广泛的应用到科学与数字分析中，比如图像可视化分析，生物信息学，常用的是 Numpy ， Scipy 等。
系统网络运维
：在运维的工作中，有大量重复性的工作，并需要管理，监控，发布系统等，将工作自动化起来，提高工作效率，这样的场景非常适合 Python。
3D 游戏开发
：Python 有很好的 3D 渲染库和游戏开发框架，常用 Pygame, ，Pykyra 等。
网络爬虫：
网络爬虫是一种按照一定的规则，自动抓取互联网信息的程序或脚本，你可以用爬虫爬图片，爬数据，只要你能通过浏览器访问的数据就没有爬不到的。
既然题主问的是系统学，那我从以下 4 个方面给出你零基础学习 Python 的路线：
视频
书籍
实战
进阶
注意辣，长文来袭，超级干货，记得先点赞收藏，再看不迷路呀~~
一、视频
视频的话，我推荐两门课，选择自己喜欢的讲解口味进行观看就行了。
1、《
Python
 
核心基础
》
这门课一共 131 集，大多数都是 Python 的核心基础知识，像 Python 环境搭建、基础语法、类型和对象、函数、面向对象等等等等，适合 Python 新手从入门开始学习。
除此以外还包括了一些操作系统的内容，说实话操作系统啦这些课程也是对于我们很重要的知识，不管是在大学还是工作中都很重要，所以我希望大家在学完 Python 的时候可以看看操作系统的内容。
2、《
Python 入门教程完整版》
这套视频一共 547 集，我看了一下，可以说是很全面了。
从搭建环境，判断语句，再到基础的数据类型，之后对
函数
进行学习掌握，熟悉文件操作，最后通过实战进行演练。
而且它不只是涉及 Python，还包括 Linux 
操作系统
等的学习，每一集的时间也不是很长。如果你对别的不感兴趣，可以直接看 Python 那一趴的，从第 110 集开始。
3、Python 入门课程
零基础的话跟着【夜曲编程】学，适用于不具备Python基础知识的人。入门课程包含了 Python 的数据与运算、条件判断、元组列表等数据结构、函数和类等核心的 Python 知识，每一个知识点下面都带着对应的练习题。除此以外每小节在最后会有几个相关的实操练习，把知识点串联起来。
这门课就是符合我在上面讲的【时长合适 + 有实例】，差不多拆成了 30 多个小节，每小节 20 多分钟的时长，练习题分布在每个小节中，一共100道题，由浅入深，所以可能因为这样叫百题斩？哈哈哈哈。
它这个还有【概念卡】和【代码卡】的东东，我当时还觉得仿佛在哪里见过，然后就去查了一下，破案了，原来是
百词斩
出品的，一个套路的，你别说，这样的卡片看着还挺好。比如这个匿名函数：
lambda函数
的格式、参数、语法会用不同的颜色标注出来，就很清晰明了。
网页还配置了Python安装教程和安装包，Mac和Windows版的都有，这一点可以说是非常方便了，一站式齐全。
感觉 Python 学的稍微有点底气了，可以去下面的 Python 做题网站练练手：
二、书籍
Python 入门书籍的话我有 2 本推荐，不同的人喜欢不同的行文方式，就比如我最喜欢的是第二本...
1、《
Python编程 从入门到实践
》
这是我买的第一本 Python 书，当然也是刚开始学的时候看了别人的推荐，加之也是豆瓣评分 9.1 的书，就买来看看。理论 + 实践，前面是基础知识，后面是实战项目。
前面的基础知识讲的很详细，以至于给我当时的感觉有点过于嗦了，不知道其他人看会是什么感觉。每个知识点后面都带着“动手试一试”，我感觉这点比较好，学编程之初，就是要多练，多敲代码...
至于后面的实践部分，包括一个简单的 2D 游戏、数据可视化和 web 项目，可能是当时我太菜了，或者之前没有做过项目的原因，我觉得这三个项目出现的太突兀了，2D 那个游戏做完我就直接被劝退了，倒是没觉得有啥提升，没甚意思，sad...
而且跟着书做项目，因为书出版的时间太长，很多用法都变了，照着书上做，大概率会有运行错误的时候，可能心态有点崩...
广告
Python编程 从入门到实践 第2版（图灵出品）
京东
￥109.80
去购买
?
2、《Python基础教程(第3版)》
这本书是我朋友送我的，书到了以后一直在吃灰，因为那时候 Python 学的差不多了膨胀了...
翻开也是很偶然，那天刚好很无聊，就随手拿出来翻了翻，然后就翻完了，怎么说呢，这本书的内容给人一种很舒适的感觉，我很少有觉得读起来很舒服的
技术书
...
整个的结构很清晰，内容简单但是不肤浅，整个基础知识的讲解简洁明了，一点也不嗦，很容易就看懂了，不会有那种我看了好几遍才理解的情况，各种小的代码片段比比皆是，在练习的过程中反过来再加深对概念的理解。而且作为实践部分，它后面带了十个小项目，按照实际开发的步骤介绍Python 项目的过程。
怎么说呢，反正我喜欢这本...
三、实战
编程语言的学习其实是边学边练，刚开始的时候是一边看视频看书，就把视频上的小例子，书上的小例子自己动手敲出来。
等能力到了一定的地步，可以尝试一下实战。
对于实战来说，可以有两种：
刷题
项目
下面我将分别来讲一下这两种。
1、刷题
刷题大家应该都知道，就是在刷题网站上解决
数据结构
与算法题。
如果你从事计算机行业，在你找工作的时候，数据结构与算法都是你跨不过去的坎儿。
这里我推荐一个 Python 的数据结构与算法的视频。
数据结构与算法的重要性不言而喻，作为一个前 ACMer 更是深有感触。
北京大学这门课主要由
陈斌
教授主讲，介绍常见的数据结构和相关的经典算法，包括线性结构、递归与dp、排序与查找、树及其算法等。
这门课我觉得最好的一个点是，比较关注数据结构与算法的时间空间效率，这个是很多课程忽略的地方。我也有一篇旧文，详细的介绍了时间复杂度和空间复杂度，感兴趣的可以看下：
时间和空间效率是数据结构和算法yyds，学会了这个你就学会了分析优劣，成长是不可同日而语。
同时这门课也比较注重数据结构和算法的实践应用，毕竟只有真正用起来你才知道你是不是真的学会了，课程里的案例和变成习题建议好好做一下。
刷题是一个很好练习和检验学习成果的方式，刷题直接在 LeetCode 上刷就好了。
至于刷题顺序，我可以分享下自己总结的【
LeetCode 刷题顺序
】，希望能帮助大家少走一些弯路。
这份清单我会一直更新，同样也会一步步的把
每个知识点的入门讲解
和
每道题的题解
用“图解”的方式分享给大家。
站在初学者的角度，
用最直白的方式和最易懂的代码，最大可能摒除不同编程语言的带来的干扰
，理论 + 实战，带你彻底搞定数据结构与算法。
下面就是我为大家精心挑选的 LeetCode 题目清单，
按照知识点进行分类
，大家可以根据知识点，有针对性地刷题。
2、项目
项目的话就先做些小项目练手。还是那句话，对于编程语言的学习来说，
“理论 + 实战”才是王道
。
当然对于现阶段的你来说可能没用，可以等你的 Python 成长到一定的地步，好的
开源项目
会对学习会有很大帮助。
我这里推荐的都不是很大，结构比较清晰的开源项目。
tomato-clock（star 240+）
Python 写的命令行番茄工作法定时器。代码仅有 100 多行，不依赖其它第三方库。
tomato 25 minutes. Ctrl+C to exit
   ---------------------------------------------- [8%] 23:4 ?
传送门
：
coolcode/tomato-clock
magic-wormhole（star 12.8k+）
一条命令就能将文件安全地传送到另外一台电脑上的工具。基于 PAKE（Password-Authenticated Key Exchange）协议实现文件在公网的加密传输，发送和接收均仅需一条命令。
传送门：
https://github.com/magic-wormho
blind_watermark（star 800+）
给图片加盲水印的 Python 库。
盲水印
就是图片有水印但人眼看不出来，需要通过程序才能提取水印，相当于隐形“盖章”，可以用在数据泄露溯源、版权保护等场景。该库出自阿里巴巴安全团队，强大之处：
解析
水印图
时无需原图
水印图剪裁、旋转都不会破坏图中的盲水印
支持密码加密
from blind_watermark import WaterMark

bwm_obj = WaterMark(password_wm=1, password_img=1)
# 原图
bwm_obj.read_img('pic/原图.jpg')
# 水印图
bwm_obj.read_wm('pic/水印.png')
# 打水印后的图
bwm_obj.embed('output/结果.png')
# 注意需要设定水印的长宽 wm_shape
bwm_objextract(filename='output/结果.png', wm_shape=(120, 120), out_wm_name='output/解出的水印.png', )
传送门：
guofei9987/blind_watermark
alive-progress（star 2.5k+）
新！Python 炫酷进度条项目。支持 Python2.7-3.8 示例代码：
# 安装：pip install alive-progress
from alive_progress import alive_bar

with alive_bar(total) as bar:  # declare your expected total
    for item in items:         # iterate as usual over your items
        ...                    # process each item
        bar()                  # call after consuming one item
传送门：
rsalmei/alive-progress
四、进阶
进阶阶段也就是以后准备从事的方向。
接下来我会从
Python 爬虫、数据分析、机器学习
几部分来推荐。
至于 Python 开发方面，虽然我考完研也做过一段时间的后台开发的实习生，但也仅限于玩票，所学基本来自于官方文档，没有系统的看过书，所以就不在此乱做推荐...
这里重点推荐书，如果
想看相关方面的视频推荐
，可以看我下面这篇文章：
Python 爬虫
1、《
Python3 网络爬虫开发实站
》
关于爬虫的话，我学的不是很深，还处在玩玩的状态，就是平时搞点数据玩儿，刚开始学的时候是在崔大的网站（静觅：
http://www.
cuiqingcai.com
）白嫖的，后来崔大出书了，就买了一本支持，因为主要精力不在这，看到 Scrapy 框架就停了，现在基本忘干净了...
书很厚，量很大，不过现在这本书很多网站也在升级，里面的很多代码都失效了，现在第二版也出来了，大家可以买最新的...
广告
Python3网络爬虫开发实战 第2二版 崔庆才网络数据采集
京东
￥104.90
去购买
?
Python 数据分析
数据分析是现在很火的一个概念，但是不知道为什么现在谈起数据分析，必定有个 Python 的前缀，这就给很多同学造成了误解，认为数据分析一定要用 Python，这就成了一个很错误的概念。
数据分析重要的是分析，Python 只是服务于它的一个工具而已。
当然这个不是一句两句就可以解释清楚的，以后我会出一些列关于数据分析的文章，届时再科普...
那么既然是说到了 Python 的数据分析，那我就先只推荐几本关于这方面我看过的书.（但是千万别理解成只有这些）...
1、《
利用 Python 进行数据分析
》
动物书，不多说，这大概是入门数据分析的必读书籍，主要介绍了 numpy、pandas 和 matplotlib 这三个Python 数据科学的库。
里面有很多功能语法的介绍，可能是因为这本书的作者同样也是 
pandas
 的作业，所以这本书里对 pandas 的描述非常细，如果你买了这本书，其他 pandas 的书基本可以不用买了，这本书基本可以满足你哪里不会查哪里了...
不过对于这本书来说，缺少一些实践性的案例操作，还是有些难顶的...
2、《对比 Excel，轻松学习 Python 数据分析》
江湖人称小黄书，好朋友
俊红
的书，我手里的这本也是他送的，就是忘了给我签名，不然现在都准备拍卖了...
从 Excel 出发学习 Python 数据分析，这本书我翻完了，成为畅销书是有道理的，简单易读又容易操作，从我们熟悉的 Excel 入手，通过对比 Excel 的常用操作来用 Python 实现，能够带你快速掌握 Python 数据分析的常用操作，跟着走下来，像基本的 pandas，numpy 和 matplotlib 的用法都会了然于胸。
机器学习
机器学习的话，如果说直接想实战，那直接就上 
scikit learn
 的官网就好了，现官网内容非常详细，不管是算法说明，参数文档还是对应的案例都应有尽有。至于对应到的知识点，现在网上好的文章也非常多，直接对应去搜就好了。
如果想系统的学习的话，可以看一下下面这几本书：
1、《机器学习》
周志华
老师的《机器学习》（西瓜书）作为机器学习领域的入门教材，可以说是学习机器学习的必读教材，在内容上基本涵盖了机器学习的很多方面，包括基础知识、经典的机器学习方法以及规则学习和强化学习这些进阶知识。
好像最近又出了一本《
机器学习引论指导
》，还没买来看，估计也没差，大家可以买来尝尝鲜～
2、《统计学习方法（第2版）》
纯理论的书，怎么说呢，想学机器学习，统计学习是迈不过去的坎～
3、《
机器学习实战
》
这本书是我同学送我的，主要就是介绍机器学习基础，还有就是如何用算法进行分类，还有监督学习和无监督学习的经典算法，再就是机器学习算法里的一些附属工具。
通过一些实例，切入日常工作任务，没有很多学术化的语言，通过实例学习到机器学习的核心算法，算是一本实战经典书。
希望对你有所帮助
哎呀妈呀，终于写完了~~码字好累呀！！！
如果觉得不错的话，
记得动动小手帮我
 
@Rocky0429
 
点个赞，给我一些鼓励，感谢辣~","原文地址：
Python超简洁教程，现在就开始加入数据科学大军
在过去的几年间，使用 Python 这门语言作为数据科学研究工具的人数逐年得到攀升，根据 O'Reilly数据科学从业者薪酬调查报告，54%的受访者都在使用 Python 作为首选语言，这个数据要比2015年的调查结果――51%还要高一点。
没人可以否认 Python 已经逐渐成为了数据科学产业以及智能化时代的先头兵，而且必定会在未来继续保佑这种优势。毫无疑问，无论是逐渐扩大的业界份额，还是海量的数据科学库件，以及平缓的学习曲线，Python 作为一门程序语言，几乎已经没有比它更适合作为数据科学的实践工具了。
当然，Python 易学好懂，但如果你是刚入行的学生或是从业者，你仍然需要一些基本的程序语言知识来帮你度过一开始的难关。因此，我（指作者，译者注）为各位
数据科学家
，尤其是初学者准备了一个小攻略。这个小攻略可以方便大家快速查阅在数据科学研究过程中的一些程序用法，也可以作为一本指南帮助大家更快更好地掌握 Python。
这本小攻略与 DataCamp 的课程《数据科学所用到的 Python》有所关联，大家可以配合阅读。
如需下载 PDF 版本，请
点击这里
。这本小攻略提及了 Python 中诸如变量、数据类型、字符串、列表等基础知识以及一些科学计算所用的基本库件如 Numpy 等等。下面是文档截图。
（为方便大家阅读，译文将原始文档截图转换呈现在此。――译者注）
受知乎编辑器限制，集智无法在此提供一个很好的操作环境
，请大家
点击这里
前往主站，点击运行尝试跑跑程序。
我们提供了一些Python入门的知识，方便大家实践。大家可以在移动端和PC端无障碍享受运行程序的快感，部分代码截图如下：
欢迎你来。
讨论组：
官方微博：@景略集智
微信公众号
：景略集智
集智QQ群：557373801
商务合作：chenyang@jizhi.im
投稿转载：kexiyang@jizhi.im","从machine learning或者web或者爬虫入手Python，会比较有成就感，不枯燥
天天print，初学者学个几天就没动力了
我推荐，machine learning in action，一点点线性代数基础即可阅读此书
web学习flask，遇到不懂的语法查文档
学习scrapy，同上，遇到不懂的语法查文档
真的，用Python写个预测足球比赛结果的小程序或
或抓取微博数据，比天天对着书上无聊的print好多了","专注Python、AI、大数据 
@七步编程
 
学习是一个循序渐进的过程，是无法直接从一个零基础的新手跳跃到Python大牛的层次，我认为对于大多数编程语言的学习都可以分为如下3个阶段：
入门
进阶
实战
入门
对于入门阶段，如果真的是零基础，对于编程语言没有任何了解，对于条件语句、循环语句、字符串、运算法都不了解的，我认为有必要先把这些知识补充一下，对于入门，我推荐使用《
菜鸟教程
》，这是我入门Python时学习的一个网站，它
从环境搭建到运算法、字符串、列表、条件语句、循环语句都进行详细讲解
，这些都是编程语言里比较基础的内容。它通过通俗易懂的语言和图形来阐述每一个专业词汇、知识点的到底在讲什么，然后开始编程实现，
理论与实践相结合
，非常有助于零基础的初学者。
进阶
我认为在线教程提供了很大的遍历，但是出于严谨性的考虑，我认为还是有必要选择一本不错的书籍进行细致的学习，对于进阶阶段，我推荐一本书籍和一份开源学习项目。
书籍
这是一本非常不错的Python书籍，它既可以作为入门书籍，也可以视为进阶书籍。
与大多数
浮于表面
式讲解的书籍和在线教程不同，它更加深入，
深入而不冗余
，在你看这本书的时候你会发现，它的每一段话都是有意义的，没有什么废话。
它分别从数据结构、字典集合、文本和字节序列、函数、设计、装饰器、闭包等讲起，然后对每一块知识进行展开，
详细介绍里面最根本的原理
，然后告诉你，该怎么用好它，高效的使用它。
举一个最简单的例子，在绝大多数教程都会讲到
循环和条件语句
，千篇一律的告诉你""if..else.."", ""for...while""，这个有一点编程语言的同学都知道，但是在Python里面循环和条件语句有什么特殊的地方吗？该怎么用好它？
《
流畅的Python
》这本书就教你怎么去使用它，告诉你
列表推导
该怎么用还有它的意义所在。
这就是这本书的优点：
不仅告诉你怎么用Python，而是告诉你怎么用好Python
。
开源项目
实战阶段我推荐这份Github学习资源Python-100-Days，截止目前已经5.2w+star，
它循序渐进的讲解了从基础阶段的循环、字符串到深入的进程、面向对象的知识，它不仅给出了知识的详细讲解，针对每一个知识点，它还给出了规范的实现代码，这样不仅有助于理解学习到的知识，而且能够帮助学习编码规范，能够在Python编程方面得到一定的提升。
实战
通过学习入门和进阶阶段的学习，想要再进一步的提升就需要在实际的项目中进行实战，这样才会更加意识到自己当初在学习过程中遇到的每个知识点的真实意义。
实战该选择什么项目？不同人会有不同的兴趣爱好，有喜欢数据分析的，有喜欢计算机视觉的，有喜欢web开发的，也有偏好
网页爬虫
的，不同人可以根据自己的兴趣选择相应的方向，然后进行实战。
如果对爬虫感兴趣，可以看一下我的另一篇关于爬虫的回答。
对于实战阶段，我同样推荐一份不错的Github学习资源--
tensorflow_cookbook
。
nfmcclure/tensorflow_cookbook
?
github.com/nfmcclure/tensorflow_cookbook
tensorflow应该大家都耳熟能详了，机器学习领域非常优秀的框架，很多公司和项目都是基于tensorflow进行搭建，在AI邻域有着不可获取的地位。
当然，单纯的学习tensorflow是没有意义的，它只是一个工具而已，tensorflow_cookbook这份资源的优点就在于，它不仅限于tensorflow，
它以机器学习为核心，围绕机器学习中的知识点，例如线性回归、支持向量机、神经网络、CNN、RNN等进行展开，不仅能够深入学习这些机器学习底层的理论知识，而且能够学习tensorflow和Python的使用，知道如何用Python去实现一个机器学习项目，去完成一个分类或者预测功能。","更新：补充了图片（昨天居然没图了orz澹
想要系统自学，首先当然是要搭建Python体系了。
大部分自学者没有知识体系可言，这是无法避免的困局。
知识体系
并不是你看几篇文章就能搭建起来的――在你对很多内容一无所知的情况下怎么可能形成完成的体系呢？
所以初步学习的时间里，最好的办法是什么？
走前人的路。
按照已经成熟的路线去前进，在接近走完的时候，按照自己的学习深度和技能需求重新整理，然后对知识架构中的缺漏作补充。
所以，想要系统自学按照别人的经验来是最快的，也是我非常推荐的一条学习路径。
下面是一条非常全面的Python学习路线，题主可以用来做个参考。（我也是照着这张图来的）
图片作者是：
nonoBoy - 简书
类似于这样的
路线图
网络上有很多，如果觉得以上的路线不太符合技能需求，题主可以自行发掘一些其他的路线图。记得要查证路线的可执行度，选错了的话会很难受。
有了路线之后，剩下的就是执行问题了。执行细节主要有两个方面，资源发掘和学习过程。
学习资源：
准备阶段
在开始之前我建议你补充自己的计算机基础知识――你用来考计算机二级证书的那点东西完全不够用。
考虑到啃大部头的难度足以把人逼疯，所以这里就直接推荐两门课程好了。我接触这两门课陈源于 
@萧井陌
大神的推荐。
计算机科学和Python编程导论（自主模式）
哈佛大学公开课：计算机科学cs50
额外附送：
麻省理工学院公开课：算法导论
对于初学者而言，把这三门课学习一下就够了。如果你甘之如饴，可以做更深的尝试，去阅读诸如《
计算机科学导论
》、《算法导论》这样的书籍。
如果真的啃下来，恭喜，你的学习之路再也不会有更大的难关了。
入门阶段
得益于Python的特性，你会发现入门的路径堪称无穷无尽――单单是在知乎就有无数的教程来解答你的问题。在这时候，你简单了解一下Python的相关北京之后就开始学习语法吧。
简单说，这一时段的阅读资料如下：
廖雪峰的官方网站
菜鸟教程
《
简明 Python 教程
》
《父与子的编程之旅》
《
笨办法学Python
》
我的建议是，挑选其中任何一个来学习就可以了。特别推荐廖雪峰的Python教程和简明Python。
视频教程：
程序设计入门-Python - 网易云课堂
补充阶段
目前Python web使用比较多的框架，Django、Flask。（Tensorflow这种level太高，就不多说了）
专栏：Django实战
――CSDN同类专栏阅读量第一
被解放的姜戈
――很经典也很引人的教程
Welcome to Flask
――Flask官方文档
这三个基本上足够你掌握基础知识，想要更加深入就要亲自动手来学习了。
实战阶段
说实话，可以实战的项目是在太多了。当你掌握了语法、熟悉了框架，不去做实战还等什么呢？
我相信这段时间里你会有很多想做的事，也会遇到很多困难，但是绝不会比学算法更困难了。
来这里，找你最喜欢的项目：
https://www.
zhihu.com/question/2937
2574
学习过程
学习从来不是一件简单的事。即使Python已经被视为最容易入门的语言，但学习过程也称不上愉悦。
别迷信什么21天精通或者7天入门之类的谎言。在这种引导下，除了虚无的膨胀感你不会得到任何东西。
保持正确的方向和学会一样重要。如果你想做开发，就别只看爬虫教程，如果你想做数据，就先去学点数学。
试着自己去判断一个技能的重要程度。正确衡量学习成本，把时间花在你最需要的技能上。
你想更深入了解学习Python知识体系，你可以看一下我们花费了一个多月整理了上百小时的几百个知识点体系内容： 
【超全整理】《Python自动化全能开发从入门到精通》笔记全放送"
,,,,,,,,,,,,,,,,,,,,,
如何评价最近CSDN的行为？,"红包雨&&多层广告遮罩&&强制登陆否则无法复制&&登录了有时候也不能单独复制代码块里的某一句&&各种抽象的付费项目&&>这网站还有什么存在的意义？
我主要是被红包雨和多层广告遮罩整破防了。急了急了","很水的排行榜：标题党、美女封面图占了一多半。
csdn
早就不看了，还有那么多好的程序员网站：
对
国内技术社区
博客园
 
https://www.
cnblogs.com/
掘金
 
https://
juejin.cn/
思否
 
https://
segmentfault.com/
开源中国
 
https://www.
oschina.net/
51CTO
 
https://www.
51cto.com/
V2EX 
https://www.
v2ex.com/
开发者头条 
https://
toutiao.io/
GitChat
 
https://
gitbook.cn/
知乎 
https://www.
zhihu.com/
牛客网
 
https://www.
nowcoder.com/
 一个互联网求职学习交流社区。
国外技术社区
Stack Overflow
 
https://
stackoverflow.com/
 全球最活跃的程序员技术问答交流社区，程序员的所有问题都能在上面找到答案。
Medium
 
https://
medium.com/
电子书
书栈网
 
https://www.
bookstack.cn/
码农之家
 
https://www.
xz577.com/
豆瓣高分计算机书单：
少走弯路，计算机豆瓣高分书单
学编程的教程网站
菜鸟教程
 
https://www.
runoob.com/
W3Cschool
 
https://www.
w3cschool.cn/
http://
how2j.cn
 
https://
how2j.cn/
易百教程 
https://www.
yiibai.com/
并发编程网 
https://
ifeve.com/
帅地玩编程 
https://www.
iamshuaidi.com/
吴师兄学编程 
https://www.
cxyxiaowu.com/
视频教程网站
B站
 
https://www.
bilibili.com/
慕课网
 
https://www.
imooc.com/
中国大学MOOC
 
https://www.
icourse163.org/
开源社区
GitHub 
https://
github.com/
 全球最大开源社区，被戏称为全球最大同性交友网站。
码云 
https://
gitee.com/
 可以看做GitHub的国内版，GitHub虽好，但GitHub服务器在美国，网络方面main一直是个问题，这种情况下，码云是个不错的替代者。
面试刷题
LeetCode
力扣 
https://
leetcode-cn.com/
 经典的刷题网站，主要是算法题。
LintCode
 
https://www.
lintcode.com/
 和LeetCode类似
刷题笔记：
两份高质量刷题笔记
接私活转外块的网站
猪八戒 
https://www.
zbj.com/
程序员客栈
 
https://www.
proginn.com/
码市
 
https://
codemart.com/
开源中国众包平台 
https://
zb.oschina.net/
人人开发 
http://www.
rrkf.com/
大佬的博客/网站
阮一峰
：
http://www.
ruanyifeng.com/home.htm
l
 计算机科普博主
陈浩
：
https://www.
coolshell.cn/
 左耳朵耗子
廖雪峰
 
https://www.
liaoxuefeng.com/
 Python启蒙老师，Python，Git系列教程作者
王垠
 
http://www.
yinwang.org/
 每写一篇文章都能引发争议的前Google程序员
整理不易，收藏的时候，顺手点个赞吧","csdn已死，一年比一年烂，不知道的还以为是广告社区呢。
打开一个链接跟叠罗汉一样，
俄罗斯套娃
，套完一个又一个，结果完事还是几年前的老内容，热榜上挂的估计也是炒冷饭，真的没意思。
技术流该看什么网站？
视频教程：
哔哩哔哩
：
https://www.
bilibili.com/
慕课网：
慕课网-程序员的梦工厂
腾讯课堂：
https://
ke.qq.com/
网易云
课堂：
https://
study.163.com/
网站自学：
廖雪峰
官网： 
http://www.
liaoxuefeng.com/
设计导航：
http://
hao.shejidaren.com/
api工程：
https://www.
it120.cc/
脚本之家
： 
http://www.
jb51.net/
菜鸟教程： 
http://
m.runoob.com/
w3school在线教程： 
http://www.
w3school.com.cn/
开源社区
：
Github――很多开源项目
开源中国
――目前国内最大的开源技术社区
zheng征项目
――(stars 5.6k)基于Spring+SpringMVC+Mybatis分布式
敏捷开发
系统架构
JFinal
(stars 4.8k)――是基于 Java 语言的极速 WEB + ORM 框架
面试刷题：
LeetCode
――据不完全统计在上面被刷过的题可以围绕地球三圈
趣IT
――企业真题，能力测评，面试提升，为你的面试助力
Codility
――是一家著名的国外刷题网站，主要是帮助各大名企、中小企业笔试
HackerRank
――提供各种编程谜题、现实中的编程难题和挑战
Programmingbydoing
――编程题目从简单到复杂，新手程序员可以循序渐进提高自己的水平
软件大全：
软件安装管家（公众号） ：从资源到破解方法都详细介绍
吾爱破解：
https://www.
52pojie.cn/
我爱分享网：
http://www.
zhanshaoyi.com/
盒子部落：
https://www.
hezibuluo.com/","别说CSDN了，某乎也是一样的，不知道是从哪传开来的运营手段。
照搬短视频APP，首页一堆视频（反正我用插件屏蔽了），可能本乎忘了自己是什么性质的平台吧；
照搬电商APP，首页顶部超大横幅活动广告，这个CSDN和知乎都有；
也许再过不久，就会出现那种开屏广告了。
CSDN从很多年前就开始出现一些迷惑性的操作了，最开始是从“擅自把我们的资源强制变成需要积分下载”开始的吧。我相信，和我同一个年代（或者比我更早的年代）的程序员，CSDN对我们来说，也许是梦开始的地方。那时候CSDN是有各路大神的。
后来，CSDN口碑在程序员当中也是逐渐变差。
也许不能怪他们，毕竟时代不一样了，要想继续运营下去，就需要有新的盈利方式。
但说实话，就目前这种运营方式，只怕是赚了钱，丢了口碑。
-----说明一下-----
我回答里其实说的都是网页版，屏蔽视频我用的是浏览器的AdGuard插件（之前说错了），评论里也有人提到用油猴，大家都可以尝试一下。这是AdGuard的教程：
https://
zhuanlan.zhihu.com/p/14
9985612
手机版的视频我也不知道怎么屏蔽，我很久没用手机版了，有朋友评论说有定制版的安装包，也许可以试试。手机版的开屏广告可以用轻启动这类app，瞬间自动点击跳过，很好用。","已
经
烂
到
底
，
包
含
社
区
，
更
包
括
一
些
内
容
创
作
者
。
C
S
D
N
已
经
烂
到
底
，
包
含
社
区
，
更
包
括
一
些
内
容
创
作
者
。
{\color{red}{CSDN 已经烂到底，包含社区，更包括一些内容创作者。}} 
{\color{red}{CSDN 已经烂到底，包含社区，更包括一些内容创作者。}} 
 
--- 2021 年 11 月 11日 update
很多人问我为什么要写这样一个回答，60% 的原因在于某个 CSDN 群里面的某些哮天犬，我比较幼稚，就是看不惯这些人，或者也有一些恨其不争的感觉吧，毕竟我早两年也用 CSDN 解决过不少技术难题。
对于哮天犬来说，因为只要你说 CSDN 哪里不好，哪里需要改进，它们比主人还更疯狂出来咬人：怎么能说我 CSDN 有不好的地方呢？
久而久之，不少和我一样曾经对 CSDN 
原力计划
有过期待的程序员技术博主也慢慢的不在群里提意见，甚至开始不更新，群里就剩下一些哮天犬喜欢天天在群里吹捧，也不聊技术，不聊 CSDN 如何改进，只会关注又有哪些人喷 CSDN 了。
截止目前，这个回答已经收获了 2000 个赞，数十万的阅读，也被转发到这个群里面多次，每次都会引发一些
哮天犬
的不适，看到它们的不适我还挺开心的。
--- 2021年10月28日 update
你以为我喷的是 CSDN 么，实际上我想喷的是 CSDN 的一些内容创作者，CSDN 本身的问题属于积重难返，想短时间改好不太现实，但它有想改好的想法我一直是很认同的。
我最想喷的是 CSDN 的那些内容创作者，一个个跟狗找屎一样，热榜上的文章他们觉得不满意就疯狂举报，
虽然自己曾经上过 CSDN 的多次热榜，但我还是想喷它。
之前，CSDN 官方邀请我们一些人去参加它的原力计划，想要我们在 CSDN 发布一些高质量的文章，
我想着 CSDN 是想把社区氛围搞好，不想把名声烂下去，也就欣然接受了。
于是每周都会在 CSDN 发布一下自己的原创文章，同时也加入了他们的一个官方群：原力计划群。
加入一段时间后，我知道 CSDN 真的已经烂到底了，最明显的两个特征一个是编辑没有常识。
在文章中提到 B 站的某个视频课，有引流信息，下架。
在文章中提到
慕课网
的某个实战课，有卖课嫌疑，下架。
在文章中提到自己的博客、网站、公众号，妥妥的营销号，下架，同时还会在群里被各种人喷。
甚至提到 GitHub 的某个项目都有风险。
第二个特征就是一堆喜欢举报的人，自己写的文章都是几百字的笔记或者东摘西抄凑成一篇万字长文，别的程序员一看就知道是垃圾文，但自己却认为应该上热榜，一旦发现热榜上没有自己的文章，就开始举报热榜上有哪些内容是违规的。
更搞笑的是，这堆网jing对引流的文章比 CSDN 的编辑还更热情，每天 24 小时不断的在群里@编辑，说某些内容违规。
但如果有人提出抄袭、内容质量差，没有一个人回话。
如果你想看文章，别去 CSDN 了，以下的博客哪个不比它强！
1、美团技术团队
地    址: 
美团技术团队
简    介：美团技术团队的博客，干货满满。
推荐指数：?????
 2、阮一峰的网络日志
地    址: 
阮一峰的网络日志
简    介：大神阮一峰，博客风格真正做到深入浅出。
推荐指数：?????
 3、Spring Boot中文导航
地    址: 
Spring Boot中文导航
简    介：汇总了一些比较优秀的Spring Boot博客、开源作品等。
推荐指数：????
 4、Spring Cloud中文导航
地    址: 
Spring Cloud中文导航
简    介：汇总了一些比较优秀的Spring Cloud 博客、开源作品等。
推荐指数：????
  上面两个索引里已经有了一些比较优秀的个人博主的相关博客地址，所以里面出现的
个人博客
，后面就不再列出了。
   5、Web前端导航
地    址: 
Web前端导航
简    介：比较全的Web前端导航，包括 团队组织 、开发社区 、 前端门户、框架类库 等等网站的导航。
推荐指数：????
 6、Spring For All
地    址: 
Spring For All
简    介：目标是做最专业的的
民间Sptng
组织。
推荐指数：????
 7、廖雪峰的官方网站
地    址: 
廖雪峰的官方网站
简    介：廖雪峰老师的网站，有一些不错的入门教程。
推荐指数：???
  8、酷壳
地    址: 
酷壳
简    介：可以了解
陈皓
，是个很有个性的人。
推荐指数：???
 9、五分钟学算法
地 址: 
五分钟学算法-一个不错的算法网站！
简 介：程序员学习网站，收集了和程序员学习相关的各种教程和资料，致力于将数据结构与算法讲清楚！
推荐指数：????
10、AlgoMooc
地    址: 
AlgoMooc-一个专属于程序员的平台，和大家一起刷题
简    介：图解 LeetCode 算法题
推荐指数：???","我之前就回答过一个问题，跟本问题性质差不多：
国内技术社区
广告太多，质量不高
，所以被越来越多的人抛弃。
多年前我也是在CSDN认真分享的，巅峰时期我的作者排名在前100名，工作之后就不常登录了，现在进去广告太多了，多年没维护排名还在900位。
我的csdn账号
那么除了CSDN，程序员们还可以选择去哪里学习呢？
分享一下我自己的学习途径吧，主要分为
技术社区推荐+
开源项目
推荐+经典书籍推荐
。
----临时更新一个小小的需求----
回答被某个大佬踩到排名很靠后，如果你觉得内容不错的话，
拜托随手给个赞哦，求捞一捞~~
（一）技术社区推荐
1、Github
网站地址：
https://
github.com/
作为程序员如何不知道这个网站的话，你可能需要回炉重造了。
我个人觉得是目前最牛逼的技术社区，
Github上面有很多非常优秀的开源项目
，包括阿里、腾讯、字节跳动、美团、Google、Micosoft等国内外大厂都有自己的Github开源库。
建议每个程序员没事可以到上面多逛逛，
多看优秀开源项目的代码和文档
，
尽量参与进去
，不论是maillist、QQ/钉钉群组等等，可以尝试从编写文档、写测试用例开始入手，逐步切入核心功能。
2、
Stack Overflow
网站地址：
https://
stackoverflow.com/
一个程序员问答网站，跟知乎一样，又跟知乎不一样。上面非常多的热心的大牛。
比如知乎虽然是个问答网站，但是你提问技术问题，答案只会告诉你关注XXX领取Java电子书、面试资料。
上面这句话纯属开玩笑。区别在哪里呢？
Stack Overflow 不欢迎任何讨论性的，非Problem-Solving类的问题
。什么意思呢？你可以提问1+1等于几，但是不要提问为什么要学c语言？
所以，如果你在开发过程中遇到了什么bug，只要你搜索能力优秀，99%在上面能找到答案。
在这里能够与很多有经验的开发者交流，如果你是有经验的开发者，还可以来这儿帮助别人解决问题，提升个人影响力。
（二）开源项目推荐
参与优秀的开源项目可以和业界优秀的程序员大神一起结对编程，开阔思路，掌握优秀的代码编写风格、设计模式和技巧。
在此推荐几个业界有名的优秀的开源项目：
1、Redis：
Redis
Redis的性能极高且拥有丰富的数据类型，同时，Redis所有操作都是原子性的，也支持对几个操作合并后原子性的执行。另外，Redis有丰富的扩展特性，它支持publish/subscribe, 通知,key 过期等等特性。 Redis更为优秀的地方在于，它的代码风格极其精简，整个源码只有23000行，很有利于阅读和赏析。
2、RocketMQ：
Apache RocketMQ
阿里巴巴
开源的消息中间件，久经双11大促流量洪峰考验。
3、Flink:
Stateful Computations over Data Streams
Apache Flink
是由
Apache软件基金会
开发的
开源
流处理
框架
，其核心是用
Java
和
Scala
编写的分布式流数据流引擎。Flink以
数据并行
和
管道
方式执行任意流数据程序，Flink的流水线运行时系统可以执行
批处理
和流处理程序。此外，Flink的运行时本身也支持
迭代算法
的执行。
Flink提供高吞吐量、低延迟的流数据引擎以及对事件-时间处理和状态管理的支持。Flink应用程序在发生机器故障时具有容错能力，并且支持exactly-once语义。程序可以用Java、Scala、
Python
和
SQL
等语言编写，并自动编译和到在集群或云环境中运行的数据流程序。
4、Google guava
：Google提供的java库函数,guava cache和guava限流的实现很有参考价值。
5、
sharding-jdbc
：数据库分库分表、读写分离的一个中间件。
6、RxJava
：java平台的Reactive 扩展。
7、Spring
：这就不解释了。
最后再
推荐几个优秀的前沿信息来源
：
infoq
《美团技术博客》
公众号-阿里技术
公众号-高可用技术
业界有名的会议：archsummit 架构师大会、flink forward
（三）多阅读经典书籍
少看博客，多读书。
博客只能帮你找到学习思路，
真正的知识储备建立在你阅读了多少经典书籍的基础之上
。
相比于电子书，我本人更喜欢纸质的，一是尊重作者劳动成果，拒绝白嫖；二是阅读体验我自己觉得更好。
网上也有很多电子书，但是希望的大家不要放在网盘里落灰。有条件可以买书回来自己看，动力更足。
研究生读的一些书，老照片了，像素太低多包涵：
工作之后看的一些书，只是其中一部分：
因为我本人是Java工程师，关于Java从入门到进阶的经典书籍之前写过一个文章，想学Java的同学可以看看：
都醒醒，看完我的回答就去乖乖看书好嘛~
下面这些高赞回答，你可能也会需要哦：
2021年你读了哪些觉得比较好的计算机书籍？
2039 赞同 ・ 90 评论
回答
神级程序员都在用什么工具?
1782 赞同 ・ 51 评论
回答
程序员行业有哪些越早知道越好的道理？
716 赞同 ・ 14 评论
回答
程序员有必要在技术网站写个人博客吗？程序员有技术博客在面试中有至关重要的作用吗？
101 赞同 ・ 2 评论
回答","还特意看了下这是什么时候的问题，以为知乎又推好多年前的呢（狗头
都2021年了，正经人，谁看CSDN啊（狗头+++
这里给大家一些不错的博客平台和
个人博客
，堪称程序员必备！
一、不错的博客平台：
我用过的
主流
博客平台有以下这些：
掘金
：
https://
juejin.im/timeline
开源中国
：
https://www.
oschina.net/
知乎专栏：
https://www.
zhihu.com/
思否
(SegmentFault)：
https://
segmentfault.com/
博客园
：
https://www.
cnblogs.com/
简书：
https://www.
jianshu.com/
慕课网手记
：
https://www.
imooc.com/
腾讯云
社区：
https://
cloud.tencent.com/devel
oper
阿里云云栖社区：
https://
yq.aliyun.com/
程序员必读书单：
没怎么用过的博客平台但耳熟：
51CTO博客：
http://
blog.51cto.com/
其他：
Hexo+GitHub
WordPress
GitHub/GitBook
一系列小众平台(Bitcron等)
二、个人博客
直接搬出了我的书签-》Blog页面收藏的地址，平时我就爱看阮一峰、左耳朵耗子、云风、
王垠
这些大佬的博客，他们风格迥异，算是扩展技术视野的一个方式吧，
话不多说，开始：
1、云风的Blog
地 址: 
云风的Blog
简 介：网易大佬云风的Blog，干货满满。
推荐指数：?????
2、美团技术团队
地 址: 
美团技术团队
简 介：美团技术团队的博客，每篇都是干货。
推荐指数：?????
2、阮一峰的网络日志
地 址: 
阮一峰的网络日志
简 介：大神阮一峰，
阮大神
喜欢翻译一些文章，而且都是非常深入浅出，我贼爱看。
推荐指数：?????
3、
陈皓
（CoolShell博主）
地 址: 
https://
coolshell.cn/
简 介：左耳多耗子叔，注重底层知识。
推荐指数：?????
另外，在这里也送大家一本帮助我拿到BAT 等一线大厂 offer 的算法笔记，是一位阿里大神写的，对于算法薄弱或者需要提高的同学都十分受用，算法一定是计算机学习的重中之重：
BAT面试官编写的leetcode刷题笔记，看完秒杀80%的题目
4、廖雪峰的官方网站
地 址: 
廖雪峰的官方网站
简 介：廖雪峰老师的网站，很多教程很适合小白，比如Python、Git都是访问量超百万的博客。
推荐指数：????
5、原创技术大联盟
地 址: 
原创技术大联盟
简 介：优秀的技术博主实在太多了，列不完，也看不完，这里有一个导航页，有上百个优秀博主的博客链接，感兴趣的按需去找吧。
推荐指数：???
6、陈硕的Blog - C++博客
地 址:  
陈硕的Blog - C++博客
简 介：知乎大V陈硕大大，muduo作者
推荐指数：????
7、刘未鹏 | Mind Hacks
地 址:  
刘未鹏 | Mind hacks
简 介：思维改变生活，这是刘未鹏网站的slogan，分享编程、心理、心智方面的知识，挺有意思的
推荐指数：????
8、道哥(
吴翰清
）:安全 道哥的黑板报
地 址:  
道哥的黑板报
简 介：道哥(吴翰清）:安全 道哥的黑板报
推荐指数：????
另外，在这里也送大家一本帮助我拿到BAT 等一线大厂 offer 的算法笔记，是一位阿里大神写的，对于算法薄弱或者需要提高的同学都十分受用，算法一定是计算机学习的重中之重：
BAT面试官编写的leetcode刷题笔记，看完秒杀80%的题目
9、菜鸟教程
地 址:  
菜鸟教程
简 介：这个教程相信大家都用过，不用我多介绍了
推荐指数：????
大家记得点赞收藏下噢，也可以关注下我 
@编程指北
，分享编程干货知识，知乎10w+关注。","早就又烂又臭了。
以前注册过它的帐号，后来发现它越来越烂，越来越臭，就想注销账号，网页上根本找不到入口，几经辗转几经周折找到了客服，并以投诉威胁（当时已经出台了相关法规要求网络平台提供账户注销功能），才说出注销的办法：下载手机版app+绑定手机号才能注销（我注册时只需要邮箱），
我tm都要注销账号了，你tm还要我下载app，还tm要我绑定手机号？！！
然后纠缠了一番终于注销了，然后我用搜索引擎搜自己的信息，点击搜索引擎返回的很多结果链接还能正常访问显示，包括个人主页。然后再去问客服，说有些页面是需要自己删除的（比如文章），个人主页是删不掉的，可以改昵称和头像。这也能叫注销账号吗？！
你说这是得有多烂，有多臭。","以前CSDN被诟病最多的可能就是，百度搜索一个内容，打开了一篇CSDN的文章，结果文章内容是一个链接。点过去链接，才是一篇文章。人品不好的时候，可能又是一个链接……
还有一个，就是作者在文章中的代码显示！
我相信在座的各位，没有人没见过那种不用任何代码块包裹的代码吧。
function
 
myFunction
(
name
,
job
){

    
alert
(
""Welcome ""
 
+
 
name
 
+
 
"", the ""
 
+
 
job
);


}


function myFunction(name,job){alert(""Welcome ""+ name +"", the ""+ job);}
我就在网上随便复制了三行代码，分别是用代码块和没用的，也就三行，我觉得已经感官上不适了。何况有时候搜出来的文章里直接甩出来一整个文件的内容……
但你说这种形式能不能全怨平台，我觉得本身写作者也有问题。
现在官方也开始整活儿了，打开页面，直接广告把三分之一的区域都给占了，接着弹蒙层等等等。我就光关闭这套广告，鼠标都要操作四步。说实话比“
贪玩蓝月
”的弹窗广告都过分，我真想顺着网线去“砍你”。
另外一个事，不知道有没有人和我又相同感受的。
现在的技术论坛真的不敢打开，我觉得每次打开首页我都是窒息的，文章清一色的
“一万字面试总结”
“这
八股文
不懂还能混下去？”
“装逼技巧108式”
“这些命令方式你都不知道？”
“完了，又火了一个项目”
“
vue3
这个特性称王！”
广告
深入理解ES6(博文视点出品)
京东
￥99.00
去购买
?
我去，比起之前那些略显枯燥的技术笔记文章，稍微带点趣味性的，自己还有欲望点进去看看。现在好了，满屏幕都是这些钓鱼标题党，看的真的让人浮躁。我现在一周只敢开一次技术论坛，如果天天看我可能致郁了。
还有那些技术公众号我挨个取关，现在点开一个就是广告，再点开一个就是卖课，真的绝望了家人们。
以前每天点进论坛这种网站，就感觉是一个茶余饭后闲聊的地方，看看大家在讨论什么技术、有什么bug、或者什么趣事。现在的感觉就是每天都在赶集，还没点进网站就已经充耳的吆喝声了。
“我家白菜便宜，再不来看看就卖完了！”
“现在家家有这套茶具，你还不买一套？”
“大家快来看，我家公鸡下蛋了！！！！！”","之前开源在github的一份大作业被人传到了CSDN上还要金币才能下载。我想举报结果发现竟然还要我先下载资源或者联系管理员，真的让我恶心坏了。
更新于2021.10.27，下面是实锤，还给我加了个斗地主的名字真的是绝了  。代码写的烂，接受任何批评。","好家伙，CSDN 28 万+读者关注，两届博客之星，总榜前十的选手，看到这里，突然想匿名
。
但我还是要站出来说两句。
我也不知道为什么 CSDN 突然下起了红包雨？这一点我也是非常反感的。这可能是产品经理出的馊主意。
我是 CSDN 的重度用户，我觉得自己作为一名普通的程序员，能在 CSDN 上取得这样的成绩，是非常不容易的。
看到红包雨的时候，说实话，我真破防了。
这种破防，就好像 TI 10 LGD 输了决赛一样！
这里留个坑：
沉默王二_CSDN博客-趣学Java,程序人生,教妹学Java领域博主
我希望过一段时间，我们能看到一个浴火重生后的 CSDN，给它一点时间吧！
-------割一下，除了 CSDN，我觉得下面这些网站也是非常不错的--------
知乎：
Java - 搜索结果 - 知乎
掘金：
后端 - 掘金
B站：
沉默王二的个人空间_哔哩哔哩_Bilibili
GitHub：
https://
github.com/
思否：
SegmentFault 思否
力扣：
力扣
中国大学
慕课网
：
大学计算机基础_国防科技大学_中国大学MOOC(慕课)
码云
：
沉默王二/JavaBooks
国外的：
https://
stackoverflow.com/
DZone
Java, Spring and Web Development tutorials
JournalDev - Java, Java EE, Android, Python, Web Development Tutorials
Java Programming Language - GeeksforGeeks
Coursera | Online Courses & Credentials From Top Educators. Join for Free
大佬的博客：
阮一峰的网络日志
酷 壳 - CoolShell
美团技术团队
对了，也可以完全自己建个
个人博客
，用 docsify +GitHub pages 非常方便。我这个《Java 程序员进阶之路》就是这么干的，界面是不是也挺漂亮的？
对应的文章还可以在 GitHub 上开源，爽歪歪！这是 GitHub 地址：
GitHub - itwanger/toBeBetterJavaer: Java 程序员进阶之路，风趣幽默、通俗易懂，对 Java 初学者极度友好和舒适 ，内容包括但不限于 Java 语法、Java 集合框架、Java IO、Java 并发编程、Java 虚拟机等核心知识点。
还可以利用 jekyll + GitHub pages 搭建个人博客，完全免费，只需要一个域名即可，样子我觉得也挺漂亮的。
还支持移动端访问。
给大家再展示一下我的收藏夹，其实还是有蛮多优秀的网站的：
真的，都是宝藏，不过，作为老博主，还是希望 CSDN 能来个浴火重生，就像明年的 Dota2 那样？","害，好的网站多的是，不看 CSDN 可以看别的，不用刻意在一棵树上吊死。
项目类
项目是一个面试官非常看重的点，也是拓展视野、挖掘轮子一个的地方，下面就为你推荐几个程序员都应该 mark 的项目类网站。
Github 代码托管 
https://
github.com/
作为开源代码库以及版本控制系统，Github 拥有140多万开发者用户。随着越来越多的应用程序转移到了云上，Github 已经成为了管理软件开发以及发现已有代码的首选方法。代码托管必备。
Github 也有非常多好的项目可以推荐，比如我自己的 github (逃了)
https://
github.com/crisxuan/bes
tJavaer
还有其他非常多优秀的 Github ，比如 
CS-notes、JavaGuide、mall 商城项目
2. 码云代码托管平台 Gitee | Software Development and Collaboration Platform
码云托管平台是中国的，之所以国内自己开发了一个码云平台，是因为 github 涉及到 fq，你懂的，而且码云是
开源中国
的托管平台，会定期评选一些优秀的项目，你不可错过！
3. Gitlab 
https://
about.gitlab.com/
对于有些人，提到 GitHub 就会自然的想到 Gitlab,Gitlab 支持无限的公有项目和私有项目。其首页截图如下
4. 
http://
coding.net
CODING - 一站式软件研发管理平台
谈到 coding.net,首先必须提的是速度快，功能与开源中国相似，同样一个账号最多可以创建 1000 个项目，也支持任务的创建等
博客类
博客园
 
http://www.cnblogs.com
这样一个不起眼的地方，却吸引了很多IT技术精英，把这里当作自己的网上家园，每天在这里分享着精彩的原创内容，也许他们看重的不是华丽的外表、诱人的虚名，而是纯净、专注、对技术人员的理解。
2. 掘金 
https://
juejin.im/
掘金
现在被字节跳动收购了，内容审核变得越来越严格，也涌现了很多大佬，他们写的文章非常棒，强烈推荐大家每天逛一逛，博客内容都是经过层层筛选的，非常值得一看
3. 思否 
SegmentFault 思否
思否上面有很多大佬，不得不说思否的界面做的非常清新，舒服，这就让人很喜欢这个博客平台，目前看来还是比较小众，但是上面的开发者的互动很多，是一个很温馨的地方。
4. infoq 
InfoQ - 促进软件开发及相关领域知识与创新的传播-极客邦
infoq 是最近兴起的一个技术社区，界面非常小清新，让人感觉很舒服，目前入驻的开发者倒不是很多，但是 infoq 依托极客邦的大流量和资源，做起来应该很快的，我入驻了 infoq ，感觉里面还是有很多大佬的，推荐大家经常浏览一波
5. V2EX 
https://www.
v2ex.com
无论你是在大学进行人生最重要阶段的学习，或者是在中国的某座城市工作，或者是在外太空的某个天体如 Sputnik 1 上享受人生，在注册进入 V2EX 之后，你都可以为自己设置一个所在地，从而找到更多和你在同一区域的朋友。
6. OSCHINA 
https://www.
oschina.net
这个网站同样是国内最大程序员社区，各种教程、资源、工具、书籍都是可以找到的。在社区里，你可以尽情的写博客，发动态，激烈的讨论问题，只有在这种环境下才能激起你学习的热情。
7. 简书 
简书 - 创作你的创作
简书是一个不仅仅为程序员提供的创作分享社区，上面充满了各种各样精彩的博文，也有很多优秀的博主，但是相比较与 CSDN 个人认为在技术创作方面就略低一筹了。
8. dev 
https://
dev.to/
dev 社区和国内的掘金社区很相似，技术分类也比较多，各种技术应有尽有，文章质量都很不错。
9. dreamincode 
Please Wait... | Cloudflare
dreamincode 是一个相对小众的技术博客，风格简约，但是内容却不简单。
10. bytes 
Where Developers Help Developers
bytes 和 dreamcode 类似，简约但不简单。
11. hongkiat 
https://www.
hongkiat.com/blog/desig
n-dev
hongkiat是与技术、设计领域相关的站点之一，大家可以在这里分享技术文章。
12. IBM Developer 
https://
developer.ibm.com
这里面都是一线工程师，技术性很强，每一篇文章都值得细细观看，认真学习。
问答类
知乎 
知乎 - 有问题，就会有答案
有问题,上知乎。知乎,可信赖的问答社区,以让每个人高效获得可信赖的解答为使命。
本是一个分享各种人生杂谈，和一些鲜为人知以及各种大牛的免费和付费的知识型网站。由于流量逐步扩大，吸引了大批优秀的程序员在上面分享自己的技术创作，也是一个程序员常去的网站之一，不仅仅是为了学习技术。
2. 思否问答 
SegmentFault 思否
SegmentFault 思否是中国领先的新一代
开发者社区
和专业的技术媒体。我们为中文开发者提供纯粹、高质的技术交流平台以及最前沿的技术行业动态,帮助更多的开发者获得认知
3. StackOverFlow 
https://
stackoverflow.com
这是一个由外国人创办的专为程序员提供的国际性问题解答交流社区，正如网站签名：
Stack Overflow - Where Developers Learn, Share, & Build Careers
。这个网站非常的纯粹，一般人还真不太习惯用这个，没有一手好英语还看不太懂全英文的技术交流与问答。
4. Reddit 
https://www.
reddit.com
reddit是一个非常个性的社区，你可以在这里讨论编程问题，还可以学习学英语，reddit 还很幽默，有古怪的莫名笑点，评论接楼很有意思。
5. daniweb 
DaniWeb Community
daniweb也是一个质量比较高的问答平台，有一种像社交平台的感觉。
教程类
菜鸟教程 
菜鸟教程 - 学的不仅是技术，更是梦想！
菜鸟教程提供了编程的基础技术教程, 介绍了 HTML、CSS、Javascript、Python、Java、Ruby、C、PHP、MySQL 等各种编程语言的基础知识，是个小白入门，学习语言的好地方。
2. w3schoool 
在W3School,你可以找到你所需要的所有的网站建设教程。从基础的 HTML 到 CSS,乃至进阶的 XML、SQL、JS、PHP 和 
http://
ASP.NET
。从左侧的菜单选择你需要的教程! 和菜鸟教程十分相似的网站。
3. 易百教程 
易百教程? - 专注于IT教程和实例
易百网是一个内容全面的教程网站，专注于 VBScript, MATLAB, EJB, IPv6, IPv4, 电子商务, PostgreSQL, SQLite, SDLC, Assembly, 操作系统, JSON, iOS, 设计模式, VB.Net, 计算机基础知识。
4. Bilibili 
哔哩哔哩 (b-b)つロ 干杯~-bilibili
起初这个网站是由游戏玩家视频火起来的，尤其LOL骨灰级玩家遍布其中。bilibili 是国内知名的视频弹幕网站，通过动漫打出了名声，最近两年发展势头迅猛，里面有不少有创意的 Up 主，不乏一些有趣的程序员。
5. 中国大学MOOC网 
icourse163.org
中国大学
 MOOC(慕课) 是国内优质的中文 MOOC 学习平台，由
爱课程网
携手网易云课堂打造。平台拥有包括 985 高校在内提供的千余门课程。在这里，每一个有意愿提升自己的人都可以免费获得更优质的高等教育。
6. 慕课网-程序员的梦工厂 
慕课网-程序员的梦工厂
慕课网(IMOOC)是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、
android开发
以及 html5 等视频教程资源公开课。
7. 网易云课堂 
网易云课堂 - 悄悄变强大
网易云课堂，是网易公司打造的在线实用技能学习平台，主要为学习者提供海量、优质的课程，用户可以根据自身的学习程度，自主安排学习进度。涵盖实用软件、IT与互联网、外语学习、生活家居、兴趣爱好、职场技能、金融管理、考试认证、中小学、亲子教育等十余大门类。
8. 实验楼 
https://www.
lanqiao.cn/courses
实验楼这个网站我直接吹爆，无需配置繁琐的本地环境，随时在线使用。
9. tutorialspoint 
Tutorials Library
这是一个在线学习的网站，并且免费，里面有各种技术、各个知识点的讲解和demo，灰常全面，这比查找API方便多了，遇到不明白的知识点直接根据索引找就是了，还有各种电子书。
10. codecademy 
Attention Required! | Cloudflare
学习新语言，敲代码玩就在这里了。这个网站将简化编程学习的过程。比如说网站左边会讲解知识点，右边直接练习。如果出现错误，就会有错误提示，直接给你反馈。所以，使用它不用想太多，直接拼命硬干敲代码入门。
11. 
Livecoding.tv
 
https://www.
livecoding.tv/accounts/
login/
http://
Livecoding.tv
 由一群欧美程序爱好者共同发起成立，旨在为全球程序员提供一个实时高效的互动平台。特色是使用了录屏直播技术，用户可以在线观看高手实时编程并且可以向对方提问互动，网站现在已经汇集了一大批程序精英。现在 
http://
Livecoding.TV
 来到中国，希望更多的中国程序员加入进来一起切磋技术。
12. Dzone 
https://
dzone.com
Dzone 是一个技术涵盖比较全面的网站，像云平台、数据库、物联网、开发运维、Java 语言等都有。
13. simpleprogrammer 
The Programming Blog to Help You Get a Job - Simple Programmer
simpleprogrammer与其他技术类的社区不太一样，在这里并没有很多技术类的文章，更多的是指导建议性的文章，讲述了一些人生道理，职场规则，编程生涯的一些文章。
14. SitePoint 
https://www.
sitepoint.com/web
通过 SitePoint 教程，课程和书籍学习 Web 设计和开发-HTML5，CSS3，JavaScript，PHP，移动应用，这是一个偏向前端方向的网站，在这里包含了各种高质量的前端方面的文章，电子书。
15. YouTobe 
YouTube
YouTobe 这个网站可算是经典，和国内的哔哩哔哩一样，各类视频汇聚于此，当然各国编程大神也在这啦。
算法类
LeetCode 
力扣
几乎每个算法大牛都知道的神奇网站，这个网站上面有：算法、数据库、Shell、多线程等多种类型供你学习。多数人在上面练习编程算法，尤其是给想进入一线互联网公司的技术人员，提供了一个免费又方便的题库。面试前都会在上面进行长期和充分的刷题，是你的不二选择。
2. LintCode 
LintCode 领扣
LintCode 领扣上有数量超过 1000 道的算法题目和人工智能题目，通过刷题熟练掌握数据结构和算法。完成各大名企的阶梯训练，为你斩获心仪的 offer 打下坚实的基础
3. 洛谷 
首页 - 洛谷 | 计算机科学教育新生态
洛谷创办于 2013 年,致力于为参加 noip、noi、acm 的选手提供清爽、快捷的编程体验。它拥有在线测题系统、强大的社区、在线学习功能，也是一个很好练习刷题的网站啦
4. Codeforces 
Codeforces
Codeforces 是一家为计算机编程爱好者提供的
在线评测系统
该网站由
萨拉托夫国立大学
的一个团体创立并负责运营。在编程挑战赛中，选手有 2 个小时的时间去解决 5 道题，通过得分排名，选手可以看到实时的排名，也可以选择查看好友的排名，还可以看到某题有多少人通过等信息。
5. Topcoder 
Top Technology Talent On-Demand
Topcoder 据说是世界上规模最大的编程网站，这里面的题型，比赛形式跟 ACM/ICPC 极不相同。该网站把中国纳入其赛区，大家可以上去那里跟来自全世界的程序员(事实上大多数也是大学生)进行更直接的交流，可能也是ACM/ICPC 练兵的好地方吧。
接单类
程序员客栈 
程序员客栈-领先的程序员自由远程工作平台
程序员客栈是领先的程序员自由远程工作平台，未来互联网企业用人方式。提供优秀程序员为您进行网站建设制作、测试运维服务、人工智能 AI、大数据区块链、软件开发等优质服务。
2. 码市 
码市 - 互联网软件外包服务平台
码市是互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作。
3. 猿急送 
程序员兼职_外包_工程师兼职招聘-猿急送
猿急送为您提供兼职程序员，兼职工程师信息，猿急送是一个高级技术共享平台，是优质的程序员兼职网站，这里汇聚 BAT 等知名互联网公司的技术开发、产品、设计大牛。
4. 开源众包 
https://
zb.oschina.net
开源众包C专业的软件
众包平台
，350万+ 优质开发者为您提供网站、APP、微信/小程序、企业应用等软件开发服务，有效降低企业 IT 软件开发成本、解决技术资源不足等问题。
5. 实现网 
按需雇佣 BAT 工程师、设计师
这个比较高级，是一些知名公司技术人员兼职的平台。我们可以在线约好去其他公司兼职坐班。实现网为企业提供BAT 等名企背景的、靠谱的开发设计兼职人才和自由职业者,满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求。
6. 猪八戒 
沈阳猪八戒网-中国领先的企业服务平台
猪八戒网企业外包服务，中国领先的灵活用工平台，其中服务品类涵盖LOGO设计、UI设计、营销推广、网站建设、装修设计、工业设计、文案策划、知识产权的服务。
7. 码易众包平台 
码易_企业应用商店_软件众包_软件服务_云市场_云课堂_云计算平台网站！
码易是智网易联旗下 IT 软件服务平台，集软件商城、企业应用、电商软件、crm 软件、商务服务平台于一体的一站式软件外包开发服务平台。
求职类
牛客网 
牛客网-找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网
求职之前，先上牛客，就业找工作一站解决。这个网站不像 csdn 和 OSChina 以技术博客论坛为主了。但是在你需要的时候，却是相当有价值，里面有面试技巧、各种知名的不知名的互联网公司的对应往年校招社招面试题库，刷到你手软，一般应届生用这个比较多。
2. 
拉勾网
 
互联网求职招聘找工作-上拉勾招聘-专业的互联网求职招聘网站
拉勾招聘是专业的互联网求职招聘网站。致力于提供真实可靠的互联网岗位求职招聘找工作信息，拥有海量的互联网人才储备，互联网行业找工作就上拉勾招聘,值得信赖的求职。
3. Boss直聘 
https://www.
zhipin.com
BOSS直聘是权威领先的招聘网，开启人才网招聘求职新时代，让求职者与 Boss 直接开聊、加快面试、即时反馈，是一个致力于为招聘者和求职者搭建高效沟通、信息对等的平台
4. 猎聘 
【猎聘】-招聘_找工作_求职_企业招人平台
猎聘，2018年香港上市。作为中国知名中高端人才求职招聘平台，汇聚56万+知名企业、16万+认证猎头，为5700万用户提供高薪工作岗位。总之，猎聘还是非常不错的。
另外，再不济也可以看看我写的七本 PDF。","浏览器自定义搜索引擎可以屏蔽csdn 
复制这个链接
https://www.baidu.com/#ie={inputEncoding}
&
wd=%s -(site:csdn.net)
以edge浏览器为例
其他搜索引擎同理","这网站，17年以来一年比一年烂，以前我搜索问题习惯性去CSDN，也算是贡献过
博客来
解决问题的，而现在一打开就是要付费，最重要的还是他还不解决问题，花钱下载的文件完全就是智商税，你在英文官网一搜就有的。要不然就是各种恶心的特效，我同事说他虽然不懂中文，但你这论坛怎么跟黄网差不多？
只不过这样也有奇效，强行帮我戒了中文依赖症，去
stackoverflow
，去各大官方网站上找解决方法，和来自全世界各地的产品供应商的工程师发邮件沟通，算是学到了很多东西，只能说这玩意儿靠着早期一波中文互联网良性用户积累，吃老本吃到现在。","CSDN的用户体验变差和它的目标受众有一定关系。
诸如GitHub, Stackoverflow一类的网站，有一个很大的门槛是英语。能混迹于这些社区，甚至有所产出的人一般来说英语水平都不差。而那些英语水平无法达到能够阅读这些英文社区的人则不得不选择
中文社区
。虽然技术水平和英语水平并不是绝对正相关的，但是能够参与英文技术社区讨论的人大多都不是入门级用户。
CSDN由于早年积累了一些技术文章和资源，SEO做得比较好，所以能吸引很多入门级的用户。这些用户由于缺乏经验，不擅长检索更加高质量的技术资源，所以会成为CSDN的主要用户。他们的需求刚好是CSDN可以迎合的。
这网站还有什么存在的意义？
因为有很多伸手党需要CSDN这样的网站为他们解决燃眉之急，或者说他们并不需要深度的、高质量的技术资料，而是需要能快速找到一个解决问题的方案。",特意进来看了下知乎是不是又推几年前的东西给我看了,"可能就是我以后不会再用了吧。
写出这句话的时候还挺难过的。
这是我从学生时代到步入社会一直在的一个平台，对我而言的意义还挺特别的。
我从 14 年的时候开始在  CSDN 上输出，认真做分享，600+ 的原创，总排名也在前几百，颠峰的时候周排名也进过前几。
之前他们第一次推出原力计划，第一次推出付费专栏，我都是第一批响应。
原力计划
做到现在，也就只是“原力”了，之前为了分享而分享的创作者看不到了，取而代之的是一批“网警”。
我记得最离谱的一次是，我在 CSDN 上发了一篇推荐 B 站上比较好的 Python 视频，一度冲到热榜第二。
然后在群里，被“网警”举报，说我这篇文章给 B 站引流。
朋友截图给我的时候我只是当个笑话看，然后没想到群里 CSDN 的工作人员积极响应，几个小时我的文章就从热榜上撤下去了。
诺，就是下面这个群...
这次感觉刷新了我三观的上限，其实我的第一反应是：B 站，赶紧给我打钱！
后来我就慢慢不怎么看 CSDN，再后来，热榜上全是一堆“小心心 + 怒干 + 万字长文”，一溜都是一模一样。
以小窥大，倒不是摆烂，封闭而已，再大白话点儿就是飘了。
平台靠创作者崛起，本该是互利互惠，现在却至如此。
眼看他起高楼，眼看他宴宾客，眼看他。。
害。
我爱知乎（狗头","csdn挺可惜的
我是非科班出生当的程序员，入门就是靠csdn论坛。当年csdn上的开发者都很热心帮助别人解决问题，一些热门板块如java、.net、web、数据库，你在上面发帖提问，过一分钟刷一下就会有答案，即使在深夜，这比找个专业的老师带你要好的多，一个老师知识量有限，不能解决所有问题，而在
csdn
上好多人都会帮你解决问题，几乎不会有解决不了的问题，除非提问方式有问题。我当年开发技术的提升就是不断的遇到问题，在csdn上提问，得到解决方案，循环这个过程。这个真的比知乎强太多了，知乎上提问，要不就没人回答，要不就很久以后才有答案，黄花菜都凉了，不过他们本身就是不同类型平台，没什么可比性。
后来自己经验渐渐丰富了，从提问变成了回帖解决问题，如果发帖者觉得你的回答解决了他的问题，会结帖给分，然后论坛每月、每年会根据板块积分生成一个排行版，前三名会获得一个勋章（一朵花），挂在你的头像下面
如
2011年11月 web大版积分第一名
2011年11月 java大版积分第二名
这种
我当年也为了这种勋章没日没夜的回答问题刷分，还获得过几枚。同时那个时候也是我技术提升最快的时间段。
不过csdn好像也只适合新手，随着经验渐渐丰富，这个论坛也就没什么价值了，因为高级开发者遇到的问题往往都不是三言两语或者一段代码能解决的。csdn就像新手村，当你级别到了，出来后就不会回去了，因为没什么好玩的。
之后用的比较多的是
csdn博客
，上面有些博客质量还是挺高的。之后就越来越恶心，看个博客先给你弹一些乱七八糟的东西，影响你的视线，用户体验实在太差。而且还形成了心理阴影，搜索出来csdn的东西就不愿意去点。
现在则基本上彻底消失在我的视线里。不过还是很怀念当年在csdn论坛里的那段时光，几乎是开发生涯最快了的阶段。","我在CSDN持续写技术文章一年多，拿过2020年的博客之星，也拿过CSDN不少奖励。
这些称号和奖励也不能说非常有含金量，但是能得到官网的认可我也是很高兴的，这是对持续写技术文章的博主的鼓励和支持，有的正反馈才能持续下去呀。
我在知乎也有发技术文章，但是我感觉知乎用户更真实一些，CSDN有的留言太像机器人了，而且CSDN历史文章很难再有流量，只能靠运气，就是看用户是否能搜到你的文章。
知乎就不一样了，知乎的文章会持续的推送，所以一年写的技术文章每天都持续有人在点赞，到现在也有很多破千赞的文章了：
还有CSDN的原创机制就是一个鸡肋的功能，根本就没有原创检测机制，两个账号发一样的文章标注原创也一样没问题，我感觉好像没有做这个原创校验的机制吧。。
总之，
CSDN作为国内的老牌技术社区，不管是从博主身份，还是用户身份，我打心底也希望做的更好吧~
我写的文章主要是
计算机基础类的，比如操作系统、计算机网络、数据库、计算机组成
等等，正好这一块知识点是大厂常问的知识点，所以我的文章帮助到了很多读者，不少读者跑来感谢我，因为看了我的文章，不再惧怕这些计算机基础的知识了，然后在校招中拿到了腾讯、字节、阿里、百度的offer。
写了这么久，我积累了不少计算机基础的技术文，正好乘着假期，我也把我这一年多输出的文章整合了起来。
计算机网络
基础篇
TCP/IP 网络模型
HTTP 篇
HTTP 常见的面试题
HTTP/1.1如何优化?
什么是数字签名和数字证书？
HTTPS RSA 握手解析
HTTPS ECDHE 握手解析
HTTPS 如何优化?
HTTP/2 牛逼在哪?
HTTP/3 强势来袭
TCP 篇
TCP 三次握手和四次挥手面试题
TCP 重传、滑动窗口、流量控制、拥塞控制
TCP 实战抓包分析
TCP 半连接队列和全连接队
TCP 内核参数：如何优化 TCP 三次握手和四次挥手
TCP 粘包和拆包
收到RST，就一定会断开TCP连接吗？
代码执行 send 后，数据就发出去了吗？
粗暴的关闭 vs 优雅的关闭
我跟面试官聊 TCP 三次握手源码，他夸我真棒！
IP 篇
IP 基础知识全家桶
ping 工作原理
网络综合篇
键入网址到网页显示，期间发生了什么？
CDN 工作原理
Linux 常用的网络命令
网络异常篇
一个 TCP 连接，一端发生宕机和进程挂掉有什么区别？
TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？
HTTPS 中 TLS 和 TCP 能同时握手吗？
TCP 三次握手和四次挥手，期间失败了会怎么样？
TCP 在 FIN_WAIT_2 状态下，收到处理乱序的 FIN 报文，会如何处理？
一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，处于 establish 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？
操作系统
硬件结构
CPU 是如何执行程序的?
存储器金字塔
如何写出让 CPU 跑得更快的代码?
图解 CPU 缓存一致性
用动图的方式，理解 CPU 缓存一致性协议！
CPU 是如何执行任务的?
什么是软中断？
为什么 0.1 + 0.2 不等于 0.3 ?
操作系统结构
Linux 内核 vs Windows 内核
内存管理
虚拟内存
进程与线程
进程和线程基础知识全家桶
一个进程最多可以创建多少个线程？
进程间通信
多线程同步与互斥
多线程那些事，硬核有趣
死锁
互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景
线程间到底共享了哪些进程资源？
大白话说协程
调度算法
进程调度/?面置换/磁盘调度算法
文件系统
一口气搞懂「文件系统」
设备管理
键盘敲入A 字母时，操作系统期间发生了什么?
网络系统
Linux 系统是如何收发网络包的?
什么是零拷贝
I/O 多路复用:select/poll/epoll
高性能网络模式:Reactor 和 Proactor
Linux 命令
如何查看网络的性能指标?
如何从日志分析 PV、UV?
系统综合篇
如何将计算机组成、操作系统、计算机网络、数据结构与算法融会贯通？
面试官：如何提高程序的性能？
MySQL
基础知识
熬夜肝了 2W 字的数据库知识点
索引
索引为什么能提高查询性能？
一口气搞懂 MySQL 索引所有知识点
组合索引遵循了最左匹配原则就走索引吗？
15 张图破局，慢 SQL
分页场景慢？MySQL的锅！
事务
事务、事务隔离级别和MVCC
幻读是怎么被解决的？
锁
MySQL 全局锁、表级锁、行级锁
MySQL 是怎么加行锁的？
完蛋，公司被一条 update 语句干趴了！
面试题
Mysql 夺命连环 13 问，你能抗住多少题？
我当面试官，面你 MySQL 基础
MySQ 八股文来袭！
Redis
数据结构
20 张图击溃，跳表！
持久化
RDB 快照
AOF 日志
RDB 和 AOF 读者问题答疑
架构
主从复制工作原理
缓存雪崩、击穿、穿透
先更新数据库，还是先更新缓存？
如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？
Redis分布式锁，你用对了吗？
面试题
Redis 为什么这么快?
Redis 八股文
我当面试官，面你 Redis ！
Java 并发
2W 字带你，深入一下线程池
17 张图看穿 synchronized 关键字
要搞懂 volatile 关键字，就靠这 26 张图
Java 多线程，八股文！
学习心得
怎么学操作系统和计算机网络呀？
学计组的亿点小建议！
看书的一点小建议
打好这些计算机基础体系，大厂 Offer 任你挑
21 张思维导图，小林肝了半个月的「后端技术学习路线」长啥样？
小林读者喜提微软offer，来瞧一瞧他的算法学习之路
我的 500 张图是怎么画的？
读者牛逼 - 校招/社招经验
双非本科 + 非科班，从月薪 5k offer 到年总包 35w+ 的 offer
211硕士 + 非科班，校招拿字节跳动offer
三本，京东美团滴滴高途作业帮等offer
双非本科，校招斩获字节、腾讯、阿里后端开发
社招转行进腾讯
双非一本，斩获字节offer
图解 PDF 发布
不鸽了，小林的「图解网络 3.0 」发布！
小林的图解系统，大曝光！
怎么样，是不是超多干货！
这次来个三连不过分吧？","其实可以换个角度看。
为什么有屏蔽知乎网页部分内容的插件，没有屏蔽csdn部分内容的插件？
因为一个还有必要，而另一个已经没有必要了，直接整个网站屏蔽了就是。
从顶端放个不跟着滚动条走的广告banner占位置，到这个banner主动伸长，再到白色关闭按钮配个灰色背景，再到什么红包雨，越来越招用户反感。
可能人家产品还纳闷呢，淘宝京东不都搞这个吗，怎么我们用户就都是骂的？拜托，人家来你csdn是来干啥的，心里没点儿(a,c)数吗？
一篇文章转载来转载去，各种作者一看就是机器人，本来已经够要命了，又弄什么聚合页，搜个东西一看结果里有csdn，还以为已有解决方案或者思路了，点进去发现是啥有用的都没。怎么你
csdn
也成流量站点了，是要向热备还是程序员宅基地看齐啊？","CSDN十年博主来答，答主里面有人说停送杂志了，其实没有，要花钱。看图：
本身对CSDN还是有很多感情，不多说了...
推荐些好的网站
https://
github.com/
  
无数次说了，教程如下，不再另写：
Newest Questions
会有很多技术人员回复一些小白的问题，还是很友好的。在问题相关的页面时没有任何广告和营销内容的。
传智教育黑马程序员高端社区-论坛版块
 
黑马的社区是有管理员实时审核监控内容的，耐心浏览一下就会发现很多干货，有学习线路图+技术交流，还有面试经。
各种内容推荐：
Coursera | Online Courses & Credentials From Top Educators. Join for Free
 
：无限制学习，与200所顶尖大学和公司合作。（但都是纯英文课）
Reddit：
在线社区，有点像天涯，每天都挺热闹的。
Good Reads：
现在ipad上直接下载就可以，￥30；是一款阅读软件，内嵌浏览器。
好的书籍
首先方向不一样读的内容肯定不一样，如果你是零基础小白或者是计算机专业的同学，给你的书单如下：
如果你想深入学Java、.NET、C++或者任意方向，建议参考下面书单：
开源项目
Google: 
https://
github.com/google
苹果: 
https://
github.com/apple
Facebook: 
https://
github.com/facebook
Twitter：
https://
github.com/twitter
微软：
https://
github.com/microsoft
Square：
https://
github.com/square
阿里：
https://
github.com/alibaba
…
开源指南 9月热榜
其实大家只要搜索，想找到开源项目非常容易，我在这就不多介绍经典开源了。其实有时间看看热门框架源码都是学习。 
两本值得收藏的经典开源书：
这本书可以让你了解开源发展的脉路，推荐原因作者给出的软件行业避免死亡的解决之道=开源+服务。
 这本书和我们探讨的是一种基本的人性冲动，单纯的为了把事情做好而好好工作的欲望。作者想到开源不仅仅是开
源代码
，也使开发部门和用户有直接的沟通，而不是通过产品。
开源学习方法
第一步：学前的思考，即将学习的开源项目是做什么的，用了什么架构。看与一些大热的开源，一般都会有架构图给大家参考，如果没有翻翻学习的人有没有画，实在没有！自己也要画出来！
第二步：这个项目有什么技术难点，用了什么解决方案。实现了什么需求。（抓主干）
第三步：扒下来代码，首先要做的是跑起来，如果涉及到什么算法，可以先跳过。还有一些费顺序的代码，如果不能理解，分析不出来就跳过，全部看不懂的都可以跳过。
第四步：按照关键技术点和模块学习，如果可以尽量做好规划，自己用思维导图串起来相关内容，否则很容易乱。
第五步：加功能，其实只要你扒下来项目，加几个简单功能的过程都是你独立思考的过程。
最后总结：
全局浏览―通过别人的评论提炼项目重点―架构图―核心技术点―技术亮点―业务流程
；
软件也好，平台也好，初衷一定是希望越来越好，没人希望自己产品被人吐槽。随着时间的推移，一定会出现一些问题，我们静待期望CSDN越来越好吧。"
,,,,,,,,,,,,,,,,,,,,,
为什么有人可以在屎一样混乱的几千行代码里加功能？不重构能驾驭屎山吗？,None,"驾驭屎山的唯一方法，不是重构，而是
不重构
。
为什么有人可以在屎山里加功能？
很简单：把屎山扒拉开，每块闻一闻，找出和你要改的功能对应的那坨屎，把这坨屎套个塑料袋（封装），你就可以假装塑料袋里不是屎，是巧克力。然后，在旁边拉一泡新的屎，等它风干成型（测试通过）就可以收工了。
当然，怎样优雅地在一座屎山里闪转腾挪，做到“百屎丛中过，片屎不沾身”，还是需要很多经验和技巧的。不过说白了，就算失误了摔个嘴啃屎，臭也只臭你程序员一个，老板还觉得你很狼性，客户还觉得真香。
很多愣头青觉得自己是天才，可以把屎山重构了。他们中的大部分人引发了屎崩，永远埋在了几千米高的屎山之下。
极少数人在泥屎流的洗礼中活了下来，浴屎重生。他们真的做到了，他们真的重构了整座屎山！
重构之后的那个东西，被后人称为――
屎山2.0。
当一个系统复杂度增加的时候，它的熵也会增加，这是宇宙规律。而某些有洁癖的码农，他们非要强行降低这个
复杂系统
的熵――不是做不到，但需要巨大的能量，也就是成本。
你想让谁来付这个成本？老板还是客户？
屎山不是一天拉成的。每一代屎山的建设者，都是非常聪明的人。他们非常清楚继续堆高屎山，未来将产生的代价。他们理性中立客观地评估了推翻屎山重建的成本，然后做出了一个充满智慧的决定：
在屎山上继续拉屎。
这个决定对于每一个人都是最优解，因为每一个人只需要对他当下的目标负责。每一次“继续拉屎”的决定都是正确的，不这样做才令人匪夷所思。如果重构屎山，客户很生气，因为交付时间更长了，还会冒出许多以前没有的bug。老板很生气，因为成本大增，而客户毫无多付钱的意思。就连重构屎山的人自己也很生气：天天钻在屎山里996，搞得浑身屎味，工资却一分钱没涨。
尿海不择细流，故能成其大；屎山不拒细壤，方能就其高。屎山就这样一天天长大，终于令最后接手的码农感叹：高山仰止，
景行行止
。
其实，屎山，是任何复杂系统的终极归宿。
无论你使用何种语言，师从什么流派，哪怕23种
设计模式
样样精通，最终还是会踏上前往屎山的道路。因为，条条大路通屎山。
就连微软、谷歌、Oracle这样的大公司，他们的产品也都是屎山。Oracle每改一个功能，全公司的服务器需要全速测试几个月。chromium浏览器的源码有十几个G，虽然是开源的，但没有人敢在如此险峻的屎峰上提交自己微不足道的屎坷垃，高处不胜寒。
至于微软，呵呵……从win8到win11，10年了，控制面板还是有两种口味：一种是古早味的，一种是苹果味的。office从2016到2021，5年了，不拿放大镜都看不出有什么区别。
这段话可能会让你误以为，微软、谷歌都是垃圾。但实际上，他们是地球上最强的软件公司。世界上最高的屎山，都是最聪明的屁股拉出来的。换了一般的程序员，屎山还没垒出一个小屎包，就屎崩了，就这点水平还天天嚷嚷着要重构屎山。
乔布斯曾说：死亡是最好的创新。
所有代码的最终归宿都是坟墓，而绝大多数代码早已死无葬身之地。屎山是不可能重构的，这辈子都不可能重构的。打败屎山的唯一方法，唯有另起炉灶，建一座新的屎山。这就是为什么在巨头们巍峨连绵的屎山脚下，总能有新的小屎包崛起。
当然，对于血气方刚的少年，我知道，你很可能觉得我在扯淡，屎山有什么好怕的，重构就是了。
明知山有屎，偏向屎山行。来，壮士，干了这碗屎，我绝不会拦着你。
我只会献上一本秘籍，祝你早日成功：
作为一名有理想的程序猿，我也在努力建造自己的屎山。
我想做一个能直接翻译英文pdf的工具，不是
划词翻译
那种，而是一次性翻译整个文件，英文pdf进，中文pdf出。这样看论文就可以偷懒了~
链接如下，感兴趣的同学可以试试。目前只有PC版，APP的坑一直没填：
大中华区
Rust语言代言人 
@张汉东
 老师在试吃之后，只评论了两个字：
神器
。
他翻译的pdf是这样的：
说实话，得到这样的评价实在出乎我的意料，因为我还从没试过翻译编程领域的文章，初看貌似效果还行。不过，我在受宠若惊的同时，也暗暗感到惭愧。因为只有我自己知道，屎山里还有多少坑没填……
不说了，我要进屎山填坑了……
评论区有人说反对我当年退出文坛，其实我进入文坛也没多久……如果你喜欢我这种用脱口秀style把道理讲通透的风格，可以尝尝我今年出版的两本科普书。这两本书都入选了2021年度CCF“科普阅读推荐图书”榜单。CCF是什么，对于程序员就不需要介绍了吧……
一本既不吹捧科学家的伟大、也不纠结历史细节、只想让你无废话看懂量子、还吭哧吭哧手绘100多张彩色漫画实验图解的硬核科普：
广告
猫、爱因斯坦和密码学：我也能看懂的量子通信
京东
￥68.00
去购买
?
一本不屑于教Python和调参、只想和你探讨人类命运和智能本质的AI科普：
还有不赚钱、只求交个朋友的套装：","2022年6月2日
补一句：你完全说反了。
―――
这个是因为你工作时间比较短…
你工作久了跳槽多了就会发现，大多数公司你都是半路进来，大多数项目你进来的时候这系统已经“稳定”运行好几年了，大公司甚至都10多年了。
你认为是屎山，当时第一波编写者看看这代码也会觉得是屎山。不，每一个接收的人都会觉得是屎山，然后他用尽全力继续拉屎。
在长时间多人数得接力赛之后，这个代码早就不是这个代码了。
每一次换新人，一看这代码都忍不住重构一波，但因为时间不够，总有一些代码没用重构，敢动得只有非核心代码，所以，在kpi的压力下，不得不妥协。
这样来最保险得做法
：自己新写的代码使用新的架构（自己熟悉的），旧的代码不变，需要用老的代码那就桥接过来。
每一个人都这么想，然后新的需求又桥接到已经桥接的代码..然后桥接到桥接的桥接的桥接的代码上..
所以这个项目中有了大量的桥接代码。
所以修改核心代码的难度
：不是每次核心代码相加
而是：第一次核心代码+每一次代码桥接的阶乘…
所以到你头上了，你最好的办法就是继续桥接。
明明直接调用functionA就好了的 需要调用一个functionM 间接调用e，间接调用d，间接调用c ….然后才是A..我只能再加一个function H。
一个1w行的大方法就是对我最大的仁慈。。。
当然还有一个问题
每一波人的编程能力或者编程思想不一样。
―――――――-
举一个例子
比如最开始的作者喜欢kiss原则，代码非常舒服，性能也很好，小而美。
第二代喜欢设计模式，
策略模式
，代理模式，工厂方法，责任链..
23种设计模式，牛逼牛逼  代码虽然复杂了，但是拓展性非常好，堪比教科书式的案例，
前一人虽然性能好，容易懂但是拓展性很差。
老子精心设计得代码，可保证10年轻松拓展。
第三代不怎么熟悉设计模式，这代码看的他云里雾里，他说：。这什么垃圾代码，一个简单的查询跳了7-8层？一个对象继承了2-3个父级？
老子重构， 这写的啥啊，为啥我改了就不行了，改回去就好了，那这样吧，我来
面向切面编程
，用切面追加我需要加的功能。比如 在输出结果中追加这几个新字段，这样可以非侵入的增加我的业务，而且保证了老代码的稳定性。
还有这块，引用得是jar，都不知道源码在哪..
我这个字段加不进去..妈的..
还有这个方法是私有的..好了，我用反射来调用..
这场景没有5年8年经验还解决不了..
多少人都搞不定，被他顺利的高效的完成了任务，领导非常高兴给他发了三个月年终奖。。。
第四代 这代码好复杂啊.还有各种切面我终于搞清楚了..
。可是明明着bean10个属性，怎最后输出了15个属性？
而我的业务需要这几个突然出现得属性..
这样好了，我隔离这个代码，使用一个函数屏蔽。所有都和这个函数打交道。
除了老代码之外，其他代码舒服了，可是老业务却都还在跑
第五代 这代码怎么会这么奇怪？
…
….
第n代 这屎山，老子要重构..卧槽，本人不才，去知乎问下：
为什么有人可以在屎一样混乱的几千行代码
里加功能。各位大佬们不重构能驾驭屎山
吗?
注意，每一代都是绞尽脑汁，发挥他们得聪明才智解决问题才导致这样的。如果大家痘傻逼一点，老老实实按照老版本逻辑写，或者一不做二不休，彻底重构底，这问题还会存在？质量时间成本不可能三角下，老板可不会允许。
所以别怪前任，他们尽力了，其他大多数都尽力了。
――――――――――――――――――
大哥，摆脱，说这么多没卵用啊，我现在急着干活呢？
我tm怕撑不过试用期呀。
来了来了别慌。
对于你我来说，想要玩起来这坨屎需要做这些事情
1搞清楚如何启动这项目
，因为通常这样的项目配置项，中间件依靠很多很杂。大概率会有大量无用配置文件，以及废代码，引入了并没使用的框架，以及莫名其妙的报错，比代码还长的警告..
顺利启动这个项目是最重要的事情。
2搞清楚如何在ide中，比如idea中打开这项目
假如这个项目可以在测试环境，生产环境启动，恭喜你..，但是这不代表你就可以开始干活了。
你需要在ide中成功编译..成功run，成功debug..
3搞清楚代码，执行链路
入参-入口-》业务-〉数据》出参
比如
某web页面上有一个按钮：放款
你要做的事情是在放款得时候追加一点业务，比如说黑名单检测。
首先找到控制器，如果找不到，打开浏览器控制台，network，看url
然后双shift在idea中搜索这个url后面的内容
大概率你能找到控制器（ssh项目）
如果找不到，比如是gwt，或者其他玩意，那就全文搜索，或者找代码中的配置文件。
这样你找到了入口
从入口出发 你可以看到宛如瀑布般的川流不息的函数调用..甚至一句注释都没
那你统一简化为：数据库操作，非数据库操作两大类
数据库操作就可以知道有哪些表。
有了表，这样就好多了，就可以分析业务了
比如有贷款表，贷款详情表，放款表，利率表，等上十个表。
这样再分类成两类，贷款业务强依靠表，弱依靠表。
强依靠只记录贷款本身数据，弱依赖??指通知，历史记录等表。
在这些表里面找入参和出参数。
顺着字段找代码。
如果能够从如参找到出参，差不多了。
如果不能全部找到，先只找几个。
到这个时候你应该可以一两句话概述主要内容了。
4搞清楚数据库中表的关系
当然大概率啥文档都没..或者文档太久没更新了..
因此需要有点想象力..毕竟不是写的博士毕业论文，还是可以猜出来4-6分。
5复习下你的业务需求，你需要增加啥入参，增加啥出参，这些参数再哪些表？算法先别管。
然后结合搜索代码..
到这儿业务自我的差不多了。
6学习那些非数据库操作。
比如发短信通知，调用接口，写队列，调用非存储中间件代码。
到这一步差不多了，然后试图加一个入参和出参。串起来这些代码，表，接口，中间件。
如果能完成，差不多了，如果不能，寻找熟悉得人，演示给他看，让他指导，如果他不愿意（大概率不愿意）那就让他在他的电脑上debug讲解一下流程。
当然这些都完成不了，也没关系，最重要得是跟你领导同步你的计划-执行-结果，然后求助他，他大概率解决不了会给你一个人帮你，这样可以吧锅甩给他（别太直接，别欺人太甚就行）如果领导说没人，让你自己看。那你为自己争取了更多时间了。
记得主动汇报，不要等到deadline再说你不行..不然这deadline真的就是deadline了..
未完待续…
看的爽麻烦来个三连呗，谢谢。
最好说一下，
还想继续看我装逼or想学习如何装逼推荐看这几个
大大大大大芳
123 次咨询
5.0
PMP 项目管理专业人士资格证持证人
74133 次赞同
去咨询","别说几千行了，几千万行劳资都可以
维护过一个神奇的软件叫
3ds Max
，总代码量大概八千万行，其中据统计活代码三千万行（就是用户经常能使用到的代码）
不过具体到工作经常需要接触到的模块，也就几百万行的样子，有些很成熟的部分，比如图像读写之类的，基本上不用管它
然后整体大规模的重构基本不太可能，主要不是做不到，是因为没这个动力，搞的再牛逼也不一定能给公司带来更多的收入，而且我觉得没人有这个魄力和实力下决策也是个很关键的因素
其实各种小规模的重构也一直在做，不过吃力不讨好，如果不产出产品价值，用户也会觉得你没做啥，但是事实上你让这个软件的可维护性可能延长了五年
不重构能不能驾驭，当然临时驾驭一下是可以的，比如离发布时间比较近了，需要快速解决问题，我就一般会开启黑客模式，我就一个办法，先把关键路径（业务工作流）反复调试，调试到对这个路径上面的局部逻辑非常熟悉，然后开始
Hack
，把相关代码按照功能需求尝试着改一遍，可以就送测试，不行就回退，然后我会拿失败的数据再调试一遍，加深下对业务流程的理解，然后重新Hack一遍，这样每遍都会越写越好，最终总能搞定（除非证明这个功能需求就是错的，一般比较罕见）
不过大部分时候还是建议能重构就重构一下的，而且要持续重构，保持这软件的可维护性，不然自己以后回到同样的逻辑再来一次也会很痛苦，我为人人，人人为我嘛。当时团队是使用相互审核代码（peer review）的制度，反正太恶心的代码别人也不想维护，所以基本上review这关也过不了。
不得不表扬下3ds Max的插件式开放架构，虽然灵活性无敌，但是因为最初的逻辑和结构设计还是非常清晰的，所以后续可以一直扩展，有些时候通过插件接口把复杂性隔离开了，有些模块可以独立分析，或者基于接口分析改动的影响范围。
3ds Max虽然代码量大还能维护这么多年的另一个重要原因是有一套非常成熟的测试机制，包括了自动化的分布式回归测试平台和非常有经验的艺术家测试，这套测试系统和数据也是有专门的团队在维护的。离开了这些的保障，软件工程师也不敢随便改代码，毕竟全球那么大用户量呢（doggy）
PS：跑一趟CICD + 分布式回归需要一个小时左右，切分支干别的事不是不可以，但是太麻烦，劳资一般喝咖啡去了^o^
后来，有些合作方谈到某个项目，我说你们为什么不这样这样做？他们说因为我们的系统太复杂了，我们的代码量blah blah，结果我一看代码，就这？？？","      见过一个写了一万多行的代码，就为了调用一个接口发送短信，把这个接口真正的功能独立出来，发现只有10行是封装参数，调用短信接口。
      而其他9990行代码在干嘛？各种if  else的判断，外加各种调用其他接口查询获取参数，其中有查询redis，取计数，查webservice、db等等，还有和别的公司系统的对接，最终一堆业务柔和在一起，形成了这一万行代码。
    咋一看，这方法名,sendSms，见名知意，走进去，我去，我XXXX，谁他丫XXXX，骂完以后还得继续。
   看完这些代码后，我理清了先辈们的逻辑，终于可以加个if  else搞定这个任务了。
   至于说重构，给钱了么？给时间了么？
   排给你任务的人说，不就是判断一下业务场景，然后发送一下短信么，之前别人做的时候就一天，你怎么还需要一个星期左右？
   你怎么说，“哦，代码复杂度高，不重构的话后面越来越复杂，系统会崩的。”
  需求会听么？架构师会听么？其他员工加班时会抱怨：“都怪那个XXXX，没事提什么代码重构，要不是他，我现在都回家了”
   有一种东西叫做工作，还有一种东西叫兴趣。
  作为兴趣，去重构吧，但作为工作，效率是第一。","分情况，大部分时候如果你完全不明白这个代码是怎么回事，那可能是因为你的水平和经验及不上最初设计这套东西的人，许多在他看来非常浅显易懂的设计理由是你完全没有想过的，还有一些奇怪的地方可能是遇到了问题但没能完全解决掉的
workaround
，或者因为需求的特殊性（比如特别苛刻的性能要求）无可奈何做的取舍。这种没有搞明白的情况下为了省去搞明白的功夫直接重写（这种不应该叫重构）是非常危险的，已知你的水平不及或者至少是不高于前代设计者，而前代设计者踩过的坑你也完全不知晓，而周边与这段代码配合的代码或者软件已经变成和它耦合的形状了，你要在这种摸瞎的情况下做出个一模一样完全匹配的东西出来是几乎不可能的，最常见的结果是要么花了大时间做了新版本最后一直测试不过上不了线，要么强行上线然后天天出问题。
如果你的水平显著高于之前的设计者，你应该能从代码里很清晰地明白他到底为什么做了这样的设计，并且同时明白这种设计远非最优选择，犯的错误主要有哪几点，并且自己尝试添加或者修复的功能为什么会直接和这个设计冲突；甚至最初的设计思想是什么、途中开发时变成了什么样、后期维护时又变成了什么样，中间哪一段是明显为了应付出现的问题随手糊上去的，哪一段是后来的维护者不理解最初设计做出的错误变更等等。这种时候才是一个适合真正重构的时机，你可以将当前代码的设计和更优的设计之间做一个折衷，在尽量保留现有成果的情况下，提供一个渐进式过渡到新设计的方案，然后逐步逐步替换掉实现错误的代码，并且有针对性地补充测试。
注意，完全不修改、继续沿用现在的设计也是一种折衷的方式，这完全取决于你对未来这段代码发展方向的预期。另外，这种理解不代表逐字逐句理解每一行，只要在整体上明白思路、有分隔影响范围的手段、然后在需要改动的局部进行细致分析即可。","听哥一句话，碰到代码屎山，不要尝试重构，如果屎山摇摇欲坠，你赶紧拉上一坨，糊上去就是。
哥当年也是激情洋溢，打算把屎山换成
钢铁森林
，最后呢，身穿黄马褂，大鱼大肉相伴，出入大小酒楼，穿梭在各种高档写字楼，给之前拉屎糊屎山的人赢恭敬地送上外卖，生怕他们打差评。","推荐下这本《Working Effectively with Legacy Code》，非常实用。
大意是先定义什么是遗留代码：没
覆盖测试
的代码就是遗留代码。
有介绍很多技巧，印象比较深刻的是怎样小切面地把新的非遗留代码功能加进去，也就是说，我的新代码首先是有测试的所以它不是遗留代码，我可以给它抽个类或者函数啥的把它放一块，然后在老代码里加一点点代码给它调一行，这行调用代码需要简单到不需要覆盖测试你也知道这行不会有错。
此外根据「没有覆盖测试的代码就是遗留代码」的定义，每多覆盖一些测试，遗留代码也就少一点... 以及重构前先覆盖测试等等。
重构不下去了这本书也有给你心理建设...
当你绝望时
对付遗留代码是件苦差事，这一点没什么好否认的。尽管各自情况不同，但有衡量工作价值的方式是相同的：算算你能从中得到什么。对某些人来说也许是薪水――这没什么不好意思的，毕竟人人都得生活。但我认为肯定还有其他什么原因让你成为一个程序员的。 要想在对付遗留代码时保持积极向上的心态，关键是要找到动力。尽管有很多程序员的生活都较小，但工作时有一个良好的环境，有你所尊敬的并且知道如何快乐工作的人做同事仍然是一个非常大的诱惑。 如果你的团队士气低迷，而且是由于代码质量太低而低迷，那么有个办法可以试一试――从项目中找出一组最糟糕的类，将它们置于测试之下。一旦你们作为一个团队共同克服了一个最困难的问题，那么就会感觉一切不过如此了。这种情况我经历得太多了。
（试试知乎的带货功能...）","因为加功能和重构完全是不一样的。
我记得有另外一个问题是问：为什么有人说只要代码能运行就不要去碰它。
这恰恰就是说的这种情况。
屎山本身内部在维持一个微妙的平衡，很多地方都是正好只有这一个点是OK的，你稍微改一下就稀里哗啦如同多米诺骨牌一样的结果。
但是这很多时候并不妨碍你加东西。你只需要注意不要去改变原来的结构就是了。
这就好像操作系统在执行屎山的时候，也能并行执行其它任务一样。
对于屎山，你需要做的就是尽量将你新加的加在外部，而不是内部。
举个例子，微软的office很多后面加的功能，其实都是类似于执行VBA，也就是用脚本模仿用户手动操作，而不是直接改内部逻辑。
所以很多操作很慢。但是能用，这就OK了。
同样的功能在google docs里面，很可能就会轻量很多，虽然那是用网页+脚本语言写的。
爱立信有位工程师，搞了一套所谓面向方面的编程（AOP），就是改编译器，在每个函数的入口和出口自动插入钩子（跳转点）。这样加功能的时候，就不必动原本的结构，只是hook出去跑新的代码，然后再hook回来。
颇有杀毒软件是如何监视其它软件运行的味道。杀毒软件都不需要改你的程序，就可以改变你的程序的很多行为。
但是重构。。。那就完全不是这么一回子事情了。大部分时候是，牵一发动全身，稀里哗啦碎了一地，然后决定另起炉灶。但是已有的生意不能停，新的生意也要做，所以最后就变成半新半旧：一座新的屎山产生了。","这个问题我有资格回答，入职微信的第一年的工作可以认为就是在做重构，重构的目标是一个游戏引擎的整个渲染系统。
重构理由
这个很重要，虽然是技术团队，但一个系统原先跑的好好的，重构总要有充分的收益理由，只是所谓“为了未来的可维护性”这一点完全不足以支撑这么大规模的重构。我们最后推进重构的理由有以下几个：
性能。混合架构设计下，原先大部分工作放在JS，客户端做重点模块加速，重构后大部分逻辑下沉客户端，获得更好的性能以及多线程的可能。
扩展性。从跨端的角度考虑，原先比较粗糙的写法不容易管理，需要有个类似RHI的中间层抽象。
业务方确实对这个性能有需求，这为重构行为提供了最终正当性。
有了充分而正当的理由，重构才能被允许加入KPI，而这只是第一步。
重构原则
对于一个已经被使用的大型项目，并不能说我们要重构了，就放下一切全力搞，搞完了再上线，重构本身需要遵守一些原则：
不影响正常的需求迭代。这个是最重要的，业务方的需求仍然要优先满足，并且追加的迭代也必须同步追加到重构后的系统中
保证兼容性。用户侧的资源升级成本很高，所以不可能重构完成就强迫升级，期间肯定有阵痛期，即“老资源跑在重构后的系统中”，需要妥善处理。
保证稳定性。由于系统本身就很复杂，并不是所有人都能搞清楚一些约定逻辑和hack，所以需要充分的测试和沟通，这也是隐形成本。
保证规范性。既然是重构，就要充分保证避免下一次大规模重构，所以需要非常合理地设计整个系统，比起开荒，重构作为承上启下要耗费的脑力更多。
重构过程
在这个过程中，我们做了：
并行需求迭代和项目重构。这造成了两个几乎完全不同的系统设计需要定期全量Merge，基本都要靠人肉Diff，做过的都懂。
由于涉及到枚举值等等的变更，为了一段时期内兼容老资源，做了很多转换性的代码。
版本回退逻辑，由于涉及到业务代码、引擎、基础库、客户端多个地方，这个逻辑非常复杂恶心。
踩过去Hack的坑，并保证效果完全不变。由于项目本身的复杂度，导致许多问题（比如
野指针
、渲染效果）极难复现和分析，耗费了大量心力。
为了证明重构的有效性，花了很多时间在构造的高性能开销场景做测试，这个也算是成本。
Runtime重构结束后，工具端接入适配又是一大堆工作。
完全重构结束后，业务方接入重构后的版本升级，进行某些废弃接口（不得不修改的）的适配，又是一大堆工作量。
以及更多不堪回首的血泪......
整个重构过程包括我在内，纯Runtime大概耗费了20多个高级开发的人月。如果加上工具端的适配、以及业务方的升级和测试方的配合，感觉没100个高级开发的人月打不住。
所以，你可以看到在一个比较大型的项目作出重构的决策和代价是多么的昂贵了。要说服老板接受这么高昂的代价，必须要有充足的理由，同时你自身还要面对接下来各种糟心的勇气。
如果不是真的必要，这时间拿去早点下班好好生活不香吗，本来国内互联网大部分的项目也活不了多久。","有些屎山是为了政治的需要，刻意为之，有时候过于干净的抽象不一定是好事。懂的都懂。
几千行的屎也能叫屎山？有些历史悠久的公司，一个子系统就有数百万行代码。
举个现实的例子，我们部门维护的一个平台，在全球的同类业务中属于碾压同行的存在，但它也是公司众多屎山中的一座高峰。可以说遍地都是雷，某些核心代码支撑着数百种业务流，改核心代码的难度堪比外科手术。
一个五人规模的精锐团队平均每个月只能产出一千行左右的有效代码，大多数时间，大家都是在进行各种烧脑的分析、测试和扯皮。最后找到精准的位置，挪动一坨屎或者再拉一坨新的。
接下来就是跑回归测试，一般需要跑两三天左右，上万个测试用例，有些测试用例需要跑多次才能pass。即便如此，代码上线后也经常会出现各种问题，高级别的线上问题每年都有十来个左右。
这种屎山如果不是亲自在里面走一圈，一般人很难想象为什么代码产出会这么低。
为什么不去重构？对于这种承载着巨大业务的屎山，重构系统需要的资金数以十亿计，单位是美元。此外，还需要上百号人干上两三年时间，而最好的结果也只是再创造一座小一点的屎山而已。
复杂度不可消灭，它永远都会在那里，只是从一个状态转移到另一个状态罢了。
巨型屎山是一个标杆，能够衡量出程序员的价值。只有优秀的程序员才能驾驭得了这种屎山，普通的CRUD boy连打杂的活都不一定做得好（关于这一点，我们曾经在外包团队身上验证过）。
其实我们都应该感谢这种巨型屎山，是它保住了我们的饭碗，让我们有上升通道，让高级技术岗有存在的价值，让企业不得不开出优渥的薪资来留住人才。
巨型屎山是不可能重构的，这辈子也不可能重构，他的最终归宿只能是被推倒重建。巨型屎山的问题在于，经过很多年的维护、很多人的工作，已经没有人能够讲清楚它承载了哪些东西。
但如果你还想挑战一下小屎包，还是有一套方法的。
至关重要的一点，和屎山搏斗一定要有足够的耐心和细心，每行代码都有它存在的意义，你需要弄清楚这些藏在背后的业务逻辑是什么。
如果不能把业务逻辑和细节弄清楚，建议不要随便动手，很容易山崩。
你需要先站在更高的层面，去理解这个屎包承载了哪些业务，有哪些业务分支，有哪些细节，然后建议你画个图梳理一下。
到了代码层面，你可以结合业务细节来读代码，本地跟踪调试深入理解每个过程。同时可以看注释、看文档或者去问写这些代码的人。
只有它是一个稳定运行于线上的系统，总有办法弄清楚的。
等你把这些都弄清楚，再去改代码就会下笔如有神。
最后，建议对自己的颈椎好一点。","一看就知道没做过大项目，做过大项目就不会有这个问题了。
1、有些项目跑了很多年了，语法，思维，习惯都跟现在的主流不一样，随着时间的推移，功能与代码的修修补补，难看是必然的。
2、维护的人换了好几批，就好像一句口信经过口口相传最后意思全变了一样，一个项目N个人接手，每个人的水平、习惯、理念都不一样，写出来的东西混乱也就不奇怪。
3、有一句老梗叫优化是万恶之源，而什么叫重构？重写一遍代码来实现原来的功能，也就是重构在短时间内是不会有任何收益的，反而会因为重构导致功能缺失或者引发新的BUG，说白了重构只会徒增成本，增加风险，肯定会有人说，我重构是为了更好的性能，更好的扩展性和可维护性，但是实际情况是大多数的软件项目不是技术驱动的，而是业务驱动的，重构在技术上有好处，但是在业务上是没啥好处的，我第一家公司就重构过一版系统，然后推销给客户，客户问重构之后有什么好处？性能客户不在乎，新功能老版本也可以改，重构版本除了增加风险，对于客户来说没啥吸引力，那谁给你的重构版本来买单？
4、部分代码可以重构，整个项目建议重做，在现有的项目上重构问题是很大的，直接重做是最直接的，当然这要看高层的想法。软件是有生命周期的，到点了就该让它死，而不是从头到尾的换血续命。重构应该只针对那些频繁改动的关键组件，一些老旧、不明所以、边缘业务代码就放那安安静静的躺着吧。
5、对于打工仔来说，主动重构没有任何好处，什么叫主动重构，你嫌弃老代码恶心，就跟领导说我要重构，领导说好，做好的了不涨工资，做差了扣你钱，你不服，问为什么？老板问重构能增加公司收益吗？能减少人力成本吗？能减少服务器开销吗？这些你都不一定能打包票，而重构肯定会影响原来系统的稳定性，徒增人力投入，万一出点严重的BUG还直接影响公司收益，你说老板是给你发奖金还是扣你钱？
6、这一句血的教训：
如果一段代码不出问题，那就不要动。","让你去接根线，
你还把下面这摊全理了啊！
你非得驾驭它干嘛
犯不着啊亲！","一个非常有意思的事情，每个人都说自己写的代码结构清晰可扩展性好，每个人都说别人的代码是屎山。
客观原因有很多。比如重构这种事在业务上讲基本是没有收益的，你说我花一周的时间重构这几千行代码，功能和以前一模一样，性能也没提升，仅仅是好读了一点，除非没业务做了大家都闲的蛋疼，一般的领导都不会批这种事的。
至于几万行代码级别的重构，那更是吃力不讨好，没收益不说，通常还会导致一定时间内功能缺失质量下降。除非拿来作为职级晋升答辩的材料，否则除了一心追求技术的人，谁会有动力搞这个？
代码重构的工作量不是线性增长的。几千行级别的代码重构，一周就能搞定。几万行级别的重构基本要两三个人搞半年。更大级别的重构，整个团队十几号人押上去搞个一两年还未必能搞成。因为有能力驾驭二十万行代码的人才是非常稀少的，你的团队里未必有。
一般的毕业生能驾驭几百行代码这个级别就算不错的了。毕业两三年达到能驾驭几千行代码的程度算进步快的。在往上到驾驭几万行这个级别，没点技术追求是做不到的。做不到，又工作在大型项目上，那除了在既有框架下修修补补生产垃圾代码外还能做什么呢。大部分人，不过是挣钱吃饭而已，技术追求是什么，能帮我挣更多钱吗？
答案是，不能。至少，非常的曲折和间接。
大佬分很多种，有 PPT 大佬，有业务领域大佬，有技术攻关大佬。这些领域的大佬和代码质量都没直接关联，有关联的是基础编程领域的大佬，能从宏观架构到代码实现细节包括性能、扩展性等等全方位无死角搞定的那种。
可惜的是，这种大佬太少了，远比 PPT 等类型的大佬少的多。
所以为什么大部分团队日复一日的在屎山上工作而不考虑重构，除了个别客观的原因，更根本的原因是技术能力不够，办不到。
待续。。。","不少人应该知道Excel 的1900年是被算作闰年，也就是2月多了一天。
这是因为给在Excel之前的Lotus写代码的程序猿是个弟弟，为了简化算法就把1900年算作闰年，反正当时功能有限，不影响使用。
这也是很多程序猿刚开始建一座山的想法，上面那个勇健（精力旺盛的老头）催的这么紧，我先搞个能用的，有问题以后再改嘛。
但是在修正这个Bug之前，有已经有很多重要的文件用上了这坨屎。这些普通人的文件里面的公式肯定是写死hard code进去的，这坨屎要是变了点味道他们还真活不下去了。
然后程序猿就开始纠结要不要重新洗一下这坨屎，但是在考虑要加什么调料重新料理这坨屎的时候，更多的人更多的文件用上了这坨屎。好吧我处理不了了，掩饰一下bug，把代码丢给下一任吧？下一任接手一看？什么鬼为什么要我给前任渣男养孩子？你看我长得像接盘侠嘛？掩饰一下bug，把代码传给下下一任吧。
越拖延，沉没成本越大，很快这个成本就大到你要是敢动这坨屎FBI就要寄刀片给你了，因为他们的人的Excel也是用这坨屎写机密文件，要是日期改了，记载外星人带肯尼迪去登月这件事的Excel就要炸，克林顿实习生地道的施工方就要不到钱。
第6任接盘侠终于肯修这个Bug了，怎么办呢，核心代码上帝都改不了，那我们只能附加上一堆更烂的屎把这个漏洞糊一糊，至于新的屎在未来会造成什么问题？未来？未来关我什么事那是下一个程序猿要头疼的问题，你现在连加班费都不付，整天在涨薪和工资上扯皮，你会付我未来的薪水嘛？
古人云不斩来使，说的就是上面的人你不要斩给自己报告坏消息的自己的使者啊，每次有问题都是砍了提出问题的人，除了刚毕业的，谁敢提说哎我们有个很麻烦的Bug，麻烦老板你推了晚上瞒着嫂子去足疗店和
阿香
谈论佛法的计划，和我熬几个月的夜修一修这个现在还能跑但是有可能在未来炸的bug好不好？
重构？对我看得懂前面的人写的屎，甚至他用“1”， “2”，“3” 来定义性别，收入，住址 这几个变量我都知道，就算我能重构这个代码，但是我怎么重构用这个代码的其他衍生代码和文件？它们的衍生产品怎么办？这就是一个深度无穷的粪坑啊你多下去洗几次就不想下去了。非要改我宁愿直接重写。
每天早上按一个跑键，然后美滋滋的等程序跑领工资不香么？非要和自己过不去慢慢的修以前人留下的代码？
别忘了你的代码可能修一个数就能修的bug, 你可能要把在他们的代码里面玩上几小时的“
威利在哪里
？”才能找到需要修改的上百个相同的数字。越烂的代码越难修补，
有的人可是连循环都不用一切都是Hard code啊，而且还是没有排整齐的就算你用代码排列洗了一下很多时候还必须一个一个词修改。
甚至还有喜欢在词后面加空格来重命名变量，比如说“pen”, “pen ”, “pen  ”, 我在这没有加双引号有谁能看得出区别？第三个词可是有2个空格的，但是显示出来只有一个，你注意到了吗？
一座屎山质量的上限取决于接手它的程序员的下限。
为了掩盖这些弟弟的无能向上面的人交代，我们还特意发明了一个专业用词，胆子大点的还能作为KPI，Backwards Compatibility回溯兼容性。
简单来说就是说：我们保证了产品新版本能让旧版本也能运行。
翻译：
林北
什么都没改，bug就在那，你还是烧香求妈祖（码祖）保佑保佑吧？","你你有那个精力和能力么？一些真的大型项目第一代程序员可能都已经死了，对应的 domain knowledge 都需要
从头重新发现
，重构一遍能比重做一个差不多的产品还麻烦。","屎山不到万不得已，千万别去重构，否则真的会爆炸的！
一家公司的某个业务，但凡稳定点发展个几年，基本都是屎山般的存在，如果没有特殊事件或者领导的绝对授权，贸然重构屎山是会出人命的。
为什么大家能在屎山加几千行代码完成老板的要求？很简单扒开屎山，加上你要的功能，勉强测试通过，打包在一起假装这坨屎变成了巧克力，然后提测风干，成型发布。
IT行业大家都懂，老板催活跟催命似的，你要胆子大敢铲屎山，屎山就敢炸你一脸，到时候直接无限delay搞不好就卷铺盖走人了。
但是遇到一些千载难逢的机会，还是可以尝试重构一下的。
说一段我自己的经历吧：
2010年加入创业时期的360，担任高级工程师，负责一个远控软件，同时要跟操作系统底层打交道。
入职后才发现在Leader的神操作下，部门的代码耦合成了一个大泥球，一个主类就有几万行，主类里的一个函数就有几千行。。
那个Leader最常说的就是：能跑起来不要想着去改，跑起来就行！
后来因为副总裁要求一个大功能，这哥们直接卡壳了，他带着我们几个小弟想改改上线，发现怎么都改不出来，，硬是delay了1个月都做不出来。
副总裁直接怒了，快速给他转岗到其他部门，让我先暂代技术经理职位，同时开始招聘。。。
面对前任Leader留下来的数十万行耦合严重的代码和框架
（大白话：代码屎山）
，压力巨大。360素来以打仗凶猛著称，发版以天计，那段时间一天好几个版本。面临的最大困境是：如何在高速迭代的过程中重构整个旧的框架。至今还记得，面对那个主类的心情，那是崩溃和无力的。但越大的压力，你扛下来往往是更高的成长速度。
一瞬间，又回到了大三的那种疯狂状态，每天极限Coding，
甚至接近入定的状态
，上班往那一坐基本不动弹，就靠几瓶水几个面包，一天的三餐就对付了。
我们将代码组件化、模块化，实现了一边飞奔一边换轮子。就带了两个实习生，花了3个月搞定了这一堆恐怖的代码。
当系统彻底被改造完毕之际，那种兴奋难以言表。
因为成功完成了技术改造，同时还满足了副总裁的各种需求，副总裁直接给我晋升技术经理，招技术经理也再没提过了。
那段时间为了更好的重构代码，我还看了很多计算机经典书籍，包括《重构》、《
代码整洁之道
》《高性能Web编程》等等，把书本上的知识应用于工程实践，这种成长真的是难以言表的舒爽。
顺便送大家一份非常宝贵的计算机经典书籍资料，我把工作中用的经典电子书库（包含代码重构、数据结构、操作系统、C++/C、网络经典、前端编程经典、Java相关、程序员认知、职场发展）、面试找工作的资料汇总都打包放在这了，
学完进大厂很容易：
我已经帮大家打包好了，点击下方链接直接获取：
计算机经典书籍（含下载方式）
?
mp.weixin.qq.com/s?__biz=MzA3MzA5MTU4NA==&mid=100008684&idx=1&sn=eb2ebb6c6f4da1b6d82c5ea643cad435&chksm=1f16fd83286174959fe46170ccbb1c65d51afb0d174b10f85eaeddfe4030d898042fe5fbecf2#rd
这段时间，我的
架构思维
开始突飞猛进，我们在每一次的重构之前，都会先画出业务时序图、类结构图、工程关系图，然后按图索骥，每每在实现的那一刻，不由得惊叹：程序世界，太奇妙了。
所以你看看，带着代码能跑就不要动的观点，真的会害死人的，程序员有的时候就得直面大泥球，不断重构，不光锻炼能力还能保证后续需求的迭代。","作为一个还在写代码，40多岁的cto，今天正好被下属的要求搞的很郁闷。
试着回答这个问题。
第一，推翻一座屎山，构建出来的可能只是一个大炕，连山都不是。
第二，哪怕构建出来一座大厦，过上几个月，99%又变成屎山。软件工程，项目管理，远比单纯的技术人员想的复杂。但是我认为我们依然应该鼓励重构，这样我们才能获得进步。
第三，90%喊着要重构的人，嘴上喊的是重构，实际是重写。重写远比重构简单。因为重写并不需要像屎山一样经历严峻的质量验证，所有新产生的bug变得理所当然。
那什么是重构呢？能把上万行的功能模块，以每天一个版本的频率提交。而且每次提交都不影响现有软件运行。通过几十次的提交后，整个代码变得整洁了，可读性变强了，这是重构。
如果觉得无法做到。那就先从小的，能在几个小时内，一天内完成的重构做起，同时好好去读
代码大全
+重构那两本书。
稳定运行的线上代码，从来都是改出来的而不是设计出来的。","当你开始吐槽历史代码已经像屎一样时，潜台词必然是没有时间重构的。不然你就会说「看，我修了一个干净整洁的厕所。以后你们随便拉」。所以其他所有建立在从你开始提升代码质量的建议，你都要谨慎评估。毕竟 DDL 不会因为你看了哪本书而改变。：P
你要做的就是 COW 大法，让屎山裂变。然后以较小的风险修改其中一个。并且对于屎山增倍的事实做到放下心里负担（不然你以为那么大的屎山怎么来的？你前面的大佬改过的屎山是大了还是小了？）
这就是在理性的职场中，导致屎山不断裂变的那双看不见的手。屎山随着业务当量的增长，总有一天会突破临界点的。这时候其他的人推荐的书就可以在复盘时用上了。环境上叫先污染后治理。屎山治理的领域就叫延迟擦腚。
不过现实一般是干掉一个过深的子屎山，让整个屎山稍微平衡一下。或者拆分下，成为屎山森林。在互联网行业称为微服务化。
经过长期的磨练，你终于成长为一个可以轻松拉屎山代码而无负担的人，我们一般称为「菊次郎」；
你的团队直接用屎山来锻炼新人，我们称作「菊里扶人」；
你的团队一边造屎山一边卖力赚钱，这种精神称为「菊与$」；
你们的架构也优化做到了屎山容忍，我们一般称为「菊次郎的春天」。","真正的工程，就是要雇佣有这样能力的人来替雇主解决问题。
我们不需要有能力重构代码写得好看的人。","我个人感觉，只是感觉哈，大部分程序员不会改代码，尤其是改别人的代码，或者改自己两周前写的但自己完全不记得自己写过的代码。
因为他们根本就没学过、也没有练习过改代码这项技能。
他们能写代码，但是不会改。
有多不会改呢？
我见过一个程序员，他改一个变量名，都不会。
他怕会影响其他代码，但他并不知道如何判定是否真的会影响其他代码。
明明看到一个局部变量命名有拼写错误，都不敢去改。
我见过一段 if else 在多位程序员的迭代下，变成一百多行的又臭又长的裹脚布，他们都只会加代码，从来不改代码，因为改了别人的代码，就意味着自己变成了这段代码的最后更新者，有 bug 就会找到自己。
如果是改自己的代码，就会觉得几天前写的代码现在改是不是就浪费了几天工时，还是不改吧。
他们都没有错。
他们也不敢抽离函数，永远都是在文件末尾加代码，觉得这样就能确保之前的代码不会产生 bug，殊不知，随着需求的变化，没 bug 的代码也有可能产生 bug。
他们信奉『开放扩展封闭修改』原则，代码一经发布，就永不再改。
他们认为『懦夫才写单元测试』，只要代码通过编译器的检查，就是没有 bug。测试走联调，一个接口调两天是常有的事。
我改变不了他们，我只能远离他们，去找敢于改代码、善于写测试、不怕担责任的程序员为伍。
因为我怕跟他们在一起久了，我也变成不会改代码的程序员。
还好，我现在已经非常善于改代码。看过我直播的同学应该都看得出来。
我始终觉得，如果你已经知道代码的问题在哪了，那么现在就应该改掉，否则你就永远都不会去改它。"
,,,,,,,,,,,,,,,,,,,,,
程序员很闷骚么？,今天上课讲唤醒理论，老师随口举了一个例子，程序员都蛮闷骚，然后全班大笑。。。没有别的意思啊（其实我个人认为这是个褒义词呢Q-Q）咳咳，根据唤醒理论，当人们进入感觉剥夺状态，或者进入相当单调的情景时，他们会变得烦躁和渴望刺激。事实也是这个样子的么？程序员的生活真的很单调么？于是。。。。,"跟大家讲个故事吧。
老张是我的室友，他喜欢上了一个姑娘。
1
老张是什么样的人呢？这么说吧，很久之前微博上流传着一份程序猿的特征大全，老张符合上面的每一条。
我搬到这个两居室一周之后才跟他打过一次招呼，当时他穿着道袍一样的巨大睡衣、嘴里叼着把上已经泛黑的牙刷、双脚穿着颜色不同的棉拖，迷茫地看着我，含糊不清地说：诶？你谁啊？
搞明白我是他的新室友之后，他有点不好意思，双手在睡衣上蹭了蹭，然后跟我握手。
我这有好几T的片儿，感兴趣的话可以来拷。他走进自己屋里，突然又探出头来很认真地跟我说。
经历过这么别致的初识，我对他产生了极大的兴趣。说来也巧，我最近在做一个心理学的课题，想着能对自己写作有些帮助。他就变成了我第一个研究对象。
别看我平时吊儿郎当，其实我心里明镜儿似的。比较相熟了之后，老张在屋里挥舞着双手这么跟我解释，身后是他贴的 Dota2 、海贼王和
斯嘉丽
的海报。
我平时不讲究，是根本没必要讲究啊。我整天西装笔挺、人模狗样的，给他妈谁看啊？不就是给女潘抗凵吐穑课揖透悴幻靼啄切┕媚镎天花枝招展是干嘛，自己花这么多钱这么多时间收拾，好看都给陌生人看去了，算什么？做公益吗？
你说同事怎么看我？他们更无所谓。你去我们大厦，就看穿衣打扮就知道哪个是我们公司的，哪个是其他公司的。我们同事都很随性，活得明白，不爱慕虚荣。你看那些媒体公司、金融公司的，一个个脸上抹半尺厚的粉，笑都不敢笑，一笑全得抖下来。多累。
你看网上都说程序猿傻，不会哄女人开心。其实哪是傻，是懒得跟你聊。说三句话才明白半句，还得用十句话给你解释，这种女人哄她干嘛？为了骗她上床？我有右手啊，轻重缓急我自己拿捏不好吗？浪费那么多时间精力骗个女人上床，都是精虫上脑的原始人干的事儿。文明人才不会被鸡巴牵着走呢。
你们这些文化人整天想的是风花雪月，我对这些不感兴趣。你说整天跟女朋友老婆宝贝地叫着、银行卡信用卡刷着，图个啥？不就是晚上来一发吗。电话里甜言蜜语的，挂了电话一口一个臭婆娘；微信上发个笑脸过去，其实眉头早就皱成花卷儿了。有意思吗？
...
我认真把这些话记录下来，心想老张要是开微博，应该能成个段子手。
2
有天在客厅里，跟老张谈到恋爱和婚姻。
我无所谓。想要孩子了，就找个想法一样的姑娘，也不用什么海誓山盟、什么对酒当歌，直奔主题，结婚生子，凡事都特坦率、特不费劲、特环保。你看过《
纸牌屋
》吧？说话都直来直去，就那意思。
老张正说得口沫横飞，门铃响了。他皱起眉头来：我今儿没订外卖啊。
我说估计是同学来找我借书，把门开了，果然是安瑜。她是系里的学妹，正在报社实习，最近的采访需要跟我借几本心理学的书做参考。
安瑜走进门来，我说你就站这等下，我去拿书。从屋里出来时，看到满头油发身穿道袍的老张坐在凳子上，漫不经心地左手抠脚趾、右手啃黄瓜，旁边站着有些局促不安的安瑜，披着耀眼的白色大衣。当然耀眼可能是因为跟老张形象的强烈对比。两个人这时正好对视一眼，互相尴尬地笑了笑，我忍不住掏出手机，抓拍了这张荒诞写实图。
送走安瑜，老张正好吃完黄瓜，边往睡衣上蹭手，边问我：这姑娘挺不错，细皮嫩肉的。
我嘿嘿一笑：老张你不是说过自己的荷尔蒙从来是在掌控之中吗？
老张鼻子哼一下，说：我也没说别的啊。只不过我要是未来找个姑娘过日子，也不可能没有底限。她这正好及格了。
我心说你就犟吧，跟他说：这个妹子还偏偏就是你说的喜欢风花雪月、对酒当歌的文青。你就别想了。
老张站起来甩甩手，边往厨房走边说：女人就是麻烦。我再去拿根黄瓜。对了，你刚才偷拍照片我可看见了。给我传一份。
3
之后的几天，老张开始时不时旁敲侧击安瑜的事情。本以为他是三分钟热度，没想到连续打听了一个月。从她最近采访了谁、跟我借了什么书，到她上个男朋友是什么样的、平时有什么兴趣爱好，通通问了个遍。
每次我不耐烦地奚落他：你的荷尔蒙都侧漏好长时间了，赶快找时间擦一擦行不行。
老张每次都能宠辱不惊地狡辩：允许你研究我，不允许我研究别人啊？我就是最近加班少，无聊了对文艺女青年特别感兴趣而已，什么荷尔蒙，我十八岁那年就戒了。
有天我终于忍不住说：我介绍安瑜和你认识吧。我跑腿算是跑够了，以后您老亲自去研究行不？
老张装出一副特别勉强的样子，缓缓点了点头。
我从微信上介绍老张和安瑜认识，俩人就聊了起来。没过几天，我看见老张开始剪胡子、洗头发、穿衬衣和皮鞋，去跟安瑜见面。整理打扮一番后，我第一次觉得老张还是挺帅气的，实话说配得上安瑜。我把这个想法告诉老张，老张得意地笑了笑：所以告诉过你了，我以前是不想讲究，但不是没有讲究的本钱。
对于跟安瑜的关系，老张也逐渐开始松口：原本只是感兴趣，这是实话。现在呢，觉得她也不是那种太虚伪、太无聊的人，我们共同话题挺多，相处得不累。交个靠谱的朋友也不错。你别用那种眼神看我，我又不是为了跟她打炮才去找她玩的。
最后这点我倒是相信。老张这么多年都没跟雌性打过交道了，平时说话都带着浓浓的匪气，真想要跟安瑜打上炮那也不容易。
4
某天晚上跟老张吃烧烤喝啤酒，都有点上头。我的课题遇到瓶颈，一个特别靠谱的访谈对象聊到一半突然闭门不见；老张的项目也不太顺利，工程进度缓慢，副总天天发火，总监一个月换了三次。
喝到凌晨一点，我俩都困意渐去、话多起来。我问老张以前有没有过女朋友。老张把半根烤茄子塞进嘴里，含糊不清地说：当然有过啊。那年，我十八，她也十八。她喜欢我，我喜欢她。我们是郎情妾意，花前月下。
我哈哈大笑：让你讲故事，你念打油诗干嘛。
老张突然叹了口气，细想好像是我认识他之后第一次见他叹气，我便正襟危坐，以表庄重。他把手里的串都放下，举起大杯的扎啤喝个精光。喝完之后，停了半晌，他开始讲他的故事：
我初中的时候还是个不良少年，三天两头出去打架，然后跟狐朋狗友在学校甬道上跟女生吹口哨、溜到厕所去抽烟，平均三天得见一次教导主任。说起来那时候还不傻，知道家长老师都在意成绩，所以每次考试都认真复习，考得不差，他们也都拿我没办法。
有一回突发奇想跟几个哥们打赌，想比赛追女生，我们写了七八个我们这届觉得难追的女生，汆成纸团抓阄，抓到哪个追哪个，谁没追上或者追上得最晚，请大家抽一个月的烟。我抽着的女生是我们班第一，平时老实巴交的，不爱说话，也不招人喜欢，我没当回事，觉得这种女生好追得很。
没想到我那几个哥们一个一个都很快拿下了，偏偏我这个全班第一无动于衷。这可让我恼火了，我那个钻牛角尖的好胜心就上头了。我也不管什么打赌什么请抽烟了，也不怎么跟他们出去吹口哨打群架了，我就一心一意想各种办法追她。细节我就不说了，你要让我记我也记不清了。
结果从初二追到初三，追到全校师生都知道我们这点事儿了，这姑娘还是一直不温不火、不卑不亢地保持姿态，把我那个气啊。初三毕业那个暑假，我们到龙泉寺去玩，我就跟这个菩萨那个菩萨的一一发誓，说不追上她我就不姓张。说实话这时候我也不知道是不是真喜欢上她了，但是对她好、同时接受她冷冰冰的回馈，都已经成了我生活的一部分了。
高中我跟她一个学校，还是维持着这种奇特的关系。但她对我是好了一些，时常也跟我问好、送我点吃的啊用的啊。你说人吧都贱，她一对我好我这感动得啊，晚上都睡不好觉。有时候她也跟我出去玩，但是照样不爱说话、不露声色。还有几次手都牵上了。但到高中毕业她都从来不承认是我女朋友。
大学就没能跟她在一块了。结果她第一个学期就跟自己学院的学长好上了。你可能觉得在这件事儿上我特别傻，花了好几年时间就耗在明知道不靠谱的事情上。其实我当时也明白啊，但每次我下定决心要放弃、要忘了她，第二天她又都会或多或少给我“还有希望哟，再加把劲说不定就接受你了”这样的信号。卧槽我毫无抵抗之力啊，又是一次轮回。
大三的时候她跟我坦白了，她确实对我有好感，但好感没有到能成男女朋友那样的程度。可是中学的时候有人照顾、有人关心又是很珍贵、很难得的，所以她自己掌握好分寸，既让我鞍前马后地讨好她，又不让我追上她。她太聪明了，知道追上以后我也许就不会对她那么好了，还可能因为交往影响学习，她一直懂得怎么把自己收益最大化。
这段故事让我后来的感情经历都特别不顺利。我在大学的几次恋爱，有的其实都算不上恋爱，全都是在不信任、不坦诚的氛围中度过的。我不敢对别人太好，还时时提防着别人对我好的目的性。所以我自己就找借口啊、找理由啊。我不愿意伤害谁，谁也别来伤害我。
...
我默默听他说完，不知道该说什么，只好把两杯酒都满上，碰杯喝酒。
他突然哈哈大笑：卧槽我说的你真信了啊？
我愣了：我了个大去，是你编的？
他狡黠一笑，再不说话，装成醉样，懒洋洋地看着天空发呆。
5
后来几天，老张心情好了很多，不知道是因为倾诉了真的经历精神舒畅了，还是因为编造了假的故事骗住了我。每次我逼问他真相，他都说，A secret makes a man man.
他跟安瑜的关系好像也进展不慢。虽然两个人从来不跟任何人提到对方，但看他们朋友圈，一目了然。老张发咖啡厅大胸的服务员妹子，安瑜就会发同一个咖啡厅里有趣的摆饰；老张发五道口堵车，安瑜就会发要等的人真慢还没到；老张发
华星
的巨幕真棒，安瑜就会发变形金刚真好看。
以往只有程序跑通的时候才会露出笑容的老张，现在时不时会对着手机屏幕傻乐，有点毛骨悚然。原来在屋里放的又吵又闹的摇滚和说唱，不知哪天也都变成了情歌大全。
有天看到他出门，头发虽然还是油得很，但好像整齐了不少，称赞他两句，没想到惹他大怒：卧槽我这是发蜡，油你个头！
现在老张也不说那些程序猿理论了，跟个刚初恋的花季少男一样，百米外就能闻到他身上浓浓的荷尔蒙味道。
我以前的观点确实有失偏颇，我也不是圣人，也有想法不全面的地方嘛。老张继续张牙舞爪地强词夺理，手里还是半截黄瓜。
有的姑娘吧，确实太笨，整天就知道甜言蜜语的，没劲。但是呢，你看安瑜就不一样啊。她聪明，我刚说半句她就懂我的意思了，沟通不费劲。而且她有理想有抱负啊，不是满脑子想着找个富二代土财主、或者找个大帅哥小暖男，然后就相夫教子、安度晚年的那种姑娘。很多方面我们都很契合，什么都坦白说、明着说，从来不端着、不装腔作势。
那，你们坦白的结果呢？没确立关系？我忍不住问。
老张很不屑地哼了一声，好像嘲笑我的肤浅，说：当两个人足够坦白了，这些名义上的东西就都不重要了。既然互有好感，那就继续交往着，干嘛非得被名义这种东西给束缚。
他把剩下一小段黄瓜都塞进嘴里，得意地嚼起来，一副事情尽在我掌控之中的样子。
6
老张一直对跟安瑜的发展很有信心，所以当他告诉我两个人已经和平结束之后我还是有些恍惚。
老张显得不是很有精神，又开始穿不同颜色的棉拖，坐在客厅里懒洋洋地说：这事儿也说不上遗憾，就是情到了，就做情人，情淡了，就做朋友。其实也挺好，最近我们项目进度得往前赶，正好省出不少时间来。
不管是做什么，你他妈老是想着能找到各种逻辑通顺的解释，就算不合理。感情的事儿是能商量出来的吗？什么情到了情淡了，感情不就是先交往才产生的吗？我突然很不爽，用恨铁不成钢的语气跟他吼。
老张看我一眼，居然没有反驳，站起来去厨房洗了根黄瓜，回到客厅跟我说：对于一个程序猿来说，一半时间要用在写代码的，另一半时间要用在解 BUG 上。当你想达成一件事情，你会发现做好的准备总是有太多疏漏，你要把问题都找出来，都一一解决，最后程序才能跑通，事儿才能做成。这就是像我这样程序猿的思维。
这种思维下，会觉得要想跟一个女生在一起，只要发现出所有的 BUG，一一解决了，就能把程序跑通。所以你看很多上 PUA 课程的都是程序猿。如果要几年前的我，要想跟安瑜在一起，肯定是死命地去追，想尽办法把中间的障碍扫清、问题解决。
可是后来我明白了，有些程序是永远跑不通的。它即使没有 BUG，照样运行不起来，因为这些代码跟你不兼容。我不是没有试过跟安瑜培养感情、不是没有试过用各种办法让她对我有好感，但这没有意义。我们能不能在一起，不管是互相坦白想法、还是各自隐藏内心，其实很快就能感觉出来的。她看你的眼神、她的细微表情、她说话的语气，我是知道她有多喜欢我的。
这次跟她一起相处的这段时间，就是我浏览她的代码的时间。我仔细阅读了每条代码和它们的注释，最后发现，她在我这里是跑不通的。
听完他说的话，虽然知道还是强词夺理的解释，但我也生不起气来，只好骂他：你们这些傻逼程序猿，满脑子就知道代码。说人话行不？
7
老张对自己的公司特别不满，决定去上海发展。互联网行业的跳槽向来是风驰电掣的，他上午告诉我他的决定，晚上就要离开。
小酌了几杯酒，我帮他收拾行李。把事先买好的一大袋黄瓜给他塞到包里，嘱咐他路上别饿着。他哼哼两声，骂着说：卧槽让你给整得跟农民工进城似的。
我突然想到一件事，问他说：有件事我一直想问，其实无关紧要，但是我特别好奇。
他猜出不是好事儿，一口回绝：坚决不答。
我没理会他的回绝，还是问出口：你跟安瑜到底打过炮没有？
他理都不理我，拿着行李匆匆出门，消失在楼道里。
我无奈地笑笑，回头看到他房间里的海报，不知什么时候旁边多贴了一张照片，是那天我抓拍的他和安瑜。
这时手机响了，我看到是他回的微信：喜欢一个姑娘分两种。有的姑娘，你看到她，就想跟她打炮；有的姑娘，你看到她，就只想给她写诗。
我抬头看到我抓拍的照片里，邋遢随意的老张，对着安瑜微笑，还真有点像个诗人。","@刘飞  答了道题，叫 “程序猿很闷骚么？”
呵呵，他竟然把我跟他的故事写成了小说，然后拿到你们七千多个赞！！！！！！！！！！！！！！！！！！
我第一次成了别人的小说素材！！！！！！！！！
让我来撕开真相吧。
其实，老张并不叫老张，但你们也看到了，“
刘飞
 ”这个名字，跟老张本质也没什么区别。
安瑜也不叫安瑜，爸妈没给我那么文艺的名字，我只好自我拯救，起了个江湖艺名叫曲臭臭。
事情是这样的――
单身太久了，一朋友说，“给你介绍个对象吧，算你半个老乡，靠谱。”
没想到还有人惦记着我的终身大事，我很感动，手抖在微信上发了好几行流口水的表情。
“但他是个程序猿。”朋友说。
“……滚。”
我还没到饥不择食找程序猿的程度吧。刚准备扔手机关灯睡觉，朋友发了他三张照片。
阅毕，我决定见他一面。
<<<
因为他颜值太高，是程序猿里的战斗猿？想多了。
第一张，他在毕业晚会上说相声。一席儒雅长衫下，露出了
阿迪王
运动鞋。
第二张，格子衫，黑框眼镜，大平头，眯着色狼眼，站在公司 logo 下，面色苍白。
第三张，一张大饼脸占满镜头的 98%，五官像被人搓麻将那样蹂躏了一圈。
――但我擅长脑补。我发现这是一只潜力猿，如果能被拾掇一下，还是很像样的。虽谈不成恋人，至少做个朋友，拉他一把，帮他提升一点审美情趣，早日体验人生真正的幸福快乐。
嗷嗷待哺的程序猿千千万，我不能普度众生，但能救一个是一个。
我开始了十九年人生里的第一次相亲。
<<<
约在
五角场
西堤牛排，他吃肉我喝汤。
聊下来，我发现他没我想象中的那么“程序猿”。
他以前在锤子工作，我刚好前几天采访一朋友，得知老罗不少八卦。于是两人相谈甚欢。
他在某美甲 O2O 创业，我刚好在做 O2O 的稿子，一起感叹这大好的创业时代。于是两人又相谈甚欢。
他在我的家乡念大学，提到一家撸串的好去处，那里刚好也有我不少青春回忆。于是两人又又相谈甚欢。
他说相声的视频很好笑，他拍的照片很有水准，他的黑色风衣还蛮有型，发蜡的薄荷香很好闻，右手还戴着一枚骚气的尾戒。（当然，看了他文章我才知道，出门之前他左手抠脚，右手啃黄瓜，完事双手往衣服上蹭。）
人的魅力之处，就在于撕下刻板标签后的两重对比。作为一枚程序猿，竟然文艺得如此嚣张。
吃完饭，我站在薄荷味的风里，看着淞沪路上随列车一闪而过的灯光，酝酿出一个恰到好处的微笑，对他说，“今天跟你吃饭好开心。”
话说到这份上，他牵我一下手表示一下总是可以的吧，结果――
他说，“那我再给你讲个笑话，让你更开心。”
“……好。”
“是这样的。我不做程序猿很久了，之前还在锤子做产品经理。其实那不是真正的经理，但是在银行办信用卡的时候，因为有“经理”这两个字，额度又给长了好多。哈哈哈哈哈哈哈哈哈哈哈哈……”
……
好，笑，吗？
<<<
第二天早上，他给我发了个 “Hi”。
到晚上，微信聊到一千多条时，他问，“今天要见面吗？”
我说“好”。
奇迹是在不知不觉中发生的。我们竟然连续见面了十几天。我是那么喜新厌旧追求新鲜感的人，十多天竟对他没有一丝厌倦。
朗朗晴天突遇洪水，就索性做一回猛兽。
<<<
那时已经期末，我被线性代数搞得焦头烂额。
每天晚上，我在学校等他从静安寺打车过来，然后他骑我的女士自行车载着我，去大学路的猫空学线代。他说自己宝刀未老，欢迎求助。我性子倔，皱着眉头翻书，咬着笔杆不肯请教他。
他坐在我对面，把双肩包里的 iPhone、iPad 和 MacBook 都摆在桌子上码放整齐，默默掏出一本纸质书来看。（……）
时间静静过去，线代书越翻越薄，他在我心里留下的脚印越来越多。
我不是观音，更不是佛。说是要渡化程序猿，却被他拉进了同一条阴沟，浑身泥巴越滚越多。
――
他说要教我用 Markdown 写文章，得意地告诉我，“一定把你培养成最会写代码的作家”。虽然不知道作家会写代码有什么用，但后来我的世界里，的确充满了 “#” 这个奇怪的符号。
我想换个电脑，他眼睛放光，用生命跟我推销 MacBook Air，说“这是全世界最适合你们文字工作者的电脑”。我点点头说，“那记得帮我装个 Windows 系统。”他浑身颤抖如丧考妣。后来，我成了 OS X 系统的死粉。
总之后来我数钱包里有几个钢G的时候总是从 0 开始数。
跟别人见面握手要握三次。
<<<
在我拿着线代书准备出门跟他见面第十七次的时候，我室友抱怨说，“你最近恋爱谈得太凶了吧，晚上都不见你人。”
“什么？我没谈恋爱啊！”我下意识反驳。
“这还不是谈恋爱？那你天天晚上是出去坐台吗？”室友说。
我被一语惊醒。
这些天，每天上百条微信，晚上见面几个小时。我跟这枚程序猿，到底在做什么呢？
<<<
每晚坐在自行车后座上，我大声哼歌，双腿乱晃，觉得身披万丈霞光。但手始终在尴尬地僵持着，不曾挽过他的腰。
他每晚送我到公寓门口，然后掏出手机滴车回
静安寺
。等车的时间，我们沉默，闲聊，四目相对，隔一江春水。直到我目送他上车，挥手再见。
我在等。
坐在自行车上等他说“你可以抱住我”而不是“你又胖了”，说冷时等他来牵我的手而不是“我要送你一副我的同款手套”，夜晚分别时等他给我一个拥抱而不是总结发言“你今天线代学得真好”。
可是，等一个闷骚程序猿的告白，比掰直一个 Gay 还要难吧。
但是，我真的喜欢他吗？我不知道。
难道我只想做个玩家，在他这里打通关而已？我也不知道。
<<<
喜欢一个人，看他一眼，就能在脑海中和他过完一生。我也想过，如果跟他在一起，未来会是什么样子。
至少很快乐。
他用老张的口气说，“很多方面我们都很契合，什么都坦白说、明着说，从来不端着、不装腔作势。”
我好久没有遇到像他这么默契的伙伴了。他懂我的文章，懂我藏着的那点操蛋的理想，懂我在世俗世界埋下的一毫米奢望。
说白了，他是枚闷骚而有情怀的程序猿。
如果遇上的是五年后的他，我一定会彻底爱上他。
但现在，顺其自然吧。
<<<
而顺其自然的结果是，我越来越忙。考试，采访，写书，时间越来越少。他在微信上写给我的段子，我只能隔半天回一下“哈哈哈哈哈”，他问什么时候能再见面，我只能草草发个微笑的表情。
就这么淡了。
直到那天，我考完线代，昏昏沉沉从考场出来，看到他用锤子便签发给我的几千字留言。
文笔好美，美得让我忘记了言语中的悲伤和无奈，只想一读再读。
像他在那篇《程序猿老张》里写，“这次跟她一起相处的这段时间，就是我浏览她的代码的时间。我仔细阅读了每条代码和它们的注释，最后发现，她在我这里是跑不通的。”
最后他告诉我，只能离开。
――这枚程序猿啊，他什么都没说，却悄然在心中走过千山万壑。他不动声色地浏览代码，阅读注释，不动声色地交集百感，最后，只丢给我一个答案。
<<<
“我们还是朋友，对吧？”我小心翼翼地问他。
“当然。”他说，“但再也做不成亲密的朋友了。”
“那，如果我线代挂了，你还愿意教我吗？”
“当然。”
聊天记录就定格在这里。
直到成绩出来，我线代真的挂了。补考前一个晚上，把搞不懂的题目啪啪啪用微信传他。
半小时后，他传来一堆图给我。行列式、各种乱七八糟的符号用绘图软件画得一丝不苟。
“我用一晚上重新把同济教材看了一遍，不时涌出一种“卧槽我到底在干什么”的想法，但毕竟答应你了，就要做到。”他说。
“那，等我考过了，请你吃饭？”我有点感动，更有点想念他。
“我回北京了。”
……
他悄然离开了我的五角场，回到他的宇宙中心五道口，摇身一变，成了知乎上“对生活讲究，原则上只加姑娘”的准大 V。
<<<
我们好像没谈过恋爱，但他在我心里，撒下了最美的一场雪。
但遗憾的是，他并没有给我写过诗。
依然谢谢你，老张。哦不，刘飞。","本人不是程序员
直接上我前几天在ACM-ICPC
国际大学生程序设计竞赛
亚洲区域赛（长春站）做志愿者的时候看到的各高校参赛队伍的中文英文名单
诸如这种↑
我是先拿到这个名单（笑抽）以后再看到的各个参赛队员 基本都是云淡风轻 放荡不羁 若有所思 还有一部分目光呆滞…总之就是无法将他们和这些队伍名字联系在一起 这些人就应该算是国家未来的程序员预备队伍了吧～
还有 你们能想象我们学校计算机系头发已经花白的老教授在颁奖的时候说：“获奖的队伍是：今天萌萌哒 感觉自己吃了药队 红鲤鱼与
绿鲤鱼
与驴队” 等…你们感受一下
第一次看到这么多理工科男生 (??????????????)  真是涨姿势啊！！到底匿不匿 好怕被人打 算了还是不匿了吧…","没错我是来炫耀男神（之一）的。
生活单调？嗯……
他确实基本不用任何SNS类的东西导致和大家联系都不多，因为他没时间用。
不过这家伙为了找时间看书曾经用过达・芬奇睡眠法。（后来似乎因为导致内分泌失调所以放弃了，所以建议大家不要轻易尝试=,.=）
有一次他敲我Q，说和我聊天是他两个星期以来第一次和别人交流。
因为各种忙所以曾有半年没有剪过头发的记录。（“后来学会了自己理发，妈妈再也不用担心我因为酷似通缉犯而被警察叔叔抓去讯问啦~(*￣￣)y ” ←话说这是发生在男神身上的真事儿=,.=）
不过他平时一有空就会在家里鼓捣各种东西：比如他初中的时候就自己编了个计算器。后来还考虑过造小型炸弹（只是考虑而已……嗯）。还组装过耳机。好像还有密码锁之类的……这只是冰山一角，他造过的其他东西还有很多，其中还有说出来肯定会被查shui表的澹还有一堆我不知道的……
觉得现有的播放器不好用就自己编了个，用来听古典乐，音质完爆其他播放器。
特别喜欢猫咪，对流浪猫特别好，估计他要有时间的话会养一屋子吧…………
至于闷骚什么的嘛……
有次我送了他一个东西，收到的回礼是他自己以前挖到的一小块化石（后来才知道这个需要上报登记的啊擦）。热爱各种古生物的我打开袋子的时候简直要疯了好吗！
后来一段时间我压力挺大，他就发一堆我从来没看过的搞笑/搞怪图过来。有时候是用word，每张图片下都配有各种段子……我的腹肌锻炼有一半来自于它们。
有段时间我因为感情的问题特别难受，那时候他已经出国了。知道了之后他什么安慰的话都没说，只是给我发了他最近在听的古典乐的名字，说这是他平时觉得压抑难受的时候会听的东西，让我戴上耳机听，他也听，然后写他对正在放的音乐的理解和感想。超！级！治！愈！TAT 
然后是到现在还记得的事儿。某年七夕的时候，给了我一个网站：
HubbleSite - Picture Album
，打开以后我差点哭了。潜台词难道不是“我们一起看星星吧~”吗！简直不是一个写代码的男银的段位啊！额这么说很不对，但是我真的觉得好浪漫啊啊啊啊啊！！！！！！（这么想来我对NASA的情结大概就是从这儿开始的orz）
要是一个人本身对生活和世界充满了热爱（还有一颗GEEK心），那就算是所谓的闷骚，也绝对是种无与伦比的浪漫啊！
所以我觉得吧……环境什么的并不是生活状态的决定性因素啦。
虽然这大概是个特例吧_(:з」∠)_
最后，我爱
技术宅
！( ????? )y
-------------------------2014年3月24日更新造福妹子们的小分割线^_^)----------------------------
给几位问治愈的古典乐的妹纸：
因为时间太久远没有找到原来的曲单，对不起TAT
……于是我就跑去问他最近在听的能平静下来的音乐，他给了我两张专辑。
George Shearing - Favorite Things
刻骨铭心DSD
另，一边听一遍讲的其中一首似乎是
沃尔塔
瓦河，诗意与宏大的交响太美了TAT
------------------------2015年6月23日想起来更一更----------------------
男神现在有一美丽文静的女朋友，不出意外的话应该会在不知道久不久的将来顺利完婚~希望他们幸福=w=
【当然如果婚礼在国外的话，份子钱就没法到位了啊ww","在回答这个问题之前，很想问一嘴，我们程序员吃你家大米了？吃你家大米了？吃你家大米了？天天被调侃。大家不都是社会主义好青年么，看我们程序员好欺负撒？
什么事咱都不能以偏概全是吧，闷骚的程序员的确有，但是闷骚的设计师也有啊，闷骚的会计也有啊，闷骚的文案也有对吧。闷骚是一种性格，和职业无关。不过，身边不少程序员的闷骚事迹还真是挺逗乐的，整理一二，权当博大家一笑了。I()J
补充提问里提到的“
唤醒理论
”，属于心理学范畴，咱不懂，不过说到“闷骚”，大概意思是一个人的表现具有“两面性”，“闷”只是一种假态，看似面无表情两眼无神，实际上内心已经历了宇宙的蜕变，完成了和霍金的第三次握手，内心戏十足。
程序员A，80后，工作期间大概连续五六年没谈过对象，后来终于认识了一位喜欢的妹子，聊的很欢乐，打算让对方做他女朋友，鼓足勇气在微信上跟对方表白，妹子虽然也对他有好感，但是感觉在微信上确定关系非常不正式，于是主动约这位程序员小哥出去，结果见面后这位小哥怂的啥都不敢说，设想的n种表白方式都没用上，最终还是妹子先开的口。A说了，他喜欢被动，啧啧。
程序员B，花了好几天给心仪的妹子挑了一款礼物――一个钱包，说妹子快过生日了，打算送她做生日礼物，结果半年后再聊起这个话题，这钱包还没送出手，B说了，没找到合适的时机。那过生日的时候呢？生日人家跟闺蜜过了，没约出来；那其他时候呢？其他时候没有送礼物的理由……
程序员C，办公室“老司机”，是真的闷骚――表面“闷”，实则“骚”，平日里讲话不多，低调码代码。业余时间接了一个交友网站的维护工作，结果呢？通过“职务”之便，换了好几任女朋友，我们认识的那一位，都是上上任了。真的是闷骚的表面下有颗狂热的内心啊。
以上情形纯属事实，下面再来八一个亲眼所见的，如有雷同，可能是巧合。发文之前，我们已经象征性的征得了小赵的同意，并以“为公司发展做贡献”为由，对他进行了采访。
故事的名字是：程序员小赵因闷骚而“一厢情愿”的恋爱故事。
小赵的“失恋”让大家没想到，因为，据他说，在这段感情的“正常运行”期间，自己已经考虑到孩子大学要报考的专业。大家都知道他已经熟读了10几本恋爱及婚姻心法，所以相信他说得是实话。
1、相识是一场意外
公司里的同事，见证了小赵和妹子的初识，妹子代同事前来办点事，误打误撞地进了我们的办公间。当时我们刚完成一个项目，小赵一改电脑面前目光呆滞的神态，正端着一杯普洱眉飞色舞的科普普洱的鉴定方法。
妹子从小赵身后的门走入，清清爽爽的声音“请问xx是在这里办公吗？”击中了侃侃而谈的小赵骚动的内心，一个猛然地转身出卖了他慌乱的心情，小半杯普洱不偏不倚地击中了妹子的白色外套。
道歉期间，小赵发现妹子不仅声音好听，还漂亮、温柔、善解人意，正是他喜欢的类型，于是小赵假借“外套洗不干净就给赔新的”为由，死皮赖脸的跟人家要了电话号码，妹子走后，小赵脸上挂着喜中五百万的表情，哼着小曲儿的扎进自己的工位，对坐在自己身边的同事说：“哥们儿的春天要来了！”
2、感情说来就来
小赵真的进入了恋爱的角色。加了妹子微信，时不时关怀一下对方的工作生活；尽可能地推掉下班后所有活动，加班也是能溜就溜，为的是能和妹子约个饭；妹子前一秒发状态说自己饿了，他下一秒就在外卖给妹子点了个单；听说妹子会拉小提琴，午休的时候还能隐约听到他耳机里的小提琴声。
生活中，小赵一改“简约随意”的风格，脱掉那件从大学就一直陪伴他的shi黄色外套，换上沉稳内敛的黑、灰、白；脚上不再是那双泛黄的运动鞋，偶尔也穿穿皮鞋擦擦鞋油；头发再也不是刚炸完碉堡的样子，每天都整理的清清爽爽，还别说，经过这么一番意粒小赵俨然成了“别人家的程序员”。
同事调侃：小赵，没想到一杯普洱泼出个女朋友，你该买两斤普洱孝敬一下月老。
小赵并不说什么，略带笑意，一口接一口地抿着普洱。
3、谈了个假恋爱
同事眼中的小赵，最大的爱好就是挑战各种“姿势”的bug，别人放假游山玩水，他放假在电脑面前一坐就是三天；做的项目该简单的简单，该炫技的炫技；曾经身无分文挑战西藏穷旅，回来的时候像个非洲难民；一通电话能将同事离家出走的儿子“骂”回家；能将公司组织的滑雪旅游剪辑成《闪灵》。所以大家觉得如此有阅历、有情怀同时又有恋爱婚姻大法加身的小赵，应该很快便能够跟妹子牵手成功了吧。
过了没多久，也就两周后，小赵又换上了他那件征战沙场多年的shi黄色外套，整个人也安静下来，不再讲如何惩治熊孩子，不再安利好看的电影，要么眉头紧锁坐在电脑前敲代码，要么若有所思抿着普洱。小赵闷了，办公室的气氛也沉下来。难道小赵和妹子已经结束了？
按理说小赵的骨子里流淌着骚气的血液，对妹子又这么上心，怎么会以失败收场？好奇的我们认为他需要找出这场恋爱中的bug，于是小赵聊起这场恋爱行为，合着都是内心戏――
微信上的嘘寒问暖，一般以妹子礼貌的答谢而告终；因为弄脏衣服的事，小赵执意要请妹子吃个饭赔礼道歉，结果约饭只约出过这一次；给妹子叫外卖，小赵觉得对方应该可以想到是他，所以只字未提，幻想着妹子感动的表情，但事实是妹子不知道外卖是谁送的，所以都没敢吃；最重要的一个问题在于，小赵从来都没有对妹子表达过爱慕之词，他觉得对方完全可以聪明到猜出他的内心世界……
同事问：那么，“分手”是怎么回事？
小赵答：她发了朋友圈。她和她男朋友。
从妹子的角度来说，就是有人不小心弄脏了她的衣服，为了表达歉意，请她吃了顿饭，就酱。
写到这，又瞅了一眼这个问题，“程序员很闷骚么？”
嗯，有的程序员，的确是很闷骚的。
推荐阅读：
程序员怎么和心仪的妹子搭讪，求教？
程序员都有哪些强迫行为？","刚毕业那两年，有一天晚上，发现一个自己偷偷喜欢的女孩上了QQ，（真的只是偷偷喜欢，基本没有说过话）鼓起勇气和她寒暄了几句，然后友好的互道晚安。
第二天晚上，发现她又上线了，激动呀，想找她聊天，但又不知道说什么可以显得自然轻松，于是去改自己的QQ签名，“等你”，“想聊天吗”，“等你和我打招呼”，“waiting”，“waiting for”，“waiting for you”，三个小时过去了，那个女孩还在线，我一直都没敢和她说话，只是在这边没完没了的改签名，心里思绪万千，突然觉得“我在搞什么东西”，于是把签名改成“觉得自己莫名其妙”，然后去睡觉了。","发小在网络公司实习，办公室里一窝程序猿，就她一枚妹子。刚才她发来信息吐槽说，今天邻座小哥换了个
静电容键盘
，一上午大伙儿排着队看，还有隔壁办公室的慕名赶来，试试手感。这期间竟没有一人发现她新染的红色头发……","谢邀！
任何行业都有人活得很单调，任何行业也都有人活得很丰富多彩。与是否程序员无关。
看了 
@铃小珊
 的炫耀答案，补充一点：有时候人们觉得另一些人生活单调、闷骚，只是因为跟他们不活在一个世界里。
当我们仰望星空，一颗星星不过是一个
单调的
白点。然而，如果能靠近去了解，你会发现那实际是一个精彩的世界――那里也有一个肆虐着
火焰风暴
的太阳，或许还有略暗的伴星、凶残的黑洞，她们会有自己的行星，每颗也都有叹为观止的高山峻岭或是波涛汹涌的汪洋大海，也许那里还有同样复杂的外星生物圈……如果碰到三体系统，那就更会热闹非凡（此处省略《三体》系列小说近百万字）。
只因为我们不了解那个世界，在我们看来，那只是一个
单调的
白点……","2015.03.09  一年后突然陆续被人挖出来，感觉很惊讶，拖延癌晚期强打精神来填坑！写的不是很满意，不过只能再找时间了
====================================
程序员确实应该是闷骚的！！！
程序员能自黑，但是不能给别人黑！！！
@宋云笛
，我觉得应该多说一点才好。
闷骚，应该是指表面蛋定，但在某一特定场合或环境中会有出人意料的表现，亮瞎各位的眼。
首先作为一个程序员，蛋定是必须的，就算入行的时候没有，久了以后自然就有了。我认为有两点很重要的原因：
经历过无数意料之外，情理之中的BUG后，不得不蛋定；经历过无数需求的修正甚至是全盘推掉重来后不得不蛋定；经历过无数客户在程序员看来白痴一样的问题后，不得不蛋定(这个可能不是所有程序员都会直接和客户打交道，不过也可能有一些team leader勇敢滴承担了这个角色)。
程序员几乎每天都要有这样的经历，当需要对一处逻辑做条件分支处理时，都要尽可能的列出所有分支，对每一个分支都要进行处理，实在想不出了还得小心翼翼加上一个缺省的方案(评论里有提到
try catch
，感谢！ 
@为梦而拼
 ，主要我目前的工作只用到C语言，所以没用到这个了)。久而久之就会成为一种思维习惯，不论是工作还是生活中，碰到任何事情都会这样去考虑问题，这样无论某件事情多么的不可思议，都能够蛋定的去面对。 
所以，一个合格的程序员必需是蛋定的，也必定是蛋定。当然，蛋定不代表不会有兴奋，惊讶，伤心，悲愤等等情感，只是因为提前在脑海里预演过了，所以不会有很明显的情绪表现出来。
其次作为一个程序员，不说技能点全满吧，但总是不断地或被动或主动的学习新的技能。主要有以下几种get新技能的方式：
相信每个程序员都有被亲戚朋友提修电脑，下软件，下小电影，充
Q币
，盗QQ账号，游戏账号，等等奇葩要求吧，有些时候解释不出清楚或者懒得解释，结果就是get了大量小技能。比如本人就学习过如何免费买当年劲舞团里面的衣服，如何装扮Qzone(话说以前Qzone是可以自己写代码装扮的)
有一些程序员会做不同业务逻辑的项目，比如财务的，银行的，零售店铺的等等，这种情况就要求他必须彻底了解相关的业务逻辑后才能顺利完成工作。比如当你偶然和他聊起要出国玩办一张外币卡的时候，他能详细告诉你办哪一种外币卡，用什么账户结算，什么时候还款最划算，因为他做过银行的外卡收单项目。
一群程序员在一起吹牛的时候，真心不能瞎吹，因为只要你吹的不严谨，总有人能立即发现你的逻辑漏洞，并直接指出来，这也可能算是职业病吧，找BUG找习惯了。所以程序员需要掌握各种各样的信息，力求知其然并只是所以然，否则不足以应付同伴的十万个为什么。
程序员的闷是职业特点，因为他们在编码的时候，不能被外界干扰，当他文思泉涌的时候，就会完全沉浸在代码的世界里面，不再理会周围的世界。而程序员的骚仅仅是厚积薄发而已。
有人问我：你整天顶着这些代码，不枯燥吗?
我脱口而出：你看到的只是一屏代码，而我看到的却是一个世界！","不请自来，先自爆身份
本人出身信息工程系，历任前台美工，用户体验设计，产品逻辑设计，产品设计，产品包工头，所以我身边――都！是！程！序！员！（有的时候也这么称呼自己）
多说几个故事
小m
圈内公认的最像程序员的程序员。
到了什么程度呢？大二那年，我还是一个吭哧吭哧的美工。小m正在吭哧吭哧的积累代码。有一天这货突然兴致勃勃的卷着一张逻辑图给我，说要写一个程序送给他正在追的一个女生做生日礼物，求我帮忙做用户界面。
那是一个pc端的个人管理应用，功能包括定时开关机，任务提醒，记账，桌面管理等等等等。我看过之后非常兴奋，连夜画了一个自认为浪漫无比的主题。然后这件事就如大家所预料的那样没有了然后。问题是，当时我们所有知道这件事的人都觉得这件事非常的酷，而且现在有一部分人仍然这样认为。
后来，我终于开始质疑小m的情商，于是有了整个大学阶段最经典的一个赌局。我和大B（这货的故事后面会提到）赌他和小m谁能先找到女朋友，我赌的是相对奔放的大B，而大B却赌小m（注意，没人关心我能不能找到女朋友）。
最终我还是输了这一局。赌局设下不到一个学期，小m已经开始赫然跟班内一个学霸级的女生出入成双（了半个月）。大势已去之后，我、小m、大B单独聊过这个事，小m的解释是当时他和那女生都对一项技术比较感兴趣，而小m又是班级里这方面最强的，所以就会经常在一起讨论。半个月后，问题解决了。同为程序员，我们当然知道对程序员来说，半个月成双入对最多可能取得什么进展，于是纷纷八卦他们这半个月内有没有实质性进展（比如搭一下肩膀）。小m对此讳莫如深。只是说，总会尝试些其他的。
再后来，小m的本科生活似乎没什么变化，不停刷代码升级，和所有人一样钟情冷笑话、数码产品，游戏和，咳咳，片儿。
他读研究生的那几年没怎么见过面。但是从社交账号上的动态来看，小m开始广泛涉猎文艺类书籍。有一天他突然在qq上问我――说实话，你觉得我这个人怎么样？我如实回答。他又哀叹。山东这边的妹子个子太高了，我最近报了个健身房，准备健身。
忘了说了，小m江西人，在山东读的研究生。
再后来，小m到了企鹅厂工作，我们可以经常见面了。身材几乎没变，还是孑然一身。阅读的涉猎面变得更广，笑话更冷，热爱加班，关心政治。
在我们眼里，这个人非常有趣！
终于说到大B了。
大B是圈里公认的最闷骚的一个，而且我坚信即这跟他是个程序员无关。当时那个赌局我之所以押注在他身上是因为，这个人是我认识的程序员里最文艺的一个，绍兴人，自带闰土的文风。经常在个人主页里指点江山，回复者女生颇多。然而，这货硬是将初恋保留到了研究生。
研究生毕业后，大B自称写代码写出了阴影，毅然放弃了开发的路径，转去做了策划，但还是摆脱不了程序员的身份。
前不久跟大B公婆俩吃饭。聊到大B本科时候的绯闻。当时传说大B喜欢上隔壁班一个长相温婉（说计算机系没有长相温婉的女生的滚出去！）的女生。没想到这事竟然是真的。然而，程序员的用词堪比作家之精准。我们全程只说喜欢，都没用到过追这样的字眼。
当着媳妇的面，大B供述如下：只是当时一起上课，看起来，这个女孩和其他人不太一样，多了一分好奇，却总也没机会深入了解。后来忙起来了，这事就过去了。
大B的媳妇是难得一见的贤妻良母，目前大B在广州做游戏策划，告别了一线开发，收入不太乐观。大B媳妇毫无怨言，两个人合租一个城中村的套件。生活简单却充满方向。
说到底，大B媳妇看中的是希望。在大B身上能清晰的看得出聪明，上进，有责任心，乐观这些性格。都说这是做程序员留下的底子好。一日计算机，终生程序员，小毛如是说。
X爷
每次大B被人说闷骚的时候必拿X爷来挡枪。说来此两人甚像，仅有的一点区别，大B缺了X爷的一点性情，X爷少了点大B的文艺。以前在知乎上看到有人解释性情――性情就是一个巨牛有上天屠龙，在地打虎的绝技，却偏不把这当回事，就会给这个美好的世界卖萌，敢对着石头说我爱你。当时读完第一个想到的就是X爷。
大四那年，系里盛传X爷暗恋隔壁班一女生（注意我的用词），最终毕业酒会上，X爷借着酒劲拨通了那个电话。说明来意之后， 畅谈革命友谊，然后送去了美好的祝福。
X爷研一那会儿，大B已经有了家室。我去X爷寝室溜达，正看见X爷对着电脑发愣。被我叫回神来就拉着我问：大飞，你帮我分析分析这个女生咋想的，然后点开了XX佳缘的网站。。。说实话，我也单身那么久了，这网站一次都没去过。
去年X爷开始找工作，来深圳找了一圈被召去北京去了号称是国内的脸书的那家网站。临走前，一班兄弟送行兼挽留。X爷毫不动摇，承诺会定期回来看我们。送走了X爷，我们自己分析，其实骚爷的选择是对的。
老P
老P和小m、大B、X爷不是一伙的。是个半路出家的程序员。所以身上总有些不属于程序员的特质。比如老P相对注重打扮，长得高高瘦瘦，热爱运动。
老P是我小学同学，过年的时候一起回家，在高铁上聊起他在微信上认识一个南京的女孩，前不久已经来深圳玩了一趟了差点把我眼珠子惊掉了。按我的逻辑，网恋这种事绝对不是程序员能干得出来的，虽然我也没有可靠的证据。
回家的路上，高铁里信号时断时续，老P还是坚持着全程跟他的女友聊着qq。看得出来那女孩很黏他。大概是我单身的太久了，这种情况下，总是想不出来应该聊啥。偏偏老P还不给我看，一个扯淡就把我打发了。一个人百无聊赖想起来身边有个同事跟我抱怨过女友太黏人，每天聊微信耽误他打游戏。其实这样的事，据我所知在程序员身上很少发生。
又过了一会儿，信号彻底断了。老P翻出电脑，跟我聊技术，随手建了个文本框敲了几下丢到浏览器里指给我看――你看我写了个框，好看吧？
说了这么多，那程序员到底闷骚么？
其实只是他们不太愿意像其他人那样与世界沟通。有句话说做技术的做到最后拼的都是情怀。每个坚持下来的程序员其实靠的都是成就感。创造和毁灭一个东西得巨大成就感。因此我们通常比其他行业的人更热爱自己的事业更热爱自己的产品。这也就很正常的赋予了程序员专注、坚韧、谨慎、有责任心的性格。
但是他们也温柔，也善良，也爱这个世界。很可能是用充满逻辑的一种方式。这种方式有一个更为大家所熟知的名字――闷骚。
你看，我定义了自己的情怀，好看吧？","怎么又来这种问题，程序员是喜欢自黑，但其他行业的人也来这么黑就变了味。
“我母校超烂的，好多硬件多少年了也不更新”
“对，你母校确实很烂”",是的。我是程序员，我闷骚。我是女的，明骚人家会说放荡。,"  我认为：
不闷骚
。
  题目：我眼中的程序员
  背景：我的哥哥是一只程序猴 。  
  小时候哥哥见我对学习还有点儿兴趣，就跟我说，要多出去浪…嗯，是多出去走走，看看更广大的世界嘛～于是发生了以下事情。 
  NO.1初中时，我第一次践行哥哥说要出去浪浪的…走走的言论。
  去哥哥所在的大学找他玩，然后见到了他的女盆友，发现他女朋友跟他一年前左右给家里人看的照片不是同一个了。我就深深的觉得大学果然是一片美丽的土地，连哥哥这一般的很的水平都有不一样的生活了呢。
 小结：一个长相一般的男生，无身高、家境等优势，计算机系（好像是这个系名）竟然在大学期间有两个以上女盆友（我当年知道的就两个）！你觉得他闷骚！？！？
  NO.2依稀记得，那年我在念高中，哥哥在读研。
  他在重庆，他女盆友（不知道还是不是我见过那个，哈哈～(?_?)）在长沙。突然有一天，哥哥从长沙回来了！然后，我就知道哥哥不知道什么时候跑到长沙陪女盆友一个礼拜，然后在身上貌似就两千块左右的情况下，给女盆友买了个一千左右的包！瞬间我被惊吓到了！哥哥竟然带包千里赴长沙会女票！我们家的穷逼孩子竟然如此奢侈？！当然，哥哥并没有装富二代，他的朋友同学也知道他的家境一般。所以，他就是为博女票一笑，要浪漫并且大出血！
  小结：这么奔放，哪里闷骚？
  NO.3艺考时，以看重大为名，我溜到重庆去了。
  又依稀记得，哥哥领我胡吃海喝之后的一个晚上，跟我聊起了泡妞一事。当时内心小激动啊～哥哥要交我人生必备技能呢～^_?☆（虽然，我不明白为何妹妹会觉得那个是必备技能…）
  哥哥说：“追女孩，其实就是耍无赖！”
  我：“噢～～哈！?(?_?;?不对啊”
  哥哥：“不对什么，你看，哪个能追到妹子的不是耍无赖？妹子冷淡，依旧P话多；妹子出远门，千里追着走；妹子不舒服，温暖使劲儿砸。”
  我：“那人家有些人追妹子，很多年的，真爱啊～”
  哥哥：“那叫持续耍无赖！”
  小结：跟自己年未满十八的妹妹说这些，闷骚吗？不闷骚。
  NO.4又又依稀记得，我刚上大学。
  在大一的某个晚上，哥哥电话打来说：“大学不要着急谈恋爱，大一先看看，熟悉熟悉环境。大二呢，就有空了可以好好谈个。大学呢谈个恋爱还是可以的，不过，不谈也很好不着急。不要跟太远的同学谈，谈远了家里人担心。”
  我：“放心吧…我们学校男生质量不好，才不要谈恋爱！”
  哥哥：“哦～那你们班没同学追你？”
  我：“不知道唉…就是一个男生要我做他媳妇儿，河北的。好奇怪～又不熟！”
  哥哥：“那种你忽略就好了，同学可能说错话了。平时要注意安全，对新同学要懂礼貌啊～”
  我：“放心，我一直都很懂礼貌的，又不是小孩子了。”
  小结：不结了。
………………………………………………抓机能源不足……………………………………………………………
  NO.5渐渐的……我大二了。哥哥知道了，经检验合格后，学校可以辅修双学位。
  于是乎~哥哥问我：“学校双学位有想学的么？”
  我：“有！想学生科，回去种树~”
  哥哥：“那就去学啊~喜欢就好好学，不过学双学位很忙的。学校有人追你么？”
  我：“有，一个学长，一个学弟。”
  哥哥：“修双学位很忙的，不能好好的陪男朋友，谈恋爱时间不足。还不如把时间放在考证啊~辅修学位上面，男盆友的话，以后等你大三了哥哥给你看看我们研一的学弟。”
  我：“恩！好的。”
  正所谓，人是会长大的。然后我长成了一只大三单身狗！今年过年回家哥哥领了嫂嫂回来，然后问我谈恋爱了没有。我内心是不想回答的，因为明明是你跟我说不要谈恋爱，把你自己的妹妹坑成了大三单身狗，你竟然还好意思问我有木有拍拖！！！！！生生坑成了大三老阿姨啊~。学弟都觉得我是“刀山”啊！要求死高啊！一定很难追啊~居然大三都没有男盆友。~~~~(>_<)~~~~ 
  但是，我是一个淡定的人。于是我冷静回答：“没有。我是会谈恋爱的人么？”
  然后，那只程序猴子用起了老战术，：“恩，没关系你还小，等工作了，哥哥给你相看下同事。大学谈恋爱不小心就谈到外省的，不好。”
  哈哈~你当我还会被坑么？才不会！我已经成长了好不好~进化了！据说在大四以前跟室友来一场轰轰烈烈的恋爱会很有纪念意义呢~嘿嘿嘿………………
  大结：看~这么会坑妹妹，会泡妞的程序猴子，怎么可能是闷骚？简直就是 明 ！骚！ 好！ 不！ 好！
――――――――――――――――――――――――――――――――――――――――――――――――――――――――以上是不正经篇――――――――――――――――――――――――――――有心情再来添加正经篇――――――――――――――――――――――――――――――","程序员闷骚怎么了！
就喜欢闷骚怎么了！
网上聊的好High 现实中脸红害羞不敢说话 多可爱！","程序员都很内秀，只是有时候要长时间面对电脑，显得不爱讲话。
他们一般都有自己很深层次的爱好，他们是博学的。
因为爱在网上看段子，所以，随便丢来一句话，就会让你笑得肚子疼。
因为精神的高度专注，有时候给人一种反应慢半拍的感觉，那只是他们对你不在意，不感兴趣的表现。
人都是有惯性的，程序员都喜欢坐着，因为他们习惯了这个姿势。但是，他们的思想是奔跑的。有时候还像风筝飞来飞去。你根本抓不住。
每一个程序员都像一个冰山，你以为他很渺小，但你不知道他藏起来多少优点。
当你遇到一个程序员请善待他，挖掘他，你会发现他像一个万花筒一点都不会闷。
程序员，微笑，萌萌哒~",你没发现闷骚的都在看而不答吗。,闷骚还是看个人本身性格吧，感觉还是有很多活跃的，另外，不要以为程序员都很靠谱，劈腿的还是一大把一大把的,"实力反对这个回答，我们公司程序员可不是这样，程序员吃你家大米啦，还说程序员闷骚！！
老王跟老张都是2个资深程序员，一个是Java高级
信息系统项目管理师
，一个是14年行业经验前IBM工程师。
老王说自己唯一开心的时候就是编代码的时候，就算天天加班心里也是一百个乐意
五一放假的时候因为被媳妇拒绝带回家，干脆就在家写代码，最后写了一个程序员老黄历出来
还可以在线测凶吉，写代码起手式必备。
不仅每次写代码之前算一次，晚上加班回家前也会算一卦
往往算出来的结果与实际都不太符合，代码写好了回家也会挨媳妇骂
骂他只有代码没有媳妇，回家这么晚袜子总是她来洗
心疼媳妇，老王就在淘宝买了个护手霜
选了半天选了个最近流行的“马油”，结果到手之后才知道是去脚气霜
为了不浪费，老王天天在办公室抹，还美曰其名熏蚊子
老王不是第一次给媳妇挖坑了，拍了张媳妇大饼脸的照片给公司所有人一一传看
媳妇晚上恰巧来送饭，看着周围同事忍俊不禁的样子才知道老王干了这样的好事
不过老王媳妇也习惯了，老王总给她挖坑跳
老王公司那群运营部的小妹子对老王和媳妇的故事简直数如家珍，都能娓娓道来
老王媳妇就是担心老王见父母的事情，父母总不同意老王，怪老王只是个程序员
老王也总催媳妇赶紧出阁，总能正儿八经的继续坑不是？
为了见媳妇父母，老王大清早就起床去购买礼品
选来选去就选了个VR眼镜，想着这样丈母娘跟老丈人以后跟媳妇视频能看的更清楚
老王媳妇看见了笑中带泪，心里却铁定了非这个人不嫁
老王不知道媳妇的心情，给媳妇擦泪还说这有什么好感动的，我一早就知道自己是个好男人
其实老王真是个好男人，追媳妇的时候天天车停在公司楼下
在车里一边敲代码完成工作一边张望着媳妇出现没有
只要出现就立马收起笔记本，装做认真思考的样子，不知道从哪看到的女人最喜欢认真的男人
老王第一次给媳妇送礼物的时候，买了6双鞋子，长靴、短靴、凉鞋、高跟、雪地靴就连拖鞋都没忘了买
想着媳妇一年四季都穿着他买的鞋，哪还有男人敢继续追她
其实老王可疼媳妇了，每天加班是为了赶紧买房把媳妇娶回家
给媳妇买很多裙子是怕媳妇在闺蜜面前少了对比的资本
也许我对你的好并非最好，但你再也找不到如我一般待你如初的人
老张是个严谨的人，非常看重数据的重要性
多年的工作经验，老张依然不会一点办公室政治
笑呵笑呵的跟下属开玩笑，从来没有一点老板的架子
漫威英雄如数家珍，听说运营部的小v要去追妇联首映，老张还千叮万嘱不要剧透，千万不要剧透
边说边继续开始敲代码，割舍了最爱的电影只因为答应了周六要陪着女儿去看
老张有天早会迟到了，自己道歉说因为早上教女儿做题没做出来
老张对女儿的疼爱不言而喻，通常媳妇打电话催他加班早点回家没用，只有女儿一声嗲嗲的“爸爸”才让老张匆匆忙忙收捡电脑
昨天，谢耳朵大婚，老张表现的比当事人还要兴奋
还拿着一张谢耳朵诅咒的表情包在公司群里面发
图片配文，你再也找不到如我一样聪明又有趣的男人了
我是小v
最爱写文章的运营部大妹子
微公号：vNext编程  有很多针对于Java系统学习的福利资料，有需要的关注哦~","泻药。
已经被楼上一堆秀恩爱的闪瞎了氪金狗眼。为何我的手中突然出现了火把和汽油桶。
让我来讲述一下我对某产品男A君的产品试用测评。
--------------------------------------------------------
一、产品介绍
第一次和产品男A君接触是在豆瓣勾搭上的。那个时候他刚从北京奔袭到上海跟着七八个小伙伴创业，每天夜晚对着日本籍大姐姐们唏嘘短叹人生苦短寂寞难耐，就上了豆瓣恋爱组蒸女友，还在帖子里放了类似于监狱资料档案式的照片，还觉着自己特别英俊潇洒。对，
剃着圆寸，穿着监狱条纹装，举着姓名牌子（工牌），一脸悔不当初的表情
赶脚的照片。由于行业和职业的原因，平时小生跟码农、产品之类的IT男纸都有不少的接触（可惜十有八九都已婚，令人扼腕），当时我也是空窗期实在有点时间了，一看是干产品的，就知道虽然自我介绍是挫了点儿，但是聊一聊一定会有惊喜。否则怎么既抚慰码农身心又摆平老板啊~于是就主动豆油惹~【没错，小生就是这样主动的姑娘】【算法证明主动的姑娘容易找到好对象】
聊了几次，交换了微信，给了照片互相觉得对方还可以，就果断地约饭了。
二、拆包体验
一开始约喝下午茶。我定的逼格贼高的餐厅，定的时间，付了预订款，而且准时到了。不幸的是，预定的淘宝卖家坑了我。当时我的内心被暴漫脸踩出了一片泥泞。但是没关系，身为坚挺地见识过技术产品UI群雄4B大场面的高贵冷艳城墙脸少女，我还是果断地先入座。结果半小时之后，A君终于姗姗来迟。【跟妹子约居然敢迟到，扣分扣分】
果然是不上相，果然还是圆寸。我内心对自己淡淡说道。
没错，A君长得比照片上要好看一点儿，戴着一副黑框眼镜，穿着大衣，收拾得居然还挺小资。不过老娘早就料到了，公司几乎所有产品IT都这副鸟样儿，
上班一个个灰头土脸，到处洋溢着格子衫的芬芳，下了班就把自己收拾得跟情场浪子一样。
【既然这样，为何婚后看上去还会更歪瓜裂枣呢？这得问他们太太。】
A君非常抱歉自己迟到的行为，并说明了理由。【然而这并没有什么卵用，迟到是既成事实，借口分分钟可以想出一堆。】
之后开始面试一般的自我介绍过程= =凸
不过没关系，小生一直都是炒气氛小能手，于是试图把话题从僵硬的职业介绍切换到兴趣爱好交流上。结果说到旅游。A君眼睛开始放光了：“我的足迹南到厦门，东到朝鲜，你若有时间可以看一下我的朝鲜游记，还被列为了blabla网站的精品游记...”滔滔不绝。至此，小生不由得长吁一口气~【虽然此时心中在吐槽还没老娘一半的里程呢…】
为了显示我是一个既有逼格又接地气的好女孩，我们决定晚餐去吃火~锅~~~~~
之后就是我油腻的脸衬着他满是雾气的眼镜。
由于初见实在是有点失败，因此吃完海底捞小生就挥一挥衣袖决定回家碎觉。睡前瞄了一眼手机，看到无微信提示，就把此次见面抛诸了脑后。
三、第一次实际测评
若干个月后【没错你没眼瘸】，我居、然、收、到、了、他、的、微、信。
起因是他未成年之前暗恋了很久的青梅竹马小学女同学要结婚了，邀请他参加婚礼。他若独身前往倍感凄凉。
于是想打肿脸充胖子找个女伴一同前往
，地点是在烟台。
重点是：包吃住。要求是：请务必打扮得光彩照人、艳压群芳。
当时，我丝毫不知道这货又滚回了帝都。还天真地以为是都从我大魔都出发呢。
出于信息不对称和人道主义精神，小生毅然决然地决定援助
亚非拉
人民“幸福奔小康“。
当然其实真正让我决定如此跋涉的原因是：老娘一个月没出门溜达两圈，又闲得慌了。
因为此事的牵绊我们又重新联系上啦~
为了不穿帮，在穿着上、言行举止上等一系列细枝末节上呈现出友达以上恋爱未满阶段的感受（这种诡异的要求是他提出来的），我们对了很久的口供。期间对他的认知就如同安装了安卓系统的三观一样又重新刷新了一遍。
哦~原来这个产品是个段子手，是靠搞笑来抚平改需求码农的悲愤的。
哦~原来收拾完是这样的~还蛮帅的~
哦~真看不出来，居然还是“学霸”。
由于小生一直秉持着”看上他就强奸他，反正不犯强奸罪“这样毫无节操可言的行事准则的，于是到烟台的时候小生就果断地推到了他。
体验感是：
艾玛，居然还可以啊~真看不出是常年禁欲的理工男。
之后就陆陆续续保持了一段时间的联系。
四、第二次测评
后来趁着端午驾校师傅还没对我下练车圣旨的时候，我去了趟北京，旅游。联系了A君来接待我。
不得不说，
A君
大多数的时候还是非常温柔且绅士的。
柔声细气一路拎包。走人行道的时候还会注意女士走在里面，过马路也会紧紧拉住我的手。最后玩水上乐园的时候我忘记提醒LOW爆从没去过水上乐园的他需要带隐形眼镜，结果
墨菲定理
出现了：他那小资的、被上海眼镜店宰得不要不要的精贵眼镜的眼镜腿儿断了。居然也没生气。不过，还是拜托了我修眼镜。
唯一不绅士的一点是：居然
难以接受部门里的女同事在他面前敷面膜。
五、总结
在接触这位理工男的时候，我发现了几个真相：
1、逼格高都是装出来哈哈哈哈哈哈，见我的时候的小资行头是他为数几套不多能见人的冬装。平时就洗的发白的T恤，运动鞋，牛仔裤。衣橱里果然还是格子衬衫和条纹衬衫的天下。
2、误交损友对人生是多么具有破坏性的事情：A君把他身边朋友几乎所有大大小小挫事儿都跟我吐槽一遍。挫事儿传千里~
3、即使是一只单身业内行家狗，回家面见江东父老尤其是参加小时候暗恋对象的婚礼的时候还是会使劲找个好看的姑娘打肿脸充胖子。
4、总的来说，闷骚和温柔并济吧
-------------------------------------------
然而以上一切都并没有什么卵用。
深爱就是把最好的青春留给你，然后我独自向前。
他心中既有了能为之写诗的姑娘，那我也只有收拾行囊继续我走遍世界的旅途。
他爱的是
小龙女
，而我是赵敏。","HHHHHHHHHHHHHHHHH今天我我是专门找这个问题来回答的，在我们学校动漫社里面一个后辈群名称后缀是一串十六进制Unicode码，一开始我并没有在意，直到今天在学习python的时候忽然想到了他名字后面那一串，然后我鬼使神差的把他名字后面那串复制了下来丢到了
py
里面
然后得到了这么一串
被我打了马赛克的是我们社团一妹子的名字
学习真是能给人带来快乐的事情啊
然后我当机立断，马上改了我的群名字
被我打码的依然是社团里那个妹子的名字233333333333
所以说，你说程序员闷骚么？当然闷骚啦！"
,,,,,,,,,,,,,,,,,,,,,
有哪些算法惊艳到了你？,有哪些算法当你刚接触的时候，心里有“居然还可以这样算..”的想法？,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,
如何用我奶奶也能听懂的话来讲什么是 debug？,None,"你奶奶蒸的馒头又大又软，你蒸出来的又小又硬，咬一口还粘牙。（
问题出现
）
你试了几次都是这样，（
复现问题，是必现
）
拿着你奶奶给的配方看了几遍也没看出来什么问题。（
读代码
）
于是你把你妈喊了过来，让她看看原因。你妈也是蒸馒头的老手了，瞅了一眼案板上堆完面团的痕迹（
看日志
）说，你是不是发完面后揉成一个一个小面团后就直接放锅里蒸了？
你一拍脑袋，是这样的！于是你又试了一遍，揉完面后放了十五分钟再上锅。（
尝试修复问题
）情况虽有好转，没那么粘牙了，但馒头还是缩成一坨。这下你妈也不知道怎么办了，只能求助你奶。
你给你奶打电话，她说蒸馒头重要的就是和面、发面、揉面、醒面、出锅这几步，你每到关键的步骤都给我打视频，我来看看（
打断点
）
你开始重新和面，你奶在视频里看着。（
开始debug
）
一直到上锅你奶都没有发现问题，她也纳闷了，她就住隔壁单元，于是一溜烟跑到你家，说：我来操作。（
单步调试
）
馒头上汽后蒸了十六七分钟，你奶把火一关。这时你急着要开盖子看有没有蒸好，手刚伸过去就被你奶打了一下：要焖个五六分钟再开盖，你现在一开盖馒头不都缩了？（
发现bug
）
你恍然大悟：原来如此，后面就交给我吧！（
放通程序，结束debug
）
果然，这次的馒头蒸得又大又软。你想了想你妈和你奶教你的，记在了配方边上，以后就不会再犯同样的错误了。（
改代码，走单
）","不是，很多答主都忽视了一个问题，我奶奶  就不能是
苏姿丰
？
还有，你怎么敢假定题主奶奶性别？他奶奶就不能是
黄仁勋
？","早上，奶奶在狗子胸前的篮子里放了一点钱，让狗子去买油条。结果狗子出去了又回来了，没有买到油条。至于为什么，狗子不会说话。。
于是奶奶就开始debug。。首先跟着狗子去买油条。结果狗子走到一半迷路了。于是带着狗子重走一遍路。。解决路由问题。。
第二天早上，奶奶在狗子胸前的篮子里放了一点钱，再次让狗子去买油条。结果狗子出去了又回来了，没有买到油条。至于为什么，狗子不会说话。。
于是奶奶就开始debug。。首先跟着狗子去买油条。结果狗子走到早点摊。发现油条买光了。。于是奶奶加了一个错误处理。在狗子胸前的篮子里放了一张纸条。写上如果没有油条，就买大饼。。
第三天早上，奶奶在狗子胸前的篮子里放了一点钱，再次让狗子去买油条。结果狗子出去了又回来了，没有买到油条。至于为什么，狗子不会说话。。
于是奶奶就开始debug。。首先跟着狗子去买油条。结果狗子走到早点摊。发现钱不够了。。于是奶奶加了一个错误处理。在狗子胸前的篮子里加了一个检查条件。检查钱数。。
第四天早上，奶奶在狗子胸前的篮子里放了一点钱，再次让狗子去买油条。结果狗子出去了又回来了，没有买到油条。至于为什么，狗子不会说话。。
于是奶奶就开始debug。。首先跟着狗子去买油条。结果狗子走到早点摊。发现油条涨价了。。于是奶奶增加了金额分配空间。在狗子胸前的篮子里加了钱。。
第五天早上，奶奶在狗子胸前的篮子里放了一点钱，再次让狗子去买油条。结果狗子出去了又回来了，买到油条啦。。。。
调试结束。。。","这个主要得看令祖母高寿几何，一生所治之学分属何业。
图片来源见水印
如果老人虽年逾古稀，但1973年之前就由自动控制或无线电等专业毕业后被分配去了
江苏无线电厂
，那么，很可能她不需要别人来解释，甚至她还能给别的后辈讲讲DEBUG。
他研制了中国第一台微型计算机
?
www.xxjjjcw.gov.cn/sitesources/xxjjjcw/page_pc/xcjy/qlfc/article22487205585b4da6b4ee57a22722a8fb.html
“……喻嗣南说，当年，编码全部要依靠手写，写后再用纸带输入，而在当时，国家发展需要大量的数据计算，她为这台微机设计了计算功能，还附带唱歌、打字等功能。“我设计《东方红》乐曲的编码，用了将近两周的时间……”
备注：
…………
1956年，
夏培肃
完成了第一台电子计算机运算器和控制器的设计工作，同时编写了中国第一本电子计算机原理讲义。
1957年，哈尔滨工业大学研制成功中国第一台模拟式电子计算机。
1958年，中国第一台计算机--103型通用数字电子计算机研制成功，运行速度每秒1500次。
1959年，中国研制成功104型电子计算机，运算速度每秒1万次。
1960年，中国第一台大型通用电子计算机--107型通用电子数字计算机研制成功。
1963年，中国第一台大型晶体管电子计算机--109机研制成功。
1964年，441B全晶体管计算机研制成功。
1965年，中国第一台百万次集成电路计算机""DJS－Ⅱ""型操作系统编制完成。
1967年，新型晶体管大型通用数字计算机诞生。
1969年，北京大学承接研制百万次集成电路数字电子计算机 --150机。
1970年，中国第一台具有多道程序
分时操作系统
和标准汇编语言的计算机--441B－Ⅲ型全晶体管计算机研制成功。
1972年，每秒运算11万次的大型集成电路通用数字电子计算机研制成功。
1973年，中国第一台百万次集成电路电子计算机研制成功。
1974年，DJS－130、131、132、135、140、152、153等13个机型先后研制成功。
1976年，DJS－183、184、185、186、1804机研制成功。
1977年，中国第一台微型计算机DJS－050机研制成功。
1979年，中国研制成功每秒运算500万次的集成电路计算机--HDS－9，
王选
用中国第一台激光照排机排出样书。
1981年，中国研制成功的260机平均运算速度达到每秒100万次。
1983年，""银河Ⅰ号""巨型计算机研制成功，运算速度达每秒1亿次。
1984年，联想集团的前身--新技术发展公司成立，中国出现第一次微机热。
1985年，华光Ⅱ型
汉字激光照排系统
投入生产性使用。
1986年，中华学习机投入生产。
1987年，第一台国产的286微机--长城286正式推出。
1988年，第一台国产386微机--长城386推出，中国发现首例计算机病毒。
…………",翻出祖传大米缸，用祖传米碗舀出一碗长了虫的大米，恭恭敬敬端给奶奶，说：“奶奶，今天下午我做饭，你帮我debug一下”,"“奶奶，为啥您当时找我爷爷不找门口村长家儿子。”
“村长家儿子丑”
“对喽，这就是debug”
“奶奶，为啥我二婶不招人待见？”
“她抠门”
“对喽，这也是debug”
“奶奶，今天的包子没昨天的好吃为啥？”
“没放鸡精”
“对喽，这还是debug”","奶奶们不关心那么detail的事情，你就说是“大城市，好工作，工资高，有前途”，就完事了。
“呵呵，我的大孙子真有本事！”","去田坎坎拔草秧秧。
注音：kei tián kàn kaner fá cào yāng yanger
含义：去田地里拔杂草。
注：假定你奶奶是四川人。","问ai就行了
gpt3.5：
gpt4.0：","大家不要看不起这位奶奶！小心到时候回旋镖扎到自己身上！
万一这位奶奶Github
热力图
全是深绿呢？谁知道cf rating的全站前100有没有这位奶奶的身影？
就算以上达不到，万一题主奶奶是一位AFOer/AFACMer呢？那不是班门弄斧吗",贪官就是bug，debug就是把他们揪出来开除党籍该坐牢坐牢该枪毙枪毙。,您孙子写文章给电脑看，不知道哪个句子写错了，电脑看不懂罢工了。得把几本书厚的文章重新找过来一句句查――对，错一个标点符号也不行，这周不回来吃饭了。,"那你得先把你奶奶的简历和Github主页贴一下看看情况，
不然我们怎么知道怎么说她听不听得懂","奶奶哪管听不听得懂debug啊
奶奶只是想多看你、多听你说两句话罢了","奶奶你看，这米生了米虫，就要想办法把米虫搞出来。
我这玩意儿也是，搞不好就有些小毛病，我们也叫它虫，要把它找出来。","打毛线漏针了，要补上。
也不是不能穿，但是有时候会漏风，也容易扯烂。
所以就拿来对着太阳看哪里透光明显，仔细看那里的针脚，找到漏的地方，但不能拆线，把毛线穿进去合拢。
这件织物就是被缔补过了。","bug就是虫子，电脑里也有虫子，所以电脑会工作不正常。
debug就是把虫子都捏出来，电脑就可以正常工作了。","程序员的比喻
就像老太太的裹脚布――又臭又长，还讲不明白
debug就是“挑毛病”，工作没干好，找找原因，解决一下，这就叫debug
直说很难吗？？？？？？
苦程序员已久
当年学java，问学长，什么叫父类子类，
学长：父类就是我有一条内裤，你是子类，你就也有一条内裤，你有一双袜子，但我没有一双袜子，懂了吗
我：懂了（内心：懂个p）
回去翻书
课本：子类会继承父类的全部特性（记不清了），同时可以拥有自己的其他特性，这些特性父类并不会拥有。
我是学数学的，计算机比不了你们，但是我知道“特例不代表全部”，你们有举例子的精力，直接给一个全集的定义多好，然后再举例子才有用啊",在她包饺子的时候，赶跑来捣乱的曾孙子。,自行车补胎，先要找到哪里漏气，弄盆水，把轮胎充上气放水里，漏气的地方在水里会冒气泡， 然后在这个位置贴一片补丁，这个过程就是debug。
,,,,,,,,,,,,,,,,,,,,,
雷军写代码水平如何？,"在网上看到这份雷军20年前写的汇编代码：
http://
mailp.in/rXX7XrVR/
 请懂的人评价评价。","1988年，雷军在武汉大学就读大一期间编写的Pascal程序，在他大二时就被编进了新生教材。
1989年，大二下学期的时候，雷军写了一个RI（RAMinit，清内存的小工具），持续十多年都有人在用。后来雷军把这款工具软件完全免费，并且开放了源代码，也算国内最早一批开源的免费软件。
同年，雷军和
王全国
合作，开始编写加密软件
BITLOK
。这款软件在后续几年里进行了多次升级，用户包括当时知名的软件公司用友、超想、金山等等。据雷军自己估计，用BITLOK加密后的软件，在超过一百万台计算机上使用过，雷军也凭借这个软件赚到自己的第一桶金。
1990年，雷军和
冯志宏
（中国知名共享软件作者，有“中国工具软件开发之父”之称）合作开发出了免疫90杀毒软件，是最早的国产杀毒软件之一。雷军凭借着“
免疫90
”的自创杀毒软件在武汉大学获得科技成果一等奖，并曾被湖北省公安厅专门请去讲课、传授反病毒技术。
1990年前后，雷军花大概两周时间破译了当时流行的中文字处理软件WPS1.0，又在原来的基础上做了一些增强和完善，不久之后，由他解密的WPS版本成了国内最流行的WPS版本。
1992年初雷军进入金山软件的珠海研发部实习，7月正式加入金山软件，8月15日，由雷军牵头的金山北京开发部成立，主要负责
WPS汉卡
的技术支持，并参与筹划做金山未来3年到5年的产品。同年，雷军和金山老板
求伯君
（中国软件行业远古大神，独自开发了WPS最初版）一起编写的书籍
《深入DOS编程》
正式出版。
1993年5月，雷军参与研发的金山Ⅵ型汉卡，及WPS-NT，广泛应用于行业，极大地提高了办公效率和工作质量，市场占有率高达90％以上。
1993-1995年，雷军参与金山“盘古计划”（WPS Office前身），负责双诚电子表（对标excel）开发。
1995年，雷军利用休假时间（大概2-3个月）全部重写了BITLOK 3.0（改版前有约3万行代码），在原有经验的基础上，使用了一些突破的技术，彻底解决了过去用户提出的各种问题。
1995-1997年，雷军带领团队完成WPS97开发，这款软件最终完成了3万套正版销售。
1997年后，雷军开始更全面地转型到企业管理领域。
1998年，28岁的雷军出任金山总经理。当时雷军白天当总经理，晚上还继续写程序，提高技术水平。紧接着就发生了那个，“金山新同事将雷军电脑格式化”的事故，雷军不得不将所有精力放在管理上。
2000年，雷军编写的《
深入Windows编程
》一书正式出版。
2002年，在雷军的领导下，100多位工程师历时3年，舍弃了积累十余年的程序架构，将500多万行代码全部推倒重写，为了降低用户学习成本尊重用户使用习惯做出了一款与微软完全兼容的产品
WPS 2005
。
如果当时的雷军继续写代码，或许中国就少了一个
世界五百强
的知名企业家，多出一名行业顶级的程序员大神。
广告
【雷军2023演讲推荐】小米创业思考 雷军亲述
京东
￥51.50
去购买
?","老金山人都知道
雷总当年是写代码出身
为了金山发展不得已去做总经理
金山那代老人都不愿意去当领导管事只想写代码
结果雷总上任安排新助理说把我电脑清理下（擦干净的意思）
那小哥耿直的把雷总前半生的心血给格式化了
然后......
然后雷总只能挥泪安安心心去做总经理了
至于他的代码水平
他自己也说了","刚发现被WPS官方翻牌子了，莫大的荣幸。
不送我个会员嘛（狗头）
雷军大学时候成功破解过WPS。然后觉得不够好用，还自己加了一些功能…
这也算是雷军和金山还有WPS的不解之缘的开端。
不过虽然没有去靠这个盈利，但毕竟“破解”可能多少有点黑历史意味，雷军自己也不怎么提这段…
这个我看好像没什么人提过。
这也是后来求伯君力邀雷军加入金山的重要契机。
1990年时，雷军第一次知道了WPS，发现WPS作为文字处理软件非常惊艳，想自己弄一套。但当时WPS和汉卡配套搭售，一套要2000多块。
这可是90年代的2000块。按照雷军的说法，在80年代刚刚改革开放的时候有一个说法叫「万元户」，可能现在白万富翁都没这样的感觉。虽然90年代万元户没有那么稀奇，但4000块依旧是一大笔钱。
顺带纠正一个特别广的谣传，就是有种说法「雷军毕业时候已经赚了一百万」，这是完全谣传，雷军自己说法是毕业时候存款是4000块，这里面包括各种稿费、奖学金、创业收入，只是说开玩笑说自己4000元差不多该有现在半个百万富翁的感觉了，不是真的赚了100万。
话说回来。
当时雷军虽然奖学金很多，已经不用家里人付学费了，但2000元实在是一个天文数字。
所以他就把WPS破解了，还移植到了普通电脑上。
雷军自己的说法是这样的：「这可不是一件容易的事，我几乎有2周就没怎么睡觉才完成了WPS的解密。而使用过程中，我又在原来的基础上做了一些增强和完善，不少朋友都觉得很好用。后来我解密的版本在当时成了国内最流行的WPS版本。」
求伯君后来自己也说市面上有三个破解版本，雷军的这个是最好的。
其他故事还有很多，比如雷军大学时候合伙创业的三色公司曾经山寨金山汉卡卖钱，结果被大公司套娃山寨卖到低价挤出市场。
这里还有个有意思的事情，就是
三色公司
因此基本上揭不开锅，甚至最后靠着一个同学麻将打得好去找食堂的大师傅打麻将赢饭菜票，结果这个同学确实有点东西，以至于很长一段时间公司没钱了就派他去打麻将。
不过也正因为这段经历，雷军一直是不主张大学生创业的。
他认为如果创业团队如果没有资源又没有人脉，一旦有很大的生存压力，就可能逼不得已走上邪路。
视频资源加载失败
最后三色公司破产了，雷军毕了业去了北京一个航天研究所工作，但业余时间还是喜欢在中关村逛。
90年代的中关村里依然有很多80年代时的著名程序员在活动，比如
周志农
就很欣赏雷军的代码水平，有时候他让雷军帮忙为自己软件加密，还抛出橄榄枝邀请雷军加入自己公司。但雷军觉得公司很像三色公司的模式，就谢绝了。
还有后来创办连邦软件公司的
苏启强
，当时他的建议是雷军工作之余可以继续开发加密软件，雷军听取了意见，没有放下自己喜欢的代码。
所以雷军周一到周五早上工作，晚上回家开发软件经常一干就到凌晨，周末再去中关村。
这是雷军感觉最孤独的时候，没有一个真正互相理解、有共鸣的人。
1991年年底，雷军和时任金山副总裁求伯君相遇。
求伯君早前已经知道了雷军破解了自己的WPS，而且是破解得最好的那个版本。
理所当然地，求伯君盛情邀请雷军加入金山。
求伯君足足劝了雷军一整天。根据两人回忆求伯君还请雷军吃了一顿很好很贵的烤鸭。
虽然求伯君是几乎所有程序员的崇拜对象，雷军也不例外。但雷军考虑再三没有立刻答应。
求伯君也没有勉强，让雷军再考虑一下，说第二天中午再来找他。
第二次见面时候，求伯君谈起自己一个人写WPS的经历，曾一年半时间内生了3次肝炎，每次都要住院一两个月。
但病痛其实不是求伯君最大的痛苦，真正痛苦的是代码上没人交流「碰到问题没人可以商量，资料完全要靠自己查。喜悦也没人懂，没人可以分享」，雷军对这种感觉很有共鸣。
雷军终于还是被
求伯君
打动了。一来是内心还是很憧憬和求伯君这样的神级程序员一起工作，希望自己可以成为求伯君第二；二来求伯君说起自己写WPS的痛苦经历，让雷军很有共鸣。
就此雷军放弃了大家眼中研究所工作的铁饭碗，来到了民营企业金山。
然后发现自己是公司的第六个人（狗头）
就此雷军在金山一干就是16年。
期间在求伯君的强烈建议下转管理岗，期间还有那个有名的被同事
刘光明
给误格式化的故事。
（不过其实格式化了的代码大部分都有备份，只是有半个月工作量没了，但后来因此一放就放下了。）
28岁雷军任金山副总裁。
微软的冲击下金山另谋出路，《金山影霸》《金山词霸》《
金山打字通
》等等都是金山另拓展的新道路。
但求伯君和雷军从来不曾有放弃WPS的念头。
比如曾经有美国公司想挖求伯君墙角，给求伯君开出了75万美元年薪的天价offer，求伯君没有丝毫犹豫一口回绝了。
雷军除了带队开发了《剑侠情缘》，还带领团队重构了WPS4.0，市场占有率重新返回20％左右，使得WPS成功在微软和盗版的夹缝中求生。
多说一些求伯君和雷军两个人的“金山情”和WPS情怀，这是我觉得非常具有
堂吉诃德
般「明知不可为而为之」的故事。
WPS其实一直是金山最烧钱的项目。
其他的无论是《金山打字通》《金山词霸》包括金山游戏《剑侠情缘》等等的赚来的钱都用来往WPS里面投，WPS活像个碎钞机。
从商业角度来看，坚守WPS简直是百害无一利的选择，放弃它的话金山的日子肯定会舒服很多。尤其《
剑侠情缘
》及其网络版对于当时金山来说可谓金钱奶牛。
但求伯君和雷军选择了坚持，无论变更多少方式，金山始终都坚持把WPS做了下去更新迭代，没有放弃办公室文字处理软件。
“民族软件”的名头听起来很伟大，但对金山来说情怀和现实的碰撞真的是很煎熬的。
雷军后来回忆，今天这个员工走了，明天那个人萌生去意，看着金山墙上的口号“让我们的软件运行在每一台电脑上”的口号心里百感交集。
这是金山的梦想，但为了这个梦想金山放弃了太多了。
期间金山一度遇到过现金流受阻，发不出工资要关门的绝境。最后是求伯君把自己的房子给卖了给员工发了工资。
可能这也就是雷军在和鲁健的访谈中（就一事无成那个）提到他极其在意现金流的原因。
所以金山为了坚守WPS走了一条最艰难的路，也错过了很多机会，几次上市尝试都比较坎坷。
这也是雷军后来退休三年中反思，得出“顺势而为”结论的重要契机。
可以说小米代表了雷军“顺势而为”的思想，那金山就是他“逆流而上”的见证。
2007年金山终于成功上市后，雷军没有喜悦。他曾经梦想要战胜微软，结果用雷军的话来说“一个照面就被对方干翻了”。
祖传“干翻”
现实一次次挫折，最后凭借敌后游击战做出了一系列其他软件维持生计，最后因为游戏收入弯道超车才完成上市。
雷军只是感觉如释重负，终于对金山有了一个交代。即便是上市当天，雷军也对镜头说“我的心情其实很平静”。
彩蛋：右二陈睿
上市以后雷军就想要离开金山，好好休息一下。
求伯君的说法是，本心是真的不想雷军走。
但是自己也是看着雷军16年来几乎每天都十多个小时拼下来，多年下来明显人瘦了，衣服号码都小了，袖口小了一两号，求伯君也真的不忍心拒绝雷军的辞职。
求伯君最后答应了，雷军正式辞去了金山总裁兼CEO的职位。
此后雷军专心天使投资，办了顺为投资，开始跟创业者打成一片。
几年后觉得有机会，开始到处拉拢微软谷歌的牛人，着手创办小米。
但2010年后的金山严重下滑，在雷军刚成立小米的时候，求伯君走投无路只能给离开了三年的雷军发了短信“如果你不回来，金山可能不行了。”
雷军也知道求伯君不到万不得已是绝对不会这么说话，他回去和求伯君和
张旋龙
会面。基本上每两到三天会面一次，求伯君和张旋龙当然劝雷军回归金山。
当时雷军已经成立了
顺为资本
，小米又是刚刚起步，自己手头事情也很多。
但雷军自己说，“金山”两个字对他意义过于重大，自己也曾经为这两个字付出很多，即便离开金山后，只要听到别人说起“金山”依旧会心潮澎湃。
最后雷军第二次答应了求伯君加入金山的邀请。
在其他小米创始人们的支持下，雷军2011年正式重返金山。
由此开始开始金山、小米、顺位三家企业来回跑。
对金山，雷军制定了「全力转型移动端互联网」的战略。现在这个战略被证明了是非常成功的，金山WPS重新扭亏为盈。
2019年，金山办公WPS上市，雷军公开信中写道：“31 年前，求伯君在深圳一间酒店闭关几个月写出第一版 WPS 时，就注定了金山的英雄梦想。31 年来，金山一直肩扛民族软件大旗，即便是在最艰难的时刻，也从未放弃。”
媒体也评价道，“因为WPS，让全世界了解到在中国还有一家软件公司能和微软抗衡。”
以上回答正好是今天上下班通勤路上打发时间写的，越写越多扯的有点远，由代码水平扯到金山还有WPS上去了。
其实我对雷军的钦佩7成甚至8成还是来自于金山这段经历，反而小米这段经历的占比少一些。当然这个就是纯主观了。
不一定完全严谨，可能个别地方有出入，还望指正。","雷军当年可是
黄玫瑰工作室
的创始人呀，90年代左右，满大街的盗版工具软件光盘里面都是他们软件工作室开发的那些解密软件，我们当时用的很多正版软件都是用他们编的
解密软件
破壳的哦。
其实很多IT名人现在看起来好像只负责管理，不懂技术，其实他们中的不少人也是程序高手，除了雷军之外，还有他的老对头
周鸿t
，当年可是中国第一个Windows平台上的电子邮件客户端的开发者哦，再往远处说，当年新浪创始人
王志东
，也是当年名满Windows 3.1的中文平台，中文之星的开发者。
所以说，不要以为他们只是通过管人管事而出名，他们自己本身也是实力超强的技术高手，才能看准技术的潮流呀。","下面请欣赏雷总1994年写的代码片段――
这段用x86汇编写成的代码（以上是代码片段）用于清除内存驻留程序，类似内存加速工具，雷军教科书般规范地注明了代码用意、时间、作者……还细腻地用符号组成了分隔符让代码更加
优雅
，读起来
清晰、舒适
，所以雷总称之为
诗一般的代码
其实也不算过分。
在B站2020年6月份的一个访谈直播活动中，雷总也在给后辈的寄语中不断强调
代码要整洁，逻辑要无懈可击，自己写的代码要达到例程（示范程序）的程度
。这一点和《代码整洁之道》的作者Bob大叔英雄所见略同了。
Bob大叔就在《
代码整洁之道
》提出一种观点：代码质量与其整洁度成正比
。
优秀的系统往往有优秀的结构设计，层次清晰，职责单一，模块化，方便拓展和复用。功能的添加往往只是在现有的框架中添加少量代码。而且Bob大叔在《代码整洁之道》中给了我们一些行之有效的规则，涵盖从命名到重构的多个方面，只要遵循这些规则，就能编写出干净的、让人舒服的代码。
详见回答――
舒服的代码和不舒服的代码，差距是怎样的？
274 赞同 ・ 16 评论
回答
更多内容――
你的编程能力从什么时候开始突飞猛进？
261 赞同 ・ 9 评论
回答
普通的程序员和大神级的程序员有什么区别？
234 赞同 ・ 15 评论
回答
希望有一天，大家的代码都能“像诗一样优雅”！
========
赠人玫瑰，手留余香，不要忘记点赞、收藏、关注 
@人民邮电出版社
 哦~
一键三连，感恩有你~","说实话我觉得应该不行。（狗头）
雷军lc有刷够1000道吗？
雷军知道
jdk14
的新特性是什么吗？
雷军知道
jdk7
和jdk8的HashMap实现有啥区别吗？
雷军用过ssm框架，redis，
kafka
吗，读过源码没？
为什么 wait，notify 和 notifyAll 是在 Object 类中定义的而不是在 Thread 类中定义？
为什么Java中不支持多重继承？
 如果你的Serializable类包含一个不可序列化的成员，会发生什么？你是如何解决的？
我猜雷军过不了一面 
面试评价：候选人技术栈陈旧，年纪太大。","雷军学长在当年的学习条件下汇编满分
我们院今年挂了四分之一
而且是在卷面34分以上就全部给60的情况下
这特么都真事儿","RAMinit程序源码-雷军出品 - 浮生笔记
结论：秒杀目前80%的程序问题不大。
看过雷军写的RAMinit代码，一个清理内存的小工具。
代码是用汇编写的，从代码质量来看，
理由如下：
 良好的函数命名
函数的名称非常好的表示了函数的作用，虽然我的汇编语言很多指令不记得了。
但是可以从这个函数名称知道下面的这个函数是用来判断是否是DOS系统的。
IsWinDOS:

                
mov
     
ax
,
 
1600h

                
int
     
2fh

                
cmp
     
al
,
 
01h

                
jz
      
@@
9

                
cmp
     
al
,
 
0ffh

                
jz
      
@@
9
                     
; Windows/386 Version 2.X

                
cmp
     
al
,
 
00h

                
jz
      
@@
1

                
cmp
     
al
,
 
80h

                
jnz
     
@@
9
            
短小的函数
即使是一个完成简单的功能的程序，程序也被分成了多个函数，并且每个函数都非常的短小，利于代码的修改。
良好的代码注释 
对于代码中使用的常量，大部分在文件的开头进行了定义。如果是函数内部使用的常量，也进行了说明。Color (White in Red)就是对于47h的解释。
NoKeepSelf:

                
mov
     
ax
,
0e07h

                
int
     
10h

                
mov
     
cs
:
clsS
tr
,
 
47h
  
; Color (White in Red)

                
call
    
RemoveTSR

                
dec
     
cs
:
Copies

                
call
    
RestoreSelfIntVec

                
push
    
es

                
cmp
     
cs
:
PrevDataSeg
,
 
0

                
jz
      
@@
1

                
mov
     
es
,
 
cs
:
PrevDataSeg

                
mov
     
es
:
NextDataSeg
,
 
-
1

        
@@1:
    
pop
     
es

                
mov
     
ax
,
 
4c00h

                
int
     
21h","我记得好像是13年的时候？阿黎整了个小米网的讨论会。大意是各部门把过去一年里，自己觉得做的好的、和做的烂的，摆出来。
例如设计，梁师傅就整了个两个图，一好一坏对比批判一番。
到代码那块，我记得好像是海洲来讲。坏的就是整个小米网，因为他觉得小米网的代码他还是不满意，还是要一边开车一边修车。
好的，就是雷老大的一段代码，说是二十年前的。
那段代码就那么直接投影到大屏幕上，程序员弟兄们沉默一会，然后纷纷点头。
发言，大意是：我不指望你们有这水平，但你们得朝这个方向努力啊！
事后我问一位程序员老铁：你们是拍马屁还是真服？我只会Hello world，看不懂。
这位后来也做了某上市公司CTO的未来大佬对我这个文科生不屑一顾：我没法和你解释。总之，雷老大写得很简练、很清晰、很干脆，这就是牛逼，而且是高层次的牛逼。
所以我觉得，应该是真牛逼。","我自学了一些c，看过雷军编写的教材
武汉大学计算机专业两年毕业，编程满分，直接编写计算机教程。大学没毕业直接编写程序卖给别的公司赚钱
进入金山凭技术做到金山总裁。
别的不敢说，他绝对是计算机领域大哥级人物，打爆百分之九十九绝对不是夸张的数字。我国计算机从业者及相关，最少也有几十万人吧？百分之一也有几千人了
凭雷军的实力，进不了前几千?","雷军22年前写的汇编代码，大家看看牛不牛：
电脑和编程是雷军人生中最大的兴趣，关于电脑和编程，雷军是这么说的：
程序员活在自己想象的王国里！
我刚接触电脑就发现电脑的妙处，电脑远没有人那么复杂。
如果你的程序写得好，你就可以和电脑处好关系，就可以指挥电脑干你想干的事。
这个时候你是十足的主宰。
每每你坐在电脑面前，你就是在你的王国里巡行，这样的日子简直就是天堂般的日子。
电脑里的世界很大，编程人是活在自己想象的王国里。
你可以想象到电脑里细微到每一个字节、每一个比特的东西。
我爱编程
这个工作，可以肯定我会干上一辈子
正是因为热爱，所以雷军一干就是10多年。
雷军认为编程是技术，也是一种艺术，程序员需要有类似艺术家对艺术一般的追求，才能真正打造出好的产品！
雷军的技术为什么这么牛逼？他在一次采访中说过一段话：我尤其喜欢阅读计算机经典书籍，那是一种如饥似渴的感觉！
另外我把大学和工作中用的经典电子书库（包含数据结构、操作系统、C++/C、网络经典、前端编程经典、Java相关、程序员认知、职场发展）、面试找工作的资料汇总都打包放在这了，这套资源可不是一般那种网上找的资源，是伴随我从学生一路成长为腾讯高级开发工程师，360技术经理、360技术总监、中小公司CTO的打包全套，非常宝贵！点击下方链接直达获取：
点击下方链接直接获取：
雷军20年前写过一篇文章：《我会当一辈子程序员》。
看完你会知道，编程在雷军的眼里是什么样子。
有的人学习编程技术，是把高级程序员做为追求的目标，甚至是终身的奋斗目标。
后来参与了真正的商品化软件开发后，反而困惑了，茫然了。
一个人只要有韧性和灵性，有机会接触并学习电脑的编程技术，就会成为一个不错的程序员。
刚开始写程序，这时候学得多的人写的好，到了后来，大家都上了一个层次。
谁写的好只取决于这个人是否细心、有韧性、有灵性。掌握多一点或少一点，很快就能补上。
成为一个高级程序员并不是件困难的事。
当我上学的时候，高级程序员也曾是我的目标，我希望我的技术能得到别人的承认。
后来发现无论多么高级的程序员都没用。
关键是你是否能够出想法出产品，你的劳动是否能被社会承认，能为社会创造财富。
成为高级程序员绝对不是追求的目标。
编程不仅仅是技术，还是艺术。
有人认为编程是一种熟练工种，也有人把编程说成是艺术创作。这两种意见争论比较激烈。
我们换个工种来看，石匠应该是熟练工种，属于工人，更和艺术似乎沾不上边。
但正是这些石匠，给我们留下多少文物古迹，如
乐山大佛
、莫高窟等等。
应该说这些石匠给我们留下了无穷的文化财产。
现代软件工业已具相当规模，很多软件的完成需要的是大兵团作战。
一名普通程序员接受编写某一模块的任务后，往往只是写代码，发挥的余地很小。
在大项目中，很多程序员只能了解到和自己所编模块相关的很局部的细节。
另外还受到开发环境的限制，真的很难体会到自己在从事”艺术”创造，更多的时候是感到自己在从事重体力劳动。
有的时候还担心自己苦苦参与的这个项目究竟有没有意义，是不是在同类产品中有竞争力，会不会开发出来以后就因为硬件的发展，操作系统的换代而过时……
我认为编程的工作和石匠比较相似，有技术活，更多的是体力活。
不管怎么说，写出一个好软件不是一件容易的事。
这两种想法都有片面性，编程应该说两种属性都有。
编程不仅仅是技术，也还是艺术。编程是技术活，才有可能大规模进行，才会有软件工程和
软件工厂
。
也正是编程是艺术，才会有如此多的好产品，让大家如痴如醉。
关于雷军的代码水平，他自己也说过：
另外，程序员多刷算法题好处多多，想要跟雷军一样长期在编程世界里遨游，先精通算法简直是必须的，算法厉害的人进大厂非常容易，再次推荐这本阿里P8大佬撰写的Leetcode刷题笔记，它帮助我身边不少朋友加入大厂：
祝大家前程似锦，在编码的道路上一马平川。
看看这本书的目录和排版！相当经典！
PS:感谢大家的阅读，觉得不错双击点赞下呀，这里也送大家一套我花1个月时间整理的超级硬核书单，总计200本书籍，希望对大家有用:
点个赞，一键三连呗，硬核码字不易。","求伯君、雷军、张小龙应该算是中国第一代程序员里面的顶尖高手，
曾经一个人写出了WPS的第一个版本，
则是一个人写出了Foxmail，雷军则是新版本WPS版本的灵魂人物，可以说是软件工业界的绝对大神。朋友说：雷军写的代码像诗一样优美。
 雷军大一时写的代码后来被老师编入教材，作为样例代码被后面的学弟学妹学习参考，仅仅用了两年时间，雷军就完成了大学四年的课程，提前毕业。
1990年初，雷军在一个朋友那里用了一次
，当时就被震住了。界面易用美观，更强的是打印结果可以先模拟显示出来，开发者是香港金山公司的求伯君。雷军觉得这个香港的软件写得真不错。由于时的电脑存贮和运算能力不足，wps软件需要一块价值不菲的汉卡支持。雷军特别想买一套自己使用，但买一套需要2200元，这在当时是一个天文数字。
雷军当了一回不光彩的""黑客”。他把WPS解密了，并移植到普通电脑上直接使用。雷军把解密的WPS版本做成了国内最流行的WPS版本。因为这个渊源，雷军后来认识了WPS的开发者求伯君。进入金山软件之后，雷军成了求伯君最得力的助手，并且最终接班求伯君。
雷军对于自己写的代码非常的重视和珍稀，即使他做了管理岗位之后，依然有机会就写写代码。
雷军还在网上发表了一篇文章，如下
雷军为什么不写代码了？
在2018年，金山软件创立30周年纪念日活动上，雷军回忆了这段经历：
当我28岁时候在金山白天当总经理，晚上当程序员，当时就想这样能干好两份工作，但发生了意外的事情，有个同事把我的电脑不小心给格式化了，连备份硬盘都格式化了，从此断了我的后路，从而走上了当CEO的“不归路”。他十年间写下的代码就此毁于一旦，心碎之余决定不再写代码，雷军至此解开心结，放下了立志一生编程的想法，全心做好公司的管理。
从此江湖上少了一个伟大的程序员，多了一个Are you ok 的网红！！！","雷军20年前曾经写过一篇作文：《我会当一辈子程序员》。
看完你会知道，编程在热爱它的人眼里是什么样子。
电脑是雷军人生中的最爱，电脑的世界对于雷军而言实在太美妙。雷军觉得，电脑的世界没有人那么复杂。只要你程序写得好，就可以和电脑处好关系，也可以指挥电脑，做一些你想做的事情。雷军认为，电脑的世界很大，程序员都是活在自己的王国里。在这里，程序员可以主宰一切。正是因为热爱，所以雷军一干就是10年。
雷军心爱的代码被新程序员格式化
对于雷军来说，虽然现在他更加专注在产品开发以及管理方面，但是曾经他对心爱的代码视为珍宝。之前来了一位技术支持人员，而这位技术人员进公司的第一份工作，就是帮雷军整理他的硬盘。 一位理解错误，原本只要覆盖式的安装系统就可以的事情，这位程序员却把雷军的硬盘格式化了。这些代码是雷军多年来积累下来，而且也是他的最爱，就这样成为 炮灰，相信雷军非常难过。
编程是技术，也是一种艺术
雷军认为，编程的工作同石匠的工作相类似，即是技术活，也是体力活，而编写优秀的软件，算是一件比较难得事。编程是一门技术活，因此才有可能大规模的进行，进而才会有软件工程。此外，因为编程是一种艺术，因此有很多好的产品。
以上内容来源于网络
如有侵权联系小编","上大学时写的代码能入教材，
九十年代写的程序能卖百万。","前段时间不是有一个事情特别火，某游戏的代码写得如x山一般，加载速度相当慢，一查才发现就是这座x山导致的，但谁也不想改也不敢改，最后还是有网上的一位匿名兄弟帮助修复了这个问题并放出开源代码供给其他玩家。
而雷军早期写得一些程序就已经注意到了代码的工整性和可修改性，真的是非常了不起、有前瞻性的行为，同时也说明这个人考虑事情很周全，不图一时之快，而是从真正做好这件事情的角度出发。
而且雷军自己不也说过吗？
“我的代码写得像诗一样优美”","        雷军的优秀是毋庸置疑的，在武汉大学，他两年学完计算机系四年的课程，大二就完成了毕业设计，汇编语言更是武大三十年以来仅有两个满分之一，大三就开始写加密软件、杀毒软件、财务软件、CAD软件等。至于老雷的代码水平，大家看看吧，
;
; RI.ASM Revision 2.12 [ July 12, 1994 ]
Revision equ 'V2.12 '
;
; 
;  
;  RAMinit Release 2.0 
;  Copyright (c) 1989-1994 by Yellow Rose Software Co. 
;  Written by Mr. Leijun 
;  
;  Function: 
;  Press HotKey to remove all TSR program after this program 
;  
; 
; ..........................................................................
; Removed Softwares by RI:
; SPDOS v6.0F, WPS v3.0F
; Game Busters III, IV
; NETX ( Novell 3.11 )
; PC-CACHE
; Norton Cache
; Microsoft SmartDrv
; SideKick 1.56A
; MOUSE Driver
; Crazy (Monochrome simulate CGA program)
; RAMBIOS v2.0
; 386MAX Version 6.01
; ..........................................................................
; No cancel softwares:
; Windows 3.1 MSD
;
; No removed TSR softwares:
; MS-DOS fastopen
; Buffers, Files ... (QEMM 6.0)
; QCache (386MAX 6.01)
; ..........................................................................
;
COMMENT 
V2.04 Use mouse driver software reset function to initiation mouse
2/17/1993 by Mr. Lei and Mr. Feng
V2.05 RI cannot work in Windows DOS prompt
3/9/1993 by Mr. Lei
V2.06 1. When XMS cannot allocate 1K memory, RI halts.
2. RI repeat deallocates EMS memory.
V2.07 HotKey Setup Error
4/25/1993 by Mr. Lei
V2.08 KB Buffer
V2.10 1. Release high memory blocks (EMM386 QEMM386 S-ICE 386MAX)
2. RI copies flag
V2.12 1. Exists a critical error in Init 8259 procedure
2. Save [40:F0--FF] user data area
dosseg
.model tiny
.code
locals @@
org 100h
Start: jmp Main
org 103h
True equ 1
False equ 0
MaxHandles equ 100h
INT3 macro
out 0ffh,al
endm
;
; HotKey Status Test Var
; --------------- ---------------
;
; 7 6 5 4 3 2 1 0 417 418 496
; . . x . x . . . Left Alt is pressed 8 2
; x . . . x . . . Right Alt is pressed 8 8
; . . . x . x . . Left Ctrl is pressed 4 1
; . x . . . x . . Right Ctrl is pressed 4 4
; . . . . . . x . Left Shift is pressed 2
; . . . . . . . x Right Shift is pressed 1
;
LeftAlt equ 00101000b
RightAlt equ 10001000b
LeftCtrl equ 00010100b
RightCtrl equ 01000100b
LeftShift equ 00000010b
RightShift equ 00000001b
HotKey db LeftCtrl or RightCtrl
DataBegin dw 0
NextDataSeg dw 0ffffh
oldInt2F_addr dw 0, 0
XMS_control dw 0, 0
Handle_begin dw 0
cvtOfs dw 0 ; DOS 3.0 equ 0 and above DOS 4.0 is 1
org 104h
db 0dh
db Revision
db ??date
db 26
org 114h
tsrLength dw 0
MachineID db 0FCh ; IBM PC/AT
AuxHotKey db 0 ; 2Dh ; 'X' Scan Code
AuxHotKeyName db 'X$ '
Power db True
Flag db '!'
Kbd102 db 0
NoFlag db 0
StopFlag db 1
DosEnv dw 0
WorkSeg dw 0
PrevDataSeg dw 0
Copies db '1'
old_8259 db 0 ; 21h port
db 0 ; a1h port
Status dw 0
XMSbit equ 00000001b
EMSbit equ 00000010b
SKbit equ 10000000b
GoINT1C: db 0eah
oldInt1C_addr dw 0, 0
newINT1C:
test cs:Status, SKbit
jnz GoINT1C
cmp cs:StopFlag, 0
jz @@0
;
; Mr. Lei 2/8/1993
; Problem: if WPS quit and reenter, old RI cann't control keyboard. ;
push ds
push ax
xor ax, ax
mov ds, ax
mov ax, ds:[94]
cmp ax, offset NewInt9
pop ax
pop ds
jnz GoINT1C
mov cs:StopFlag, 0
@@0: push ax
push ds
push es
xor ax, ax
mov ds, ax
mov es, ds:[94+2]
cmp word ptr es:[101h], 'IE' ; 'LEI'
jz @@1
cli
mov cs:StopFlag, 1
mov ax, ds:[94]
mov cs:oldINT9_addr2, ax
mov ax, ds:[94+2]
mov cs:oldINT9_addr2[2], ax
mov ds:[94], offset newINT9_2
mov ds:[94+2], cs
sti
@@1: pop es
pop ds
pop ax
jmp GoINT1C
; ----------------------------------------------------------------------
; INT2F Func
;
; AX = C0D7h Return RI segment in AX
; AX = C0D8h Removes all TSR programs after RI
; AX = C0D9h Removes all TSR programs include RI
; AX = C0DAh Removes all RI copies
; ----------------------------------------------------------------------
newINT2F:
cmp ax, 0c0d7h ; LEI Hanzi GB Code
jnz @@1
push cs
pop ax
iret
@@1: cmp ax, 0c0d7h+1
jnz @@2
jmp KeepSelf
@@2: cmp ax, 0c0d7h+2
jnz @@3
jmp NoKeepSelf
@@3: cmp ax, 0c0d7h+3
jnz @@9
mov cs:NextDataSeg, -1
mov cs:Copies, '1'
jmp NoKeepSelf
@@9: jmp dword ptr cs:oldInt2F_addr
CallInt9:
ret
newINT9_2:
mov cs:NoFlag, 1
pushf
db 9ah ; call far ptr oldint9_addr
oldInt9_Addr2 dw 0, 0
jmp newINT9_proc
newINT9:
pushf
db 9ah ; call far ptr oldint9_addr
oldInt9_Addr dw 0, 0 cmp cs:NoFlag, 0
jz newINT9_proc
mov cs:NoFlag, 0
iret
newINT9_proc:
cmp cs:Flag, '!' ; busy ?
jnz @@0
iret
@@0:
mov cs:Flag, '!' ; set busy flag
push ax ; cmp hot key
push bx
push es
mov ax,40h
mov es,ax
cmp cs:AuxHotKey, 0
jz @@_1
mov bx, es:[1ah]
cmp bx, es:[1ch]
jz @@10
push bx
mov bl, es:[bx+1]
cmp bl, cs:AuxHotKey
pop bx
jnz @@10
@@_1:
mov ah,es:[17h] ; test CTRL SHIFT ALT
mov al,cs:HotKey
push ax
and ax,0f0fh
cmp al,ah
pop ax
jnz @@10 cmp cs:Kbd102, True
jnz @@1
shr al, 1
shr al, 1
shr al, 1
shr al, 1
push ax
mov ah, es:[18h]
and ax, 303h
cmp al, ah
pop ax
jnz @@10
mov ah, es:[96h]
shr ax, 1
shr ax, 1
and ax, 303h
cmp al, ah
jnz @@10 cmp cs:AuxHotKey, 0
jz @@_3
inc bx
inc bx
cmp bx, 3eh
jb @@_2
mov bx, 1eh
@@_2:
mov es:[1ah], bx
@@_3:
call IsWinDos
or ax, ax
jz @@1
call Beep
@@10:
sti
pop es
pop bx
pop ax
mov cs:Flag, ' ' ; no busy
iret
@@1: ; OK
pop es
pop bx
pop ax
KeepSelf:
call RemoveTSR
push es
mov es,cs:WorkSeg
mov dx,es:tsrLength
mov di,dx
mov al,0h ; Aug 24, 1993
mov cx,100h
rep stosb
pop es
int 27h
NoKeepSelf:
mov ax,0e07h
int 10h
mov cs:clsStr, 47h ; Color (White in Red)
call RemoveTSR
dec cs:Copies
call RestoreSelfIntVec
push es
cmp cs:PrevDataSeg, 0
jz @@1
mov es, cs:PrevDataSeg
mov es:NextDataSeg, -1
@@1: pop es
mov ax, 4c00h
int 21h
; ---------------------------------------------------------------------------
IsWinDOS:
mov ax, 1600h
int 2fh
cmp al, 01h
jz @@9 cmp al, 0ffh
jz @@9 ; Windows/386 Version 2.X
cmp al, 00h
jz @@1 cmp al, 80h
jnz @@9 ; Windows 3 in enhanced mode
; Version number in AL/AH
@@1:
mov ax, 4680h
int 2fh
cmp al, 80h
jnz @@9
xor ax, ax
jmp @@10
@@9: mov ax, 1
@@10: ret
; -----------------------------------------------------------------------
RestoreSelfIntVec:
cmp Copies, '0'
jz @@0
ret
@@0:
cli
push cs
pop ds
xor ax, ax
mov es, ax
mov si, offset oldInt9_Addr
mov di, 94
movsw
movsw
mov si, offset oldInt2F_Addr
mov di, 2Fh4
movsw
movsw
mov si, offset oldInt1C_Addr
mov di, 1Ch4
movsw
movsw
sti
ret
; ------------- KERNEL PROGRAM ----------------------------------------------
RemoveTSR:
pop ax
cli ; Set stack
mov sp, cs
mov ss, sp
mov sp, 100h
sti
push ax
cmp cs:Power, True
jnz @@1
call Init8259
@@1:
push cs
pop ds
@@_0:
mov ax,ds:NextDataSeg
cmp ax, -1
jz @@_1
mov cs:PrevDataSeg, ds
mov ds, ax
jmp @@_0
@@_1: mov si,ds:DataBegin
mov cs:WorkSeg, ds
lodsw
cmp ax, 'XX'
jz @@_2
call Beep
ret
@@_2:
call RestoreEnvStr
call RestoreMCB ; restore current mcb
call CloseFiles
call RestorePort
call RestoreLEDs
call RestoreVecList ; Restore vectors list
call RestoreFloppyParam
cmp cs:Power, True
jnz @@2
call RestoreCVTchain ; Restore cvt chain
call RestoreMemoryManager
@@2:
call RestoreBiosData
call Enable8259
mov ah, 1 int 16h
call RestoreClockSpeed
call CloseSpeaker
call ResetDisk
call UpdateTime
call ClosePRN
mov bx,cs:WorkSeg
mov ah,50h
int 21h ; Set PSP segment
mov ax,3 int 10h ; Set display mode
call InitPRN
call InitMouse
mov al, cs:Copies
cmp al, '1'
ja @@_sh1
mov cs:ShowCopies, ''
jmp @@_sh2
@@_sh1: mov cs:ShowCopies, al
@@_sh2:
mov si, offset clsStr
call ColorPrintStr
mov cs:Flag, ' ' ; no busy
cmp Copies, '1'
jnz @@_end
mov cs:StopFlag, 0
@@_end:
call ClearKB_buffer
ret
Beep:
mov ax,0e07h
int 10h
ret
; #########################################################################
ClearKB_Buffer:
push es
push bx
mov bx, 0040h
mov es, bx
cli
mov bx, es:[1ah]
mov es:[1ch], bx
sti
pop bx
pop es
ret
Init8259:
; cmp cs:Copies, '1'
; jz @@1
; ret
@@1:
cmp cs:MachineID, 0fch
ja @@pc_xt
@@AT:
mov bx,870h ;
mov al,0 ;
out 0F1h,al ;
jcxz $+2
jcxz $+2
mov al,11h ; ICW1
out 0A0h,al
jcxz $+2
jcxz $+2
out 20h,al
jcxz $+2
jcxz $+2
mov al,bl ; ICW2
out 0A1h,al
jcxz $+2
jcxz $+2
mov al,bh
out 21h,al
jcxz $+2
jcxz $+2
mov al,2 ; ICW3
out 0A1h,al
jcxz $+2
jcxz $+2
mov al,4
out 21h,al
jcxz $+2
jcxz $+2
mov al,1 ; ICW4
out 0A1h,al
jcxz $+2
jcxz $+2
out 21h,al
jcxz $+2
jcxz $+2
mov al,0FFh ; OCW1
out 0A1h,al
jcxz $+2
jcxz $+2
out 21h,al
ret
@@PC_XT:
mov al,13h ; ICW1
out 20h,al
jcxz $+2
jcxz $+2
mov al,8 ; ICW2
out 21h,al
jcxz $+2
jcxz $+2
mov al,9 ; ICW4
out 21h,al
jcxz $+2
jcxz $+2
mov al,0FFh ; OCW1
out 21h,al
ret
Enable8259:
mov ax, word ptr cs:old_8259
out 021h,al
jcxz $+2
jcxz $+2
mov al,ah
out 0a1h,al ; DEC PC Bus Mouse
ret ; July 1994 by Mr. Lei
; -------------------------------------------------------------------------
RestoreBiosData:
lodsw
cmp ax, '--'
jz @@1
call Beep
ret
@@1: push es
push di
mov di, 40h
mov es, di
mov di, 10h
movsw
mov di, 0a8h ; [40h:a8h]
movsw
movsw
mov di, 49h
mov cx, 1dh
rep movsb
mov di, 0f0h ; User data
mov cx, 8
rep movsw
pop di
pop es
ret
; -------------------------------------------------------------------------
RestoreMCB:
push ds
push es
lodsw ; 'MZ'
@@0: lodsw
cmp ax, 'MM'
jz @@1
mov es,ax
xor di,di
movsb
movsw
movsw
inc ax
mov bx, ds
cmp ax, bx
jz @@10
mov byte ptr es:[8], 0 ; Aug 24, 1993
@@10: cmp byte ptr es:[0], 'Z'
jnz @@0
mov byte ptr es:[10h], 0
jmp @@0
@@1:
pop es
pop ds
ret
; -------------------------------------------------------------------------
CloseFiles:
mov ax, 5 ; Begin handle
push ds
push si
mov cx, 15 ; Max handle
sub cx, ax
inc cx
mov bx, ax
@@1: push bx
push cx
mov ah, 3eh
int 21h
pop cx
pop bx
inc bx
loop @@1
pop si
pop ds
ret
; -------------------------------------------------------------------------
RestorePort:
mov di, 40h ; restore port
mov es, di
xor di, di
mov cx, 8
rep movsw
ret
; -------------------------------------------------------------------------
RestoreLEDs:
lodsb
and al, 11110000b ; LED status
mov ah, es:[17h]
and ah, 00001111b
or ah, al
and ah, 0f0h ; Clear CTRL ALT SHIFT
mov es:[17h], ah
ret
; -------------------------------------------------------------------------
RestoreEnvStr:
lodsw
push si
push di
push ds
push es
mov es, cs:DosEnv
mov ds, ax
xor si, si
mov di, si
@@0: lodsb
or al, al
jnz @@1 cmp byte ptr ds:[si], 0
jz @@2
@@1: stosb
jmp @@0
@@2: stosb
stosb
pop es
pop ds
pop di
pop si
ret
; -----------------------------------------------------------------------
RestoreVecList:
xor ax,ax
mov di,ax
mov es,ax
mov cx,100h
@@0: lodsw
xchg dx, ax
lodsw
cmp dx, 'EL'
jnz @@1 cmp al, 'I'
jnz @@1
sub cl, ah
push cx
mov cl, ah
mov ax, es:[di-4]
mov dx, es:[di-2]
@@a: stosw
xchg ax, dx
stosw
xchg ax, dx
loop @@a
pop cx
or cx, cx
jz @@9
jmp @@0
@@1:
xchg ax, dx
stosw
xchg ax, dx
stosw
loop @@0
@@9:
ret
;----------------------------------------------------------------------------
RestoreFloppyParam: ; Mr. Lei 2/10/1992
push es
push ax
xor ax, ax
mov es, ax
mov byte ptr es:[525h], 2
pop ax
pop es
ret
;---------------------------------------------------------------------------
RestoreCVTchain:
lodsw
cmp ax, 'VC'
jz @@_0
call Beep
ret
@@_0:
push ax
push cx
push es
; -----------------------------------------------------------------
lodsw ; DPB
mov di, ax
lodsw
mov es, ax
@@1: lodsb
inc di
stosb
add di, cs:cvtOfs
add di, 10h
movsw
movsw
les di, es:[di+2]
cmp di, -1
jnz @@1
; -----------------------------------------------------------------
lodsw ; DCB
mov di, ax
lodsw
mov es, ax
xor ax, ax
dec ax
stosw
; -----------------------------------------------------------------
lodsw ; Device Driver Chain
mov di, ax
lodsw
mov es, ax
xor cx, cx
@@9: push di
mov cl, 5
rep movsw
pop di
les di, es:[di]
mov ax, di
inc ax
jnz @@9
pop es
pop cx
pop ax
ret
; ----------------------------------------------------------------------------
RestoreMemoryManager:
test cs:Status, XMSbit
jz @@1
call LoadXMSstatus
@@1:
test cs:Status, EMSbit
jz @@2
call LoadEMSstatus
@@2:
ret
LoadEMSstatus:
lodsw
cmp ax, 'ME'
jz @@_0
call Beep
ret
@@_0:
lodsw
mov cx, ax
xor dx, dx
@@_1: push ds
push si
push dx
push cx
@@0: cmp dx, ds:[si]
jz @@1
add si, 4
loop @@0
push cx
mov cx, 5
@@0: mov ah, 45h ; Deallocate Handle and Memory
int 67h
or ah, ah
jz @@1
loop @@0
@@1: pop cx
@@1:
pop cx
pop dx
pop si
pop ds
inc dx
cmp dx, 100h
jb @@_1
shl cx, 1
shl cx, 1
add si, cx
ret
LoadXMSstatus:
lodsw
cmp ax, 'MX'
jz @@_0
call Beep
ret
@@_0:
lodsw
mov cx, ax
jcxz @@5
@@1:
lodsw
mov dx, ax
@@2: push dx
mov ah, 0ah ; free
call dword ptr cs:xms_control
or ax, ax
pop dx
jnz @@4 cmp bl, 0abh
jnz @@4
push dx
mov ah, 0dh ; unlock
call dword ptr cs:xms_control
or ax, ax
pop dx
jmp @@2
@@4: loop @@1
@@5: ret
endp
; -----------------------------------------------------------------------
CloseSpeaker:
in al, 61h
and al, 0fch
out 61h, al
ret
; -----------------------------------------------------------------------
RestoreClockSpeed:
mov al, 00110110b
out 43h, al
xor ax, ax
out 40h, al
out 40h, al
ret
; -----------------------------------------------------------------------
ResetDisk:
xor ax, ax
xor dx, dx
int 13h ; Restore A
inc dx
int 13h ; Restore B
mov dl, 80h
int 13h ; Restore C
ret
; --------------------------------------------------------------------------
ClosePRN:
mov ah, 51h ; Get PSP seg
int 21h
mov es, bx
mov ax, es:[16h] ; Prev PSP seg
cmp ax, bx
jnz @@9
mov ax, 3e00h ; COMMAND
mov bx, 4 int 21h
@@9:
ret
InitPRN:
mov ax, 3e00h
mov bx, 4 ; PRN
int 21h
mov ax, 3d01h
mov dx, offset PRNname
push cs
pop ds
int 21h
ret
PRNname db 'PRN',0
InitMouse: ; 2/16/1993 by Mr. Lei
push es
xor ax, ax
mov es, ax
cmp word ptr es:[33h4+2], 0
jz @@0 cmp word ptr es:[33h4], 0
jz @@0
mov ax, 21h
int 33h ; Hook Mouse Interrupt
@@0: pop es
ret
; ------------- CMOS CLOCK set to System -----------------------------------
UpdateTime:
call GetRealTime
mov ah, 2dh
int 21h
ret
GetRealTime:
mov ah,2 int 1Ah
mov al,ch
call bcdxchg
mov ch,al
mov al,cl
call bcdxchg
mov cl,al
mov al,dh
call bcdxchg
mov dh,al
mov dl,0
ret
BCDxchg:
push ax
push cx
mov cl,4
shr al,cl
pop cx
mov bl,0Ah
mul bl
pop bx
and bl,0Fh
add al,bl
ret
; -----------------------------------------------------------------------
; Display string
ColorPrintStr:
lodsb
mov bh, al ; color
xor cx, cx
mov dx, 014fh
mov ax, 0600h
int 10h
mov ah, 02 ; GotoXY (0, 0)
xor dx, dx
mov bh, 0 int 10h
PrintStr:
push cs
pop ds
xor bx, bx
@@1: lodsb
cmp al, '$'
jz @@2
or al, al
jz @@2
mov ah, 0eh
int 10h
jmp short @@1
@@2: mov al, cs:clsStrcolor
mov cs:clsStr, al
ret
; -----------------------------------------------------------------------
Self dw 0
clsStrcolor db 17h
clsStr db 17h ; Color (White in Blue)
db ' RAMinit Version 2.12 (c) 1989-1994 by KingSoft Ltd. Mr. Leijun'
db 0dh,0ah
db ' ['
ShowCopies db ''
db '] Activate...',0ah,0dh,'$'
endTSR equ $
mcbList equ offset endTSR + 2 + 2
vecList 
equ
 mcbList + 710 + 2 + 10h + 1 + 400h
devLink equ vecList + 4 + 5  26 + 4 + 10  30h + 4
xmsList equ devLink + 2 + MaxHandles  2
emsList equ xmsList + 4 + 1024
crtMode equ emsList + 2 + 1Dh + 4 + 10h
tsrLen equ crtMode + 1
;
; DOS Environment Reserved by RI
; --------------------------------------------------
; Flag 'XX' 2 bytes
; Environment Segment 1 word
; Free MCBs <=710 bytes
; MCB segment 1 word
; MCB 5 bytes
; End flag 'MM' 1 word
; COM LPT ports 10h bytes
; LEDs status 1 bytes
; Packed vectors list <=400h bytes
; Flag 'CV' 2 bytes
; CVT First DPB pointer 4 bytes
; DPBs data <=526 bytes
; First DCB pointer 4 bytes
; Pointer to NUL 4 bytes
; All device driver datas <=30h10 bytes
; Flag 'XM' 2 bytes
; XMS free handle counter 2 bytes
; EMS free handle list <=100h4 bytes
; Flag 'EM' 2 bytes
; EMS free handle counter 2 bytes
; EMS free handle list <=1024 bytes
; EMS handle 1 word
; Number of pages 1 word
; Flag '--' 1 word
; Equipment List 1 word
; CRT 40:49h-66h 1dh bytes
; 40:A8h 1 dword
; BIOS User Data Area 40:F0--FF 10h bytes
; **
;
main: jmp main0
Print Macro Str
Lea dx, Str
call DisplayStr
endm
InstMsg db 'RAMinit Version 2.12 '
db 'Copyright (c) 1989-1994 by KingSoft Ltd. ',0dh,0ah,'$'
Msg0 db 'Already installed !',0dh,0ah,0ah
db 'For Help, type ""RI /?"". ',0dh,0ah,'$'
Msg_0 db 0ah,'Residents a new RAMinit copy [y/n] ? $'
Msg_2 db 'OK, RI No.'
Msg_RI db '2'
db ' residents successful !', 0dh,0ah,'$'
Msg1 db 'Activate with: $'
KeyMsg db 'Right_Shift$'
db 'Left_Shift$ '
KMsg1 db 'Left_Ctrl$ '
db 'Left_Alt$ '
db 'Right_Ctrl$ '
db 'Right_Alt$ '
KMsg2 db 'Ctrl$ '
db 'Alt$ '
db 'Ctrl$ '
db 'Alt$ '
PlusMsg db ' + $'
crlf db 0dh,0ah,'$'
HelpMsg db 'Programmed by Mr. Leijun Dec 1992', 0dh,0ah,0ah
db 'Usage: RI [options]',0dh,0ah,0ah
db '/H,/? Display this screen',0dh,0ah
db '/CLS Removes all TSR programs after current RI',0dh,0ah
db '/RET Removes TSR programs include current RI',0dh,0ah
db '/NEW Residents a new data copy of current environment',0dh,0ah
db '/ALL Removes all RI copies and all other tsr programs',0dh,0ah
db '/Sxyy.. Define Hotkey x=AuxHotkey yy..=shift status',0dh,0ah
db ' x=auxiliary hotkey (default is ""X"") ',0dh,0ah
db ' x equ ""1"" means need AuxHotkey',0dh,0ah
db ' yy..=shift status [CAScas]',0dh,0ah
db ' C: Left Ctrl A: Left Alt S: Left Shift',0dh,0ah
db ' c: Right Ctrl a: Right Alt s: Right Shift',0dh,0ah,0ah
db 'Example: ""RI /S1c"" means Hotkey is Right_Ctrl+X',0dh,0ah
db ' ""RI /S0Cc"" means HotKey is Left_Ctrl+Right_Ctrl',0dh,0ah
db ' ""RI /CLS"" equals simply press hotkey',0dh,0ah
db ' ""RI /RET"" Removes all TSRs after current RI and this RI',0dh,0ah
db 0ah
db 'Contact me for RAMinit problems: (01)2561155 Call 1997',0dh,0ah
db '$'
ErrMsg db 'ERROR: Invalid options !',0dh,0ah,0ah,'$'
WinErr db 7, 'Sorry, I cannot work in Windows DOS environment.',0dh,0ah,'$'
SetMsg db 7, 'Defines new Hotkey successful !',0dh,0ah,0ah,'$'
tsrOK db False
Main0:
cld
Print instMsg
call IsWinDos
or ax, ax
jz @@1
Print WinErr
mov ax, 4c00h
int 21h
@@1:
call HotKeyValid
mov cs:Status, 0
call EMS_test
call CmpDosVer
call CmpSideKick
call GetMachineID
call ModifyHotKeyPrompt
mov ax, 0c0d7h
int 2fh
mov es, ax
cmp word ptr es:[101h], 'IE' ; 'LEI'
jnz @@0
mov cs:Self, ax
@@0:
call CmdLine
call PrintHotKeyPrompt
cmp cs:tsrOK, true
jz @@2
call tsrReplyOK
@@2: cmp cs:tsrOK, true
jnz @@_2
call PrintCopies
@@_2:
mov word ptr cs:[100h], 'EL'
mov byte ptr cs:[102h], 'I'
push cs
pop es
push cs
pop ds
std
mov si, offset eof
mov cx, eof - offset Here
mov di, tsrLen
add di, cx
inc cx
rep movsb
cld
mov bx, tsrLen
jmp bx
Here:
mov ax,cs
mov es,ax
mov di,offset endTSR
mov cs:DataBegin, di
mov cs:NextDataSeg, -1
mov ax, 'XX'
stosw
in al, 0a1h
mov ah, al
in al, 21h
push ax
mov word ptr cs:old_8259, ax
xor ax, ax
out 21h,al ; CLI
call SaveOthers
call SetSelfInt
call BackupVecList
cmp cs:Power, true
jnz @@20
call BackupCVTchain
call BackupMemoryManager
@@20:
call BackupBiosData
sti
mov cs:Flag, ' ' ; no busy
mov cs:StopFlag, 0 ;
mov cs:tsrLength, di
call SetDosEnvSeg
cmp cs:Self, 0
jz @@29
push cs
pop ds
push cs
pop es
cld
mov cx, cs:tsrLength
mov si, cs:DataBegin
sub cx, si
mov di, 120h
mov cs:DataBegin, di
rep movsb
mov cs:tsrLength, di
@@29:
pop ax
out 21h, al ; STI
mov al, ah
out 0a1h, al
mov dx, cs:tsrLength
inc dx
int 27h
; ----------------------------------------------------------------------------
SetDosEnvSeg:
push ds
push es
mov ax, cs
@@10: mov es, ax
mov ax, es:[16h] ; Get father process psp segment
or ax, ax
jz @@11
mov bx, es
cmp ax, bx
jnz @@10
@@11:
mov es, word ptr es:[2ch] ; Get father process env segment
mov cs:DosEnv, es
pop es
pop ds
ret
; ----------------------------------------------------------------------------
SaveOthers:
mov ax, cs:[2ch] ; Env Seg
stosw
call backupMCB ; Current MCB
mov ax, 40h ; COM LPT Port
mov ds, ax
mov si, 0h
mov cx, 8
rep movsw
mov si, 17h ; LED status
lodsb
stosb
; call OpenLEDs
ret
; --------------------------------------------------------------------------
backupMCB:
mov ax, 'ZM'
stosw
push ds
push es
mov ah, 52h
int 21h ; Get MCB chain head
mov ax, es:[bx-2]
pop es
@@0: mov ds, ax
cmp byte ptr ds:[0], 'Z' ; End ?
jz @@20 cmp byte ptr ds:[0], 'M' ; Memory control block
jnz @@30 cmp word ptr ds:[3], 0 ; Nul mcb
jz @@10 cmp word ptr ds:[1], 0 ; Free MCB
jnz @@10
call SaveFreeMCB
@@10: inc ax
add ax, ds:[3]
jmp @@0
@@20:
call SaveFreeMCB
cmp ax, 0a000h
inc ax
jnb @@30
mov ax, 9fffh ; MS-DOS UMB
jmp @@0
@@30:
cmp ax, 0c000h ; 386MAX
ja @@90
mov ax, 0c020h
jmp @@0
@@90: ; Error ?
pop ds
mov ax, 'MM' ; Set MCB flag
stosw
ret
SaveFreeMCB:
stosw
xor si,si
movsb
movsw
movsw
ret
;
; push ax
; stosw
; xor si,si
; movsb
; movsw
; movsw
; pop ax
; cmp ax, 09fffh
; jnb @@3
; push ax
; push ds
; mov ds,ax
; cmp byte ptr ds:[0], 'M'
; pop ds
; pop ax
; jnz @@4
; mov ax, 09fffh ; MS-DOS UMB
; jmp @@0
; @@4: cmp ax, 0c000h
; ja @@3
; mov ax, 0c020h ; 386MAX
; jmp @@0
;
; --------------------------------------------------------------------------
OpenLEDs: push ax ; Open all LEDs
or al, 070h
mov ds:[17h], al
mov ah, 1 int 16h
mov cx, 4 ; Delay
@@20: push cx
xor cx, cx
@@21: loop @@21
pop cx
loop @@20
pop ax
mov ds:[17h], al
mov ah, 1 int 16h
ret
; --------------------------------------------------------------------------
SetSelfInt:
push es
push di
cmp cs:self, 0
jnz @@1
push cs
pop ds
mov ax,3509h
int 21h
mov word ptr cs:oldInt9_addr,bx
mov word ptr cs:oldInt9_addr[2],es
mov dx,offset NewInt9
mov ax,2509h
int 21h
mov ax,352Fh
int 21h
mov word ptr cs:oldInt2F_addr,bx
mov word ptr cs:oldInt2F_addr[2],es
mov dx,offset newInt2F
mov ax,252Fh
int 21h
mov ax,351Ch
int 21h
mov word ptr cs:oldInt1C_addr,bx
mov word ptr cs:oldInt1C_addr[2],es
mov dx,offset newInt1C
mov ax,251ch
int 21h
cli
jmp @@2
@@1:
mov es, cs:Self
inc es:Copies
@@_0: cmp es:NextDataSeg, -1
jz @@_1
mov
 es, es:NextDataSeg
jmp @@_0
@@_1: mov es:NextDataSeg, cs
@@2:
pop di
pop es
ret
; -----------------------------------------------------------------------
SaveCounter:
mov word ptr es:[di], 'EL'
mov byte ptr es:[di+2], 'I'
mov byte ptr es:[di+3], bl
xor bx, bx
add di, 4
ret
; -----------------------------------------------------------------------
DisplayStr: push cs
pop ds
mov ah, 9 int 21h
ret
; -----------------------------------------------------------------------
CmdLine:
push cs
pop ds
xor ax, ax
mov si, 80h
lodsb
or al, al
jnz @@1
ret
@@1:
mov cx, ax
dec ax
push ax
push si
@@0: lodsb
cmp al, ' '
jz @@0 cmp al, '/'
jnz @@2
lodsb
cmp al, 'S'
jz @@_2
cmp al, 's'
jnz @@2
@@_2:
call SetHotKey
Print SetMsg
mov ax, 4c00h
int 21h
@@2:
pop si
pop ax
push ax
push si
@@_3: lodsb
cmp al, 'A'
jb @@3 cmp al, 'Z'
ja @@3
add byte ptr ds:[si-1],20h ; DownCase
@@3: loop @@_3
pop si
pop cx
add si, cx
lodsb
cmp al, 's' ; CLS
jnz @@5 cmp word ptr ds:[si-3], 'lc'
jnz @@5 cmp cs:Self, 0
jz @Err
mov ax, 0c0d7h+1 int 2fh
@@5: cmp al, 'h' ; HELP
jz @help
cmp al, '?'
jz @help
cmp al, 't' ; RET
jnz @@6 cmp word ptr ds:[si-3], 'er'
jnz @@6
@@7:
cmp cs:Self, 0
jz @Err
mov ax, 0c0d7h+2 int 2fh
@@6: cmp al, 'w' ; NEW
jnz @@8 cmp word ptr ds:[si-3], 'en'
jnz @@8
mov cs:tsrOK, true
ret
@@8:
cmp al, 'l' ; ALL
jnz @@9 cmp word ptr ds:[si-3], 'la'
jnz @@9
mov ax, 0c0d7h+3 int 2fh
@@9:
cmp al, ' '
jnz @Err
ret
@Err:
Print ErrMsg
@help:
Print HelpMsg
mov ax
, 4c00h
int 21h
;---------------------------------------------------------------------------
tsrReplyOK:
cmp cs:Self, 0
jz @@1
Print Msg0
push es
mov ax, cs:Self
@@_10: mov es, ax
mov ax, es:NextDataSeg
cmp ax, -1
jnz @@_10
mov ax, es
@@_0: push ax
dec ax
mov es, ax
mov bx, es:[3]
pop ax
add ax, bx
inc ax
mov es, ax
cmp word ptr es:[0], 'OC'
jz @@_0
mov bx, cs
cmp ax, bx
pop es
jz @@2
Print Msg_0
mov ah, 1 int 21h
push ax
Print crlf
pop ax
cmp al, 'y'
jz @@3 cmp al, 'Y'
jz @@3
@@2: ; Print Msg_1
mov ax, 4c01h
int 21h
@@3:
@@1: mov cs:tsrOK, true
ret
PrintCopies:
cmp cs:Self, 0
jz @@1
push es ; Added -by- Mr. Lei
mov es, cs:Self ; Aug 24, 1993
mov al, es:Copies
inc al ; Total RI copies
push ax ; Set es = current mcb
mov ax, cs
dec ax
mov es, ax
pop ax
mov cx, 5 ; Search end of file name
mov bx, 8
@@10: inc bx
cmp byte ptr es:[bx], 20h
jz @@20 cmp byte ptr es:[bx], 0ffh
jz @@20 cmp byte ptr es:[bx], 00h
jz @@20
loop @@10
@@20: ; Set current RI no
mov byte ptr es:[bx], ':' ; ""RI:2""
mov byte ptr es:[bx+1], al
cmp bx, 8+7
jnb @@30
mov byte ptr es:[bx+2], 0
@@30:
pop es
mov cs:Msg_RI, al
Print Msg_2
@@1: ret
;---------------------------------------------------------------------------
; Backup Interrupt Vector List
;
BackupVecList:
push ds
push cs
pop es
xor si,si ; Vectors
mov ds,si
movsw
movsw
xor bx, bx
mov cx,00ffh
@@0: lodsw
xchg dx, ax
lodsw
cmp ax, es:[di-2]
jnz @@1 cmp dx, es:[di-4]
jz @@2
@@1: or bx, bx
jz @@3
call SaveCounter
@@3: xchg dx, ax
stosw
xchg dx, ax
stosw
loop @@0
jmp @@4
@@2: inc bx
loop @@0
call SaveCounter
@@4:
pop ds
ret
;
;-----------------------------------------------------------------------------
BackupCVTchain:
mov ax, 'VC'
stosw
push ax
push bx
push cx
push ds
push es
mov ah, 52h
int 21h ; ES:BX -- DOS table as described below
; --------------------------------------------------------------------
push es ; DPB chains
push bx
lds si, es:[bx]
push cs
pop es
mov ax, si
stosw
mov ax, ds
stosw
mov bx, cs:cvtOfs
xor cx, cx
@@1: mov al, ds:[si+1]
stosb
mov ax, ds:[si+bx+12h]
stosw
mov ax, ds:[si+bx+14h]
stosw
inc cx
lds si, ds:[si+bx+18h]
cmp si, -1
jnz @@1
; mov ax, 5
; mul cl
; add ax, 4
; add cs:tsrLength, ax
pop bx
pop es
; --------------------------------------------------------------------
push es ; DCB file control blocks
push bx
les bx, es:[bx+4]
@@11: cmp word ptr es:[bx], -1
jz @@10
les bx, es:[bx]
jmp @@11
@@10:
mov ax, es
xchg ax, bx
push cs
pop es
stosw
xchg ax, bx
stosw
pop bx
pop es
; add cs:tsrLength, 4
; ---------------------------------------------------------------------
push es ; Device Driver Chains
pop ds
add bx, 22h
mov si, bx ; NUL
pop es
mov ax, si
stosw
mov ax, ds
stosw
xor cx, cx
xor bx, bx
@@9: push si
mov cl, 5
rep movsw
inc bx
pop si
lds si, ds:[si]
mov ax, si
inc ax
jnz @@9
pop ds
pop cx
pop bx
pop ax
ret
; ----------------------------------------------------------------------------
BackupBiosData:
mov ax, '--'
stosw
push ds
push si
mov si, 40h
mov ds, si
mov si, 10h
movsw
mov si, 0a8h
movsw
movsw
mov si, 49h
mov cx, 1dh
rep movsb
mov si, 0f0h
mov cx, 8
rep movsw
pop si
pop ds
ret
; ---------------------------------------------------------------------------
BackupMemoryManager:
push cs
pop es
push ds
push es
call SaveXMSstatus
call SaveEMSstatus
pop es
pop ds
ret
;---------------------------------------------------------------------
SaveEMSstatus:
test cs:status, EMSbit
jnz @@1
ret
@@1:
mov ax, 'ME'
stosw
inc di
inc di
push di
mov ah, 4dh
int 67h
pop di
mov es:[di-2], bx
shl bx, 1
shl bx, 1
add di, bx
ret
; -------------------------------------------------------------------
SaveXMSstatus:
call XMS_test
test cs:status, XMSbit
jnz @@1
ret
@@1:
mov ax, 'MX'
stosw
mov dx, 1
call XMS_alloc
jnz @@_1
xor cx, cx ; XMS alloc failure
stosw
ret
@@_1:
push dx
sub dx, MaxHandles  10
@@2:
push dx
call XMS_Lock
pop dx
jnz @@3 cmp bl, 0a2h
jnz @@4
add dx, 10
jmp @@2
@@3: push dx
call XMS_unlock
pop dx
@@4:
mov cs:handle_begin, dx
pop dx
push dx
call XMS_bstat
xor cx, cx
mov cl, bl
inc cx
pop dx
call XMS_Free
mov dx, cs:Handle_begin
push cx
push cs
pop es
mov ax, cx
stosw
@@5: push dx
call XMS_Lock
pop dx
jnz @@6 cmp bl, 0a2h ; Handle invalid
jz @@7
@@6: call XMS_unlock
add dx, 10
jmp @@5
@@7: mov ax, dx
stosw
add dx, 10
loop @@5
pop cx
ret
; ------------------------------------------------------------------
XMS_test:
push es
mov ax, 4300h
int 2fh
cmp al, 80h
jnz @@9
mov ax, 4310h
int 2fh
mov cs:XMS_control, bx
mov cs:XMS_control[2], es
or cs:Status, XMSbit
@@9:
pop es
ret
XMS_stat:
mov ah, 0
call dword ptr cs:xms_control
mov hma_exist, dl
ret
hma_exist db 0
XMS_alloc:
mov ah, 9
call dword ptr cs:xms_control
or ax, ax
ret
XMS_lock:
mov ah, 0ch
call dword ptr cs:xms_control
or ax, ax
ret
XMS_unlock:
mov ah, 0dh
call dword ptr cs:xms_control
or ax, ax
ret
XMS_bstat:
mov ah, 0eh
call dword ptr cs:xms_control
or ax, ax
ret
XMS_free:
mov ah, 0ah
call dword ptr cs:xms_control
or ax, ax
ret
; ----------------------------------------------------------------------------
EMS_test:
push cs
pop ds
mov dx, offset EMMname
mov ax, 3d00h
int 21h
jc @@2
mov bx, ax
mov ah, 3eh
int 21h
or cs:Status, EMSbit
@@2:
ret
EMMname db 'EMMXXXX0',0
; -----------------------------------------------------------------------------
SetHotKey:
xor bx, bx
lodsb
push ax
@@1: lodsb
cmp al, 0dh
jz @@9 cmp al, 'C'
jnz @@2
or bl, LeftCtrl
jmp @@1
@@2:
cmp al, 'c'
jnz @@3
or bl, RightCtrl
jmp @@1
@@3:
cmp al, 'A'
jnz @@4
or bl, LeftAlt
jmp @@1
@@4:
cmp al, 'a'
jnz @@5
or bl, RightAlt
jmp @@1
@@5:
cmp al, 'S'
jnz @@6
or bl, LeftShift
jmp @@1
@@6:
cmp al, 's'
jnz @@7
or bl, RightShift
jmp @@1
@@7: pop ax
jmp @Err
@@9:
mov cs:HotKey, bl
pop ax
mov cs:AuxHotKey, 2dh ; 'X' scan key
cmp al, '1'
jz @@29
mov cs:AuxHotKey, 0
@@29:
cmp cs:Self, 0
jz @@30
push es
mov es, cs:Self
mov es:HotKey, bl
mov bl, cs:AuxHotKey
mov es:AuxHotKey, bl
pop es
@@30:
call GetRunFileName
mov ax, 3d02h
int 21h
jc @@10
push cs
pop ds
mov bx, ax
mov cx, 4
mov dx, 100h
mov ah, 40h
int 21h
jc @@10
mov ax, 4200h
xor cx, cx
mov dx, 17h
int 21h
jc @@10
mov cx, 1
mov dx, offset AuxHotKey
mov ah, 40h
int 21h
jc @@10
mov ah, 3eh
int 21h
@@10:
ret
; -----------------------------------------------------------------------
GetRunFileName:
; Return:
; DS:DX Pointer of this run file name ASCIIZ string
push ax
push bx
push cx
push si
push di
push es
push cs
pop es
mov ax, es:[2ch]
mov es, ax
xor di, di
mov cx, 1000h
xor al, al
@@1: repnz scasb
cmp es:[di], al
loopnz @@1
mov dx, di
add dx, 3
push es
pop ds
pop es
pop di
pop si
pop cx
pop bx
pop ax
ret
; ---------------------------------------------------------------------------
GetMachineID:
push es
mov KBD102,True
mov ax,40h
mov es,ax
test byte ptr es:[96h], 00010000b
jnz @@1
mov Kbd102,False
@@1:
xor ax,ax
dec ax
mov es,ax
mov al,es:[0eh]
mov cs:MachineID, al
pop es
ret
; ---------------------------------------------------------------------------
ModifyHotKeyPrompt:
cmp cs:Kbd102, True
jz @@9
push cs
pop es
push cs
pop ds
mov cx, 124
mov si, offset KMsg2
mov di, offset KMsg1
rep movsb
@@9: cmp cs:MachineID, 0fch
jna @@10
mov cs:clsStrcolor, 70h ; Mono
mov cs:clsStr, 70h
@@10:
ret
; ---------------------------------------------------------------------------
PrintHotKeyPrompt:
Print Msg1
mov al, cs:HotKey
mov ah, al
shr al, 1
shr al, 1
and ax, 33ch
or al, ah
mov dx, offset KeyMsg
@@40:
or ax, ax ; Mr. Lei 4/25/1993
jz @@_42
shr al, 1
push ax
jnc @@41
push ax
call ColorDisplayStr
; mov ah, 9
; int 21h
pop ax
or al, al
jz @@42
push dx
mov dx, offset PlusMsg
call ColorDisplayStr
; Print PlusMsg
pop dx
@@41: add dx, 12
pop ax
jmp @@40
@@42: pop ax
@@_42: cmp cs:AuxHotKey, 0
jz @@43 cmp cs:HotKey, 0 ; Mr. Lei
jz @@_43
mov dx, offset PlusMsg
call ColorDisplayStr
; Print PlusMsg
@@_43: mov dx, offset AuxHotKeyName
call ColorDisplayStr
; Print AuxHotKeyName
@@43:
Print crlf
ret
ColorDisplayStr:
push bx
push cx
push dx
push si
mov bl, 0fh
mov si, dx
xor bh, bh
mov cx, 1
@@1: lodsb
cmp al, '$'
jz @@2
or al, al
jz @@2
push cx
mov ah, 09h
int 10h
mov ah, 3 int 10h
inc dl
mov ah, 2 int 10h
pop cx
jmp short @@1
@@2:
pop si
pop dx
pop cx
pop bx
ret
; ---------------------------------------------------------------------------
CmpSideKick:
xor ax, ax
mov es, ax
les bx, es:[20h]
cmp word ptr es:[bx-4], 4b53h
jnz @@1 cmp word ptr es:[bx-2], 4942h
jz @@2
@@1: mov es, ax
les bx, es:[94h]
cmp word ptr es:[bx-2], 4b53h
jz @@2
ret
@@2: or cs:Status, SKbit
ret
; ---------------------------------------------------------------------------
CmpDosVer: mov ah, 30h
int 21h
cmp al, 3
jb @@1 cmp al, 3
jna @@2
mov cs:cvtOfs, 1
ret
@@2: mov cs:cvtOfs, 0
ret
@@1: Print DosVerErr
mov ax, 4cffh
int 21h
DosVerErr db 'Sorry, DOS version too lower !',0dh,0ah,'$'
HotKeyValid:
cmp cs:HotKey, 0
jnz @@_1
cmp cs:AuxHotKey, 0
jnz @@_1
Print HotKeyErr
mov ax, 4cfeh
int 21h
@@_1: ret
HotKeyErr db 'Sorry, please setup hotkey again. ',0dh,0ah,'$'
eof:
ends
end Start
; ------------- The End ! ---------------------------------------------------
反正我这个菜鸡是编不出来啊，大兄弟你们怎么样;","别说20年前的雷军，就是现在的雷军，让他复习2个月去面试阿里的p8，都毫不费力...当年雷总的汇编和c水平，没有任何一个现代程序员能够望其项背。一旦遇到极其底层的优化问题，雷总吊打现阶段99%程序员不是吹的。这群只会用python的，咋可能玩的过雷总
2019.10.30更新
哇...收到了入驻知乎以来最多的赞hhhh
评论中提到了一些问题，首先不是汇编吹哈，只是单纯来看面临的挑战的话，越古老可能越难，对于一些初学者，面向对象已经很难了，更别说c和汇编面向内存思考了。也不是说python就不好，毕竟没有元老的铺垫，也不会诞生这么多应用层的语言。科学的大楼是一层一层盖起来的，更多的应该尊敬那些最底层的建设者，就是这个意思～
感谢大家的批评，欣然接受！望其项背我也不知道用的对不对，所以就当用错了大家看个乐吧哈哈哈。99%也确实太过绝对，但只是表达对雷总的尊重。
但有一个批评不能苟同
，大家可以移步评论区找找看，开头的第一句话是：
“区区一个新加坡的硕士的言论，可笑之至”
你可以说我的水平不如你，你可以说我发的paper不够好，
但你如果觉得你读过博士，拿头衔压人，我觉得你不配博士的名头，字里行间处处是宣扬自己海归博士学成归来，你这个小屁孩这么低的学历也好意思说话，那你这个博士不如还给美国，顺便做个学历认证，让我看看大牛到底是哪个top10藤校毕业，敢说出区区NUS的话。
这种无脑喷不想较真。","阿里云P10 褚霸，真名余锋，江湖人称霸爷。现阿里云弹性计算负责人，曾一手将数据库团队带到国内云数据库顶尖水平。
　　褚霸身上标签众多，中国第一代技术网红，软硬兼修，是阿里云备受外界关注的技术大牛。知乎网友对他有一句评价很经典：对于计算机的了解到了庖丁解牛的程度。
　　磁带机和自建实验室
　　上世纪八十年代初，中国社会对于科技发展的关注开始趋热。
　　偶然一次，当时大约 7 岁的褚霸拆了家里的磁带机，结果装不回去了，索性开始思考这个东西为什么能发出声音。从此他一发不可收拾，开始偷家里钱买万用表，电焊器，组建了一个小实验室。
　　“我发现把交流电接到直流电机里面去不会转，但是装四个二极管进去它就转了。后来上大学学了电路原理，才明白为什么。”少年褚霸成为了一名当时时髦的无线电爱好者，这对他的未来影响深远。
　　“后来面对未知领域时，你有过去的一些经历，其实你是不怕的。探索出规律，自然也就明白了道理。”褚霸说。
　　大学时期和病毒的故事
　　大学时期的褚霸是个潮男，留着长发，还留着胡子，甚至常常去美容院洗脸做面膜。褚霸的理论是成为校园名人需要“软硬件结合”，形象是硬件，能力是软件。某一天，他突发奇想，要做个病毒来显示能力。
　　那是 1994 年，互联网没有普及，除了学校的 286 电脑，没有其他任何资源。褚霸坐了很久的火车去省城，淘遍各大书店买回几本关于计算机杀毒的书，开始反推病毒怎么写。学徒阶段，
褚霸
就常常把计算机弄死机，最夸张的时候一天要重启上百次。
　　临近崩溃的他找到一个叫 RAMInit 的工具，可以用于清除内存的驻留程序。24 年后，褚霸还清晰记得这个小工具，长度是 4156 字节，在它的二进制文件里留有作者的签名：Lei Jun(雷军)，没错，就是小米创始人雷军。受此影响，后来褚霸也习惯在自己编译出的二进制文件里，留下签名: “YuFeng is a good boy”。","今天99%的程序员做的事情，o雷军学习三个月就可以做出来。
雷军当年能做到的事情，o今天99%的程序员学习三年也不一定做的出来。","雷军技术还是非常牛的，大学的时候还在学校看到过他出的关于病毒的书。
如果技术不溜估计也不会被
求伯君
这样的大佬看上眼。
不止雷军，
张小龙
做产品经理之前也是写代码的，Foxmail最早就是他一个人开发的。
还有
李彦宏
，创业之前就是硅谷知名的搜索引擎专家，那时候布林佩奇这哥俩还算后辈，谁知世事难料。"
,,,,,,,,,,,,,,,,,,,,,
如果让无所不能的神来写代码，是否能写出没有bug的软件？,软件有那么多bug的原因是不是程序员水平低？如果换一个智商无限高的神来写会怎么样,"不能，你永远无法知道你的用户会怎么用你的产品，他们测试流传着一个广为人知的段子：
一个测试工程师走进一家酒吧，要了一杯啤酒
一个测试工程师走进一家酒吧，要了一杯咖啡
一个测试工程师走进一家酒吧，要了0.7杯啤酒
一个测试工程师走进一家酒吧，要了-1杯啤酒
一个测试工程师走进一家酒吧，要了2^32杯啤酒
一个测试工程师走进一家酒吧，要了一杯洗脚水
一个测试工程师走进一家酒吧，要了一杯蜥蜴
一个测试工程师走进一家酒吧，要了一份asdfQwer@24dg!&*(@
一个测试工程师走进一家酒吧，什么也没要
一个测试工程师走进一家酒吧，又走出去又从窗户进来又从后门出去从下水道钻进来
一个测试工程师走进一家酒吧，又走出去又进来又出去又进来又出去，最后在外面把老板打了一顿
一个测试工程师走进一
一个测试工程师走进一家酒吧，要了一杯烫烫烫的
锟斤拷
一个测试工程师走进一家酒吧，要了NaN杯Null
1T测试工程师冲进一家酒吧，要了500T啤酒咖啡洗脚水野猫狼牙棒奶茶
1T测试工程师把酒吧拆了
一个测试工程师化装成老板走进一家酒吧，要了500杯啤酒并且不付钱
一万个测试工程师在酒吧门外呼啸而过
一个测试工程师走进一家酒吧，要了一杯啤酒';DROP TABLE 酒吧
测试工程师们满意地离开了酒吧。
然后一名顾客点了一份炒饭，酒吧炸了","研发工程师慢慢走到屏幕前，把鼠标移动到编译按钮上。他只能先在本地运行代码，以防线上服务被未知的Bug弄伤。接着，三位工程师也都开始运行代码了。
“看上去太脆弱了，真怕把它碰坏了。”QA小声说。
“找不到一点儿Bug，”实习生惊奇地说，“这代码
鲁棒性
太强了。”
“能强到什么程度呢？”研发问。
为了解答这个问题，QA从文件夹中翻出了一个
jar包
，那是一个压测工具。她用单机发压模式开始运行，从服务器的日志上，可以看到打印的异常信息。日志上仍然没有显示出error。
“当前压测QPS是多少？”研发问。
“峰值的一百倍。”QA指指显示器一角的一个数字，同时把压测流量调到一千倍。
压测后的服务依然没有任何error。
“你这东西坏了吧？”实习生说。
QA把压测流量注入到自己的测试机上，其他三人凑过来一起看着显示屏，只见压力被放大一千倍的测试机，肉眼看上去很正常，但异常监控曲线如同乱石滩一样粗糙。QA又把压测流量重新打在本地服务上，监控上再次出现了空白的异常打点，与压力没有放大的时候无异。
“把倍数再调大十倍。”研发说。
这超出了单机发压的能力，QA进行了一连串的操作，把发压机由单机模式切换到集群发压模式，现在放大倍数是一万倍。
放大后的异常监控仍是一片空白。而人类技术所能编写的最完美的代码，压力只放大上千倍后其问题就暴露无遗，正像格利弗眼中的巨人美女的脸。
“调到十万倍。”实习生说。
他们看到的仍是毫无异常。
“一百万倍。”
毫无异常。
“一千万倍！”
在这个放大倍数下，已经可以看到，但屏幕上显示的仍是毫无异常，看不到一点儿Bug的迹象，其服务可用性与没有被压测的服务毫无区别。
“再把倍数调大些！”
QA摇摇头，这已经是发压集群所能达到的极值了。
……
“真有没有Bug的代码？”QA惊叹道。
“有，”研发说，“Hello World就没有Bug。”
“但这东西的代码量是正常的！”
研发离开到工位上寻找着什么，回来时手里拿着一只猴子，可能是有人在做故障注入时丢下的，其他人来不及制止，他已用力把猴子甩到了电脑上！他只看到一个""WARN""，这日志是出现在控制台上的，由于是本地环境，其他三人看不到。研发接着将鼠标移动到日志打印的代码行打断点，QA立刻用调试模式debug那一行。
一千万的压力倍数下，仍是没有任何error日志。
研发颓然地把猴子扔掉，不再看代码，低头深思起来，三位工程师的目光，还有知乎上数百万工程师的目光，都集中到他身上。
“只能猜了。”研发抬头说，“这项目的代码逻辑，像说明书一样清晰，同时能够自解释，知道这种代码有多难写吗？不用编译器，用记事本就可以看懂。”
“这就是它毫无Bug的原因！”QA说，她和另外两位工程师都明白研发的话意味着什么：在普通的业务代码中，代码的历史包袱是很多的，把祖传代码优化掉，不比让程序员写注释容易多少。
“怎么才能做到这一点？”
“只有一个：产品经理不改需求。”透过屏幕的反射可以看到，研发的额头上已满是冷汗。
“这……不是等于业务不迭代了吗！”
“业务确实不迭代了……”研发发出一阵冷笑，听起来有种令人胆寒的凄厉，三位工程师也同样知道这冷笑的含义：那就代表程序员也要失业了。
“那……我们该怎么办？”实习生脱口问道。
“谁知道？也许它只是一个故事，但带给我们的是另外一个信息……”研发说，同时把目光从代码上移开。
这句话带来一阵死寂，就在现场的另外三名工程师和知乎上的百万人咀嚼其含义时，研发突然说：“快点赞。”这三个字是低声说出的，但紧接着，他扬起双手，声嘶力竭地大喊：“程序员们，
快――点――赞――啊
！","bug是个主观概念，没有客观衡量标准，客户觉得它是bug它就是bug，即便在需求文档上没有明文说出来。所以不可能做到没有bug。
但是万能的神或许能够催眠客户让客户认为这个程序就是没bug，这样的话自然就写出没有bug的程序了。","bug有很多种，全知全能不会出错的神只能防止硬性bug的出现，但很多bug并不是简单的错误，而是反映了程序不够 “聪明”。
第一类神没办法解决的bug是设计缺陷。
这是业务逻辑上的漏洞，比如老师的课选满了，你想让老师加名额，结果教务处让你找老师，老师让你找教务处。
这种bug不是程序员nb能解决的，需要改需求。
第二类是对悖论问题的处理方式。
两面镜子对着放，左边的镜子反射了右边的镜子里左边的镜子反射的右边的镜子里左边的镜子反射的右边的.........
又或者是一个只说真话的人说：“我说的这句话是谎话”。
显然这种问题是不可解的，但计算机该如何处理呢？
是触发报错，还是什么都不做，还是只处理一次，还是设置固定的递归深度，还是直接向屏幕打印一句颇有哲理的话，比如 “如果有人能理解世界，那么这个人一定是无法理解的。”
直接报错是对的吗？程序接受了无法处理的输入，那就应该报告异常。可报错本身会对系统的执行流程进行破坏，错误应该以什么方式被报出来，程序应该终止还是继续执行，哪些模块要回档，回档到什么程度，都是问题。
比如支付宝交易，如果你支付的时候断网了，那应该等下次连上网的时候自动完成支付，还是立刻把这次交易作废呢？如果自动完成支付，应该直接谎称交易成功，然后在后台偷偷把事给办了，来获得丝滑的用户体验，还是应当提示用户，添加到挂起列表呢？
当然，为了确保安全性，程序会直接告诉你网络中断，交易失败，但如果神把安全性提升了一大截，那是不是这个新特性就能被允许了呢？
因此，对于很多答案不明确的问题，不同的时期，不同的人，有着不同的偏好，程序聪明与否，非常主观。
对于镜子反射的问题，目前的游戏大都是计算一次，即为，左边的镜子反射了右边的镜子，却看不到右边的镜子里反射的东西。
但如果是非实时渲染，通常会计算若干次反射，有一定数量上限。
现实中，光碰到镜子，会被吸收一部分能量，在两个镜子间来回反射直到能量全部被吸收或被反射到两个镜子以外的地方。
计算次数多了，玩家会说有bug，看见镜子就卡。计算次数少了，玩家也会说有bug，镜子里不反射镜子，不真实。
第三类是对于规则以外的输入的处理
如果在一个计算器里输入汉字“一加一”，程序应不应该正常运行呢？如果汉子可以，那其他国文字，甚至外星文，应不应该被支持呢？
游戏里有一个商人，可以接受物物交换，让你用装了消音器的手枪换任务道具。
那装了消音器，又装了瞄准镜的手枪可以不可以？瞄准镜要不要在交易后返还？
弹夹装满，弹夹打空，弹夹半满，]b弹夹，哪种可以交换？
狙击枪比手枪值钱，给他狙击枪可不可以？长得像手枪的冲锋枪行不行？
背包满了，先给他一个手枪，待会补一个消音器行不行？
新手枪，用过了的手枪，卡壳了但还没修好的手枪，损坏了的手枪，哪些能被接受？
显然，只有全新的，型号一致，装且仅装了消音器，上满子弹的手枪才是标准输入，但如果游戏这么死板，会被玩家喷。甚至你还要特意为了做任务而跑一趟商店，买一把根本不需要的手枪，而不能直接从背包里掏出一个给他。
但如果兼容性太强，只要拿一个价值比消音手枪高的物品就能交换，那游戏的流程可能会被破坏，比如原本这是一个射击训练任务，给你一把无限子弹的枪打靶，打完靶回收，结果你直接用别的东西代替了。或者是游戏有意引导玩家做一些事，但玩家直接用策划想不到的方式给过了。这种“聪明”，没起到好作用，反而成为了新的bug。
无敌的代码之神，也没法做到尽善尽美，永远有一些人们不喜欢的特性被标记为bug。或者用户本身对程序的认知有误，用户以为这个按钮是xxx，没想到却xxx。（这也不是代码的锅，是设计问题，引导不到位）
简而言之，没bug，不可能的。","不知道写圣经的上帝算不算无所不能的神。但圣经的水平嘛……最蹩脚的码农看不见警告，而上帝连错误都看不见。
转自： 
https://www.
douban.com/note/1327773
08/
 
错误百出的圣经――方舟子
 我在网上宣扬了一下进化论，揭穿了某些神创论者的把戏，很让有些人头疼。 
有信徒来信指教我：“不管你怎么说，进化论与圣经不符，所以一定是错的，因为 
圣经记录的是上帝的话，一句顶万句，句句是真理。你现在胆敢为进化论辩护，乃 
是犯了大罪，将来是要下地狱的，赶快忏悔，皈依我教，或许还有得救的可能。要 
皈依我教，第一步就是要读圣经。圣经的作者有四十几位，但是实际作者只有一个 
，那就是上帝。所以圣经的成书虽然长达一千多年，却首尾一贯，前后呼应，没有 
一丝一毫的纰漏，这正是上帝存在的最好证明啊。”说得我砰然心动，赶快借了本 
圣经来读。这一读不得了，人家说没有一丝一毫的纰漏，我怎么尽看到前后不一致 
、自相矛盾、违反常识的错误呢？屈指一算，有好几十处。定是我弱智，没能领会 
上帝他老人家的意思。我知道网上圣经专家不少，特提出我的疑问请专家们指正。 
１、上帝先造动物还是先造人？是同时造男造女还是先造男后造女？ 
说法一：〔创１：２３〕“神就造出大鱼和水中所滋生各样有生命的动物，各 
从其类；又造出各样飞鸟，各从其类。……是第五日。”“于是神造出野兽，各从 
其类；牲畜，各从其类；地上一切昆虫，各从其类。”“神就照着自己的形象造人 
，乃是照着他的形象造男造女。……是第六日。” 
说法二：〔创２：７〕“耶和华神用地上的尘土造人，将生气吹在他鼻孔里， 
他就成了有灵的活人，名叫亚当。”“耶和华神说：‘那人独居不好，我要为他造 
一个配偶帮助他。’耶和华神用土所造成的野地各样走兽，和空中各样飞鸟，都带 
到那人面前看他叫什么。”“耶和华神就用那人身上所取的肋骨，造成一个女人， 
领她到那人跟前。” 
比较一下，我们会发现，“创世纪”第一章、第二章有关上帝创造万物的顺序 
的说法截然不同： 
第一章：天地光→空气水→植物→日月星→动物→人（有男有女） 
第二章：天地→男人→植物→动物→女人 
神创论者是试图用“创世纪”来代替进化论的，但这第一章和第二章自相矛盾 
，不知道我们应该相信哪一章？ 
２、蛇吃土？ 
〔创３：１４〕“神对蛇说：‘你既作了这事，就必受咒诅，比一切的牲畜野 
兽更甚；你必用肚子行走，终身吃土。……’” 
不必是动物学家，一般的人也知道蛇不吃土，难道上帝的咒诅一点效用都没有 
？ 
３、蝙蝠是鸟？ 
〔利１１：１３〕“（上帝对摩西、亚伦说）‘雀鸟中你们当以为可憎不可吃 
的，乃是雕、狗头雕、红头雕、鹞鹰、小鹰与其类；……戴任与蝙蝠。” 
〔申１４：１１〕“（摩西重复上帝的教导）‘凡洁净的鸟，你们都可以吃。 
不可吃的是雕、狗头鹰、……戴任与蝙蝠。” 
今天恐怕连小学生都知道蝙蝠是哺乳动物而不是鸟，当时的人不知道不奇怪， 
但是上帝居然不知道！ 
４、兔子反刍？ 
〔利１１：１〕“耶和华对摩西、亚伦说：‘你们晓谕以色列人，在地上一切 
走兽中可吃的乃是这些：凡蹄分两瓣、倒嚼的走兽，你们都可以吃……兔子，因为 
倒嚼不分蹄，就与你们不洁净。猪，因为蹄分两瓣，却不倒嚼，就与你们不洁净。 
这些兽的肉，你们不可吃，死的你们不可摸，都与你们不洁净。” 
莫非当时的兔子乃是反刍（倒嚼）动物，现在进化了？另外，今天的基督徒还 
有多少人遵循上帝的教导，不吃兔肉、猪肉，甚至连摸一下都不可以？ 
５、昆虫四足？ 
〔利１１：２０〕“（上帝继续说）‘凡有翅膀用四足爬行的物，你们都当以 
为可憎。只是有翅膀用四足爬行的物中，有足有腿，在地上蹦跳的，你们还可以吃 
。其中蝗虫、蚂蚱、蟋蟀与其类；蚱蜢与其类；这些你们都可以吃。” 
不必上什么动物学课，小时候抓过上帝提到的蝗虫、蚂蚱、蟋蟀的人都知道它 
们是六足，而不是四足。上帝若非未卜先知，何不屈尊抓一只蝗虫研究一下？ 
６、一对还是七对？ 
〔创７：１〕“耶和华对挪亚说：‘……凡洁净的畜类，你要带七公七母；不 
洁净的畜类，你要带一公一母；空中的飞鸟，也要带七公七母，可以留种，活在全 
地上；……” 
〔创７：８〕“洁净的畜类和不洁净的畜类，飞鸟并地上一切的昆虫，都是一 
对一对的，有公有母，到挪亚那里进入方舟，正如神所吩咐挪亚的。” 
上帝明明说洁净的畜类和飞鸟，要各带七对，挪亚竟敢偷懒，只各带一对，然 
而却说“正如神所吩咐挪亚的。” 
７、天有柱、地有基？ 
〔伯：２６：１１〕“天的柱子因他（神）的斥责震动惊奇。” 
〔伯：３８：４〕“（上帝对约伯说）我立大地根基的时候，你在那里呢？你 
若有聪明只管说吧！你若晓得就说，是谁定地的尺度？是谁把准绳拉在其上？地的 
根基安置在何处？地的角石是谁安放的？” 
这一段，令人想起了中国的神话：天圆地方，天是靠四根柱子支撑着的。原教 
旨主义者要我们相信圣经上的每一句话，看来连天文学、地理学都得改写了。 
８、地球是平的？ 
〔太：４：８〕“魔鬼又带他（耶稣）上了一座最高的山，将世上的万国与万 
国的荣华都指给他看” 
“万国”，查英文版，指的是世上所有的王国(all the kingdoms of the wor 
ld)。地球是球形的，不论站在多高的山上，都不可能看遍整个地球，只有地球是平 
的才有可能。显然圣经的作者认为地球是平的，但是远在此之前，希腊学者已经知 
道地球是球形的，并且准确地测出了它的半径。 
９、上帝就是魔鬼？ 
〔撒下：２４：１〕“耶和华又向以色列人发怒，就激动大卫，使他吩咐人去 
数点以色列人和犹太人。” 
〔代上：２１：１〕“撒但起来攻击以色列人，激动大卫数点他们。” 
根据上下文，这两段话描述的是同一件事。这激动大卫的究竟是耶和华还是撒 
但？或者耶和华就是撒但？ 
１０、上帝能不能看见？ 
说法一：可见 
〔创３２：３０〕“我面对面见了神，我的性命仍得保全。” 
〔出２４：９〕“摩西、亚伦、拿答、亚比卢，并以色列长老中的七十人，都 
上了山。他们看见以色列的神，……他们观看了神，他们又吃又喝。” 
〔出３３：１１〕“耶和华与摩西面对面说话，好象人与朋友说话一样。” 
〔出３３：２３〕“（上帝对摩西说）然后我要将我的手收回，你就得见我的 
背，却不得见我的面。” 
〔摩９：１〕“我看见主站在祭坛旁边。” 
说法二：不可见 
〔出３３：２０〕“（耶和华）又说：‘你不能看见我的面，因为人见我的面 
不能存活。” 
〔约１：１８〕“从来没有人看见神，只有在父怀里的独生子将他表明出来。 
” 
〔提前６：１５〕“到了日期（最后审判），那可称颂，独有权能的万王之王 
、万主之主，就是那独一不死、住在人不能靠近的光里，是人未曾看见、也是不能 
看见的，要将他显明出来。” 
错误百出的圣经（二） 
?方舟子? 
先解决一个上一帖的问题： 
〔创７：１〕“耶和华对挪亚说：‘……凡洁净的畜类，你要带七公七母；不 
洁净的畜类，你要带一公一母；空中的飞鸟，也要带七公七母，可以留种，活在全 
地上；……” 
〔创７：８〕“洁净的畜类和不洁净的畜类，飞鸟并地上一切的昆虫，都是一 
对一对的，有公有母，到挪亚那里进入方舟，正如神所吩咐挪亚的。” 
有人说，后一条“一对一对”也可以理解成是七对分成七次，一对一对地进入 
方舟，所以与第一条并不矛盾。好，有点道理，但是在前面上帝对挪亚还吩咐过一 
次，明显地说是一对： 
〔创：６：１９〕“凡有血肉的活物，每样两个，一公一母，你要带进方舟， 
好在你那里保全生命。飞鸟各从其类，牲畜各从其类，地上的昆虫各从其类；每样 
两个，要到你那里，好保全生命。” 
还是自相矛盾。 
１１、谁杀了歌利亚？ 
〔撒上１７：４〕整整一章描述大卫怎样杀死歌利亚。 
〔撒下２１：１９〕“又在歌伯与非利士人打仗，伯利恒人雅雷俄珥金的儿子 
伊勒哈难杀了迦特人歌利亚。” 
这个战功究竟属于谁？ 
１２、上帝试不试探人？ 
〔创２２：１〕“这些事后，神要试验亚伯拉罕，就呼叫他说……” 
〔雅１：１３〕“人被试探，不可说：‘我是被神试探；’因为神不能被恶试 
探，他也不试探人。” 
１３、有没有人升过天？ 
〔王下２：１１〕“他们正走着说话，忽有火车火马，将二人隔开，以利亚就 
乘旋风升天去了。” 
〔约３：１３〕“除了从天降下，仍旧在天的人子，没有人升过天。” 
１４、我们究竟应该怎样回答愚昧人？ 
〔箴２６：４〕“不要照愚昧人的愚妄话回答他，恐怕你与他一样。” 
〔箴２６：５〕“要照愚昧人的愚妄话回答他，免得他自以为有智慧。” 
１５、担子该怎么担当？ 
〔加６：２〕“你们各人的重担要互相担当，如此，就完全了基督的律法。” 
〔加６：４〕“各人应当察验自己的行为；这样，他所夸的就专在自己，不在 
别人了，因为各人必担当自己的担子。” 
１６、上帝会不会后悔？ 
〔撒上１５：２９〕“以色列的大能者，必不至说谎，也不至后悔。因为他迥 
非世人，决不后悔。” 
〔玛３：６〕“因为我耶和华是不改变的，所以你们雅各之子没有灭亡。” 
〔雅１：１７〕“各样美善的恩赐和各样全备的赏赐都是从上头来的，从众光 
之父那里降下来的；在他并没有改变，也没有转动的影儿。” 
〔创６：６〕“耶和华就后悔造人在地上，心中忧伤。” 
〔拿３：１０〕“于是神察看他们的行为，见他们离开恶道，他就后悔，不把 
所说的灾祸降与他们了。” 
１７、所罗门有多少督工？ 
〔王上９：２３〕“所罗门有五百五十督工，兼管工人。” 
〔代下８：１０〕“所罗门王有二百五十督工，监督工人。” 
１８、所罗门有多少套车的马？ 
〔王上４：２６〕“所罗门有套车的马四万，还有马兵一万二千。” 
〔代下９：２５〕“所罗门有套车的马四千棚，有马兵一万二千。” 
中文版在第一句没用“棚”，第二句用“棚”，大概是想暗示一棚马等于十匹 
。查英文版，两处用词一样，都是stall，所以第一句也应该翻译成“马四万棚”。 
１９、沙拉是亚法撒的儿子还是孙子？ 
〔创１１：１２〕“亚法撒活到三十五岁，生了沙拉。” 
〔路３：３６〕“沙拉是该南的儿子；该南是亚法撒的儿子；” 
２０、从约沙法到约旦，一笔糊涂账 
〔代上３：１１〕“约沙法的儿子是约兰；约兰的儿子是亚哈谢；亚哈谢的儿 
子是约阿施；约阿施的儿子是亚玛谢；亚玛谢的儿子是亚撒利雅；亚撒利雅的儿子 
是约但” 
〔太１：８〕“约沙法生约兰；约兰生乌西亚；乌西亚生约旦” 
错误百出的圣经（３） 
?方舟子? 
２１、上帝慈悲吗？ 
〔诗１４５：９〕“耶和华善待万民，他的慈悲覆庇他一切所造的。” 
〔耶１３：１４〕“耶和华说：‘我要使他们彼此相碰，就是父与子彼此相碰 
；我必不可怜，不顾惜，不怜悯，以致灭绝他们。” 
２２、耶稣等于还是小于上帝？ 
〔约１０：３０〕“我与父原为一。” 
〔约１４：２８〕“你们若爱我，因我到父那里去，就必喜乐；因为父是比我 
大的。” 
２３、巴沙死后十年又是一条好汉？ 
〔王上１６：６〕“巴沙与他列祖同睡，葬在得撒。他儿子以拉接续他作王。 
”“犹大王亚撒二十六年，巴沙的儿子以拉，在得撒登基作以色列王共二年。” 
〔代下１６：１〕“亚撒三十六年，以色列王巴沙上来攻击犹大，修筑拉玛， 
不许人从犹大亚撒那里出入。” 
２４、亚哈谢几岁登基？ 
〔王下８：２５〕“以色列王亚哈的儿子约兰十二年，犹大王约兰的儿子亚哈 
谢登基。他登基的时候，年二十二岁，在耶路撒冷作王一年。” 
〔代下２２：２〕“亚哈谢登基的时候年四十二岁，在耶路撒冷作王一年。” 
２５、谁是约西亚的继承人？ 
〔代下３６：１〕“国民立约西亚的儿子约哈斯，在耶路撒冷接续他父作王。 
” 
〔耶２２：１１〕“因为耶和华论到从这地方出去的犹大王约西亚的儿子沙龙 
，就是接续他父亲约西亚作王的” 
耶和华记混了？ 
２６、那是谁的三十块钱？ 
〔太２７：９〕“这就应了先知耶利米的话，说：‘他们用那三十块钱，就是 
被估定之人的价钱，是以色列人中所估定的，买了窑户的一块田，这是照着主所吩 
咐我的。” 
〔亚１１：１２〕“于是他们给了三十块钱，作为我（撒迦利亚）的工价。耶 
和华吩咐我说：‘要把众人所估定美好的价值，丢给窑户。’我便将这三十块钱， 
在耶和华的殿中，丢给窑户了。”（耶利米书没有这些话） 
２７、究竟要不要智慧、聪明？ 
〔箴４：７〕“智慧为首，所以要得智慧，在你一切所得之内，必得聪明。” 
〔哥前１：１９〕“就如经上所记：‘我要灭绝智慧人的智慧，废弃聪明人的 
聪明’” 
２８、聪明人有福吗？ 
〔箴３：１３〕“得智慧，得聪明的，这人便为有福。” 
〔传１：１８〕“因为多有智慧，就多有愁烦；加增知识的，就加增忧伤。” 
２９、约雅斤几岁登基？ 
〔王下２４：８〕“约雅斤登基的时候，年十八岁，在耶路撒冷作王三个月。 
” 
〔代下３６：９〕“约雅斤登基的时候年八岁，在耶路撒冷作王三个月零十天 
。” 
３０、谁是我们的敌人，谁是我们的朋友？ 
严要求： 
〔太１２：３０〕“不与我相合的，就是敌我的；不同我收聚的，就是分散的 
。” 
宽要求： 
〔可９：４０〕“不抵挡我们的，就是帮助我们的。” 
〔路９：５０〕“耶稣说：‘不要禁止他，因为不敌挡你们的，就是帮助你们 
的。” 
错误百出的圣经（四） 
?方舟子? 
３１、耶稣死时穿什么颜色的衣服？ 
〔太２７：２８〕“他们给他脱了衣服，穿上一件朱红色袍子” 
〔约１９：２〕“兵丁用荆棘编作冠冕，戴在他头上，给他穿上紫袍” 
３２、耶稣死前喝的什么酒？ 
〔太２７：３４〕“兵丁拿苦胆调和的酒给耶稣喝。他尝了，就不肯喝。” 
〔可１５：２３〕“拿没药调和的酒给耶稣喝，他却不受。” 
３３、耶稣最后说了什么话？ 
〔太２７：４６〕“约在申初，耶稣大声喊着说：‘以利！以利！拉马撒巴各 
大尼？’就是说：‘我的神！我的神！为什么离弃我？’……耶稣又大声喊叫，气 
就断了。” 
〔路２３：４６〕“耶稣大声喊着说：‘父啊！我将我的灵魂交在你手里。’ 
说了这话，气就断了。” 
〔约１９：３０〕“耶稣尝了那醋，就说：‘成了！’便低下头，将灵魂交付 
神了。” 
３４、耶稣复活后谁在空墓旁边？ 
〔太２８：１〕抹大拉的马利亚，那个马利亚和一个从天而降的天使。 
〔可１６：１〕抹大拉的马利亚，雅各的母亲马利亚和一个坐在坟幕里的少年 
。 
〔约２０：１〕抹大拉的马利亚，西门彼得，耶稣所爱的那个门徒，和两个坐 
在坟幕里的天使。 
３５、犹大是怎么死的？ 
〔太２７：５〕“犹大就把那银钱丢在殿里，出去吊死了。” 
〔徒１：１８〕“这人（犹大）用他作恶的工价买了一块田，以后身子仆倒， 
肚腹崩裂，肠子都流了出来。” 
３６、是谁买了血田？ 
〔徒１：１８〕“这人（犹大）用他作恶的工价买了一块田，以后身子仆倒， 
肚腹崩裂，肠子都流了出来。住在耶路撒冷的众人都知道这事，所以按着他们那里 
的话给那块田起名叫亚革大马，就是血田的意思。” 
〔太２７：５〕“犹大就把那银钱丢在殿里，出去吊死了。祭司长拾起银钱来 
说：‘这是血价，不可放在库里。’他们商议，就用那银钱买了窑户的一块田，为 
要埋葬外乡人。所以那块田直到今日还叫作‘血田’。” 
３７、鸡叫了几遍？ 
〔可１４：６８〕“于是出来，到了前院，鸡就叫了。……彼得就发咒起誓的 
说：‘我不认得你们说的这个人。’立时鸡叫了第二遍。彼得想起耶稣对他所说的 
话：‘鸡叫两遍以先，你要三次不认我。’思想起来，就哭了。” 
〔太２６：７４〕“彼得就发咒起誓的说：‘我不认得那个人。’立时，鸡就 
叫了。彼得想起耶稣所说的话：‘鸡叫以先，你要三次不认我。’他就出去痛哭。 
” 
〔路２２：６０〕“彼得说：‘你这个人！我不晓得你说的是什么。’正说话 
之间，鸡就叫了。主转过身来看彼得。彼得便想起主对他所说的话：‘今日鸡叫以 
先，你要三次不认我。’他就出去痛哭。” 
〔约１８：２７〕“彼得又不承认。立时鸡就叫了。” 
３８、只看到光还是只听到声音？ 
〔徒９：７〕“同行的人站在那里，说不出话来，听见了声音，却看不见人。 
” 
〔徒２２：８〕“我回答说：‘主啊！你是谁？’他说：‘我就是你所逼迫的 
拿撒勒人耶稣。’与我同行的人看见了那光，却没有听明那位对我说话的声音。” 
３９、做好事要不要让人知道？ 
〔太５：１５〕“（耶稣说）人点灯，不放在斗底下，是放在灯台上，就照亮 
了一家人。你们的光也当这样照在人前，叫他们看见你们的好行为，便将荣耀归给 
你们在天上的父。” 
〔太６：３〕“（耶稣说）你施舍的时候，不要叫左手知道右手所作的；要叫 
你施舍的事行在暗中，你父在暗中察看，必然报答你。” 
４０、耶稣首次布道是在山上还是山下？ 
〔太５：１〕“耶稣看见这许多的人，就上了山，既已坐下，门徒到他跟前， 
他就开口教训他们，说（布道内容略）” 
〔路６：１７〕“耶稣和他们下了山，站在一块平地上；同站的有许多门徒， 
又有许多百姓，……耶稣举目看着门徒，说（布道内容略）” 
错误百出的圣经（五） 
?方舟子? 
４１、会有多少年的饥荒？ 
〔撒下２４：１３〕“于是迦得来见大卫，对他说：‘你愿意国中有七年的饥 
荒呢？是在你敌人面前逃跑，被追赶三个月呢？……’” 
〔代上２１：１１〕“于是，迦得来见大卫，对他说：‘耶和华如此说：你可 
以随意选择。或三年的饥荒；或败在你敌人面前，被敌人的刀追杀三个月……’” 
４２、义人该活还是该死？ 
〔诗９２：１２〕“义人要发旺如棕树，生长如利巴嫩的香柏树。他们年老的 
时候，仍要结果子；要满了汁浆而常发青，好显明耶和华是正直的。” 
〔赛５７：１〕“义人死亡，无人放在心上；虔诚人被收去，无人思念。这义 
人被收去是免了将来的祸患。” 
４３、善有善报，恶有恶报吗？ 
〔箴１０：２７〕“敬畏耶和华，使人日子加多；但恶人的年岁必被减少。义 
人的盼望，必得喜乐；恶人的指望，必至灭没。耶和华的道，是正直人的保障，却 
成了作孽人的败坏。义人永不挪移；恶人不得住在地上。” 
〔箴１２：２１〕“义人不遭灾害；恶人满受祸患。” 
〔诗５５：２３〕“神呵，你必使恶人下入灭亡的坑；流人血行诡诈的人，必 
活不到半世，但我要倚靠你。” 
〔诗７３：３〕“我见恶人和狂傲人享平安，就心怀不平。他们死的时候，没 
有疼痛；他们的力气，却也壮实。他们不象别人受苦，也不象别人糟灾。……看哪 
，这就是恶人。他们既是常享安逸，财宝便加增。” 
〔来１１：３９〕“这些人都是因信得了美好的证据，却仍未得着所应许的； 
因为神给我们预备了更美好的事，叫他们若不与我们同得，就不能完全。” 
４４、父罪子偿吗？ 
〔赛１４：２１〕“先人既有罪孽，就要预备杀戮他的子孙，免得他们兴起来 
，得了遍地，在世上修满城邑。” 
〔申２４：１６〕“不可因子杀父，也不可因父杀子；凡被杀的都为本身的罪 
。” 
４５、亚撒毁没毁邱坛？ 
〔王上１５：１１〕“亚撒效法他祖大卫行耶和华眼中看为正的事，从国中除 
去娈童，又除掉他列祖所造的一切偶像。……只是邱坛还没有废去。” 
〔代下１４：２〕“亚撒行耶和华他神眼中看为善为正的事，除掉外邦神的坛 
和邱坛，打碎柱像，砍下木偶，……” 
４６、瘟疫死了多少人？ 
〔民２５：９〕“那时瘟疫死的，有二万四千人。” 
〔哥前１０：８〕“我们也不要行奸淫，象他们有人行的，一天就倒毙了二万 
三千人。” 
４７、以色列人在埃及住了多长？ 
〔出１２：４０〕“以色列人住在埃及共有四百三十年。” 
〔徒７：６〕“神说：‘他的后裔必寄居外邦，那里的人要叫他们作奴仆，苦 
待他们四百年。’” 
４８、雅各在埃及的后代有多少人？ 
〔创４６：２７〕“雅各家来到埃及的共有七十人。” 
〔出１：５〕“凡从雅各而生的，共有七十人。” 
〔徒７：１４〕“约瑟就打发弟兄，请父亲雅各和全家七十五人都来了。” 
４９、雅各葬在哪里？ 
〔创５０：１３〕“把他（雅各）搬到伽南地，葬在幔利前、麦比拉田间的洞 
里，那洞和田，是亚伯拉罕向赫人以弗仑买来为业作坟地的。” 
〔徒７：１５〕“于是雅各下了埃及，后来他和我们的祖宗都死在那里；又被 
带到示剑，葬于亚伯拉罕在示剑用银子从哈抹子孙买来的坟墓里。” 
５０、乌沙死在哪里？ 
〔撒下６：６〕“到了拿艮的禾场，因为牛失前蹄，乌撒就伸手扶住约柜。神 
耶和华向乌撒发怒，因这错误击杀他；他就死在神的约柜旁。” 
〔代上１３：９〕“到了基顿的禾场，因为牛失前啼，……” 
错误百出的圣经（六） 
?方舟子? 
５１、他拉活了多少岁？ 
〔创１１：３２〕“他拉共活了二百零五岁，就死在哈兰。” 
〔创１１：２６〕“他拉活到七十岁，生了亚伯兰、拿鹤、哈兰。” 
〔创１２：４〕“亚伯兰出哈兰的时候，年七十五。” 
〔徒７：４〕“他（亚伯兰，后被上帝改名亚伯拉罕）就离开迦勒底人之地，住 
在哈兰。他父亲死了以后，神使他从那里搬到你们现在所住之地。” 
根据后面三则推算，他拉的寿命不会长于一百四十五岁（七十加七十五）。 
５２、所罗门什么时候登基？ 
据〔徒１３：１６―２２〕，从出埃及到大卫登基共５３０年。据〔代上２９ 
：２７〕，大卫在位共４０年，之后所罗门登基，即在出埃及后５７０年。 
〔王上６：１〕“以色列人出埃及地后四百八十年，所罗门作以色列王第四年 
”。 
５３、扫罗临死前求问上帝了吗？ 
〔撒上２８：６〕“扫罗求问耶和华，耶和华却并不藉梦，或乌陵，或先知回 
答他。” 
〔代上１０：１４〕“（扫罗）没有求问耶和华，所以耶和华使他被杀，把国 
归于耶西的儿子大卫。” 
５４、有多少老百姓？ 
〔代上２１：５〕“（约押）将百姓的总数奏告大卫：以色列人拿刀的，有一 
百一十万；犹大人拿刀的，有四十七万。” 
〔撒下２４：９〕“约押将百姓的总数奏告于王：以色列拿刀的勇士有八十万 
；犹大有五十万。” 
５５、大卫杀了多少战车？马兵还是步兵？ 
〔撒下１０：１８〕“亚兰人在以色列人面前逃跑，大卫杀了亚兰七百辆战车 
，四万马兵，又杀了亚兰的将军朔法。” 
〔代上１９：１８〕“亚兰人在以色列人面前逃跑。大卫杀了亚兰七千辆战车 
，四万步兵，又杀了亚兰的将军朔法。” 
５６、出埃及的路程 
〔民３３：３８，４１，４２〕阿珥山、撒摩拿、普嫩，亚伦死于阿珥山。 
〔申１０：６，７〕比罗比尼亚干、摩西拉、谷歌大、约巴他，亚伦死于摩西 
拉。 
５７、小耶酥的历程 
〔路２：２１―３９〕耶酥出世八天后，被父母带到耶路撒冷的圣殿，“照主 
的律法，办完了一切的事”，回到拿撒勒。 
〔太２：１４―２３〕耶酥一生下来，其父母即连夜带他逃到埃及去，住在那 
里，直到希律死了，再去拿撒勒。 
５８、耶酥什么时候开始传教？ 
〔可１：１４〕“约翰下监以后，耶稣来到加利利，宣传神的福音，说：‘日 
期满了，神的国近了！你们当悔改，信福音。’” 
〔约３：２２〕“这事（耶酥首次传福音）以后，耶酥和门徒到了犹太地，在 
那里居住，施洗。……那时约翰还没有下在监里。” 
５９、两个还是一个附鬼的人？ 
〔太８：２８〕“耶酥既渡到那边去，来到加大拉人的地方，就有两个被鬼附 
的人，从坟茔里出来迎着他” 
〔可５：２〕“耶酥一下船，就有一个被污鬼附着的人，从坟茔里出来迎着他 
。” 
６０、两个还是一个盲人？ 
〔太２０：３０〕“有两个瞎子坐在路旁，听说是耶酥经过，就喊着说……” 
〔可１０：４６〕“有一个讨饭的瞎子，是底买的儿子巴底买，坐在路旁。他 
听见是拿撒勒的耶酥，就喊着说……” 
错误百出的圣经（七） 
?方舟子? 
６１、该不该孝敬父母？ 
〔出２０：１２〕“当孝敬父母，使你的日子，在耶和华你神所赐你的地上， 
得以长久。” 
〔利１９：３〕“你们各人都当孝敬父母，也要守我的安息日。” 
〔申５：１６〕“当照耶和华你神所吩咐的，孝敬父母，使你得服，……” 
〔弗６：１〕“你们作儿女的，要在主里听从父母，这是理所当然的。要孝敬 
父母，使你得福，在世长寿。” 
〔太８：２１〕“又有一个门徒对耶酥说：‘主啊，容我先回去埋葬我的父亲 
。’耶酥说：‘任凭死人埋葬他们的死人；你跟从我吧！’” 
〔太１０：３５〕“因为我来是叫人与父亲生疏，女儿与母亲生疏，媳妇与婆 
婆生疏。人的仇敌就是自己家里的人。爱父母过于爱我的，不配作我的门徒” 
〔太１９：２９〕“凡为我的名撇下房屋，或是弟兄、姐妹、父亲、母亲、儿 
女、田地的，必要得着百倍，并且承受永生。” 
〔太２３：９〕“也不要称呼地上的人为父，因为只有一位是你们的父，就是 
天上的父。” 
〔路１２：５１〕“你们以为我来，是叫地上太平吗？我告诉你们，不是，乃 
是叫人分争。……父亲和儿子相争，儿子和父亲相争；母亲和女儿相争，女儿和母 
亲相争；婆婆和媳妇相争，媳妇和婆婆相争。” 
〔路１４：２６〕“人到我这里来，若不爱我胜过爱自己的父母、妻子、儿女 
、弟兄、姐妹，和自己的性命，就不能作我的门徒” 
６２、耶酥审判吗？ 
〔约５：２２〕“父不审判什么人，乃将审判的事全交与子，……并且因为他 
是人子，就赐给他行审判的权柄。” 
〔约９：３９〕“耶酥说：‘我为审判到这世上来，叫不能看见的可以看见； 
能看见的反瞎了眼。” 
〔哥后５：１０〕因为我们众人必要在基督台前显露出来，叫各人按着本身所 
行的，或善或恶受报。” 
〔约８：１５〕“你们是以外貌判断人，我却不判断人。” 
〔约１２：４７〕“若有人听见我的话不遵守，我不审判他。我来本不是要审 
判世界，乃是要拯救世界。弃绝我，不领受我话的人，有审判他的；就是我讲的道 
，在末日要审判他。” 
６３、耶酥显神迹吗？ 
〔太１２：３９〕“（有人请耶酥显神迹给他们看）耶酥回答说：‘一个邪恶 
淫乱的世代求看神迹，除了先知约拿的神迹以为，再没有神迹给他们看。约拿三日 
三夜在大鱼肚腹中，人子也要这样三日三夜在地里头。’” 
〔可８：１２〕“（有人求耶酥显神迹）耶酥心里深深的叹息说：‘这世代为 
什么求神迹呢？我实在告诉你们，没有神迹给这世代看。’” 
〔路１１：２９〕“当众人聚集的时候，耶酥开讲说：‘这世代是一个邪恶的 
世代；他们求看神迹，除了约拿的神迹以外，再没有神迹给他们看。” 
〔约３：２〕“这人夜里来见耶酥，说：‘拉比，我们知道你是由神那里来作 
师傅的；因为你所行的神迹，若没有神同在，无人能行。’” 
〔约２０：３０〕“耶酥在门徒面前，另外行了许多神迹，没有记在这书上” 
〔徒２：２２〕“以色列人哪！请听我的话：神籍着拿撒勒人耶酥在你们中间 
施行异能、奇事、神迹，将他证明出来，这是你们自己知道的。” 
６４、怎样才能得救？ 
只要信主就可得救： 
〔约３：３６〕“信子的人有永生；不信子的人得不着永生，神的震怒常在他 
身上。” 
〔约５：２４〕“我实实在在的告诉你们，那听我话，又信差我来者的，就有 
永生，不至于定罪，是已经出死入生了。” 
〔约２０：３１〕“但记这些事，要叫你们信耶酥是基督，是神的儿子，并且 
叫你们信了他，就可以因他的名得生命。” 
〔徒２：２１〕“到那时候，凡求告主名的，就必得救。” 
〔徒１６：３０〕“当信主耶酥，你和你一家都必得救。” 
〔罗１：１７〕“义人必因信得救。” 
〔罗１０：９〕“因为人心里相信，就可以称义；口里承认，就必得救。” 
仅仅信是不够的： 
〔太７：２１〕“凡称呼我主啊，主啊的人，不能都进天国；惟独遵行我天父 
旨意的人，才能进去。” 
〔太１６：２７〕“人子要在他父的荣耀里，同着众使者降临；那时候，他要 
照各人的行为报应各人。” 
〔太１９：１６〕“你若要进入永生，就当遵守诫命。” 
〔约５：２９〕“行善的复活得生；作恶的复活定罪。” 
〔徒１０：３５〕“原来各国中，那敬畏主行义的人都为主所悦纳。” 
〔罗２：６〕“他必照各人的行为报应各人，凡恒心行善，寻求荣耀、尊贵和 
不能朽坏之福的，就以永生报应他们。” 
〔哥前３：８〕““栽种的和浇灌的，都是一样；但将来各人要照自己的工夫 
得自己的赏赐。” 
６５、大卫向谁要的陈设饼？ 
〔可２：２６〕“他（大卫）当亚比亚他作大祭司的时候，怎么进了神的殿， 
吃了陈设饼，又给跟从他的人吃。” 
〔撒上２１：１〕记载的是大卫向挪伯祭司亚希米勒要圣饼。 
６６、五个人还是七个人？ 
〔王下２５：１９〕“又从城中拿住一个管理兵丁的官，并在城里所遇常见王 
面的五个人和检点国民军长的书记，以及城里遇见的国民六十个人。” 
〔耶５２：２５〕“又从城中拿住一个管理兵丁的官，并在城里所遇常见王面 
的七个人和检点国民军长的书记，以及城里遇见的国民六十个人。” 
６７、铜柱有多高？ 
〔王上７：１５〕“他制造两根铜柱，每根高十八肘，围十二肘” 
〔代下３：１５〕“在殿前造了两根柱子，高三十五肘；每柱顶高五肘。” 
６８、铜海可容多少罢特？ 
〔王上７：２６〕“（铜海）可容二千罢特。” 
〔代下４：５〕“（铜海）可容三千罢特。” 
６９、大卫向谁、花多少钱买禾场用于筑坛止瘟疫？ 
〔代上２１：２５〕“于是，大卫为那块地平了六百舍客勒金子给阿珥楠。” 
〔撒下２４：２４〕“大卫就用五十舍客勒银子，（向亚劳拿〕买了那禾场和 
牛。” 
７０、人能否圣洁？ 
〔利１１：４４〕“我是耶和华你们的神，所以你们要成为圣洁，因为我是圣 
洁的。” 
〔利１９：２〕“你晓谕以色列全会众说：你们要圣洁，因为我耶和华你们的 
神是圣洁的。” 
〔利２０：７〕“所以你们要自洁成圣，因为我是耶和华你们的神。” 
〔启１５：４〕“主啊！谁敢不敬畏你，不将荣耀归与你的名呢？因为独有你 
是圣的” 
错误百出的圣经（八） 
?方舟子? 
７１、要不要带鞋和拐杖（耶酥对门徒的吩咐）？ 
〔太１０：１０〕“行路不要带口袋，不要带两件褂子，也不要带鞋和拐杖； 
因为工人得饮食是应当的。 
〔可６：８〕“行路的时候不要带食物和口袋，腰袋里也不要带钱，除了拐杖 
以外，什么都不要带；只要穿鞋，也不要穿两件褂子。” 
７２、人死能不能复活？ 
〔传８：８〕“无人有权力掌管生命，将生命留住” 
〔徒９：３７〕彼得使一个死去的女徒大比大复活。 
７３、该不该抛弃家庭去当信徒？ 
〔路１４：２６〕“人到我这里来，若不爱我胜过爱自己的父母、妻子、儿女 
、弟兄、姐妹，和自己的生命的，就不能作我的门徒” 
〔路１８：２９〕“我实在告诉你们，人为神的国撇下房屋，或是妻子、弟兄 
、父母、儿女，没有在今世不得百倍，在来世不得永生的。” 
〔提前５：８〕“人若不看顾亲属，就是背了真道，比不信的人还不好，不看 
顾自己家里的人，更是如此。” 
７４、耶酥能为自己作证吗？ 
〔约５：３１〕“我（耶酥）若为自己作见证，我的见证就不真。” 
〔约８：１４〕“耶酥说：‘我虽然为自己作见证，我的见证还是真的”“我 
是为自己作见证，还有差我来的父也是为我作见证。” 
７５、上帝的律法可不可废？ 
〔太５：１７〕“莫想我来要废掉律法和先知；我来不是要废掉，乃是要成全 
。我实在告诉你们，就是到天地都废去了，律法的一点一画也不能废去，都要成全 
。” 
〔路１６：１７〕“天地废去比较律法的一点一画落空还容易。” 
〔罗７：６〕“但我们既然在捆我们的律法上死了，现今就脱离律法，叫我们 
服事主，要按着心灵的新样，不按着仪文的旧样。” 
〔弗２：１５〕“而且以自己的身体废掉冤仇，就是那记在律法上的规条，为 
要将两下藉着自己造成一个新人，如此便成就了和睦。” 
〔西２：１３〕“神赦免了你们一切过犯，便叫你们与基督一同活过来；又涂 
抹了在律例上所写、攻击我们、有碍于我们的字据，把它撤去，钉在十字架上。” 
７６、安德烈的家在哪里？ 
〔可１：２１，２９〕“到了迦百农，耶酥就在安息日进了会堂教训人。…… 
他们一出会堂，就同着雅各、约翰，进了西门和安得烈的家。” 
〔约１：４４〕“这腓力是伯赛大人，和安得烈、彼得同城。” 
７７、上帝把什么都给了耶稣了吗？ 
〔约３：３４〕“神所差来的，就说神的话；因为神赐圣灵给他，是没有限量 
的。父爱子，已将万有交在他手里。” 
〔太２０：２３〕“耶酥说：‘我所喝的杯，你们必要喝；只是坐在我的左右 
，不是我可以赐的，乃是我父为谁预备的，就赐给谁。” 
〔约５：１９〕“耶酥对他们说：‘我实实在在的告诉你们，子凭着自己不能 
作什么，惟有看见父所作的，子才能作；父所作的事，子也照样作。”（此处父指 
天父，子指耶酥自己。） 
７８、所有的人都有罪吗？ 
〔代下６：３６〕“世上没有不犯罪的人” 
〔传７：２０〕“时常行善而不犯罪的义人，世上实在没有。” 
〔约一３：５〕“你们知道主曾显现，是要除掉人的罪，在他并没有罪。凡住 
在他里面的，就不犯罪；凡犯罪的，是未曾看见他，也未曾认识他。” 
７９、耶酥何时被抹的香膏？ 
〔太２０：１―１３〕〔太２６：６―１６〕〔可１１：１―１１〕〔可１４ 
：３―１１〕耶酥先进耶路撒冷，再在伯大尼西门家被一女人抹了香膏（浇在头上 
），引起门徒的不满。 
〔约１２：１―８〕〔约１２：１２―１５〕耶酥先在伯大尼被抹了香膏（抹 
在脚上），引起门徒的不满，之后再上耶路撒冷。 
８０、什么样的最后晚餐？ 
〔太２６：１９〕〔可１４：１６〕〔路２２：１３〕都说最后的晚餐是逾越 
节的筵席。 
〔约１３：１〕最后的晚餐在逾越节以前。〔约１８：２８〕抓耶酥的人不敢 
进衙门，恐怕染了污秽，不能吃逾越节的筵席，“那时天还早”。 
错误百出的圣经（九） 
?方舟子? 
８１、耶酥什么时候警告彼得“将三次不认我”？ 
〔太２６：２０―３４〕〔可１４：１７―３０〕吃完了晚餐，到了橄榄山后 
警告。 
〔路２２：３３―３９〕〔约１３：３７〕〔约１８：１〕还在吃晚餐的时候 
警告。 
８２、耶酥何时受审？ 
〔太２６：５７―６８〕在晚上受审，早上被带去见彼拉多。 
〔路２２：６６―７１〕〔２３：１〕受审和见彼拉多都在早上。 
８３、同钉的两个强盗与耶酥 
〔太２７：４４〕“那和他同钉的强盗（复数〕也是这样的讥诮他。” 
〔路２３：３９〕和耶酥同钉的两个犯人，一个讥诮他，另一个则相信耶酥， 
并责备另一个犯人。 
８４、耶酥和同钉的强盗同往乐园？ 
〔路２３：４３〕“耶酥对他（那个相信他的犯人）说：‘我实在告诉你，今 
日你要同我在乐园里了。’” 
〔约２０：１７〕耶酥复活后告诉马利亚：“我还没有升上去见我的父。” 
８５、耶酥与天父同在吗？ 
〔约１０：３０〕“我与父原为一。” 
〔约１４：１０〕“我在父里面，父在我里面” 
〔约１６：３２〕“其实我不是独自一人，因为有父与我同在。” 
〔可１５：３４〕耶酥在临死前大声喊道：“我的神！我的神！为什么离弃我 
？” 
８６、耶酥之死的确定 
〔约１９：３１―３３，３８〕彼拉多在刑场监视直到确信耶酥已死。 
〔可１５：４３―４５〕亚利马太的约瑟向彼拉多要耶酥的尸体，彼拉多诧异 
耶酥已经死了，叫百夫长来询问。 
８７、耶酥是不是大卫的后裔？ 
〔罗１：３〕“论到他儿子我主耶酥，按肉体说，是大卫后裔生的” 
〔太１：１―１６〕〔路３：２３―３８〕耶酥的“父亲”约瑟虽然是大卫的 
后裔，但耶酥是马利亚处女所生，与约瑟并无肉体关系。〔路１：３６〕马利亚是 
以利沙伯的亲戚，〔路１：５〕以利杀伯是亚伦的后人，不是大卫的后裔。 
错误百出的圣经（十） 
?方舟子? 
《破绽百出的耶酥复活》 
耶酥复活可以说是基督教的最大信仰。即使历史上真有耶酥这个人（实际上没 
有任何历史文献记录耶酥的存在），也不等于他就是神之子，只有他真地复活了， 
才能证明他是神之子。对于耶酥复活的唯一记载是《新约》里的四篇福音：“马太 
”“马可”“路加”“约翰”，没有别的独立资料来证明。而且，非常遗憾的是， 
就是这四篇福音，在耶酥复活的情节上，也是各说各话，时间、人物、地点、经过 
，无一不互相矛盾，法庭上要是有这样的四个证人，他们的证词肯定不会被接受。 
现在就让我们来看看这四个“证人”在耶酥复活这件事的证词离谱到何等程度： 
一、耶酥给埋了多少天？ 
〔太１２：４０〕记载耶酥的话说，他要在土里给埋三天三夜。据〔可１５： 
４２〕〔约２０：１〕耶酥在星期五被葬，星期天早晨就被发现坟墓已空，实际上 
是被埋了一天两夜。 
二、耶酥的坟墓什么时候被发现空了？ 
马太：天快亮的时候。 
马可：清早，出太阳的时候。 
路加：黎明的时候。 
约翰：清早，天还黑的时候。 
三、谁最先发现坟墓空了？ 
马太：两个马利亚。 
马可：两个马利亚和撒罗米。 
路加：那些从加利利和耶酥同来的妇人，包括两个马利亚、约亚拿和其他人。 
约翰：抹大拉的马利亚。她发现坟墓空了以后，跑去报告西门彼得和耶酥所爱 
的一个门徒，三个人又一起去看。 
四、在空墓看见了什么？ 
马太：地震，一个天使从天上下来，辊开石头坐在上面。 
马可：石头已经辊开了，一个少年人坐在坟墓里面。 
路加：石头已经辊开了，两个人站在坟墓里面。 
约翰：石头已经辊开了，没有看到人。两个门徒离开后，马利亚看到两个天使 
坐在安放耶酥的地方，一转身，见到了耶酥。 
五、天使说了什么话？ 
马太、马可：说耶酥已经复活，传令门徒们到加利利去。 
路加：只说耶酥已经复活。 
约翰：问“妇人，你为什么哭？”，没再说别的话。 
六、妇人发现坟墓空了以后做了什么？ 
马太：跑去报告门徒，路上遇见耶酥，耶酥重复天使的话。 
马可：逃跑，因为害怕，什么也不告诉人。 
路加：跑去告诉门徒，路上没有遇到耶酥。 
约翰：马利亚在坟外与耶酥交谈，然后再去告诉门徒。 
七、耶酥在什么时候第一次显现？ 
马太：在妇人回去的路上。 
马可：这一日的清早，向已从坟地回来的抹大拉的马利亚显现。 
路加：在两个门徒去以马忤斯的路上。 
约翰：抹大拉的马利亚还没离开坟墓的时候。 
八、耶酥从复活到升天经过了多长时间？ 
马太：至少等到门徒们到达加利利。 
马可：时间不明，只是说在十一门徒坐席的时候最后一次显现。 
路加：耶酥在一天之内复活、显现、升天。 
约翰：至少一星期。耶酥在复活后第八日专门向多乌显现，以后又在提比哩亚 
向门徒显现。 
〔徒１：３〕“他受害之后，用许多的凭据将自己活活的显给使徒看，四十天 
之久向他们显现，讲说神国的事。” 
现在就请各位根据这些证词断定耶酥复活的可信程度","转知友 
@doing
 的一篇回答：
有太多的证据说明我们这个世界是虚拟的。
1. 为什么宏观上丰富多彩，但是微观的基本粒子却都是一模一样的？这正和图片丰富多彩，但是像素是一模一样的一回事
2. 为什么光速有上限？因为机器的运行速度有限
3. 为什么会有普朗克常量？因为机器的数据精度有限
4. 为什么微观粒子都是
几率云
？这是为了避免系统陷入循环而增加的随机扰动
5. 为什么有
泡利不相容原理
？看来系统采用的数据组织是多维数组
6. 为什么量子计算机运行速度那么快，一瞬间可以尝试所有可能？因为这个本质上是调用了宿主机的接口
7. 为什么会有量子纠缠？这实际上是引用同一个对象的两个指针
8. 为什么会有
观察者效应
？这显然是lazy updating
补充：这一点非常类似于程序中的延迟初始化
为了避免无限止实例化所有微观对象，顾在程序运行时只保留一个状态分布函数，等观测的时候，也就是在使用组件或对象时，进行初始化，new一个新对象出来，同时也确定了该对象的状态。
9. 为什么时间有开端？系统有启动时间嘛
10. 为什么宗教人士，程序员都很难找女友？系统对这些探索系统奥秘的不稳定份子都很不友好啊
如果说什么语言最接近系统使用的语言？我觉得是c++，不然bug不应这么多。
总结：建议提问者多看看日报，或许很多脑洞问题会提前被这些精彩的回答所解决
最后，不多说了，地球online的服务器快没钱了，我得去帮忙续个费(逃",智商无限高的神会立刻指出甲方需求里的逻辑矛盾和不完备然后因为羞辱客户被开除，而无所不能的神会消灭所有甲方，天下无bug,"按照神就是程序员的设定，人+社会就是代码。
结论就是充满了bug，但是不用慌，因为整体采用的是进化算法。
Bug实在太多了也没事，大堆大堆删代码，重来就好了。
盲猜God是一个暴躁程序员
就当是一场梦，醒来还是很感动。
god在debug
随便写点代码，让他们自己玩去吧","这就是中了“计算机软件行业就是写代码”的毒。
软件工程别说这几年的急速发展，就算是能看一眼三十年前的《
人月神话
》也不敢说出这种话。
一个软件，能够商用或者广泛使用的软件，无论是单机软件，还是B/S系统，都会面临非代码bug，也就是各种各样的非软件逻辑defect。
软件本身功能错误，无论是你用一个MS word，还是一个淘宝，这都可以通过极端人力，在这里预设为神来解决，但是软件是没有可能独自生存的。MS word还要跑在操作系统上，淘宝还要跑在浏览器里，这些容器带来的bug，是软件本身不可能完全解决的。
再往上想一层，为什么我们开始的时候提出
敏捷开发
，快速原型？就是因为有很多最终客户认为是bug的东西，其实根本就是客户的“另一种认知”，我有个实际例子告诉你。前几天我有个项目，有个客户的人，提出了一个很严厉的系统bug，是什么呢？是这个B/S结构的系统，在右上角会显示用户的登陆名，她认为这是个bug，“这个用户名的显示不能清晰地表达登陆人员的部门结构”，这一条，既没有在需求列表里出现，也没有在其他同样的100多个项目当中出现过，乃至于这群客户20多个人当中也只有她一个人坚持这么认为，但是这就是被当做一个bug提交上来了。
这些全部是非代码部分会出现的bug，更不用说，软件写完了以后，还要部署，分发，分发渠道会不会有问题？商用的服务器设置会不会有问题？单机软件会不会和其他软件起冲突？截图软件shareX的热键就会和
picpick
起冲突。
这个神既然无所不能了，与其写代码，还不如直接改了用户的
mindset
，什么叫无所不能啊 （战术后仰","不能
。
哥德尔
不完备原理已经清楚的告诉我们：
任意一个包含一阶
谓词逻辑
与初等数论的
形式系统
，都存在一个命题，它在这个系统中既不能被证明为真，也不能被证明为否。
如果你对这些术语不熟，那可以直观但不确切的理解下：一阶谓词就是“存在XX、所有XX、如果XX则XX”，初等数论就是加减乘除自然数。任何软件只要包含这些功能，那么一定有IF判断既没法返回真也没法返回假，那只能死机了，这不就是BUG吗？
当然，我这里是假设开发任何可能的软件都不出BUG。你都把神请过来了，要求高一点也可以理解嘛！
“说人话！！！“，可能有不少观众会打心眼里怒吼。好吧，那么现在进行――实例问答！
有请――神谕机：
对于输入的任何问题，
神谕机
都能询问神明得到答案并立即返回它的结果。
叮叮口当！这么好康的东西，一定能横扫所有BUG吧！
好吧，请听题：
请问下边这个程序最终是否能执行完毕：
程序 Q():
IF Q 停机
   死循环
IF Q 死循环
   输出(停机)
神谕机：&%！%￥！%
如果你不意思不是开发任何可能的软件都不出BUG，而仅仅是针对某一不太变态的软件，那用不着神出手，我们已经有形式化分析手段从理论上就能确保软件的可靠性。
说白了，只要钱到位，都不是问题。","没有bug的软件，是还没开始写的那个。但凡写出来了，就肯定有bug。
虽然软件都是程序员写的，但bug不都是程序员的锅，水平再高的程序员也有bug。
换句话说，如果没bug，那还有什么维护什么事儿，有新需求什么事儿。我记得Software Quality Assurance的老师说，你们千万千万别怕新需求，new requirements are where the money is.
@平凡
 说得好呀，按照神的设定，这个世界就是神的代码，including everything，都是他的creation，这其中，人是他最满意的。可是再满意，也出现了蛇，让
夏娃
吃了苹果。从此，bug便越来越多，越来越多。
没有软件是完美的，因为为了与时俱进，咱就得让软件跟上各种更新。用户的需求是不确定的，也是不断调整的，他们的期望也在变化。
所以，有变化，就有可能产生bug。
No software is perfect
Zero bug development is a myth that should be dispensed with. In order to stay relevant, you need to keep things fresh. Twitter, Facebook, Gmail, Dropbox, and other companies constantly improve their software, as we can see in the What’s new section of app store listings. They make improvements to meet end users’ evolving expectations along with changing web and mobile technology. 
[1]
参考
^
https://hackernoon.com/is-there-such-a-thing-as-bug-free-software-320cd862af17","这个问题有意思，更有意思的是炸出一堆被甲方虐了千百遍，自尊心受到极大打击的程序猿。
抛开可以扯皮的，和需求相关的“Bug”不谈，我认为没有bug的软件理论上存在。
如果只讨论bug的一个子集：
安全漏洞
，其实是有标准可循的。
比如美国国防部于1983年提出了一个“可信计算机系统安全评价准则”TCSEC（Trusted Computer System Evaluation Criteria），分为七个等级，D,C1,C2,B1,B2,B3,A1:
D:
 Minimal protection
C:
 Discretionary protection (C1 and C2)
B:
 Mandatory protection (B1, B2, and B3)
A:
 Verified protection (A1)
商用化的操作系统包括Windows NT内核的系统，大多只能通过C2等级认证。
最高的A级认证，要求软件使用
形式化方法
设计和验证，包括采用顶级的形式规范（Formal design and verification techniques including a formal top-level 
specification
）。
形式化方法是基于数学的方法，简单来说，要用
数学证明
的方法来验证你写的代码符合预期的功能，想想数学证明无可辩驳的威力。
资料显示，采用形式化方法开发的软件有：阿丽亚娜火箭的任务调度模型，我国的玉兔号月球车控制系统等。
所以为什么商用软件没听说过用形式化方法开发？显然成本很高，而且只能开高度耦合的程序。
但如果是神来做这件事的话，
写个200TB的数学证明
都是小菜一碟，有什么不能的？
――――――再来写点维护程序员自尊心的话―――――
软件开发本身就是挑战人类智力极限的事情。如果随机把一个CPU执行的实时机器码dump出来，估计没人看得懂计算机正在处理什么。所以有段子说：计算机就像女人，你永远不知道她心里在想什么。
80年代IBM曾投入5000人年来开发OS/360系统，花了数亿美元，仍然延迟交付。
，幽灵漏洞，心脏出血……这两年爆出的各种大厂的史诗级bug还少嘛？！
所以我觉得广大程序员们不用羞于承认自己写不出无bug的软件，本来就只有神能做到。","不能！
但神是不在乎这种bug的。
我们来看下神写代码的过程：
1、起初神创造天地。
In the beginning God created the heaven and the earth.
2、地是空虚混沌。渊面黑暗。神的灵运行在水bai面上。
And the earth was without form, and void; and darkness was upon the face of the deep. And the Spirit of God moved upon the face of the waters.
3、神说，要有光，就有了光。
And God said, Let there be light: and there was light.
4、神看光是好的，就把光暗分开了。
And God saw the light, that it was good: and God divided the light from the darkness.
5、神称光为昼，称暗为夜。有晚上，有早晨，这是头一日。
And God called the light Day, and the darkness he called Night. And the evening and the morning were the first day.
......
神写代码的过程都被很多世人所敬昂，他写的代码会有人看出bug？会有人承认bug？
都不是一个层次的智能生命好吗？
养猪场老板会在乎猪说饲料不好吃吗？他只在乎猪长的肥不肥.........","这个问题我觉得要这样来看，首先要搞清楚这个所谓的bug是由谁来定义。大部分情况下，这是由需求文档来定义的，这种情况下判断是否是bug比较客观，只要需求文档break down的足够细，那么神能写出没有bug的软件的可能性就足够大。另外一种情况，是否是bug，要根据用户的需求来决定，这个判断是否是bug就比较主观难以把控了。当然，如果是神的话，他(她?它？搞不清楚)完全可以大吼一声改变你的心智: 这不是个Bug，这是个Feature！！！
首先，我们看第一种情况，需求文档说要实现1+1=2的功能。但是因为神要写出的没有bug的代码，这一句需求文档就要进一步进行细化。
第一， 哪个运行环境下。安卓和苹果，安卓和苹果的哪些版本？从安卓和苹果诞生版本至今？然后安卓又分很多定制版，在不同的硬件平台上，甚至模拟器等等
第二，性能。从点击到返回结果少于100毫秒。输入弹出款性能，软件打开性能参数，键盘输入参数等等
第三，外观。必须白底黑字，按钮长方形，大小40 x 20 像素。输入框为input box，不带边框，不支持语音输入，不支持手写，点击input后弹出框从上往下到输入框位置动画渐进式弹出，速度符合既定公式，键盘自定义只接受数字，键盘数字排列为从1到9，如此之类
第四，功能限定。是否只接受数字，还是能接受字符串一加一,one plus one, 语音，触屏，物理按键，新灵感应
第五，如此之类一大堆，总之要将所有可能的情况都考虑在外。
大家看到没有，只要你有时间将需求文档做足够的细化，神是绝对可以写出对需求文档来说没有bug的软件的。如果加多一条，只要不跳出当前科技水平和人类认知的物理规律之外的，那别说神了，我们人也完全能写出对需求文档没有bug的软件。只是说如果你要像《三体》中质子在
汪淼
眼睑中显示结果，我们还没有到这个科技水平而已。
既然神和人都能写出对于需求文档没有bug的代码，那么第二种情况，对于用户没有bug的代码呢？
如果要实现这种情况的无bug化，万能的上帝只能做一个事情，先制造出一个人，然后以这个人作为蓝本作深度复制，注意是深度复制而不是浅度拷贝(大家都是写代码的，你应该知道我在说什么)，这时还要控制时间和空间，让这些人在同一个时间同一个空间，同样的视力，体力，角度，反正所有东西都要相同的情况下做同样的操作，然后获得正确的结果。那么这个时候上帝就可以捋着胡须说，好，看来我这个1+1是没有bug的！
以上只要条件差一点你都没有办法做到面向所有用户无bug化：
第一，只要不是深度克隆的两个人，就会存在一个人认为1+1等于2，一个人认为1+1=王的情况，因为这个是非常主观的东西。
第二，如果你不是处于完全相同的一个时空和坐标，那么就算同一个用户，我在做数学题时要求1+1=2， 和小孩做IQ题的时候要求1+1=王，你哪里说理去？
第三，其他所有情况不是完全一样的，也同样无法做到面向用户无bug化。比如一个体弱的人无力按不下你物理键盘，那么他就会认为你这东西又bug，一个近视到只能看到牛大一个字的，也会认为你这东西有bug...
第二种情况下，我们没有办法控制时空，且对人类克隆是犯法的（^_^），也没有办法控制所有人的所有身体和各方面的条件，所以没有办法做到面向用户无bug化。但是第一种情况下，我们作为做产品和写代码的，还是要尽量做到需求文档的细化，然后尽量的做到面向需求文档无bug化，这是我们基本的职业操守。
另外，现在都追求
敏捷开发
，代码即文档。是否真正是bug，还要看迭代过程中用户的反馈。如果你一个MVP(Minimum Viable Product最小可行性产品)出去后，大部分用户反馈认为1+1要等于2，你改还是不改？
最后，大家都看到这了，不妨停下来喝杯茶，顺便瞧一瞧鄙人写的自命为最美小清新待办清单小程序 - ”
三日清单
“吧，放心，绝对有bug！因为我没有需求文档，而又不能和神一样控制时空和人类。哈哈...","谢邀，没有bug的代码是可以实现的，不过并不取决于谁写，而是取决于系统的复杂度。
这里我们要先解释一下
bug的概念
：我们通常所谓的bug是指电脑系统的硬件（或系统软件、应用软件）程序设计有错误或者硬件本身有问题造成测功能不正常、死机、数据丢失、非正常中断等现象。
造成bug的原因
有很多，例如：
需求表述、理解、编写引起的错误
系统设计架构引起的错误
开发过程缺乏有效的沟通及监督，甚至没有沟通或监督
程序员编程中产生的错误
软件开发工具本身隐藏的问题
软件复杂度越来越高
而
最可怕的“bug”则是，软件本身无缺陷，但和目标需求不符
。
如果我们的系统复杂度是“Hello world”难度级别的，那么除去硬件问题，不用无所不能的神，我也可以（手动狗头）。
但如果我们设计的是一个极其复杂的系统，那就很难保证无所不能的神能够写出没有bug的软件了。这是因为
系统越复杂，需要考虑的东西越多，就很容易出现一些逻辑上的错误，导致出现非设计者想要的情景，甚至是bug
。
就好比上帝设计人类之时，并没有想到人类会发明出酒并大量饮酒，而酒喝多了会让人断片儿，即会造成生理功能不正常甚至数据丢失，这在某重意义上就是出现了一个bug。也就是说无所不能的上帝创造出的系统（人类）也是有bug的。
在题主之所以会认为的无所不能的神能够写出趋近于完美的软件，不过是认为无所不能的神能够拥有比人脑更加
强大的运算能力和存储能力
，
掌握更多维度的信息
，
预设出更多的问题
，从而
解决所有可能发生的问题
。
而人类虽然难以无限增加自身的信息存储和运算能力，但
我们可以利用机器替代我们完成这些
。也就是说
如果我们能够利用好深度学习这个像神一般的技术，在软件开发时候也就能够拥有无所不能的神一样的能力
。
其实20世纪探索
感知机
和
人工神经网络
的科学家都是基于这样的想法，即模拟人的大脑，但是能够
存储更多的信息
、
拥有更强的运算能力
，学习
识别物体
或
执行其他人类任务
。
深度学习在本世纪代取得的辉煌成就也都与此相关，如今深度学习的成功已经用于在照片中识别物体或分类、自动驾驶汽车、游戏、自动机器翻译、图像字幕生成、文本生成、化学结构的毒性检测、预测蛋白质的3D结构形状等。
在此，人邮君推荐三本书，
帮助你快速入门和提升深度学习，无限接近无所不能的神
。
《动手学深度学习》是一本关于体验的书。书中不仅阐述深度学习的
算法原理
，还演示它们的
实现和运行
。与传统图书不同，
本书的每一节都是一个可以下载并运行的Jupyter记事本
，
将文字、公式、图像、代码和运行结果结合在一起
。此外，
读者还可以访问并参与书中内容的讨论
。
全书内容分为3个部分：第一部分
介绍深度学习的背景
，包括深度学习最基础的概念和技术，以提供预备知识；第二部分
描述深度学习计算的重要组成部分
，还解释近年来令深度学习在多个领域大获成功的
和
循环神经网络
；第三部分
评价优化算法
，检验影响深度学习计算性能的重要因素，并分别列举深度学习在
计算机视觉
和
自然语言处理
中的重要应用。
广告
动手学深度学习(异步图书出品)
京东
￥51.50
去购买
?
《深度学习》被誉为“AI圣经”，其作者是全球知名的三位人工智能专家：生成对抗网络的发明者――Ian Goodfellow、2018年
得主――Yoshua Bengio和蒙特利尔大学计算机科学与运筹学系助理教授――Aaron Courville。
全书内容包括3个部分：第1部分介绍
基本的数学工具
和
机器学习的概念
，它们是深度学习的预备知识；第2部分系统深入地讲解现今已
成熟的深度学习方法和技术
；第3部分讨论某些
具有前瞻性的方向和想法
，它们被公认为是深度学习未来的研究重点。
广告
深度学习(异步图书出品)
京东
￥132.40
去购买
?
《Python深度学习》由
Keras之父
、现任
Google人工智能研究员
的弗朗索瓦?肖莱（Fran?ois Chollet）
执笔
，详尽介绍了
用Python和Keras进行深度学习的探索实践
，涉及
计算机视觉
、
自然语言处理、生成式模型
等应用。
书中包含30多个代码示例，步骤讲解详细透彻，立足于人工智能的可达性和大众化，读者无须具备机器学习相关背景知识即可展开阅读。在学习完本书后，相信你将具备搭建自己的深度学习环境、建立图像识别模型、生成图像和文字等能力。
广告
Python深度学习(图灵出品)
京东
￥64.90
去购买
?
========
赠人玫瑰，手留余香~
不要忘记点赞、收藏、关注 
@人民邮电出版社
 一键三连哦！感恩有你~","不用神，
linus torvalds
写软件就很少有bug，他不是自称自己从来只写一遍吗，可见没什么bug，秘密是什么，他c的编译器是自己写的，所以显然他可以DIY一下编译器，把它变成解释器用，热态写，写一行查一行，困扰程序员的一般性的错误，如内存泄露之类，都能在写时验校出。我没linus的编译器，但我用笨办法，写C也是热态不停重载动态库在gdb中边写边调边查contex，截获sigsegv信号或不停编译查错（所以我只写c，c我可控制到一秒内编译，所以边写边打F5的，其实这个1秒，如果能详细研究下links的代码，还可以大大缩短，那样我就可以用clang编译了，clang比gcc慢了0.3秒左右，尽管提示准确，且支持几种新语法，但我感觉时长影响写作思路了。如果c++，最少十秒以上才能编译一次，那完蛋了，要不停十秒十秒的等，显然不能如此写代码，一秒内不会影响和打断思路。）改好一断后jump到开头，直接热态重载动态库，再jump回原位置接着写，一般bug也几乎没有，就是最大的内存泄露解决不了。
上python的大当也缘于此，我改了下它的pdb，不停在热态循环写，直接提示contex，几乎不用动脑子记什么东西，简单死了，一遍写好后也肯定没什么常规bug。感觉这东西太方便了，结果写了一堆脚本，那知便宜没好货，当最终发现python根本干不了真正的活时，删都不容易删。
最不容易出bug的我用下来觉得是guile的scheme，那个括号一开始觉得别扭死，可后来觉得精妙无比，一个括号就是独立的一段，拷贝删除都方便无比，具然有傻子做了工具硬要把括号改成缩进。写完后一层括号后，我只要在当前层敲个 <s-k>把它发送给右窗的repl，可以一层层单独调，明面上的bug基本不会有，真试用发现有时，它可以整体-拉出每行的执行日志，可以不用进入热态调试，这时我才发现原来热态调还不是效率最高的，不用进热态但能看到热态的全部运行效率才真TM高，python也能这么干，但python给不出变量和参数运行时的值，而且方法一大速度不可接受的（因为它的catch不是在源码层是在脚本层实现的，guile是在虚拟机上做的）。
所以你写软件有bug，归根及底还是因为你水平有限导致工具有限而已。当你能写编译器时，你写常规软件会有逻辑错误，框架失败，但不会有太多bug。
象c程序员一般bug根本无感，但内存问题个个惊恐不已，没工具你就是神探也没用，我也见这个东西头皮发麻。但如果你能吃透
valgrind
的源码，把valgrind整合进gdb进行内存检查，bug与你基本已无缘。象我平时用这东西查查，基本也能扫清问题。就是1、太慢了。2、不能进入调试态查看，还要分析猜测，用gdb进去查看，太麻烦。所以有时间，我想把valgrind整合进gdb中的，那真太方便了，一进gdb，它马上告诉我内存定义或使用在那里出问题了。
其实我认为libgc也能做这个工作，比如它有个用sigsegv信号截停调试的，可以去除掉libgc的自动回收机制，但所有内存依旧调用gc来分配，并增加一个在 debug 模式下对所有分配的变量内存进行越界监控的功能，一旦越界就给出信号或调gdb来attach，因该更简单的。我觉得我把这个实现出来倒不是很费劲，正好最近又积累了不少内存错误（平时我自用的软件只要能混下去我一般都不查）。
所以现在社区的那些所谓大牛说起来忙，开发这个开发那个的，不知道忙些什么东西，没见做什么有意义和价值的东西。linus也就知道吹牛，也不把他的秘密武器公布出来让大家都用用。
有高倍的瞄准镜，从没开过抢的也能轻松一抢爆头的。世人急功近利，视底层为浪费时间，其实底层才能控制一切。
-------------追更下，我猜torvals的开发环境会怎样-----------------
""Nobody actually creates perfect code the first time around, except me. But there’s only one of me.” linus Torvalds
他写代码一次好，没bug，我想完全可能，也必须可能。
他所谓精简版的emacs因该编辑、编译、调试源码层三合一的，每次写时，先打个 ctr-b 在当前行设断点，将程序载入gdb，然后编辑，编辑中查询接口直接接入gdb，所以方法签名、全局/局部变量提示什么的全不用tags方式查，gdb直接导进complete热区（这很重要，在定义新方法、全局新变量时，可迅速查清space内有无重名和新名称要怎么样命名合适），引用的所有方法全可通过gdb定位源码，直接jump看源码，实在老了，有的记不清了，方法名上 info 一下，他们写底层，方法定义说明全进info库的。（下属开发递交上来的代码，在gdb中先自动过一遍，设个查看粒度和过滤器，将所有主要方法的调用拓扑及运行值trace出来，生成个tree看看结构有没有问题，没有就通过，如果看到有内存泄露的问题，正好装B教训他们几句，反正内存泄露类较难调的错误在他的gdb运行过程一般都能找出并传给quickfix窗口。别人？我干吗要给你们装老大，自已去编。）
然后写完一行或几行，打个enter存盘，不用再打F5了自动后台进行编译，这个过程很快几乎没有停顿和感觉，如果有错，quickfix弹窗，在编辑窗与quickfix之间轮换几次改好。改好再enter存盘一下，自动编译通过，然后gdb将编译好的内容自动重载并运行到新写作点，然后继续。在这一步一步的步步为营中，绝大部分contex上的引用错误，类型错误有gdb的现场值守，全部因能校验出。
敲了一天代码后，看下表，该吃饭了，他现在基本不写kernel了，如果写的是git，那正好用写的新的功能 git 下试两下，有问题？ gdb attach后，recreate下现场trace下，看看怎么回事，也分分钟搞定。再有问题，那是
all  bugs are shallow 
的事了，管他呢，群众的眼睛是雪亮的，给点机会大众 happy 一下不好吗？ 管他了，吃饭重要，伸个懒腰，然后 torvals 就直接 git 了，工作结束了。对了，张三pull后怀疑torvals一遍写成的东西不靠谱，张三用 gcc 编译了一下，一个 warning 也没有。写了几千行啊，没见他调试啊，高，实在是高啊，张三由衷的佩服和热爱老大。然后可能吃瓜的王二发现了个bug，这个激动得几天几夜睡不着，比中大奖还开心。当然，感激之余的他也不会忘了饮水思源的解释，这其实很可能是个”彩蛋“的！
这同样也能解释他为什么讲""
Nothing better than C
"" ，因为只有c可以技术上这么做， 并不见得他真喜欢C，其实C的编码非常乏味。因为C在本质上不是为抽象服务的语言，属于干苦力用的，所以他才有点精分的，一会又说自已 “
not a programmer  any more
.
”。
当然，广义的逻辑需求类bug不在讨论范围的，那也是
all  bugs are shallow 
的事。但torvals也不要太自信全世界就他一个人会想到这样做，我就早想到了，当然还没法完全象他那样干。","这个问题很有趣，但是也有一个陷阱。
里面潜藏的一个逻辑是：
无所不能的神来写代码，但是软件是给人用的，bug也是人提的。
我们应该假设有一个无所不能的社会。
里面有无所不能的码农神，还有无所不能的测试神。
码农神的设定是：他能写出无懈可击的代码，因为他无所不能。
测试神的设定是：他能从任何软件里找出bug，因为他无所不能。
最强的矛和最强的盾到底谁最厉害？
最强的码神和最强的测神到底谁最厉害？
无所不能本身限制了无所不能。
原来无所不能TMD本身就是个循环逻辑错误。
因此本问题提的就有bug。
打回重提。","以下是我的思考。
软件中大多数Bug的产生和程序员水平并没有直接的关系。
有人的地方就有Bug。这是人类的弱点。
你的大脑总有不在线的时候，你的逻辑并不能一直保持严谨。与智商高低亦无关。
所以，换成无所不能的神来写代码，效果也不一定好。
既然无所不能了，那肯定能写出Bug，是不是这个逻辑？
你需要的是一个永远正确的神。
其实现在人类也发明了很多技术手段来对抗这种先天的弱点。比如静态分析。
比如写C/Cpp代码的程序员，会经常写出一些内存不安全的Bug。即便高手也难以避免这类问题。这是因为C/Cpp把底层控制力完全交给了人类，靠人类的逻辑思维来保证安全性。但人类是脆弱的，包括逻辑思维能力。
所以C/Cpp会依赖编译器提供的，以及外部第三方的静态分析工具来避免人类脆弱的逻辑思维而产生的坑。
现在，Rust的出现，则又更进一步。在语言层面利用静态分析来解决特定的内存安全问题。配合严格且智能的编译器来保证开发者在底层资源控制方面不会出错。语言级别，意味着开发者写下的每一行代码，都是严谨的。相当于把C/Cpp完全依靠人类逻辑思维的状况，剥离了出来，让开发者对底层资源控制的同时，由编译器来辅助开发者保证逻辑的严谨和正确性。Rust让开发者的思维可以更接近于神，在控制底层资源的时候不容易犯错。这是Rust比C/Cpp更优秀的本质原因。
我并不是在吹Rust，上面只是我的一些思考。人类的思维本身就是脆弱的，包括我上面的思考。希望各位看官能来指出我思考的缺陷，而不是来喷我黑我。
以上。","还需要一个无所不能的神来当产品经理。
如果需求提错了，代码再怎么正确也满是bug。","无所不能的神写的软件给谁用？
软件是给能力不足的人类用的，借助计算机的运算和存储能力。
所以，神要给谁写软件？既然他们都无所不能了，人类有什么需求，直接满足就完事了，神们内部有什么需求吗？不可能啊，大家都是无所不能的了，能有什么需求要借助软件来实施？
问题不成立，没有答案。"
,,,,,,,,,,,,,,,,,,,,,
大学计算机系最努力的同学都是如何学习的？,看看大神们是如何努力的,"我来给年轻人讲讲我当年上海交大的情况和我儿子多伦多大学的情况  
我是1984年入
上海交大计算机系
本科，1988年考入上海交大计算机系研究生。大一的时候，除了吃饭睡觉，几乎都在学习，不记得有任何娱乐，最多一两个月去外校见见高中同学。我的另外三个要好的高中同学分别在复旦、同济和上海医科大，我们都是写信邀请，周期长，所以一般一个学期也就聚两次。平时没有周末，8个人一个寝室，每个人都是只有教室、宿舍、食堂三点一线。也从来没有什么卧谈会，所谓的睡前聊天，完全没有。聊天都是一起食堂吃饭时聊天，吃完直接去教室。除了体育课，没有任何运动。前两年我们都是用的
Pascal语言
编程，三年级开始用C语言。
从二年级开始，周末已经慢慢开始有休闲时间了，唯一娱乐是打扑克牌。当然周末只是周日，周六是weekday，和平时一样上课。weekday和一年级差别不大。
三年级开始轻松一些，因为专业课相对容易，经常熄灯前一个多小时就回宿舍了，打扑克一小时。四年级打牌时间更长，经常上两个小时的自习，作业做完就回寝室打牌了。四年级毕业设计时就是天堂了，白天机房，天天晚上都是打牌。
我三年级开始谈恋爱了，一般周日都去女朋友的学校当时叫
华东化工学院
，晚上到她学校的舞厅跳舞，然后11:15分末班公交车50路回交大。学校的舞厅要么是体育馆，要么是食堂，作为大学生最火的娱乐，票子非常紧缺。交大唯一的舞厅是体育馆，每周一次是周六晚上舞会，每个班只发两张票。化工学院比较好，3个舞厅，周六周日两场，所以能够买到票。
总的来说，四年大学还是打好了扎实的基础，为将来的工作做了很好的准备。我们班很多同学还是很有成就的。成绩第一的
胡振江
，一直是理论研究，现在是
欧洲科学院
院士，北京大学计算机学院院长。顾延，做过跨国公司
阿尔卡特
CTO，百度CTO。
叶伟民
，中兴通讯付总裁。因为在风口上，还有几个同学控股参股的公司A股上市了。只可惜大部分同学都早早去了国外，错过了国内发展的风口。
研究生时是最轻松的，我们系共17人，一半是交大的，一半是外校进来的，我们系和电子系、自控系住在研一楼九层楼上，宿舍不熄灯了，两个人或者三个人一个寝室，没有多少作业，有努力的同学和导师做做课题，大部分的同学经常打扑克牌、下军旗
四国大战
。我们一层楼有大约20个房间，总有几个房间晚上在打牌下棋。
二年级时，无锡电子研究所的三个工程师找到我，我们一起开发了国内最早的动态心电监护系统，替代进口，找了香港人投资，我们技术入股，成立了深圳金冕电子仪器有限公司。我们也坐上了风口。很多很多的故事，到1998年，我退休至今。
我的导师特别好，我毕业设计很简单，因为我没有时间，深圳、上海两边跑。学校计算机不够用，我给几个四年级的同学机时，他们帮我编程，算是完成了毕业设计。
下面我介绍我儿子在多伦多大学计算机系的情况。
先说他本科是多伦多大学工程科学系，是多大最牛的系，没有之一。他自己计算，每周有5个小时的自由时间，除了学习睡觉吃饭。买21个玻璃饭盒，每周日做一次饭，分成21份，每天吃三个，微波炉加热，没有时间在酒店点菜吃（高中四年午餐都是酒店点菜吃）。三年如一日。四年级和女朋友住一起，有所变化。上课永远坐第一排，努力回答问题，让老师记住他，暑假前才能写信跟老师申请科研工作。
硕士研究生和博士进了计算机系。到现在博士3年级了，总共在多大7年了，没有休息过周末和寒暑假，每天每天工作和学习，我佩服的五体投地。唯一陪女朋友旅游一次是今年暑假。女朋友也读博士。
他今年5月到12月在一家公司实习，是世界前7大动漫游戏公司，他经常一次动用二十台计算机运算，大学里没有这个条件。今年9月，他正式告诉我，他决定每周休息一天。
他的努力有回报，已经在计算机图像领域最权威的
siggraph
杂志发表了两篇论文，今年丹佛的年会上，他演讲完，英伟达主动找到他，邀请他去工作。
看到这个题目，做为老一代计算机系学生，一时兴起，第一次发言，不当处，多包涵！
2024，10，19
我是刚刚实名制登记，甚至没有评论过别人的贴子，第一次发帖，完全没有想到这么多人看，非常感谢大家
更没有想到评论中最多的问题是问我退休后的生活，  巧合的是其中一个还是我的大学老师的中学同学，所以有长辈问，我必须说一说。其实我31岁又三个月退休后，很多同学朋友也一直问我这个问题。
我是一个好奇心很强的人。我一直以为人在宇宙中太渺小，甚至银河系都是亿万星系中的一个而已。世界很大，我又好奇心重，想了解世界是我退休生活的主基调。
我第一个家肯定是深圳。后来上海第一套房是古北新区一期，金色房产证，外汇买，涉外的，所以很多国外频道，我们家电视永远只看一个频道，discovery美国国家地理杂志。
我最想了解的是全世界的人是怎么生活的，我对风景不太感兴趣。所以，看书、看纪录片，看新闻，经常各地去见朋友聊天。也旅游，今年6月份和太太一起西班牙三周多，7月在南部非洲，总共50天。
我退休后第一次旅游是1998年和太太去新疆哈纳斯湖。乌鲁木齐租了一辆
北京吉普
2020，朋友帮忙请了布尔津县的医药公司老总做导游。从牧民手里买了两只羊放在后备箱做食物，吃住都是沿途在哈萨克和蒙古人的家里，从那时我知道了我更喜欢了解人，而不是风景
我经常一个人住在丽江、凤凰、芙蓉镇这种古城，一住就是两个月。酒吧里和天南海北的人聊天，也认识很多朋友，听很多有趣的故事。当然我家保姆是最不喜欢我这一点，经常会有各色人等到我家吃住，增加她的工作量。当然现在情况变化很大。第一次去丽江，1999年，总共不到10家酒吧，酒吧老板、游客很多都是艺术家，很有趣，见过几次就是朋友了，喝酒互相买单，白天组团一起租车。后来慢慢变，商业化越来越浓，游客也都急匆匆的，不像原来都是慢生活
2012年来加拿大，一方面是因为两个孩子读书，移民可以省很多学费。更重要的是，体验新环境，看洋人是怎么生活的。所以我和邻居们处的很好，犹太人法国人伊朗人，经常一起吃饭聊天。我刚才说今年夏天出去旅游，开始时忘了交代孩子草坪割草，结果隔壁的犹太律师，77岁了，看到我家草坪草太高了，自己跑来给我割草
出国后也解惑了一些以前的一些疑问。比如，过去看美国电影，经常看到偷车的，不用钥匙 直接开门，拉出几根线，几个
电火花
就发动了车。我去费城一个朋友家，她白人丈夫从不锁车门，无论在哪儿停车，包括新买的
牧马人
，他的宠物。我太太最要好的闺蜜在水牛城，曾经的钢铁重镇，大工业时代有三十四万钢铁工人，离多伦多两个多小时。她买了房子二十多年，从来不锁门，我们随时开车就去了，推门就进，做好饭等他们下班吃饭。知道了为什么美国的职业政治家才会撒谎，因为普通的红脖子可能一辈子都不会说假话。
多年英语忘光了，来加拿大前几年上课学英语，加拿大政府免费对新移民开的。老师都很好，讲很多风土人情，加拿大的知识。
我学以致用，一个人去印度住了三个月。到了一个城市，拼命和当地人搭讪，如果有缘交一个朋友，就住半个月，看看他的生活；不成功就换下一个城市。最好的体验是在恒河边圣城瓦伦纳西，交了两个朋友，住了二十天。我选的酒店离一个露天火葬场只有80米远，24小时不会停歇地烧，我每天都会站在那里看好久，和家属聊天。思索人生的最好地方。无论贫贱，烧的结果一样，只是用不同档次的木材
好奇是我的一个性格。懒也是我的另一个特点。所以我说我非常佩服我儿子，他极其勤奋。
我喜欢打扑克，线上线下都打。我至今最要好的朋友，都是中学田径队和篮球队的同学，平时一起上课一起训练一起比赛，寒暑假在一起打扑克，大学时也是这样，放假大家都回老家，假期一半时间打扑克。我太太也是扑克迷
来加拿大，入乡随俗，运动时间更多了，每周至少5天，一般自己四天排球，一天陪太太网球 。
我的一个大学班主任告诉我，30岁之前了解自己，人生成功了一半。我非常同意，扬长避短才能成功。但是不容易，大部分人高估自己，无视自己的缺点。
如果能掌握了这条，管理也是易如反掌，安排工作发挥员工的长处，避其短板。社交也是如此，我在儿子高中时训练他，尽短的时间，发现对方的优点，巧妙的表达出来；或者找出对方擅长的领域提问题，增加好感还增长知识，沟通的技巧是少说多问。
另外我岳父汤任基对我的早早退休影响很大。他是流体物理学家，三钱之一
钱伟长
清华的研究生，80年正教授极少，他已经是博导了。他说人生就是猴子爬树，越底下竞争越激烈，不小心被别人一脚踩下去了，要尽快拼命爬到上面，上面很多树杈，你可以坐在上面，很不容易掉下去，风景也很好。你可以选择，继续爬也可以。我选择了停下看风景。
一口气想到哪说到哪，比较散。总的来说，过自己适合的生活。像评论区有朋友说的，儿子大学毕业就工作了，全家一起经常旅游，没有那么累，过的舒服。我完全赞成！
2024，11，21
评论区有朋友问勤奋努力的习惯是如何养成的？
我来讲一下我儿子习惯的养成，希望对大家有帮助。
我完全是用的目标导向。
我是煤矿子弟，所以我初中毕业的时候，三分之二的同学就到工厂去工作了，三分之一的同学读高中。后来到九十年代大量的国企倒闭，我一半的同学就失业了，生活非常困顿，有的在传达室看大门，有的做保安。我从小就刻意的带儿子到他们家里去，回家以后就告诉他，如果学习成绩不好，将来的生活就是这样的。
我高中是上的省重点中学，大部分同学都读了大学，我会带他到在老家工作的同学的家里去看，告诉他如果读了大学情况就会改善成这样。
带他到上海同学的家里去，然后告诉他如果读了最好的大学，就可以生活在喜欢的任何一个城市，过非常好的生活。
当然，如果碰到乞丐的话也会告诉他，如果完全不上学的话也是可以生活的，就可以当乞丐。
当然，这个工作不是一次两次是要反复多次进到他的血液里。
所以等到他上小学的时候，他就已经有这个想法要进最好的小学。当时上海最好的小学是世界外国语小学，他上海科技幼儿园的老师告诉我们至少要认识3000个汉字才能考进去，最好还要学点英语。正常每年8000个学生报名考录取160个，四个班，每个班38个人是考进去的，每个班学号的39 、40是要走大领导的关系，特批进去的。
他有了发自内心的这个想法，我先是花了10天时间教会了他汉语拼音，然后给他买了我们家的第一台手提电脑，东芝电脑，买了一套学认汉字的游戏软件叫《娃娃丫丫》买了全套的英文原版的《米老鼠和唐老鸭》。我们保姆的工作就是每天早上起床，只要他玩玩具，就一边给他电视上放《米老鼠和唐老鸭》。其他不玩玩具的时间就是陪他玩《娃娃丫丫》。当然我们夫妻都不陪，因为反复让他知道，学习是他自己的工作。三个月后他成功了
他所在的上海科技幼儿园只考进去了两个，我儿子的学号在班里是32号，也就是说他在班里入学考试成绩是第32名。
有了这次成功的经验，他就知道了，只要努力什么都能做到，他有了信心。
刚进高中的时候，他为了进网球校队，他每天早上起床两个小时，下午放学三个小时在我们小区里免费的网球场认识打得最好的人一起打，后来成功地进了校队。
大学的时候暑假他都是一边搞科研，一边拼命地练滑板。现在他的长版 long board dancing是美国和加拿大的冠军，没有对手，只要他参加的比赛都是第一名，今年的世界锦标赛进入前八名。他一个人三年举办了三届加拿大全国比赛，现在是北美地区最有影响力的比赛之一
下面这个是他主办的第三届加拿大比赛，有十个赞助商。
视频资源加载失败","垃圾本科，非清北复交985牛逼学历，
智商平平，非
ACM
拿牌sci论文天才光环选手。
就只靠自己一个人的努力，本科毕业前实习过多个大厂，拿到字节跳动，网易等多个大厂offer。
看到这里是不是应该算比较努力了？
不，还没有！
从大一开始，只靠自己，疯狂努力。
不仅所有计算机相关科目课程的成绩全都拿到90+满绩点的分数，
同时，在大学用拼命的两年的时间, 做完了其他优秀的学长学姐三年才做完的事情，
努力参加各种计算机相关比赛,获得若干省部级，国家级奖项，
拿光了学校里所有学年的各种奖学金，
并在大二就以综合素质全系第一名的成绩就拿到了学院唯一的国家奖学金。
大学四年时光，整整两年没有回过家，不是在实习就是在兼职。
保研曾在某985院校复试排名第一，最后以排名靠前的成绩保送至浙江大学计算机硕士。
本科毕业前实习过多个大厂，拿到字节跳动，网易等多个大厂offer
......
我知道我其实算不上计算机系最厉害，最努力的同学，
但是当我毕业后看到这个知乎上的这个问题，
脑海中回想到当年那么努力的自己，心里是真的如翻江倒海，五味杂陈。
一个从十线小城市出来，
没有优渥的家境，没有过人的天赋，没有从小就受到精心的培养，良好的教育的普通人，
要么拼命努力
，
要么自暴自弃
，好像就没有其他选项？
平淡无奇的普通人，拼不了爹，拼不了妈，只能拼命。
大学计算机系的同学努力一些的，要么只专注于比赛论文成绩绩点，保研出国，要么只专注于计算机技术毕业拿到大厂offer。像老学长这样两方面都有一些经历的，应该是比较少的人。
同时一路走来，我也踩过不少坑，走过不少弯路。既然问题是如何学习的，那么我也作为一个过来人，给计算机专业学弟学妹们写一写计算机专业学习的一些经验。我会从校内学习，尤其到校招各个技术岗位的求职学习都抽空写一写，无论你现在是大一研一还是大四研三，真心希望下面的内容都能帮助到你们。
很多同学发私信给猪学长求一些计算机学习的
书籍推荐
以及
字节、阿里、腾讯
的校园招聘面试
面经
，这里先分享给同学们：
一、说在开头，计算机真的是一个努力可以改变命运的专业
首先相比于其他大部分专业，我真的觉得计算机计算机是真的可以通过努力改变命运的专业。
其他大部分的专业，大学里主要的优秀就是学好专业的课程，取得一个优异的成绩，然后再参加一些专业相关的项目比赛，或者本科能有一些科研论文，就足够代表这你在学校内很优秀了，毕业无论找工作求职还是继续升学深造都足够了。
但是计算机专业真的特别不一样。
计算机专业技术岗位的求职几乎跟校内的成绩没有什么太大的关系，
甚至可以说校内的学习成绩对于找工作来说几乎真的没什么用。
产生上述现象的原因，
就是国内的计算机专业课堂上所传授知识，跟企业里的面试官要求的标准相差太多了。
甚至计算机专业还会出现很多奇葩的现象，就是成绩比较不错的同学反而求职并不成功。
我甚至见过一个985大学，计算机科班，专业里排名前几名的女生，面试连一个最基础的
二分查找
都写不出来。成绩单上门门课程都写着90+，但是具体一些技术内容完全都回答不上来。
但另一方面，我还见过有的同学，大学几乎不上课，挂科无数，学校里所有的活动都不参与，只专心低头学技术。最后毕业的时候成功拿了很多大厂offer。
于此同时浙江省有很多双非本科的学校，ACM校队实力超群，每年都会有很多能力超强的选手在ACM编程比赛上摘金夺银。但是尽管他们并没有非常牛的学历，甚至有些选手校内成绩也一塌糊涂，但是并不影响他们毕业找工作时疯狂收割offer，甚至本科就可以进入谷歌微软等知名外企。
也正恰恰因为如此，计算机专业也是不限出身，不看成绩，最可以通过努力改变命运的专业。
金融行业一直流传着一句非常有名的话:
清北复交以下无金融
如果你是金融专业，普通本科的同学，
那么毕业很难进入头部金融名企去工作，而只能是去卖保险推理财。
但是计算机专业这些年来双非本科进大厂的故事每年都在上演，只要你肯努力，一定会得到回报。
二、掌握信息源，打好基础的大一
我的大一在其他同学还在游戏中疯狂战斗的时候，我做了
两件
让我整个大学受益4年的事情。
1、结识了很多优秀的学长学姐
物以类聚，人以群分
如果你认识很多优秀的人，你自己就会慢慢变优秀。
到了大学的时候几乎每个人都会迷茫，我也是一样的。
但是迷茫的本质是你没掌握到足够的信息。
我的开头有写到我在大学里非常非常的努力，做了很多很多的事情。
但是这些的前提是你首先要知道要了解这些事情。
我在大一的时候，也跟所有普通的新生一样，
面对崭新的大学生活，各种各样眼花缭乱的社团，并不知道在大学里该做什么。
这时候我选择走出寝室，去多结识学院里很多优秀的学长学姐们。通过一两个月的时间，我就发现真正厉害的学长学姐们都特别的忙碌且低调，他们一般并不在各个社团里抛头露面，当什么部长团长，而是都把时间投入到非常重要的事情上。但是，当你真的找到他们向他们请教问题的时候，他们都非常的友好热情而且热心，告诉你很多大学里关键的事情。
我在大一上学期的时候就认识了我们学院当时大三拿到国家奖学金的优秀学长，并向他请教很多经验。很早就知道了
国家奖学金
的评比条件，准则要求，大学里有哪些比赛含金量非常高需要参加。同时我在大一的时候也认识了
保研名校
的优秀学长，早早的在其他同学还不知道保研是什么意思的时候，学长就给我分享了当年他们那届的保研文件，对里面的要求细节了如指掌。
也正是因为我在大一就知道了很多信息，所以我才能早早的准备，因为知道自己不是天才，就只能比别人更早的行动！
每次评奖学金的时候，当你刚刚知道别人申请表上有某个荣誉的时候，有可能他一个月前已经出结果拿到了，三个月之前已经去参加比赛了，六个月之前就开始实施准备了，一年前已经提前知道了。
掌握信息很重要。
2、大一就开始早早刷题，打下了扎实的算法数据结构基础
我看了这个问题下面的很多回答，都推荐了很多各种各样的巨厚无比的计算机类书籍或者非常高深的项目。但是我觉得对于计算机在校的学生来说，首先最关键的就应打下坚实的编程功底，提前尽早扎实的掌握算法与数据结构基础。
说大学
：如果你大学里想要超过很多同龄人，在成绩比赛等加分方面超过别人，大学计算机专业里有非常多程序设计类比赛都是非常有含金量的。如果你能在大一就多刷一些题目，打下坚实的编程基础，绝对可以让你在大二大三在各种别赛中崭露头角，最后大学里各种评奖评优奖学金都不是梦。
说深造
：如果你有意向大学毕业进入高等学府继续深造，那么无论你是保研还是考研。现在国内著名的计算机高等院校复试均有上机
在线编程
考试。无论你大学里成绩多优异，无论你考研初试多高，研究生复试机考永远是你不可避免的一关。大学里热爱算法，热爱编程刷题很多的同学们，往往都会在机考中取得优异的成绩，甚至可以弥补你初试分数低的不足。学长还见过大学里非常优秀的其他同学，就是因为只注重考试的分数，疏忽了对自己编程能力的训练，最后导致复试机考爆冷，与自己心仪的大学失之交臂的。
说工作
：随着国内互联网行业的发展，对编程人员求职者编程能力的考察越来越重视。如果你以后希望去外企工作，你会发现外企非常注重对求职者算法与数据结构基础，编程能力的考察。国内互联网早些年可能不会要求职者面试时编写程序，现在几乎各大公司面试都会模仿外企的模式，考察求职者的编程能力。很多面试题背很多，很多开发框架了解多少，面试造的火箭对你以后做的工作不一定影响很大，但是你的编程功底是否扎实直接影响了你以后的工作效率。如果你没有通过编程题目的考察，几乎很难通过心仪公司的面试。
自己虽然不是ACM选手，但是也同样深知打好扎实的算法数据结构基础的重要性，在大一早早的就开始刷题。让我之后在大学中的各种程序设计类比赛，保研复试机考，大厂求职面试都受益匪浅。
说完了重要性，那么该如何做呢？
学长之前在工作闲暇之余随手回答过一个关于编程的问题，没想到帮助了很多的同学，收获了800多个赞同，这里我就不重复写了，如何做可以看一下这个：
二、没有休息的大二
回想一下大二的我，好像真的没太休息过......
我们大学中大二的课程是非常非常满的，因为自己大一就定下了要拿国家奖学金的目标，所以在专业课程方面丝毫不肯松懈，不仅不能轻易翘课，就连平时作业都需要尽可能的都高质量的完成。与此同时我还给自己计划安排了大量的校内项目，国内比赛要参加。
我是一个非常喜欢早睡早起的人，我的本科室友们都是会玩游戏到很晚，早晨起得也晚。我为了不打扰他们，同时又不让自己懒床，我天早晨都定两个闹钟。
一个是手机振动放在枕边:
一个是金属闹钟放到床下桌子上：
闹钟设置成05:30, 手机振动设置成05:20。
这样每天就能05:20被手机振动叫醒，同时因为10分钟之后，床下闹钟就要响了，自己还不能贪睡。这样就能做到，既让自己早起，同时又不打扰到室友。
同时起床之后洗漱完毕，我也会静悄悄的收拾好书包，然后迎着6点的清晨第一个冲到自习室。几乎大二的无数个日子每天都是在这样的晨曦中开始。
因为自己要参加很多的计算机类比赛，大学中的比赛主要就分为程序设计类比赛与软件设计类比赛大类。
算法比赛方面:
自己在大一打下一定的算法基础之后，大二又阅读了很多算法相关的书籍:
比如非常经典的刘汝佳的紫书,第一次学习这本书简直太爱不释手了，里面有大量的精彩的高频算法题目的归纳与精彩的讲解。记得当初非常认真的去复现里面好多的题目，然后跑去
oj平台
上去提交。
还有蓝书，有一段时间我对图论相关算法特别痴迷，觉得紫书里面题目还太少了，就买了蓝书去专攻图论相关算法题目。另一方面也是为了后面要参加的算法比赛做准备。蓝书里面有大量的不同算法专题的ACM经典例题与讲解！
巫神的挑战程序设计竞赛，这本书也是非常棒的！里面分为不同章节，由浅入深的介绍各种算法。最关键的是，里面给出的很多算法模板都非常非常的经典。是一本不错的算法比赛学习书籍。
其实此刻在写这些的时候，回想当年的自己也是觉得走了不少弯路。当年因为我本科学校是垃圾弱校，学院根本没有ACM队伍，其实上面这些书籍的内容有些偏深了，比较适合ACM选手。但是作为普通的计算机专业学生，我当初花了好多精力练习的很多偏深，偏难，偏怪的题目其实后面也不太常用到了。还不如多刷刷
LeetCode
实在hhh。
然后还有剑指offer
上面这些书籍有需要的，这里先分享给同学们：
我是在大三时候才知道剑指offer这本书的，其实上面的那些ACM级别的算法书我都阅读过之后，
剑指offer
其实就有些更偏基础了，好像60多道题目，都不算很难。
在这期间，我一直活跃在各个oj平台上，然后积极参加各种算法比赛。我贴我一直比较喜欢，一个冷门一点的oj:
哈哈当年的账号都已经找不到了。
项目比赛方面:
同时因为项目比赛我不太喜欢依靠别人，抱别人的大腿，所以一般我都是自己一个人是队伍中的主力。
大二那一年我涉猎了非常多的不同方向的软件开发技术，几乎比赛需要什么，我就立刻学什么，然后就开始上手开发。
搞过
Qt
，当时看的是这个，顺手也把c++期末大作业给搞了。当别人的c++大作业还是控制台的某某管理系统的时候，我用
QT
写了一个3000多行的带图形界面的桌PC端软件，老师直接就给了我98分的成绩让我印象非常深刻。
玩儿过Android ，为我当时还在上小学的小弟开发了一个数学算数训练小游戏的App。同样不仅参加了一个小比赛，而且同时还作为了java课程的期末大作业。我记得当年好像是用安卓写了一个小的游戏机app，里面有别踩白块，
汉诺塔
等几个小游戏。现在app已经找不到了。
上面这些书籍与项目如今都免费分享给同学们：
然后同时写过web，搭过电商网站......
这其中有的是自己对技术感兴趣，有的是项目比赛需要。
回忆起来最有趣的事情，是我曾经还花了一个通宵的时间写了一个
游戏脚本
，30元一份的超低价，一晚上卖出去
500
多元，后来才知道贩卖游戏脚本不合法，吓得我赶紧就收手了。
哈哈哈，但是我当时一晚上写游戏脚本赚500块钱的事情还是在学院里传了很久。
悲催的期末:
因为自己要参加的比赛，项目太多，有时候当比赛与期末考试周赶到一起的时候，简直就是如噩梦一般的存在。
单片机期末，通宵到天亮。
还记得当初大家都觉得单片机好难好难，我好像是全班为数不多把功能都实现的。
终有收获:
我只记得我大二那一年课真的是巨多巨多，然后真的是好忙好忙。但是努力的付出终究是有结果的！！！
长风破浪会有时，直挂云帆济沧海
当大二下学期结束，大二一年的成绩几乎满绩点4.0，同时辛苦很多时间参加的非常多的比赛都有了收获。
然后终于等来了我们那年的国家奖学金的评选。
按照当年我们学院的规定，学院每年有四个国家奖学金名额，大三学生分配三个名额。只分配给大二学生一个名额。
我当时怀着忐忑的心情像辅导员提交了申请表，因为当时并不知道系里其他同学的实力情况如何，自己能否当选。
当评选结果公布，我在公示栏上看到了自己名字的那一刻，
我感觉一切的付出都有了结果。还清楚的记得当时每个公示的时候，我的个人信息是跟三名大三的当选的学长学姐并列在展览栏里，我大二的履历栏里的经历就和他们大三时候一样多。
那时候我才发现，我用两年的努力，做完了他们三年的事情。
三、说好""休息""的大三？
当我踏入大三年级的时候，我的成绩已经在专业排名里比较靠前，综合素质排名全系第一。虽然我们学校非常差，保研名额不是很多，但是只要自己大三正常上课，自己不作死，几乎保研是十拿九稳的事情了。
因为自己真的大一大二太辛苦了，同时也实现了拿到国家奖学金的这个目标。自己原计划在大三可以休息一下。
但是学长得知的一个消息，彻底改变了我的整个大学轨迹。
因为我本科的学校是一个垃圾本科，没有很多985名校那些学生自带光环的学历。
之前一直觉得这样的学校是不可能有机会进入阿里腾讯这样的大厂的。
但是自己大三的某一天突然得知，自己上一届有一个一直非常低调的学长毕业拿到了阿里巴巴的offer。
自己永远记得当时自己那个惊讶的程度，在那时的我眼中，垃圾本科学校跟阿里腾讯这样名企是根本毫无关联的事情。
然后我就详细跟这个学长请教了好久好久，那个学长人非常非常好，耐心的跟我说了好多他的经验以及准备过程。
那时候我才刚刚知道什么是互联网校园招聘，什么是大厂求职面试，什么是秋招春招，才发现校招技术岗所考察的东西跟学校里学的东西几乎完全不一样。
自己虽然是学校里“成绩优异”的好学生，但是竟然与企业里要求相差甚远。
同时学长也告诉我，去大厂实习非常的重要，不仅可以学到学校里学不到的企业里真正的研发技术，同时还可以作为简历上很大的加分项。
然后我的大三就开始又放弃了休息，再次开始进入疯狂的模式，
我时隔好久再次又在大三走进了考研自习室......跟着所有大四考研的学长学姐一起，他们准备考研复试，我开备战大厂的实习。
我在大三上学期花了
三个月
的时间，每天早睡早起，除了上课以外，放弃所有的课余休息时间，复习准备冲刺。
看了
无数本
重要的技术书籍，学习并跟着做了
好几个
比较优质的项目，在
csdn
上写了
400多篇
读书笔记，刷题笔记，
首先最开始的时候，
我先通过校招面试题了解到，原来想要面试一个大厂技术工作岗位，原来需要在一个方向上深入的精通，而不是像自己之前那样瞎搞，所有方向都会一点儿，并不深。我就开始锁定的方向上大量的，先结合面经，然后深入的看很多很多的书。
因为计算机相关书籍实在是太贵了，就一本一本的去网上寻找电子版的。你们可以看到我的截图里，每个书籍前面都标明了页数，这些都是我自己认认真真阅读过的书籍，并不是像其他人随便搜集到的资源。
然后项目方面，我花了好几百块钱在某宝上买了很多的优质的项目课程：
上面这些书籍与项目如今都免费分享给同学们：
然后这块真的是采坑太多了！！！
网上好多的卖项目资源的都是骗子，买到手里之后发现项目都是非常差的那种，技术也非常落后。
这块真的是踩了好多的坑，浪费了不少的钱。最后终于找到了一些跟自己方向一致，比较优质的项目。
上面的每一个我几乎都是先点进去大致了解，然后最后挑选出最好的几个项目自己深入去学习，同时在电脑上配置相关环境跟着实操，以此来充实自己的简历。
然后开始准备在网上投递简历，寻找实习。
原本以为普通垃圾本科的我不可能又大厂会看上我的简历，真的没想到在投递后，竟然有很多公司的hr电话联系了我，其中还有很多大厂。
在之前我那个时候，好多公司的日常实习还都没有远程面试，都要求必须去现场面试。
因为联系我的很多公司都不在一个城市，我只能选择面试机会最多的城市跑过去面试。
最后在大三上学期结束的那个寒假，其他同学都回家过年的时候，我放弃了回家，自己一个人跑去了北京面试。
原以为自己能找到一个实习就很错了，但是真的没想到最后经过了非常多公司的忐忑的面试后，自己竟然几乎全部通过了，其中还拿到了多个大厂的offer！！！
那时候我刚刚大三上学期......
当人生中第一个offer进入我的邮箱的时候，我真的不知道我的人生从此被彻底改变......
千淘万漉虽辛苦，吹尽狂沙始到金。
四、后记
别人的人生我不了解，至少我看到的世界里，我周围所有的同学，同事，小伙伴们都是: 
越优秀
的人越懂得
努力
，越极度的
自律
。
但是如果你能看到了这里，透过我的大学经历你会发现，不仅仅只能低头的努力，越早的掌握信息，越早的找到努力的方向，是远比努力更重要的事情。
知道怎么做远远比低头去做更重要。
同时你也会发现我的大学里也走了不少的弯路，我是少数既花时间在国奖保研上，又拼命找工作求职的。在计算机专业这是两种截然不同的维度。
如果你在大一就决定今后想要去国内外更好的学校读研深造
，那么你就应该像我大一大二时候，早早的掌握保研，考研，留学相关的信息。像我大一大二那样努力的搞好成绩，然后了解清楚学院内评奖评优的各种规章制度，制定好计划，去实施！
如果你决定毕业想要早些工作
，那么计算机专业真的是一个不看出身，甚至连专业都不看的行业。你只需要早早的关注求职，校招，面经，岗位等相关信息。早早的出去实习，学校里的很多无意义的事情，甚至成绩你都可以不用关心！毕业的时候拿到bat大厂offer不一定是遥不可及的事情。
在我后来的读研以及毕业后工作的期间，无数的学弟学妹们都来问我许多非常经典的问题:
我的学历不好，不是985、211有机会进大厂吗?
我本科专业并不是计算机的，有机会进互联网公司吗？
等等......
我在多家国内头部互联网大厂，跟无数面试官聊过，在校园招聘中，
几乎没有一个技术面试官会因为学历专业出身去歧视候选者。
互联网技术面试官就是会认真的去考察候选者的真正实力。
985/211计算机科班硕士毕业拿不到大厂offer的人比比皆是，
双非本科逆袭进大厂的故事每年都在上演。
我知道有很多
学校非常差
的同学，
有的在ACM赛场上挥洒汗水艰苦努力，有的甚至早早的就在大二从学校溜出来去大厂实习的。
而还有的同学身在
985
甚至
C9
这样的计算机名校里，
昏天黑地
，
游戏里激情人生
，
浪费四年
，
一无所知
。
都已经毕业了，待在家里的时候才开始到处投简历。
无论你现在处在任何阶段，如果你能看到老学长的这篇回答，同时还真觉得有收获，
放下手中的手机，关掉电脑中开着的游戏，好好对未来规划一下，我觉得一切都还来得及。
最后留下一句我一直特别喜欢，一直用来鞭策自己的一句话，送给大家:
10698字
....我吐了....就先写到这里吧.....手好酸.....
到这里
10698字
都看完的同学，如果觉得有收获，不要只偷偷收藏
白嫖
猪学长， 给猪学长留一下一个
赞
呀，这样也可以让更多的小伙伴看到呀！
后面老学长的经历还有很多很多，
保研读研，校招求职，方向专业，工作经历
......之后有时间再更啦。
五、赠人玫瑰，手有余香
上文中提及到的所有
技术书籍
，
项目课程
，
校招优质面经
我之前一直都有认真整理，其中有很多某课上的优质课程是我曾经花了很多钱购买的，现如今也已经毕业啦，都分享出来直接分享给有需要的同学们。
如果同学们还有其他什么问题，欢迎在评论区给我留言呀，不忙的时候我都会回复的。
然后所有对字节跳动实习，或者求职感兴趣的同学，
想找学长内部推荐的，也都统统都可以联系猪学长，记得点一个关注呦 
@风口浪尖上的猪
 
Update：
啊啊啊啊啊，猪学长又肝了10多天，累死猪了！
15000字长文字节现在java求职攻略更新了啊！！！！
然后对很多同学提的问题我更新一个问答环节！！！
在这里我对几个高频的问题统一给学弟学妹们回答一下:
1、我学历并不是985/211有机会校招进大厂吗？
看了我这篇回答，很多同学心里应该特别清楚了啊。
互联网校园招聘技术岗求职
，学历真的影响没有金融专业那么大。
学校名称，在整张简历上只占4个字！！！！！你能实力绝对跟4个字没关系！！！
举一个最简单的例子，如果一个同学是985学校的毕业的，简历上除了985学校几个字，其他空空如也，面试问的问题都不会，实习经历也没有，算法题也写不出来，你觉得他能进大厂吗?
如果你是双非的，你能做到
阿蓝
这样，你觉得呢？
2、我专业不是计算机，我能进互联网行业从事计算机相关岗位吗？
这个是我太太太太想回答的问题了，我身边两个部门里工作多年的
高级开发工程师
，本硕都不是计算机专业的！！！！
很多同学从一开始就想当然错了，认为我想要当程序员，我大学专业必须得是计算机，然后大三就开始夸考计算机，然后考研疯狂内卷！！！
你可以问问身边计算机科班的同学，几乎所有人校招求职几乎都是靠自己自己学，学校会上一些计算机相关课程，但是那些真的无关紧要啊。
同时，真的互联网校园招聘是真的不看应试者的学历专业，因为很多面试官自己本身都不是计算机专业的！！！
我之前在网易工作的时候，我亲眼看到我们老大给一个历史专业的同学面试机会，去面试他。
我一开始很惊讶，然后我老大说现在其他行业都不景气，同学都是想靠自己努力找到好工作，而且他简历也非常的优秀，不会因为他是历史专业就不给面试机会。
现在
通信专业
转计算机都是常态，通信还算跟计算机沾点儿边，其他专业比如
本硕生物
的，
本硕机械
的，这些一样有通过校园招聘进互联网大厂的啊！！！
很多同学都是活在自己的信息世界里，导致走了很多很多的弯路！！！
3、我已经毕业了，但是所从事行业不是互联网，想再去做程序员有机会吗？
每次看到这个问题我都只能说非常的惋惜，我前面说的求职不看学历专业真的只限制在互联网校园招聘中。
如果同学你已经毕业了，那么你就失去了应届生的身份了。你只能走互联网社会招聘。
互联网社会招聘技术岗位非常看重你上一份的工作经验的，如果你上一份的工作经验不是技术岗位，
对于部门来说你几乎都不如校招生，所以是很难通过大厂的社会招聘的。
至于其他中小型互联网公司能否接受转行的，这个我就不太了解了。
Update2
猪学长又更新回答啦！
关于算法编程如何提高，更相细版本的大家可以看这个！！！
Update3
猪学长又更新回答啦！
这个回答是关于互联网校园招聘详细的时间介绍的，
想要求职计算机的同学们一定要留意一下互联网校招时间早早准备！！！
真心希望可以帮助到你。","谢邀，没见过贵系/
姚智
/图灵班/信科/致远/竺院的大佬，这里提供一个我室友，末流985CS卷王的例子。
大佬入学的时候还只会python语言，军训的时候就开始看紫书和一本信奥的教材。等我们军训完，大佬已经开始活跃在我们学校的oj论坛上问各种学长学姐问题。我们平时的作息时间是，早上没课就睡到下午，下午没课就睡到晚上。大佬的作息是，有没有课都是十一点睡觉（打cf时除外），八点起床，四年雷打不动。开学两个月有个ACM队新生赛，大佬当时貌似是排第六还是第七，前面都是OI爷。 然后，大佬就开始了疯狂的训练，我印象比较深的就是他每周除了会打leetcode周赛，
atcoder
的竞赛，vj上的集训，cf也是经常熬夜打（为此还和我们闹翻过一次，毕竟太吵了，当然大佬后面打cf都是去自习室了）。我还偷偷关注了他的博客，发现他题解几乎每天都在更新。  除此之外，大佬每次上课都是在第一排最左边或者第一排最右边的位置，而且总是随身携带着一塌厚厚的板子，老师上课的时候就认真写笔记，闲聊的时候就结合板子刷题。 我清楚地记得大佬大一上学期在
acm
颗粒无收，但是下学期就和学长一起参加了一个邀请赛拿了一个银牌。 绩点也是刷到了年级前五。
到了大二，大佬逐渐在acm崭露头角。听说他一般负责写图论，
计算几何
和模拟，大二在acm区预赛是拿了一块铜牌一块银牌。然后大佬那会经常在宿舍刷一些国外的公开课，并且常常手舞足蹈地对着屏幕说一些我们没听过的词。 大二学校开了大创项目招新，大佬和我们一个做数据库的老师带了一个国家级的创新项目，貌似是和分布式数据库还是图数据库相关的。然后大佬暑假还报了字节青训营，最后貌似拿到了offer，但是因为要赶项目就没去。 其他竞赛能参加的都参加了，比如蓝桥杯，美赛，csp等等。 
到了大三，大佬就开始收割了。他大三上区预赛拿了一块金牌，建模国赛拿了二等奖，大创也评了省优秀项目然后发了一篇SCI，我记得那个时候看他个人主页的博客有两百篇左右，虽然近百分之七十是题解，但是我看他公开课的
lab代码
笔记，上课笔记，个人做的
开源项目
笔记也超级多，当时记得他好像还被腾讯的学长和百度的学姐邀请投简历。 同时，大佬大三上花了三个月刷出了GRE325的分数，并并且还跟我们分享了他买的课的资料哈哈。 
大佬大三寒假就去了百度做实习生，大三下的下半学期去了字节做日常实习生，暑假忘了具体去哪了，好像是在字节继续实习，好像是去了purdue还是
ucsd
做暑研去了,然后大佬又在大四上把托福考了。 
大佬最后去了一所美国top10读博了，我们毕业聚餐调侃大佬一个人学了我们四个人该学的东西。当打下这段文字的时候，我又开始怀念那段岁月，怀念大佬在屏幕前纯粹又热诚的身影，怀念他的
茶轴键盘
，怀念我们四个人深夜撸过的串串。","那当然是疯狂卷啊。
不是学院最努力的同学，但是自认为还是算在正确的道路上持续付出。
在高中，我完全没有想过自己会学计算机，成为程序员。
我在大一之前完全没有编程经验，高考后，填的专业前几个也是清一色的传统工科，被软件工程录取纯碎是意外。
大一开学，第一门编程语言就是学的 C 语言，怎么说呢，老师讲的，书上写的我都能看懂，但是让我写一个大的程序，我就摸不到头脑。不知从何下手，学了半学期，也只能写写课后习题，算算
水仙花数
什么的。
大一上考完 C 语言后，我便在心里默默念想，这辈子再也不写 C 了，但没想到的是，后来这成了我最爱的一门语言。
https://www.
yuque.com/csguide/go
整个大一，一个词语就是“迷茫”，一个字就是“混”
混到什么程度呢，王者荣耀打了几千场，线代考试前一晚才在 
mooc
 上刷完所有章节，因为平时上课我基本都没听的，这也是我最后悔的事情。
转变大概从大一下开始吧，那时候好几个室友都拿到了奖学金，于是，我自己也开始慢慢反思，觉得这样下去，大学可能就废了。
默默的把王者荣耀卸载（当然，后面又下回来了，反反复复十几次。。。）
大一下，开始学习
数据结构与算法
、数字逻辑这些计算机核心课了。
此外，还学了一门当时我看来非常牛逼的语言：Java。
为啥说我当时觉得它牛逼呢？
因为刚经历过 C 语言的摧残，发现 Java有丰富的类库，各种方便的工具类。
再也没有指针了，变成了对象引用，简直是新大陆。
所以我学得很认真，还记得当时看过
高琪
的 Java 300集 教程，也是从那里算是正是开始了我编程学习之路。
自己也用 Java 写了不少好玩的东西，比如
联机五子棋
、
HTTP Server
 等等。 类似这种：
这让我第一次感受到编程这么有趣，俗话说兴趣是最好的老师，Java 也算是帮我解锁了对于编程的兴趣。
在学 Java 的时候喜欢在网上搜资料，但总觉得各种博客上的知识过于零散，为了“精通” Java，我在知乎搜索各种书单，先后看了《Java核心技术卷》《Java并发编程》好几本书，自觉 Java 基础还算可以，不过现在已经快两年没写了，成功转入C++阵营。
而且我有个习惯，就是每天早上基本都是六七点起床，八点多对我已经算赖床了，所以和我室友显得有点“格格不入”。
--->
【
我是传送门
】
，内含海量CS学习资料、
八股文
、算法刷题手册、优质技术文章、交流社群、offer神器，简历模板等
早上起太早的话，他们还在睡觉，我在寝室写代码的话，难免会发出各种声音吵到他们，尽管我做什么都是蹑手蹑脚，生怕发出椅子摩地，或者碰撞的声音，这让我也觉得不太方便。
所以，后面没有课的早上我一般都去图书馆五楼自习室了，在那看书，看书觉得烦了，就写会代码或者刷刷知乎，看看博客。
这是被我长期占领的一个位置，因为书太多，不方便每次都背来背去的，所以就找了个考研自习室。
就这样从秋天，到了冬天，桌子上多了围巾手套，还有 
C++ primer
（误，我从大二才开始学C++的）
那时候，每天上午的盼头的就是早点到中午，我就可以去吃饭，然后去学校散步了，我经常把中午饭菜拍下来，感觉蛮有意思的哈哈哈：
一般我都是赶在中午下课高峰之前去吃完，然后去学校绿荫道散步
大二时，在上一些无聊的课时，我总把这本书带着，每节课可能会翻个几页，那时候看到里面的汇编、内存管理、存储器层次我是真的云里雾里，因为还没学操作系统，C 语言也学得很差。
所以断断续续的看了几章，说不上学到了什么，但让我对这种枯燥的基础知识第一次产生了兴趣，有一种想彻底搞懂它们的想法。
后来在知乎大佬的指引下，为了看懂这本书，去看了
王爽
那本《汇编语言》，也在上图。
重学了 C 语言（主要是指针和内存），由于已经学了汇编，指针对我再也不是问题了，同时看完了《C和指针》、《
C专家编程
》、《C陷阱与缺陷》，对 C 语言使用得也愈加的熟练。
大学时，我看了很多计算机专业书籍，我把大学时候这些电子书库、简历模板、博客汇总、谷歌大佬的刷题笔记都打包放在这了，点击下方可以直达领取
：
书单：
大二那段时间，学院里突然刮起全员学机器学习的风气，虽然不至于全部，但是真的是很多人都在学，明明 16 年大一时客户端安卓开发还挺火的，到了 17 年各种机器学习、神经网络就席卷而来。
不能不感叹，IT 行业日新月异呀，不学习就可能被淘汰。
当然了，我也不例外的加入了，先后看了些
吴恩达
的视频、西瓜书。
很多学弟学妹在问怎么咨询、提问，最近我开放了我的编程学习圈子，欢迎加入，不管是计算机转专业，还是大二面临分流、大三找实习、校招、写简历、Offer 选择等都可以直接问。加入星球后，还可以找
小北
提问1V1定制学习路线、学习规划、修改简历、做项目等等，点击下方了解：
https://www.
yuque.com/csguide/go
跟着做了手写数字识别这种入门必做的项目，但是后来总觉得对机器学习、深度学习提不起兴趣，原因之一就是我觉得无法完全掌握每一步，了解每一步背后的原理，再加上自己数学也学得不太好，这让我学得很没底气。
于是机器学习之路也止于大二。
大二是学习内容最丰富的时间，当时室友用 Python 写了抢课脚本，感觉很好玩。
然后自己又跑去学 Python，学爬虫。
写了一堆爬虫，什么爬豆瓣电影、知乎回答、抢课脚本，玩了一段时间也没太大兴趣了。
时间来到了大二下，按照课程安排，开始上操作系统了。
于是我又在知乎搜索「操作系统怎么学」，不得不说知乎上各位前辈大佬的回答对我的指引作用极其的大。
顺着一堆回答，我发现原来还能跟着别人写一个 
mini OS
，这对我吸引力太大了。
于是我买了一本
《操作系统真象还原》
，这本书真的非常仔细，把写 OS 需要用到的前置理论知识、
Intel手册
、汇编、内联汇编全都给你讲清了。
我一路跟着书写，写到了汇编开机打印出我的名字，再到后来进入 C 语言写内核各个模块，写到内存管理我就中断了，没有继续写下去，这也算个遗憾吧。
这本八百多页的书，我花了两个月时间啃了五百多页，一下课就跑去图书馆，在我的虚拟机中跑 
qemu
，那时候就沉浸在类似下图这种界面：
当时我真的对这个入迷了，为了写 
mini os
我还去看了 Linux0.11 的部分代码，看了哈工大李治军老师的 OS 公开课，原因就是哈工大 OS 实验课是用的 Linux 0.11 来魔改。
还很奇葩的把我 QQ 签名改成了 jmp 0x7c00
(PS: 这句汇编就是跳转到 0x7c00 地址，BIOS 开始引导操作系统
于是就这样，我越来越喜欢偏底层一点的东西，所以决定走 Linux C/C++ 路线，然而现在看来确实太年轻了，Linux C/C++ 在鹅厂好多也是用来写业务滴。。。
大二下在知乎、牛客网搜索学习路线，我大概清楚了需要看些什么书（
搜索
敲黑板，一定要学会主动搜索各种信息。
也非常推荐大家尽早去刷一下牛客网，上面很多大三、研二的正在找工作的学长学姐们分享的帖子，早点接触这种就业的氛围，自己也会更加有动力去学习，也知道学习的方向，另外上面可以针对校招刷算法题、刷SQL等等，还挺方便的，现在很庆幸自己在大二的时候就在刷这个网站：
专注的大三
于是在大三左右开始了非常标准的 Linux C/C++学习之路：
前前后后看了《C++ Primer》、《APUE》、《UNP》、
《深度探索C++对象模型》
、《STL源码剖析》、《C++设计与演化》、
《Linux内核设计与实现》
、《Linux内核完全注释》、《effecitve C++》 、《effective modern C++》、
《程序员自我修养》
、《Linux高性能服务端编程》、
《Linux多线程服务端编程》
(知乎
陈硕
大佬写的)......
顺便还看了点 Muduo 源码，自己模仿着基于 Epoll 写一个 
Reactor模型
的 Web 静态服务器，跟着知乎 Milo 大佬写 Json 库，总之，这段时期是写了一些小”轮子“的。
（PS：知乎上有朋友问我是如何看完这么多书的，其实在之前的文章中就写了，看书我会有选择的挑章节看，不会从头看到尾的，而且大三开始课就少了，我基本就在刷这些书，其实时间还蛮多的？毕竟我也没参加什么社团、学生会之类，也没女朋友。。。
那时候会每天记录看书的进度，感觉特别有劲：
书看得越多，其实你越能找到自己的方向，大三上我就给自己学习定位：
深入C++语言（多线程）+ 存储（学习 Redis、leveldb）+ 网络编程（学习
muduo
，各种网络编程模型）+ 学习分布式（MIT 6.824、ddia、google 三大论文等）
基本上是沿着上面几个方向去展开学习的，有的看书，有的论文，也有的看博客看源码。
总之，知识面在大三不断扩充，自己开始关注学习 C10K、C100K 这样的后台服务器开发高性能、高并发的解决方法。
当然了，还有些到现在还没开始，比如 leveldb 的源码、6.824 的 
lab
，可能是变懒了......
也可能是学习变得不那么纯碎面向技术了，变成面向工作、面向赚钱了哈哈哈。
值得一提的是，大三上我们学院有门 System Programing 的课，教材就是使用的 
CSAPP
，因此我之前大二草草看完的书，得以再次翻开，这一次我把附带的是个实验也挨着挨着做了，收获良多，有位运算各种奇技淫巧，有 Bomb lab 刺激的打怪通关、也知道了
buffer overflow attack
.... 还有实现基本的内存管理等等。
印象最深的便是做 bomb lab，一个个 phase 的通过真的很让人兴奋，我几乎是熬夜连着把这几个 phase 过掉的，当然头发也没少掉。
当时还在
简书
写了个万字长文记录： 
再到后来，我拿到了微信实习 offer，然后顺利转正。
在我大三下拿到实习 offer 后，开始做一些国外计算机课程 lab，一方面有钱赚，而且还不低，靠这个我在大三下就实现了经济独立，另一方面这些 lab 有些很有意思，对提高基础和编程能力很有帮助。
在这里列举一些我做过的觉得有意思的 lab（之前有篇文章写过）：
第一个是文件系统
这个玩意挺有意思的，就是要让你自己去设计一个文件系统，比如文件、数据块、目录等等，而且你要提供创建、读写、删除、随机读、随机写等等接口，然后通过 Linux 的 
VFS
（虚拟文件系统） 机制挂载到 Linux 内核中，然后就可以用系统调用 open、read、write 这些来在你的文件系统上进行读写。VFS 是Linux一个机制，它规定了 IO 接口，然后你去实现这些接口，你就可以挂载在上面。通过这个东西我深入的学习和了解了文件系统，报酬也是非常值的。
第二个是
SVC
就是版本管理系统，类似 
SVN
 和 GIT的，但是相对 GIT 做了很多简化，核心的就是创建分支、分支合并、回滚、
commit
 这些，通过这个我又去详细了解了 GIT 的实现原理，并且自己写了一个简单版本的 GIT，受益匪浅，也赚到了几千大洋。
第三个是操作系统的锁实现
这个就是让你基于硬件的原子指令 xchg、cmpxchg 这些实现一个锁，这个需要内联汇编、汇编等知识，简直是硬核！！！做完这个也解开了我对锁实现的一些疑惑。
Web Proxy
这个就更有意思了，要求用 C++ 写一个代理服务器，类似 
Nginx
 的代理功能，当然，相比 Nginx 弱鸡很多，
但是麻雀虽小，五张俱全，而且老外最有意思的是要求代理服务器对一些图片和 HTML 恶作剧，就是代理服务器随机的在原始服务器，返回的响应里 插入一些图片和文字，因为那天是愚人节。。。 不得不说老外还是很有趣的。
还有模拟实现 TCP 可靠传输的
这个就更硬核了，人家老外老师就是给力，直接做了一个网站，这个网站你可以通过 TCP 连接上去，然后你需要运行几个节点，互相发消息，他们之间的消息都会经过老师的网站，所以通过网站上是可以控制丢包率的，也能控制节点的拓扑结构，要求就是让你基于这种不可靠的信道，做出可靠数据传输！这简直就是翻版 TCP 嘛，超时重传、ACK、滑动窗口啥的都给我上！就是像下面图中一样，圆圈就表示你可达的范围，不同节点形成各种网络拓扑，可以调节网络 丢包率 Loss chance。
img
当然也有很多写算法的，数据结构实现的，图搜索的，也有做机器学习、深度学习的，反正各个方向都有。
做这些 lab 真的实实在在的提高了我的编程实践能力，也算是检验了前期看那么多书还是有效果滴。
大学靠做硬核lab赚到了10w+，如果你也想做Lab赚钱，可以看下我推荐的这两个平台，可以看下这个。
所以写了这么多，再点次题吧，我认为自己编程能力突飞猛进就是在看完一本本大黑书、做完一个个 lab、写下一行行代码之后。
最后，这里送大家一本帮助我拿到BAT offer算法笔记，是一位阿里大神写的
附录
 
附上大学期间买的一些书，毕业的时候大部分都卖了，因为实在不便携带：
这是带去图书馆自习室的书（常占位置）
这是毕业整理的书：
买这些书花了我不少钱，大家都知道计算机这些书一本就是五六十、七八十起步。大学四年光买书就花了几千块。不过我一直认为这也是我花的最值的一笔投资。
当然了，我还有自己整理的电子书库，绝不是在网上那种打包下载的，而是自己需要学到某个方向知识的时候，需要看了，去网上挨个找的，最后汇总而成。这部分我是会不断把它完善的，当成自己的小电子书库，不多，但贵在精。
我整理的这些书大家可以在这里获取，对于学习计算机的同学帮助非常大，且十分系统
：
最后真心想说一句，滴水穿石非一日之功，学习计算机还是需要沉下心来好好啃书、看源码、写“轮子”。
逐渐构建起属于自己的计算机知识体系，然后选择一个专业方向不断专研。 
推荐一下计算机系统学习网站，有Java、C++、Python、操作系统、网络等学习路线，计算机必读书籍PDF、C++、Java、计算机基础面试题等：
来源： 我的公众号「编程指北」，欢迎关注～
原文：
帅北的「编程能力」从什么时候开始突飞猛进的？
在这顺便推荐一个 
Github 开源仓库
，基本包含了常见的 CS 编程学习书籍，可以 star 一下，需要的时候直接去上面找书：
https://
github.com/imarvinle/aw
esome-cs-books
大家觉得不错的话，记得帮我 
@编程指北
 点个赞哟，笔芯～","上篇
我是如何在一晚上拿到阿里巴巴offer
一文分享给大家后，获得大家一致好评，都说学到了很多面试技巧。
但这次我要说的是面试技巧只能让你提高获得面试资格的概率，最终能不能拿到offer还得看你的硬实力。
我在准备10几天的时间下顺利通过面试，也许有人会说是运气，但运气为什么有的人有而有的人没？
因为运气是留给有准备的人的。就算彩票中奖起码也得比大部分人多做一步，首先得去买张彩票。
因此本篇我不讲速成论，而是让你扎扎实实打牢基础，然后等着运气降临。
看过
我的编程人生
一文的同学应该知道里面我提到自己读了很多书，专业的非专业的都有。
在这过程中我也踩了不少坑，好书读过，烂书也读过。当然话说回来，你不读也不知道它是好是烂，这是个悖论。 
这次我就结合自己的真实学习经验，并结合大学里的课来给大家分享那些年我读过的书。
注意，本文提到的书不是网上随便找的书单，全部是自己亲自看过的。
1.
屠龙术
为什么这节标题是屠龙术，因为我认为读这些书能让你了解计算机科学的本质，掌握屠龙之技。
了解了本质，一切就变得容易了。 
以下书籍重要程度分先后。
1. 汇编语言(
王爽
版)
没看错，就是汇编语言。为什么是汇编语言，因为我认为现在大家对这门古老的语言都不重视。
这本书是我在大三上汇编语言这门课时买的。当时上课用的教材不是这本，因为个人感觉教材不太友好，在网上搜索后买了这本书。
这本书不厚，由浅到深的介绍了汇编语言，重要的是还有实践代码。学完后会让你对汇编语言有一定的了解，不深，但是足够用了。我汇编语言课最后考了94分，这本书功不可没。
很多人会问，汇编语言都淘汰了，学了有什么用，你看现在哪家公司招汇编语言开发？
我想说是的，现在公司很少有用汇编语言的了，毕竟有了农耕机，谁还用牛耕地？
但是，我要说的是，只有用牛耕过地，你才会更了解这片孕育万物的土地。
学任何东西只有了解它的本质，你才能学的更快，学的更深，学的更好。
而汇编语言就是能让你了解语言本质的东西，是所有高级语言的源。
所以不管你是计算机科班出身还是半路出家，我都建议你去看看这本书。
如果你本身就是计算机专业，那你上课时候一定要认真去学，为你的“专业性”打基础。
如果你是中途转行或者经过培训上岗，我也建议你有空的时候去看看，能让你更了解计算机的本质，缩小和科班的差距。
当然花了这么多篇幅介绍此书，我也不是让你成为汇编语言的高手，只是让你对这门语言有一定的认识。
不会汇编语言不会影响你成为
编程高手
，但是一定成为不了大师。
2.
深入理解计算机系统
这本书很多人应该都知道，是经典书。能让你对整个计算机硬件和软件体系有所了解，建议计算机从业者收藏，反复阅读，常读常新。
如果是计算机专业学生，建议和
计算机组成原理
这门课搭配使用，可以出奇效。
3.现代操作系统
这本书是我大三上操作系统这门课时看的书，当时上课用的教材不是这本，是我在图书馆看到的。当时看后觉得讲的比较详细，就自己买了本当作教材使用了。
这本书如书名，讲
操作系统原理
，计算机专业学生应该都会上这门课。建议大家上这门课时候都能认认真真上，尤其是考研的同学，考研会考里面的知识。
为什么我建议认认真真上，因为这门课比较枯燥，内容也比较难，所以逃课率很高。我是为数不多从来不逃这门课的学生之一。
4.计算机网络
这本书是我大二上学期上计算机网络这门课时买的。同样学校教材也不是这本书，是自己在图书馆查资料时发现的。
这本书讲的比较全面，可以提高对计算机网络系统的认识，同样建议准备考研的同学好好学这么课。
4.
离散数学及其应用
这是大二下学期我们上离散数学课的教材，主要讲计算机中的数学知识。
计算机学科本就是从数学发展出来的分支，因此数学对程序员的重要性不言而喻。
写程序最重要的是逻辑性，学习这本书能系统性的提高逻辑推理能力，学的时候最好把每章后面的题做一下。
5.
数据结构与算法分析
这是大一下学期上数据结构课时我搭配的一本书。同样上课教材不是这本，是我在图书馆发现的。
讲数据结构的书很多，为什么选这本书？
因为这本是用C语言来描述的，示例代码都是C语言。我认为学数据结构算法最合适的语言是C，用纯
面向过程的语言
去学习数据结构和算法才更能理解其本质。
算法本质是对空间复杂度和时间复杂度的优化。
空间上C语言没有面向对象的特性，声明变量后完全可以根据变量类型计算出程序总共消耗的内存，可以更准确的评估程序运行过程中到底消耗了多少内存。
时间上C作为面向过程语言，可用函数库很少，通过自己写代码能让你清楚的了解程序运行时执行了多少指令，让你对你算法效率有更精确的评估。
当然随着计算机CPU性能的提高，内存的不断增长，程序员对时间和空间的要求也没那么严格了。但在系统性能优化和虚拟机优化等难度较高领域对算法还是有严格的要求。
虽然用Java、Python、JavaScrpit等语言介绍算法的书市面上很多，也能让你对算法有一定了解。但我认为通过这些书去学习算法，还是有隔靴搔痒的感觉，虽然你懂了，但是没有那么透彻，换种语言说不定也就写不出来了。
而用C语言能让你更透彻的理解算法的本质，因此我建议有C语言基础的同学最好用这本书去学算法。尤其是计算机专业学生，因为大部分专业课教材里涉及到的代码都是用C语言写的。
6.
数据库系统概念
这是大三下学期学数据库课时我搭配的一本书，同样不是上课教材，是在图书馆发现的。
作为一名程序员，或多或少肯定会用到数据库，有的人只会简单的SQL语句或者熟练使用MySql、Oracle、SQLServer等软件就说自己懂数据库了。
其实数据库是一套很完善的数据存储系统，SQL语句只是和用户交互的通道。不了解数据库系统的知识充其量只是个数据库软件熟练工。
而通过看这本书，你可以系统的了解到数据库知识的全貌，学完后甚至可以自己去实现一个小型数据库，这样对别人说自己懂数据库时才更有自信。
7.C++程序设计语言
这本书是我们大一上C++课程时的教材，发的教材其实是英文版的，这里我给大家介绍中文版。
毕竟是C++之父写的，比世面上其它C++书好太多。由浅入深，知识很全面，书上的代码也都很有代表性。如果把书上的代码都上机打一遍，C++绝对入门了。
不知道是不是所有计算机专业都会把C++当作第一门语言课，因为C++相对其它语言来说，入门上手会相对比较难，可能会打消掉一部分同学的积极性。
但学任何东西其实都有一个学习曲线，只要你沉下心去学，多花点时间，总会跨过那个曲线，后面学习过程就会变得很平滑。学C++也类似，建议大家不要知难而退，而是要迎难而上，翻过大山也许就能看到彩虹。
这里我也提自己一个观点，我认为把C++当成编程语言的入门课其实是有好处的。因为只要你学会C++，其它面向对象的语言学起来都会很快，只要看一遍语法就能立马上手。毕竟难的都会了，简单的不更轻松吗？
8.编码:
隐匿在计算机软硬件背后的语言
这本书是我研究生时看到的课外书，也推荐给大家。
书很有趣，像讲故事一样把计算机的前世今生和重要知识点娓娓道来。如果想偷懒，不想读厚厚专业书的同学可以通过看这本书来了解计算机体系的整体脉络。
2.
乘龙术
介绍完可以屠龙的书，再来讲讲自己读过的一些比较好的书。这些书可以提高你的专业技能，让你的职业道路走的更扎实，更长远，所以我称为乘龙术。
1.C语言
《
C程序设计语言
》
，机械工业出版社，作者Brian W. Kernighan / （美）Dennis M. Ritchie。
C语言之父写的，入门经典书籍，建议大家作为C语言入门的第一本书。
《
C Primer Plus
》
 ，人民邮电出版社，作者Stephen Prata。
可以作为C语言工具书，也可以作为入门。
《C和指针》
深入了解指针，看完以后对指针不再害怕。
《C陷阱与缺陷》
看完后可以避免C语言开发的一些坑。
2.Windows开发
《Windows程序设计(第5版 珍藏版)》
这是我在大二学C#时候看的一本书，里面的代码我全部在电脑上手打了一遍。
这本书主要介绍Window系统桌面软件的开发，想了解和从事这方面开发的同学可以看看。
看过这本书，你会对你电脑上用到的软件有一个更深的体会。窗口是怎么出来，菜单点击后是怎么处理的，动画是怎么绘制的，软件又是怎么和操作系统通信的，看完这本书你通通都会知道。
《
Windows核心编程》
如果想对Windows系统有更深的了解可以看看这本书，我当时在图书馆看到了这本书，讲的也挺不错。
3.Linux
《
鸟哥的Linux私房菜
》
Linux入门书籍。我记得在大一下学期，有段时间自己痴迷安装各种版本的Linux系统，到最后虚拟机上把当时各种Linux发行版都装全了。
4.数据结构与算法
《
编程之美
》
这本书我没有看完，但里面的讲的算法都很不错，想对算法有提高的同学这本书一定要看看。
5.Java：
《
Java核心技术 卷1》
，
《Java核心技术 卷2》
这两本书是在上Java课时看的，同样不是我们教材，在图书馆发现的。
讲的很好，可以作为Java入门书籍。
《Java并发编程实战》
讲Java并发库的一本书，这本书强烈推荐。自己看这本书的时间很晚，是研究生找工作时候看的。
找工作时基本都会问到书里的知识点，看这本书可以在找工作时给你带来直接的价值。
《Java并发编程艺术》
同样是讲Java并发编程的。Java并发编程实战相对来说全是干货，看起来可能比较晦涩。这本书可能看起来更通熟易懂些，但是没有Java并发编程实战全面，大家可以搭配着读。
6.Android
《
第一行代码 Android》
Android开发入门书籍。因为我当时学Android时候这本书还没有，所以自己不是通过这本书入门的。
但是后面看过，讲的不错，可以作为入门书籍之一。
《Android 开发艺术探索》
这本书强烈推荐。是从Android初级向中高级进阶的必看书籍，里面讲的知识点都很好。重要的是Android面试会问到很多这本书里面的知识点，找Android开发必看。
《Android 系统源码代码情景分析》
从源码分析Android系统的书。自己找工作时候反复看了很多遍，面试时候也问到了一些知识点，找Android开发的也可以看看。
7.Java Web
《深入JavaWeb技术内幕》
从Android向后台转型过程中看的一本书。比较全面的介绍了Java Web知识，可以当作入门辅助书籍。
《Spring in action 中文版》
学习Spring时候看的书，主要介绍了官方文档的知识。讲的很全面，准确度也高。
《Spring MVC学习指南》
Spring MVC入门书籍，可以快速上手Spring MVC。
《Maven实战》
学Java Web离不开Maven，这本是Maven入门书籍，讲的很全面。
《大型网站技术架构》
找工作时看的书，主要讲网站从小到大发展过程中技术架构的演进。看完以后你就知道为什么一个淘宝首页会有那么多程序员维护了，也能让你有理有据回怼对产品提出的“给我做一个淘宝，美团”的需求。
《大型分布式网站架构设计与实践》
主要介绍大型网站建设过程中使用到的一些技术，可以作为技术参考书。
《大型网站系统与Java中间件开发实践》
从中间件角度介绍大型网站的建设。
8.编码素质
《
大话设计模式
》
大二上设计模式课时看的书。当时的教材晦涩枯燥，在图书馆闲逛时看到了这本书。这本书以讲故事的形式逐一介绍了23种设计模式，生动形象。还有代码示例，可以变学边实践，是入门设计模式的一本好书。
《
程序员修炼之道：从小工到专家
》
大四时候看的书，可以学习书里提到的编码技巧。
《
代码大全
》
大四时候看的书，同样可以提高自己的专业素质，构建专业的编码风格。
9.人文
《疯狂的程序员》
大一时候看的一本小说。讲了一个程序员大学、工作、创业、以及爱情故事经历的励志书籍。我在手机上看完的，看的时候热血澎湃，让我在大一就对程序员这个职业有了一个初步的认识。
《史蒂夫・乔布斯传》
这本书大家应该都听过，是我在大四时候看的。当时实体书比较贵，图书馆也没这本书，我在网上下载了电子版，花了两天时间趴在电脑上看完的。可以学习一下乔布斯创新和执着的精神，苹果有如今的成就不是偶然的，与乔布斯的做事风格有直接的关系。
《
浪潮之巅
》
研究生时从图书馆借的一本书。是一本互联网发展的历史书，看完可以对互联网的历史有一定的了解。
《
黑客与画家
》
硅谷教父写的书。我在研一时候看到的书，可以一定程度提高程序员的情商，财商。
3.立地成佛
这小节的标题是
立地成佛
。
别想太多，不是说你看完这些书就能成佛。看这些书只是让你的计算机基础更牢固，但是成为高手还有很长的路要走。
上面这些书也只是我读过的书的一小部分，还有很多书我没有提到。要想有更高的成就只读专业的书是不够的，还得读文学、历史、经济、商业等各方面的书。
而且光读书也不够，只能成为书呆子。学很重要，实践更重要，只有把学到的知识应用出来产生价值才能证明你确实学到了，也就是人们所说的学以致用。
所以在这里也建议大家多读书，读好书。
如果你是你学生，很幸运，你有大把读书的时间。少打点游戏，少看点综艺节目，少睡点懒觉，多去图书馆走走，自习室坐坐，你会拥有更精彩的人生。
如果你已经步入职场，工作再忙也要抽出点时间去多读读书，去升华一下自己，只有这样，在这个贩卖焦虑的社会你才会比别人多一份淡定与从容。
最后希望大家都能活到老，学到老，立地成佛。在此也我拍一张自己书架一角与大家共勉。","2019.12.12
谢谢大家的鼓励和关心，2021考研究生的现在可以准备了。有好多人觉得自己的大学荒废了，白上了，听着，只要你在大学一天，只要你活着一天，永远不晚，你有责任，义务把自己的大学，把自己的人生变得充实且有意义！别犹豫了，行动起来。最后，对我来说，再苦再难，我都不会放弃。还有，感谢国家，感谢党，感谢学校，把少有的
国奖
名额给我，定不负众望，一路向前
2019.7.8
刚刚洗漱完毕,准备睡觉 。最近留校考研,挺累的。平时去图书馆不带手机。好久没登知乎,发现大家的留言和点赞,大一无意间写下来这篇回答,转眼大四了，能帮到大家,我很开心。好多人问我是怎么做到自律的。其实也是有一套自我奖励机制。大概给大家讲讲吧。上大学时我给自己定了积分奖励机制。底分100分 然后是各种加分减分选项。比如早起加一分,早睡加一分,上课或者做题跑神扣一分。赖床扣2分。搞懂一道数学题奖励一分。网上回宿舍学习加3分(因为我晚上一会去就控制不了自己玩手机,毕竟白天一天没碰,手痒。一玩儿就到了半夜,所以给自己的奖励很大)等等这些吧。好多人会问,积分有啥用？玩两天就没劲了…………图样图森破~我是这样的,我得到的分数正好是我余额宝里的钱数。也就是说我今天做了5件正能量有意义的事,加了5分,我就把卡里的钱存到余额宝里5块,这个钱最终会累计到一定的量(我给自己定的目标是超过1000可花),供自己使用。说实话,我花钱挺大手大脚,这也是自我约束的一个方法。不早了,明天5点40要起床去自修室背书,我要睡觉了,对了,我给自己约束的是,晚上11点30之前睡觉加一分哦。(我是不会告诉你我余额宝已经两千一百多了,哈哈,大学三年………)
对了,发呆跑神没事干的时候多问问自己：我现在心里想的事是不是虚荣心在作祟？(比如：①我考名校研究生是不是为了炫耀？为了发朋友圈,让所有人觉得自己很NB？②我追求这个女生是为了可以秀恩爱,带出去有面子,满足自己那可怜的虚荣心)如果有虚荣心理,立刻停止,你达不到目标的,你目的不纯,考名校是为了有进一步的发展,为自己的下一个目标做铺垫,追求喜欢的人,是因为爱,因为依赖,是因为想和她过简单的生活,换句话说,真心的爱情是藏在心里的,不需要华丽的外表来时刻提醒别人。一开始的目的就不纯粹,很难自始而终,做任何事都一样。有这种心理的人趁早反省,否则滚犊子 ...(??ˇ?ˇ??) ...
没事多问问自己：我现在所做的事情,是让我更加靠近我的目标吗？你打游戏骂队友的时候,你刷微博瞎喷胡侃的时候,你谈恋爱如胶似漆没话找话的时候…目的要明确。要时刻提醒自己,既然定下了目标,那就是你的天职,使命,应该时刻提醒自己,有没有偏离目标,背离初心。
不早了,晚安,各位。
2019.6.24
还在努力考浙大。双非考浙大，很难很难很难！好多人劝我现实一点，不要硬杠，可是，我何尝不想呢？如果我今天退缩了，那我就会一直退缩下去，一直妥协下去！我知道很难，但我决不放弃！绝不！哪怕高手如云，我亦不退缩，他强任他强，我亦有锋芒！
2019.5.16更新
(转眼间就要大四了，还记得写这篇回答的时候我好像还大二，真的是时光荏苒，转瞬即逝啊！)
最近忙着考研没怎么上知乎,后台很多人给我留言说，小甲鱼的那个数据结构视频，听着口音问题太严重，而且废话太多,看着看着就看不下去了……
好吧，真是服了你们的，真矫情！那我就再给你们找一门非常非常适合入门的零基础的,
数据结构课程
吧！在b站上搜“数据结构，青岛大学,王卓”。王卓老师的视频非常非常适合零基础入门，而且老师讲的速度非常的慢。她的课程一共有14周左右，你就跟着她的节奏，她开一周的课你就花费一周去学。学的时候记好笔记，同时注意总结。这个是配套的课本。网上都有卖，还有一套练习册，每一周的课结束之后记得做练习册。如果你还是学不会的话,要么是你不用心，要么是你真的不适合计算机。好啦，我继续复习考研了，你们加油哦。
2019.3.2更新
这两年确实学到了很多东西，去年用Java和朋友们做了一个大众创业项目。是一个滴滴快递平台。
接下来所有的精力都在考研上。因为我知道自己是一个普通本科出身，哪怕将来能到北上广深，拿到月薪1万多。但是出身的差距在30岁以后就会显现出来。到时候会不断的有新人加入公司，我的可取代性就会变得非常高。所以说，我还是决定潜心修炼自己，慢慢的继续往前走。
我对自己的目标必须要求非常高。要求自己极度自律。有时何尝不想让自己放松一点呢？可是一旦你放松了，就会被踢出局！与其将来进入社会之后被疯狂蹂躏，还不如现在多吃一点苦，受一点累，多锻炼一下自己将，来便更加懂得珍惜生活的来之不易。
其实最近心情有点烦。因为我的父亲因为互联网的发展失业了。家里的收入锐减，父母的争吵不断。而我作为一名互联网行业的参与者，理应承担更多的责任，为家里多分担一些。所以自己也渴望快快长大，现阶段，于我而言最大的目标就是尽快考上一个不错的研究生学校，然后尽快出来工作。所以我的目标是――浙大。如果可以的话，考上后我再过来更新，加油吧，我和你们共勉。 
“年轻人，你职责是平整土地，而非焦虑时光。你做三四月的事，在八九月自有答案。” ????―― 
余世存
《时间之书》 ???
2018.10.12更新 
好久没来了，补充一些干货吧。今年大三了，我在实验室这两年已经掌握了一套属于自己的知识架构了。对于刚加入这个专业的学弟学妹们，我的建议，还是先学C，建议入门的书《
C primer plus
》
刚开始可能，枯燥一些，一旦熬过枯燥期，你就会发现一片新世界。当然，纯看书肯定是看不进去的，建议到
网易云课堂
上搜索《
老九学堂
》里面有C语言的入门视频，免费的，而且讲的很细致，非常适合入门。
C语言入门之后，真正的编程才开始起步，我们要学习最最重要的一门课《数据结构》。数据结构是程序的灵魂，没有数据结构的程序顶多算是一堆披着程序外衣的骨架罢了。因为程序=数据结构+算法。这是他的精髓。但是这门课确实有一定难度，我啃了一年半。入门书《
大话数据结构
》配合视频B站上搜小甲鱼。讲的不错，就是有时候废话有点多，偶尔开开车。我们数据结构老师在第一节课上说过，数据结构学的好不好决定了你将来年薪5万还是50万。我不屑
后来的某一天，下课后，我找他聊天，故意调侃到“老师，你数据结构教的这么好，一年不还是5，6万块钱？”老师看着我，带着一丝笑意，点燃一根烟，眼神呆滞的望着前方，“这点死工资，还不够我喝酒呢，不过就是清闲点，一周来你们学校一次”。后来我才知道，我们老师是外聘的，一周来一天，一天1300。他自己开的有两个IT辅导班，同时还带了5个大学的数据结构。
    学完数据结构之后，建议把操作系统好好学，搞一搞Linux，自己捣鼓捣鼓。当然我对操作系统没多大兴趣，只专注于编程了。
这个时候的你基本可以确定你以后的发展方向了，如果你想要稳定的就业，java语言方向的岗位需求量会比较大一些，代表性的有阿里巴巴。但一般的公司也仅仅是够得上温饱，当然，如果你在公司里待个2年以上的话，成长肯定会比较快。和我一起玩的好的同学不考研，大三暑假就开始去我们郑州这边的互联网公司实习了。虽然刚开始工资低一些，工作量大一些，但是，学的很多。他现在已经跳槽了好几家了。成长很快。当然还有学php的，前端的，现在基本都有稳定的工作量，郑州这边拿个5000左右还算可以的。java入门的话有一本《head first Java》不错。可以配合网易云课堂上的老九学堂的java课程或者黑马的视频都可以。其他的中后期的学习自己在网上找，一堆。
放一张去年暑假，室友半夜在改公司里的代码(我们暑假在学校留宿，有的考研，有的培训，有的上班)
c语言和c++方向的岗位也不错，代表性的有腾讯。但是需求量没java那么大。准确的说是招不到合适的，学的不错的人。C语言不错，但是能做的有限，做底层还行。C++又太难，除非你耐力，自律能力超强，不然…半途而废的可能性极大。想学C++的推荐《c++primer plus》.但是学好C语言再学C++的衔接性回很好，如果把C++学的差不多的话，java上手就会如鱼得水。
大数据，人工智能，云计算最近很火，但是，打铁还需自身硬，不要跟风，把基础打好，把语言学好才是当务之急。毕竟，想要高谈阔论，先得把语文学好，把字认全。
最近忙着比赛(ACM亚洲区域选拔赛)，今天校庆，大家都在操场上狂欢，我也实在是有点烦躁，刷一会知乎。此时此刻，我们比赛队伍里的三个人都留在实验室刷题。没有任何怨言，而且都是自觉的。何为大学？我的理解，就是大不了自己学呗？第一次参加这个比赛，可以和来自清华，北大，甚至其他国家的院校IT精英一起同台较量，是我莫大的荣幸！一起加油吧！
//以下是原答案:
说说我吧。计算机专业大二在读。冬日的早上，当室友还在床上扯着呼噜磨着牙，放着响屁说梦话的时候，我已经背起书包，仰望
北斗七星
朝着实验室走去。大雪封校的时候，索性买了张折叠床住在了实验室。这样忙到十二点的时候，也听不到室友对我冷嘲热讽了。暑假留校做项目，宿舍停电停水，身上跟鲶鱼似的，脸上油的跟面糊似得，厕所辣的眼疼……再苦再累没有抱怨过。我只是觉得我做的是对的，虽然我知道，去富士康打工的话能让手头更宽裕……
   从大一到现在，没有中断过，早起背单词，预习课本，然后安排一天的事情。一边看视频，一遍敲代码，然后翻书，记笔记，晚上总结，反思。我们实验室的人一般都是用两个显示器，一个笔记本自带的，一个实验室的。有疑问的话可以和其他的学长交流，进步很快。
一定要勤快，老师有时候让你做小任务，一定不能推辞，因为在帮忙的过程中最容易发现不足。很多人都容易犯眼高手低的错误。
另外，干这一行的，确实不愁就业，但是，想华山论剑，你得先混个掌门当当啦！你只看到ceo，cto们年入百万，却没有看到他们的知识储备，和行业水平都是无可替代的。另外关于软硬件问题，我觉得软件这条路更好走，亲身经历，学了单片机，参加了机器人比赛，硬件这条路，难走，更重要的是，就业难。
至于学哪种语言，适合自己的才是最好的，语言没有优劣，重要的是思想，也就是说，你脑子里有货，有idea，举个栗子，英文字母就26个，背下来，So easy。但是写出一篇不错的英语作文就是另外一回事啦！或者说，你只要写出一篇优秀的的文章，谁会在意用英文还是中文呢？《
钢铁是怎样炼成的
》原著是俄语，影响在中国的销量吗？
其实哪有什么大神学霸，一切都只是厚积薄发， 我就是这样日复一日，坚持到现在，终于在上周日
得了痔疮，至今没出宿舍门
哈哈，开玩笑啦，之前在知乎上看到一个回答，或许会有启发","更新一下，已经是读大学的事情了，没必要现在来喷为什么看了这么多。我想说的是工作以来，我依然持续的再不停的学新知识，可能人年纪越大，越容易健忘，但是学的多不是坏事，总比什么都没有学的好。我觉得持续的学习是个人习惯，至于为什么能在有限的时间看这么多书并记住，我觉得就三点：
1.管理时间
2.专注
3.实践
希望看到此答案的在读的大学生有所收益，私信非关注不收。
还有我脾气不好，脑子有病的我会喷回去的。
<!――――――――分割线――――――――>
我大学有个同学，每天大概有4个多小时在码代码，每天晚上看书基本上不熄灯就会在一点多才睡，大学读的计算机书有他自己那么高。书的顺序与看的顺序无关。
这本书写的非常好，是你从
谭浩强
的a b c变量到专业编程的开始。各种指针处理，越界判断等，每个C/
CPP
入门必读。
这本数据结构是教材，但是觉得不错就都看了，并且全部把所有数据结构自己实现了一遍。能找到的已经不多了，忽略以前那些中文命名自己各种。。。（再牛逼的人都是从Hello Kitty 开始的，谁都有过去）
这个是听从传销组织的洗脑去报的一个培训班，学的是
CCSP
，思科的安全专家认证，不过当年可是骑着车风里雨里去上课啊。学完后对网络知识还是有了很好的掌握了。
当时还看了另外两本书《Windows 核心编程》以及 《win32汇编》，和这本书，基本入门了Windows 开发，不过后来都废了。
C井
专业书籍，微软出品，我们当时可是有这门课程的，只是教材不是这个。这两本书太厚了，说实话没看完。
这两本书不适合入门，非常晦涩难懂。最后硬着头皮看完了。
这本书是C++作者自己写的，一直当神书供奉着，大学就是有时间就拿来看一下。
这本书是学安全的时候买的，基本上也就是聊一下iptables命令了，配置一下
SSH
这些基础的。
这本书是操作系统领域的经典了，没有针对特定类型的系统，但是讲了很多系统设计的抽象和方法，非常经典。
很厚的一本书，被我朋友一个叫
郭旭
（和翻译一样名字的狗子）薅去了，不过基本上每个子系统都讲了，太厚了没看完。
这个不用解释了吧，全看完了并且把所有算法都用C实现了。
有段时间误入歧途了一会儿。。。
这本书非常好，看完这本书，还有一本《Python 灰帽子》，加起来完全吃透了
gdb
以及各种调试技术。
这已经是11年的时候写的文章了，那时候读大3。直接变成了gdb大神，之后看啥调试器都不顺眼。
这两本很薄的书一直放在我枕头边，作为圣经隔三差五背一下。
这本书讲的是网络的物理层和链路层的，非网络或者通信专业的不用看。
很精炼的一本讲内核的书，精读了几遍。
数据结构的C++实现，个人觉得一般。
不用多说了吧，TCP/IP的圣经，有三卷的，精读第一卷，第二卷可以看看，但是是
FreeBSD
的内核协议栈实现，和现在的Linux有一些差异。卷三讲了作者YY的一个客服
TCP协议
。
这本书用一句话形容就是话糙理不糙，非常适合入门的同时，还能够知道
socket
底层的一些实现原理，精读了无数遍。
有很大部分讲的是Linux的ELF文件结构还有其他的，协议栈部分代码太多，看了70%就刚不下去了。
这本书是网络安全课程的教材，入门难度有些高了，大部分网络安全知识点都有涉及，包括密码学及应用kerboros协议等。当时课程设计就是实现kerboros协议。
这两本是专业老师推荐的，个人觉得自顶向下好一些，不过后来非常经典的书，作为辅助教材，必须精读且牢记，后来面试官问什么TCP三次握手什么滑动窗口都是被秒杀的。
真本书也是非常适合入门的。和《
unix环境高级编程
》有一定差距，不过作为入门很推荐，成为大神的第一步就是把所有demo全部自己实现一遍，一但你这样做了，基本上可以说吃透了，后面无论多久都或多或少记住，不然很容易过目就忘了。
放一张大概的吧。
其实还有很多的书在毕业的时候卖掉了，卖不掉的送都送不出去，有点尴尬。
大学期间打好基础挺重要的，工作了给你大把可以精读一本书的时间是很少的。同时如果是读书期间，从底层基础开始学习比一开始就各种spring，各种MVC来的踏实一些。希望各位在读书的大学生听我一句劝，大学期间最重要的努力还是要找个女朋友。
是的，这个同学就是我自己。
已经毕业很多年了，有些书可能年代久远了些，但是都没有过时，计算机和系统的发展没有都是积累的，没有突变过程，所以学好基础，几十年都受用。","Update 一些元知识。
如何阅读大部头的计算机书籍：
CS专业书籍(科学与技术类)应该怎样阅读？
从哪里找学习资源：
国际顶尖CS名校（如四大）的本科生需要学习哪些课程？
算不上努力，只能说路子没有走歪。
大一 C 语言课 Final Project 在大家都选择写
学生管理系统
的时候写了一个解释器，期间研读了著名的 SICP（《
计算机程序的构造与解释
》），王垠的解释器教程，不完全刷了 CS 61A，其他
编译原理
相关的书也翻了一下，还学会了 Emacs 这种神器（现在 Emacs + Vim 双修，主要在 Emacs 里用 Vim 的键位），最后写出一个非常简单的 Lisp 解释器（C 写起来太累了），大二大三的时候又拿 Python 重写了一下。
大二上算法课开始刷 CLRS（《
算法导论
》），直接看的英文版（其实中文看起来也没有多少错误，只不过为了练习一下看英文资料的能力），期间停了一段时间看了 《Algorithms》（红书），不完全刷了 MIT CS 6.001，偶尔刷刷 LeetCode。
大二下操作系统和组成原理课开始刷 CSAPP（《
深入理解计算机系统
》），这也是我大学以来看过的最值的一本书，期间看 xv6 源码。
大三上比较水，大部分时间都在看 Web 开发的东西，读了 Flask 源码后自己造了一个类似的 Web Framework，Python 方面读了《Python Cookbook》和《
Fluent Python
》后功力大为精进。
大三下到现在一直在实习中，工作内容主要 Python 后端 + 前端（Vue.js）+ 机器学习
调参工程师
，另外在公司对大型系统的设计有了实践性的了解，比如在一定并发量的情况下需要分配多少台机器和数据库，服务之间如何更好地解耦，该用 HTTP 还是 RPC 云云。
虽然所在的学校比较垃圾，但是因为大方向没有太歪，所以最后结果还不算太差，几点不算经验的经验：
逃得课比上的课多，大部分课程都是提前学完，然后和老师申请免修，节约大量时间自己学习。逃课没什么，想好那些时间用来做什么就可以了，当然要学会与老师周旋。
学好英语，这个是 key。建议直接用起来，文档看英文的，教材看英文的，视频看英文的，刚开始看不懂是正常的，在用的时候学习。摄入只需要听力和阅读能力就可以了，水平也不需要特别高，阅读能看懂 
quora
，听力能听懂 YouTube。
翻墙，Google，YouTube，学会搜索，在 2 的前提下，你几乎没有找不到的
高质量
学习资源。
跳出周围的圈子，多出去参加比赛（Hackathon），多认识别的
大牛
，看他们在做什么。
多读源码，多写 Project，多造轮子，多在 GitHub 上给别人提 issue，修 bug。
多看经典书籍，多刷四大的公开课，少看大部分国内的书，为什么要看这些？「取乎其上，得乎其中；
取乎其中，得乎其下
；取乎其下，to所得矣」不是白说的。
个人经验，不适合所有人，请勿轻易模仿。","说个我读者的事吧。
双非本科 + 非科班，通过自学计算机，校招时共投递了上百家公司，最终他从最开始月薪 5k offer 成功换成年总包 35w+ 的 offer，从他的身上只看到「努力」这两字。
诺，
在校期间买了上千元的计算机书，
下图只是其中的一部分：
他去年校招相当坎坷，被打击过，也失落过，但是他并没有因此一蹶不振，而是继续坚持自学下去，他相信努力是有用，在今年春招拿下了
年总包 35w+ 的 offer，
虽然相比大厂offer收割机的同学不算什么，但是作为一个普通人，能逆袭成这样，已经相当牛逼的了！
他的经历写的很长，我认认真真看完了，感触很深，看的出是个很认真的小伙子，大家可以耐心把这篇文章看完，相信你会收获很多。
一、校招路程
伴随着拿到一份满意的offer，令人折磨的校招终于告一阶段了…
我的校招经历应该是非常坎坷的一段经历，但是应该能够给其他还在迷茫的小伙伴一点帮助，所以在小林哥的鼓励下我决定将我的校招经历和我的学习路程以及经验还有一点这段时间的感悟分享给大家，如果能对大家起到一点微小的帮助是最好的事情。
先说一下我自己的校招经历吧。
我自己是一名双非非科班的学生，高考的时候报「软件工程」这个专业但是滑档了，分到了一个自己不喜欢的专业，又没有提前做职业规划，导致到了大学之后浑浑噩噩了三年。
一直混到了大三下学期，因为疫情的原因在家里上网课，在六月份左右的一天，我突然觉得我不可能这样一直混到毕业吧？那我以后能干什么呢？
认真思考了几天，
觉得不能这样子下去了
，但是又不喜欢本专业，因为我一直对计算机比较感兴趣，所以最后想着干脆去当程序员吧。
说干就干，我从七月份开始买了一本《大话数据结构》和一本
谢希仁
的《计算机网络》还有一本《
C++ primer
》就开始看起来了，当时也没有做任何规划，也是一时兴起，所以就三天打鱼两天晒网的开始学起来了（
真的很建议大家在不论做什么事情之间做一个详细的规划，这非常非常重要！
）。
然后一晃眼就到了九月份，开学我到了学校还要先补考两门课程（
混子的悲哀…大学千万不要挂科！
），然后补考完就到了九月中旬了，我匆匆制作了份简历，然后就开始投简历，基本上都是石沉大海，
只有一份面试机会
，而这个面试也是让我真正改变的契机。
我还记得这个面试是来自「深信服」的，甚至到现在我都记得当时那个面试官的长相，整场面试三十分钟，我说的最多的三个词是「不了解」、「不清楚」、「不太懂」…基本上是一问三不知。
甚至最后面试官想捞我一手，问我们专业还学什么课程，我说模电、数电，面试官说：额…好吧…你有什么想问我的吗？
我都结结巴巴说不出话来。面试的过程中我真的超级超级羞愧，刚开始面了五分钟我就想结束面试了，真的是什么都不会，真的说不出来的丢人，我同学说我当时整个人的脸都涨红了。
当天晚上我躺在床上羞愧又难过，都睡不着觉，我不断地问自己：「你这么菜哪来的脸投简历？」
下定决定开始
停止投简历
，好好充实自己。
正赶上当当做活动，我一口气买了一千多元的书，从C++、数据结构与算法、计算机网络、操作系统还有 Linux 相关的全部买了个齐全。
从此开始了每天疯狂学习的道路，每天基本上
睁眼学到闭眼
，梦里都是知识，我觉得我自己在计算机这方面还是有一点悟性的吧，再加上一点韧性，所以我学起来很快。
我尤其喜欢 C++ 相关的知识，当时觉得学累了就看看 C++ 相关的书籍充一充电。
就这样充实的生活学了一个月左右，正好十月中旬学校有线下校招，我就去试了试水，面试比较简单，很快就下了offer，我还记得好像是 base 长沙月薪 5k+，其他的待遇就忘记了。
我当时的心态就是觉得啊？不是吧？我就值这个价吗？
还难过了一段时间，然后想都没想就直接拒了，觉得还是自己太菜了，然后
继续投入到学习当中
了。
到了 11 月初学校又有线下校招，我又过去试了一下。最后拿到了 base 上海月薪 10k+，我还记得岗位是叫「 MMI 助理开发工程师」，我当时都不知道这个是干什么的，待遇觉得还挺好的，因为我们专业以前的毕业生都是能拿到 6―8k 都算是不错的了。但是最后犹豫了一下，还是拒绝了，
觉得这应该不是我的极限
。
一直保持学习到 12 月初，突然某手机大厂联系我面试，说实话都我不知道什么时候投的简历了，应该是秋招补招把我捞上来了。
当时我整体学的差不多了，蛮久没面试了，所以我就试了试，几轮面试下来我基本上侃侃而谈，不会的东西很少，所以很快 offer 就下来了，base 北京月薪 15k+，犹豫了蛮久的，最后考虑到秋招末期了而且有大厂的名头，最后就接了 offer 了。
当时心里想着拿一个保底，然后还想着再好好学一学，春招再冲一冲。
结果放假回家两个月基本没怎么学习，因为过年家里事挺多的，也没有一个好的环境，自己的内心也比较浮躁。
到了三月初又补考了一门课程，然后发现自己根本学不进去了，最后就决定去公司提前实习了。
到了公司以后，感觉大厂确实是大厂，各方面真的很不错，但是呆了一段时间之后发现部门的业务和主要技术和我期待的有偏差。
所以一边实习一边学习，最后在四月初离职回到学习继续开始春招，
最后成功拿到了一份 base 北京总包 35+ 的 offer
。
我自己挺满意的，而且因为我学习的时间太短了，前前后后可能有效学习就大半年左右，最后能拿到这样的 offer 我也感到非常庆幸，最重要的是技术方向也是我比较喜欢的方向。
这里提一下违约的事，我之前签的那个大厂
没有索取违约金
，然后违约流程走了大概半个月左右，最后拿到了新的三方。
据我了解好像一般比较大的企业都不会索取违约金，一些小企业可能要先交违约金再解约三方。
这里并不是鼓励大家去违约，只是说在有更好的选择或者明显感觉到现在的岗位不适合自己的情况下，不要惧怕去违约，有些同学可能害怕违约了企业会拉黑自己，实际上这种可能性很低，而且并没有实质的影响。
hr 经历的违约事件数不胜数，并不会对你做特殊处理。就业是一个双向选择的过程，为了自己以后的职业发展，还需要做更慎重的考虑。
因为匆匆学习，更多的只是学习了理论知识，而且算法与项目经验还有实习经历都阻隔了我进大厂的可能，基本上我笔试都做的很艰难，大部分大厂笔试都挂掉了，就算勉强进了面试，也倒在了手撕算法的环节上。
导致我现在拿到 offer 后还是在不断的刷题，因为算法基础太差了，但是它又是那么重要。
我的经历更像是一个普通人的经历吧，不像其他大佬大厂offer拿到手软，我前前后后的面试公司可能就十来家，最后成功拿到手的 offer 也就四个。
功利一点来看，从 5k+ 到 10k+ 再到 15k+ 最后到 20k+，慢慢打怪成长一样。有时候后悔自己觉悟的太晚，准备的太慢，导致错过了更好的自己。
但是转念一想，
改变，就是好事
。
二、学习规划
我自己一开始没有什么规划方向，走着走着就往 C++/QT 客户端那边走了，因为学了点 QT，但是后来又觉得后端可能发展方向好一点，所以在辞去实习之后重新投的简历也全部投的后端方向的。
所以我的学习规划基本上是 
C++ 服务端方向
的，希望可以给各位同学一些帮助。
编程语言
我自己是有较扎实的 C 知识，所以学 C++ 并不是那么困难，而且我比较喜欢 C++ 这门语言，喜欢它的严谨和多样性，所以我看的 C++ 书籍可能比较多。
从《C++ Primer》到《Effective C++》系列再到《C++
沉思录
》这些前前后后可能看了十几本左右，越往后看越体会到 C++ 的复杂性，越看越感觉难…
校招的话 C++ 一般不会问的很难，甚至如果面试官是搞 PHP 或者 Java 的可能都不问你语言相关。
所以我
不建议你直接啃《C++ Primer》，把它当作一本词典来用会更好
，新人上来一直看这么厚一本书很容易直接被劝退。
我推荐你从《C++ 新经典》 -->《
Essential C++
》 --> 《C++新经典 对象模型》这样的顺序学习，基本上校招应付面试是绰绰有余了。
如果想要在面试中在 C++ 相关做到侃侃而谈的话可以看看 Effective 系列的书籍，以及啃一啃《深入理解 C++ 对象模型》这本书，我过年的时候把它放在家里了，是我最后悔的事。因为到现在为止，我看这本书都蛮吃力的，需要慢慢的看，细细的看，而且很多地方都不理解。
如果有时间的话也可以把 python 当第二语言，用惯了 C++ 再学 python，是一种不一样的体验，真的挺有意思的。
其实语言并不是那么重要，基础知识更重要，建议把更多的时间放在基础知识上，尤其是想要冲大厂的同学
。
数据结构与算法
数据结构与算法这方面的话是非常非常非常重要的，想要冲大厂的同学们如果这方面不过关可能连笔试都过不去，更别谈面试的手撕算法了。
我自己的话因为准备比较匆忙，所以只是把匆匆《剑指offer》刷了一遍半，然后 leetcode 刷了 100 道左右 easy 题，看了一遍《labuladong算法小抄》（从小林哥这中的嘿嘿），面试和笔试一般太难的题我就宕机了。
我后面复盘了一下，我因为时间紧，所以刷题很匆忙，像赶任务一样，刷完了就完了，也没有做总结和回顾。
实际上一道题可以牵扯到一类题的做法，都是有框架和套路的，有很多大佬都总结过。
刷题的话还是需要不断地总结和回顾，才能达到有效刷题，像我都是无效刷题。
根据我做的笔试题来看的话，基本上我
建议你把《
剑指offer
》刷两遍，然后 leetcode 热题 100 道刷一遍，最后跟着《labuladong算法小抄》总结一遍框架，基本上这一块就妥了
。
但是尽量还是一直要保持刷题，因为以后工作了跳槽也对算法有要求，多多益善吧。
以上是建立在有数据结构的基础上，如果对数据结构不了解的话可以先看一下《大话数据结构》或者某客时间上有一门关于数据结构的课程。
算法这方面的话一定不要一直闷头刷题，要学会总结题型和方法。
做的多了你拿到一道题的时候脑海里就有了基本的框架，该用什么数据结构去做，该用什么方法去做，心里都有一个数了，是数量引起质变的一个过程。
我个人就比较惭愧了，这方面基础不是很扎实，导致现在也在一直补。
从我寥寥无几的大厂面试经验来看，在面试的时候面试官会引导你去做题，是有一个相当舒适的做题环境的，所以不用畏惧算法如猛虎，做的多了对付校招还是绰绰有余。
操作系统
操作系统我自己是从《
深入理解计算机系统
》先看，发现有些地方难以理解，而且不少章节用纯汇编来演示，看不太懂，又去看了《现代操作系统》和《操作系统导论》，阅读顺序几乎是从难到易，一路踩雷…
我建议初学者先看一下《
操作系统导论
》，这本书讲的比较浅而且易懂，然后再看《现代操作系统》，看的差不多了，最后看《深入理解计算机系统》。
《深入理解计算机系统》的话，可以跳着看，有几章节是用纯汇编演示的，懂汇编的同学可以看一看，不懂的同学粗略看一看也没关系。
还有可以看看小林的图解操作系统，有了一定基础知识，去看之后基本能应对校招的面试。
小林已经把图解操作系统整理成PDF。
现在开源给大家下载：
到这基本校招问的知识你已经具备了，如果想要实践的话，github上也有一些和操作系统相关的项目可以看一看。
计算机网络
计算机网络我自己是先看了谢希仁的《计算机网络》，发现讲的太杂了，并不是很深入，又看了《TCP/IP详解：卷1》，又发现讲的太深入了，根本看不懂，最后又看了《
计算机网络自顶向下方法
》和《Http图解》，面试的时候就够用了。
我建议你直接看《计算机网络自顶向下方法》就好了，然后直接看小林哥总结的计算机网络相关的知识就可以了，应付面试时绰绰有余了。
为了方便阅读，小林也把
图解网络
整理成了PDF，大家可以作为面基突击的手册，开源给大家下载：
设计模式
这个我自己是通过《
大话设计模式
》入门，然后看网上别人博客总结的一些知识，最后在某客时间上买了一门设计模式相关的课程学习了一下（
某客时间该打广告费了，笑~
）。
总体来说学的并不是很深入，因为设计模式这个东西学起来很简单，但是实际项目中应用起来太难了，而且根据我面试中的经验，一般蛮少有面试官会问，就算问也就问一问简单的单例模式、工厂模式这些，问的不是很深入。
所以我建议你通过《大话设计模式》入个门，然后对设计原则和常用的设计模式有个印象，最后可以在网上看看别人的经验。
校招的话很难在这一块问的比较深入，虽然它很重要，但是没有商业项目和工作经验的前提下，应届生很难真正熟悉这些，最多做到入个门，这样就已经足够了。
数据库
数据库相关的话我是学习了 MySQL 和 Redis 两个比较常用的数据库。
MySQL 我是先读《高性能 MySQL 》然后又学了某客时间上的《 MySQL45 讲》最后最近再看《 MySQL 是怎样运行的》，又是一路暴雷…
所以我建议你先看《MySQL是怎样运行的》，然后在某客时间上看《MySQL实战45讲》，最后稍微看一看《高性能MySQL》（
挑章节看，这本书讲的太深，理解起来比较困难
）。
最好在学完这些之后自己动手去部署一个 MySQL，然后挑一些小项目做一做。
我在面试的时候和面试官聊 MySQL 聊的比较深，他给我出了蛮多 MySQL 相关场景题，我答的不尽人意，面试官说我基础可以，但是实际上手比较差，建议我私下可以部署一个 MySQL 试一试，这些问题会有更好的理解。
所以我把这个建议也给你，希望可以理论实际双管齐下，不要像我一样做个偏科生（哭）…
Redis 的话我是先看了一遍《Redis设计与实现》，然后在某客学了《Redis 核心技术与实战》，在看实战经验的过程中，感觉有一些吃力，于是又返回去看了一遍《
Redis设计与实现
》。
Redis 算是我比较匆忙的学习了，因为在决定走后端这条道路之后补学的，学习的比较匆忙，所以我也只能给一点粗浅的建议，建议先看《Redis设计与实现》，有了基础知识之后可以选择看一下其他 Redis 的书籍或视频加深基础，然后去某客时间学习一下《Redis设计与实现》。
我面试的话，Redis 方面基本没有什么太大的问题，一般问的都可以说道一二。
Linux系统
Linux 的话我建议你先看《
鸟哥的 Linux 私房菜
》，对 Linux 整体有了一些了解之后，可以再看一看《
Linux 系统编程
》。
因为走的是后端方向，所以看一下《
Linux高性能服务器编程
》，强推这门书，都是干货，然后跟着书上做一个服务器相关的项目，会有助于加深理解。
如果想学Linux内核的话，先看《Linux设计与实现》，这本书看起来难度尚可，后面有能力的话可以研究下《深入理解Linux内核》（我自己是放弃了…真的看的很困难）。
而且我面试的时候虽然简历上写了，但是面试的时候并没有被问到 Linux 内核相关的问题，所以这个一般应该是加分项，有能力的可以搞一下。
Linux 系统的话纯看书可能事半功倍，最好在 Linux 环境下做两个小项目，这样子对整体学习可能更有用处。
上一张我在这个过程中不断补全自己知识点的图吧，只要知识框架搭起来之后，学习是件很轻松的事情。
三、
学习心得
我觉得我自己算是学习速度比较快的人吧，学习效率也还可以，所以把我自己的学习方法分享给大家。
我在学习一门新技术的时候，会选择一本难度适宜的书，根据目录在自己脑海中把知识框架搭起来，然后看书慢慢去填补具体的知识，就像一颗多叉树一样，系统化的学习。
在看完一遍书之后，会有意的去看一些比较重要的知识，深化这些知识，同时我也关注了许多公众号，在框架搭起来并完善之后碎片化的学习。
最后再看一看网上别人对这门技术一些知识的理解，再对照自己的理解，补充优化。
最好的是做一些小的项目，去应用这些知识，毕竟实践出真知（然而我因为时间太短，这一步没有进行555）。
同时面试的过程也是一个查漏补缺的过程。
思维导图是一个好东西，给大家推荐一下，有助于系统化的搭建知识体系，上一张我在春招的时候补全Redis知识的图吧。
因为学习 Redis 的时间比较短，而且并没有过实际上手，所以用知识导图把这些知识分门别类的存储，然后记忆到脑子里，在面试的过程中，学习并且不断补充，加深自己的知识深度。
其实看视频也是一种不错的学习方式，但是我个人更习惯看书构建知识框架，所以仁者见仁智者见智啦。
四、感悟
给大家分享一些我在校招中的感悟吧，我眼中的【
校招 = 技术 + 心态 + 运气 + 勇气
】。
技术是毋庸置疑最重要的一点，没有技术的基础，一切都是空谈。
同时心态也非常重要，在经历长时间的笔试、面试的折磨时，还要一日一日的等待面试结果，那段时间每一个电话都以为是 offer call，每一个提示音都以为是邮箱信息…最后可能大部分都没有结果…
从一开始的满怀信心到后来的迷茫踌躇再到最后的怀疑自我，这些我都经历过，在最崩溃的时候真的不想再找工作了，随缘吧。庆幸的是我坚持下来了，并且最后有一个好的结果。
运气是比较玄学的一个东西，从投简历的时间到面试的部门到各个公司不同的需求，都有可能决定你能否拿到一个满意的offer。
从我个人而言，秋招和春招加起来可能投了有一百多家公司，最后面试的可能只有十几家左右，拿到了 4 个offer。
这个是我辞去实习后回到学校春招投的公司，最后笔试的有三家，全挂，直接面试的有两个，最后拿了一个offer。
因为我算法基础比较差，拿 offer 的那家没有笔试，直接面试，我在面试中发挥的比较好，而且算法题也都会，所以最后成功拿到了 offer。
最后同时也需要有做决定的勇气，我在提前实习之后，感觉到我可能不适合这份工作，但是公司又是大厂，而且适时又在春招中后期了，当时也犹豫了蛮久的，最后觉得还是决定不将就，回到学校重新找工作，最后对我而言也是一个比较满意的结果了，而且公司也没有要违约金，感谢公司~
比较重要的一点还有就是持续保持学习，并且永远相信自己，不要放弃。
不止校招，而是进了互联网这一行，我们基本上只能保持学习，不然犹如逆水行舟，不行则退，大家应该也知道这一点。
放一张自己还放在学校的一部分书吧，其他的都在春节搬回家去了。
也可以看到这部分书中算法书的比重就很高，所以算法真的非常非常非常重要，学好算法是进大厂的第一步，希望大家可以早点做准备，不要像我一样临时抱佛脚。
洋洋洒洒写了这么多，不止是希望我自己的经历可以对各位小伙伴起到一些帮助，也是对自己的深度复盘，在这个过程中发现了自己蛮多的不足，希望可以慢慢成为一个技术全面的人。
复盘之后就该进行新的学习啦，努力让自己享受这个学习的过程吧，毕竟进了咱们这一行，持续学习是非常重要的一件事。
希望大家都可以早作准备，日后拿到一份满意的 offer ~
感谢你能耐心看到这儿，希望我的经历能对你起到一些帮助。
如果对你有帮助，别忘记给个三连呀，这对我非常重要
也欢迎大家关注 
@小林coding","双非本科，先是在计算机系摸鱼3年，大四决定痛改前非，全身投入考研，最终上岸浙大，不知道算不算是努力学习了呢？
这次考研对我的人生产生了巨大影响，改变了研究方向、学习方法，也重新认识了“努力”一词的定义。
1. 本科摸鱼史
先分享一下我本科时的样子。
我的本科是一所普通二本，校园很美，老师们很友好。但在一所双非院校，学校没有任何优势，如果想提升，只能靠自己去努力。只可惜大四之前我都不懂这个道理。
那时候，一到周末我就离开学校到处玩自己的爱好―骑行，买了一辆近3000元的单车，参加了不少省内的自行车比赛。
为了体验生活顺便攒点生活费，我送过外卖，在KFC做过汉堡，上门当过家教；唯独很少把时间放在自我提升和专业能力上。
而计算机系的一些老师有时候过于佛系，怕最新的技术太难我们接受不了，就只教一些老掉牙的方法。
我对教Java老师的印象最深刻。16年上Java课时，老师没教我们Spring、MVC等成熟框架，代码还是用非常古老的JSP和Servlet。最让我吃惊的是，他让我们把后端代码和前端代码直接写在一个jsp文件里。
我们班的一些同学后来在b站自学才知道这种方法有多么不规范。
在这样宽松的环境下，本科三年很快就滑过去了。
2. 考研奋斗史
大三暑假是个分水岭，很多人渐渐知道再这么玩下去就真废了，开始收心苦思出路。有狂投简历找实习的，有在图书馆复习考研考公的，也有家里有钱继续放纵的...
看到很多同学投递大厂简历直接被机刷，我第一次觉得母校不够好。
我想去牛b的学校读书，接触更前沿的技术，看看那儿的同学是怎么学习的。刚好那个暑假，在校园中我遇到了初恋女友，爱情的责任感进一步激发了我潜意识中的斗志。
我要考研，而且要考就考牛b的！
经过谨慎考虑，7月初我把考研目标定为浙江大学计算机专业，这是一个当时看来很难，但冲一冲又有希望的选择。
我用最快的速度收集了考研数学、英语、专业课408的复习资料，和女朋友一起在学院提供的考研教室中开始“8-12-7”的复习模式。
我考研，她考司法，我们每天都在教室中复习的不亦说乎。到了饭点就一起骑小龟去食堂吃饭，饭后绕校园后边的竹林散步，缓解大脑压力。
回想那段青春岁月，可以用“摸着石头过河”形容。每天日程排得满满当当，没有休息日，没有收入，没有可咨询的师兄师姐，压力远胜于现在的“996”。我们只有彼此和一个考研进入名校的梦想。
好在我们都努力坚持下来了！考研前一个月，司法考试出结果，女朋友顺利通过。考研前一天，学校派大巴送我们去各个考点。
车上有同专业ACM集训队的队长，他也是一个非常努力的同学，经常在实验室和宿舍写代码到深夜。后来，他考研被北大成功录取。
考研让我意识到，
有吸引力的的目标+正确的努力方法可以让人改变现状，达成想要的目标
。于我而言，考研就是最好的选择。
3. 在专业领域继续深耕
2018年6月，我和女友驾车从杭州出发，经安徽、江西、湖北、重庆，最终到达四川成都朋友家，完成了首次长途自驾。在那次旅途中，家里收到了浙大寄来的硕士研究生录取通知书。
9月，进入学校和实验室后，我从最底层的爬虫(为师兄提供训练语料)和机器学习理论学起，将研究方向从开发调整为算法。
学了几个月之后，我开始不安现状。从爬取的文本入手，主动研究文本分类和实体识别等NLP底层任务，带头的博士师兄发现我的动手能力还可以，于是将我从
爬虫
转向了NLP。
这也是我进浙大后发现周围优秀同学最大的一个学习特点：
不用人催，能自我驱动主动学习
。
我们实验室有一块大白板，上面列满了今年各大顶会的deadline与投稿目标，每当临近会议时间，很多同学会自发来实验室加班加点写论文、跑实验。即便是已经手握7-8篇A类一作的巨佬，依然很勤奋很努力在学习。
受到周围同学的鼓舞，除了上课和陪女朋友出去玩，我把时间都花在看书提升专业能力上。
术业有专攻，我明白毕业后这就是我的主业
。
研一阅读《
数学之美
》，《
Python自然语言处理
》和《
自然语言处理理论与实战
》，帮助我启蒙数学和自然语言处理；
研一研二学习
《Python深度学习》，《动手学深度学习》，《Deep Learning in Pytorch》，《hands on Machine Learning with Keras and TF》
帮助我快速上手机器学习和深度学习框架；
《笨办法学Python》，《
Python编程从入门到实践
》和《流畅的Python》
帮助我持续提升优化Python编程能力；
《百面机器学习》，《百面深度学习》，《深度学习500问》
帮助我在面试前查漏补缺。
下面是我硕士期间看过的部分书单，已经打包压缩好了，共计100本。有需要的朋友点击下面的链接可以直接下载：
后来我觉得仅仅看书还不够，是不是还能再努力一些，从项目实践、比赛、paper等方面做些尝试呢？
于是研二开始，我认真参与了公司多个智能机器人项目研发，和室友在天池、Kaggle等比赛上获得了不错的名次，发表数篇发明专利，产出了论文。
计算机真的是一个通过努力可以改变命运的学科。
前期专业能力的积累，帮助我在秋招大军中幸存下来，同时收获了BAT的算法offer。
Python是入门算法的必备工具之一。如果不知道如何快速入门Python的同学，可以试试【
夜曲编程
】，在手机上就能学习。囊括了Python入门到进阶的各项课程，还有网页开发、
网络爬虫
、数据分析等进阶内容。
课程内容以卡片的方式推送给用户，这种互动的学习方式非常有趣，不会让你一接触Pyhton就从入门到放弃。
在使用夜曲编程前，我也接触了很多在线学习平台和软件。对比下来我发现夜曲的学习面板对初学者是最友好的，可以事半功倍，所以推荐给大家！
4. 进入职场持续输入与输出
有的同学觉得校招拿到offer上岸，就能躺平了。其实，新的生活和挑战才刚刚开始。
离开学校进入公司，我遇到了很多实力雄厚的同学，无论是专业技术还是业务交流、逻辑沟通能力，他们都有很多值得我学习的地方。每周一次的技术分享，也为大家提供了丰富的养料。
想要保持工作稳定甚至升职加薪，最好的办法就是提高公司对自己的产出/投入比
。如果我每一年为公司提供的价值与产出超过了工资收入，那公司一定很乐意将我留下；反之，有可能“入职即巅峰”甚至随时被送飞机票。
而想要达成这样的目标，需要不断提升自己的专业能力，无论在哪家公司何种职位，保持持续学习与输入。认真观察你会发现，身边那些优秀的同学都是这么做的。
这里分享一个费曼技巧提高学习效率：
原文来自 Quora: 如何才能学得快一些 (How can you learn faster)
第一步 - 选择一个你想要理解的概念
选择一个你想要理解的概念, 然后拿出一张白纸, 把这个概念写在白纸的最上边.
第二步 - 设想一种场景，你正要向别人传授这个概念
在白纸上写下你对这个概念的解释, 就好像你正在教导一位新接触这个概念的学生一样. 当你这样做的时候, 你会更清楚地意识到关于这个概念你理解了多少, 以及是否还存在理解不清的地方.
第三步 - 如果你感觉卡壳了, 就回顾一下学习资料
无论何时你感觉卡壳了, 都要回到原始的学习资料并重新学习让你感到卡壳的那部分, 直到你领会得足够顺畅, 顺畅到可以在纸上解释这个部分为止.
第四步 - 为了让你的讲解通俗易懂，简化语言表达
最终的目的, 是用你自己的语言, 而不是学习资料中的语言来解释概念. 如果你的解释很冗长或者令人迷惑, 那就说明你对概念的理解可能并没有你自己想象得那么顺畅 -- 你要努力简化语言表达, 或者与已有的知识建立一种类比关系, 以便更好地理解它。
学习之余，我开始在知乎和公众号上用文字输出原创技术文章，并尽可能做到通俗易懂，与更多亲爱的读者共享学习成果：
如何通俗易懂地让女朋友明白什么是语言模型？
文本匹配利器：从孪生网络到Sentence-BERT综述
2021年了，你还在手写SQL吗？
7分钟搞懂逻辑回归的来龙去脉
认真的聊一聊决策树和随机森林
天池NLP赛道top指南
复盘人生第一次科研经历
“天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能”――孟子
最后，结合自身经验我概括了计算机系最努力的同学的8个学习方法：
1）尽早明确自己的研究方向，并持续发力；
2）学会自我驱动主动学习，决定未来发展好坏的只有你自己；
3）计算机是一门对理论与实战都非常看重的学科，二者要兼顾；
4）尽早开始实习，为学校过渡职场做好准备；
5）懂得劳逸结合，健康第一；
6）尽可能减少外界负面干扰，认准的事坚持做下去；
7）遇到问题冥思苦想，不如Google或多和同学交流；
8）多看书，多看好书。
最后和你正式介绍一下自己哈：
我是
叶琛
，一个爱旅行，懂养生的算法工程师兼干货答主，也是个喜欢用接地气的文风为年轻朋友分享职场经验和算法知识的人。希望我的文字可以为你提供帮助！
总结不易，觉得有帮助请给
 
@Giant
点个赞哟，谢谢啦！
参考资料：
[1] 
号称终极快速学习法的费曼技巧，究竟是什么样的学习方法？","在同学眼里，我应该算是特别努力的人了。
先简单说下我大学的一些主要经历吧
入学前
没有学过任何编程知识
，没有 ACM 背景；
大一
转专业
到计算机，电子设计院赛
一等奖
，当选技术协会
会长
；
大二凭借提前规划，拿到了
腾讯实习 offer
；
大三打各种比赛折腾，做校内小程序，
上线两小时用户量破千
；暑期跳到
字节实习
；
大四
收割各大厂 offer
 后，不断提升软实力，看书，做
技术公众号
，分享自己
最真实
的经历，训练自己的
文字表达与逻辑归纳
能力。
大学四年假期基本都在学校，学习、比赛、做项目；只会预留少部分时间回家。
我觉得，贯穿整个大学生涯乃至以后的职业生涯，最重要的技能并不是我学会了哪门语言，搞懂了哪个框架的源码，而是
我的搜索能力
。
据我观察，大部分刚入学的大学生，信息搜集能力都很差，而正是因为这样参差的关键能力，会带来影响全局的信息差。
这个时代，并不是呆在图书馆一顿猛学就能翻盘的。
大多数人眼中的信息搜集，可能就是百度下关键词，看看前几页有没有；
或者换个搜索引擎（比如谷歌、
必应
）；
好一点的可能懂得一点技巧：site、filetype 等关键词的运用；
本质上，这样的搜索只能算是入门级的搜索技巧。
那么怎样的信息收集能力才能对自己的大学生活产生飞跃式的帮助？
且听我慢慢道来...
入学前
高考数学成绩雪崩，考了高中三年的最低分。
但抱着不想复读一年，不想把时间浪费在高中那点知识上的心态。
我硬着头皮填志愿，
看了分数段和地理位置，合适的就这个大学了，
但这个大学我在填志愿之前根本没听说过。
填了计算机，想着肯定稳稳的，
结果现实又给了我一大耳刮子，
计算机差 2 分，软件工程同分，同分要按数学成绩排序，理所当然，我又被刷了。
我从没这么讨厌过数学。
大一上
我来到了通信工程专业。
一开始想过要不要转专业，
但觉得我以后做
嵌入式
好像发展也不错，
就决定先好好学硬件，
干了再说。
事实证明我和硬件无缘。
学院唯一的技术社团招新，
有考核， 要焊板子，给了我们一张电路图回去准备，
一开始我也是一个一个元件百度，然后看电路图，看得一脸懵逼。
后来想起我在成电的一个师兄，
高考后曾经联系过他，可惜成绩出来后太丢人了，就不敢再联系他。
但这次没啥办法了，厚着脸皮去问他。
结果他很详细地指导了我，还给了我一本单片机的 PDF 电子书，里面有各种元件的详细介绍。
我只花了半天时间，就搞懂了。
这个恩情我可以记一辈子。
考核当天，很多人连元件都认不全就上了。
我准备充分，还把我梳理好的导图打印后带上了。
后来会长说，对我那张纸印象深刻。我是全场唯一准备得如此充分的人。
宿舍四人都参加了考核，只有我通过了。
接下来的日子里就是上课、上协会的技术课（虽然我基本都在课前搞懂了）。
学单片机的过程其实也把 C 语言的基础学了。
当然，如果你以为我的大学只有技术那就打错特错了。
我还参加各种志愿活动，泡图书馆看杂书，参加非技术性社团，拉赞助，搞活动。
虽然确实对我就业帮助不大，但认识了一帮小伙伴也是极好的。
大一下
寒假觉得自己的 C 学得不是很牢固，当时正好看了香蕉地的『编程可以这样学』，跟着敲了一遍，然后花了三天时间，做了一个贪吃蛇：
找到了当时的票圈，现在有点不忍直视
有一说一，香蕉地这门课并不算很优秀，我写的这个贪吃蛇现在看来也是一大堆可以优化的点。
但对当时的我来说，自己做出了一个小游戏，成就感还是非常巨大的。
而且也是首次运用到面向对象的编程思想。
不得不说，这个小游戏是我编程路上的启蒙之作。
回校后，
和同学一起参加院内的电子设计比赛，
拿到了一等奖。
也正是在这个比赛中，
我对硬件时不时产生的玄学 BUG 感到厌烦。
也有的人可能会被激发探索欲，从而喜欢上搞硬件。不得不说，就是这么奇妙，我对软件上的奇奇怪怪的 BUG 并没有过分的厌恶。
同期，学院也下发了转专业的安排。
我一想，不如我就转去计软吧。
说干就干，开始收集往届的转专业资料。
转专业要先笔试高数，然后再面试，占比五五开。
我还分析了上一届的笔试成绩和最终通过面试的情况，发现至少要在笔试前 50% 才有机会通过面试。
因为准备时间短，笔试成绩不是很理想，但凭借面试的表现，我最终险过面试，转专业成功。
期末前竞选协会会长，当时想法很单纯，
协会帮助我这么多，我也要带领协会更好的走下去
。
可能是平时人缘还不错，我以微弱的优势打败了另一个竞选的同学，当选会长。
担当与责任，有时会给我们带来意外之喜。
当时其实有比技术更强的同学，有的从高中就开始接触单片机了。说实话，对他们来说，在协会中学到的知识可能真不多。包括对我来说，
其实更多时候我也是自己先学一遍，然后再去上课，上课期间基本就是在帮周围同学调试
。
但不论怎么说，我在协会期间还是得到过不少帮助的。
正是这个选择，让我后来有更多的机会。
包括在暑期时找到了女朋友。
大二
刚转完专业，我便开始着手规划后续的大学生活了。
第一步，便是收集资料。
首先我从多个地方都发现提及了牛客网，便将搜索重心转移至牛客，在笔经面经的精华专区，找到了非常多优质的内容。
目前其实有越来越多的人在分享自己的技术成长经历，这对师弟师妹们是大大的好事，打破信息差。牛客、优质博客、优质的公众号，都是非常好的获取信息的渠道。
第二步，在看过了很多大佬的经历分享后，我开始规划自己的路径。
我所在的大学虽然是双非，但胜在地理位置优越，周围有很多互联网公司，实习方便。
因此我希望能
用丰富的实习经历弥补学历的不足
。
一般学生的暑期实习在大三下开学前；那么我最好能在大三上去实习。
而实习一般需要至少一周去三天，因此我大三上的课要提前修掉一些。
那么继续反推，我大二时需要提前修掉一些大三的课。
真正的逆袭才刚刚开始。
大二上选了30多分，
刚转完专业，初生牛犊不怕虎，
补修大一的课的同时，还选了几门大三的课
，还是算法、数据库等硬课。
同时和大一、大二、大三的同学上课，
那酸爽，现在回想都心有余悸，基本
每周都要熬夜两三次肝作业，肝报告
，11点回到宿舍洗个澡然后去楼下自习室看书写报告，搞到两三点回宿舍睡觉。
担心猝死，选择了隔一天熬夜的方式勉强续命。
现在看来，当时其实少选一两门专选都能舒服很多，
透支自己的健康绝对是最愚蠢的选择
。
身体是革命的本钱，我强烈建议大家在大学期间养成良好的作息和健身习惯。
当时除了繁重的课业压力以外，我还身兼着协会会长的头衔，与校外企业谈合作，给师弟师妹们培训上课。
正是这个合作，我去到了这个企业实习，技术老大手把手教，虽然只有短短十几天，也是学到了不少东西。（因为开学了要回学校）
他们是几个大佬出来合创的创业公司，其中一个是某银行大数据部门的技术总监，跟我聊的时候，有几句话让我印象特别深刻。“大学生有目标的很少，我面试的时候经常问对方有什么职业规划和目标，能清晰思考过这个问题，并有条理回答得上来的寥寥无几。”
凭借着几个课设项目、
微信小程序
比赛赛区二等奖，以及不太扎实的算法基础（当时没有刷题）和短暂的实习经历
。
大二下的时候我拿到了腾讯的日常实习offer。
当时一边准备期末考试，一边准备腾讯面试。
后来跟不少师弟妹聊，他们都觉得我这太肝了。其实还好，我有时候熬夜并不是事情真做不完，就是不想做，然后去打了几把王者， 等到 DDL 快到了才开始做导致的。
本来打算暑期继续去那家公司实习的，不过我已经拿到了腾讯的实习 offer，当然是去腾讯实习啦。
暑期入职，然后一直干到了年底。
这时候就体现大二刷学分的好处了，大三课就不用选那么多，正好每周能挤出三天去实习。
其实大厂日常实习面试难度并不大，
需要的其实是，
一定的项目经验 + 还算扎实的计算机理论基础 + 时间
；
学校周围没有大厂的、甚至连公司都没有的，那就只能靠春招找暑期实习了。
平时想实习基本很难挤时间了，光是通勤就要花掉一两个小时。
另一个是周围尽管有不少企业，但学校课程设置不合理，大三还一堆课的，想实习也是很难，需要提前了解，想办法提前修。
腾讯实习
在腾讯实习，那时啥也不懂，配个环境常常要搞大半天。也缺乏职业素养，一被要求跟其他同事交接、合作，心里总会发怵，担心自己太菜做错事，遇到问题了也总是自己鼓捣，导致进度延误。
觉得不熟，发自内心的不敢问
后来在
leader
的引导下，慢慢克服了这些恐惧，尽管在此期间的我技术水平没有太大的提升，但是我的职业素养却提升迅速。这大概也是提前实习的好处之一了。
其实同事之间的交流是不需要那么复杂的，该问就大胆问，出了事情你
leader
自然会帮你扛着。初入职场的师弟妹们，你们要做的，就是大胆地踏出第一步。
到四个月的时候，组内大佬去
封闭开发
了，整个平台的
web
端（前后端都要）都丢给了我来维护，工作量激增，更重要的是，以前总觉得有啥解决不了的都有大佬扛着，心里不慌，现在有啥搞不定的就很捉急。
每天忙忙碌碌，却总感觉提升没那么明显了。
终于12月份时趁着回学校准备期末，结束了我的第一份实习。
离职回校，一方面准备暑期实习面试，一方面准备期末考试。
那时大抵自信心爆棚了，觉得春招肯定能做个offer收割机装装逼了。
春招实习面试
打脸总是那么一瞬间的事。
字节一面，挂！
阿里一面，挂！
而且疫情原因，回不了学校了，我的书都还在宿舍。无奈，开始分析自己的情况。
学历、专业
：没啥优势，也没太大劣势；
实习经历
：有鹅厂实习背书，尽管是测开，但这段经历应当是大大加分的；
项目经历
：大大小小项目做了不少，但是没有一个是针对面试去精心准备的，为此我专门搞了一个人手一个的秒杀项目，进行优化，不得不说效果很好；
个人技能
：也就是个人的基础，JVM、计网、数据库、操作系统这些，我当时的情况也是很糟糕的，很多东西问到了说不出来；另一个就是算法题没怎么刷；
比赛
：有点小奖，但是含金量也比不上 ACM 之类的大赛，聊胜于无。
那么目前该突破的点就是：项目、基础知识、算法题；
然后开始规划，整整两周突击之后，我又可以了。
后来顺利拿到字节暑期实习 offer、腾讯暑期实习 offer，放弃了腾讯offer来到了字节。
一方面想多体验下不同的公司，另一方面字节实习真的给得很多。
字节实习
不得不说，字节的实习体验还是很棒的。
组里大佬很多，每周的技术分享，技术评审都能学到不少东西，当然要看的东西太多，压力也比较大（基本10105.5）。在字节实习，确实可以很快地提升自己的技术能力，毕竟大家都不把你当实习生的。我觉得这其间最重要的就是学会撰写技术方案，学会主动思考。
实习的选择有很多，比如全力实习，争取高评分转正。也可以一边实习一边复习，利用转正保底，同时拿下其他家的 offer。这里我走的是第二条路线。但事实上我建议暑期实习的最优解，是在8月份之前全身心投入实习，8月份后全力备战秋招。
另外，字节的福利也很OK（当然也不是十全十美的），三餐免费（尽管有时饭菜不那么好吃）、每天都有下午茶（并没有想象中那么豪华）、零食区（好吃的很容易就被拿光了）等等，当然更重要的是具有竞争力的实习薪资。
去不同的公司实习体验
，找到最适合自己的工作节奏，对后续秋招选择 offer 有很大的裨益。
秋招
有的时候真是
福祸相依
。
我的转正比较晚，组里同学8月初已经拿到了转正意向书，而我最终拖到10月中才完成答辩。
也正是因为迟迟不能转正，对转正通过率心有疑虑，就投了腾讯，想拿个保底先。没想到原本的保底 offer 变成了最优选择，幸运地开了一个大奖，薪资远高于我的预期。尽管字节还没开奖，但此时的我也没有必要等待了，双休、平台大、钱还多，果断跑路。
毕竟工作就是为了赚钱，真正能时时刻刻把工作作为挑战去激励自己成长的人，寥寥无几。
后来就开始总结经验，分享经验，多次被辅导员邀请到学校开讲座，在公司 openday 被邀请到给参观的师弟妹做分享；
今年春招就有不少师弟妹在我的帮助下拿到了 BAT 的实习 offer
：
我的经历到这里其实已经讲得差不多了。
题目问『最努力的同学是如何学习的』
其实真的是想知道别人有多努力么？
很努力，但是结果很糟糕，这样的例子有人会感兴趣么？
单纯比拼谁比谁努力，谁比谁刻苦，其实意义不大。
我们都渴望用最少的努力获取最好的结果，
但现实往往是，我们还没开始努力，
就想知道这个努力与结果相比值不值得。
---------------------- 4.29 更新 ----------------------
你们要的提升搜索能力的文章来了
菜饼的搜索能力是怎么练出来的？
想了想，还是多说几句。
我很庆幸自己选择了互联网行业，尽管目前很卷，竞争压力也很大，但是又有哪个行业不卷呢？
起码顺应时代，钱给得够多，对咱这些普通农村家庭的人来说，这是时代给予的机会。
但是不是所有人都适合这个专业的，
我见过很多在这个专业浑浑噩噩的人，不喜欢，就是不喜欢，学不会，就是学不会。
很难想象读了四年计算机，连电脑都用不熟练，但确实就有这样的人。
所以这里我要劝退下大家，三思而后行。
你问我计算机是不是很赚钱，我告诉你，就是很赚钱
，校招工资年年涨，甚至我校招拿的工资顶得上其他行业深耕十几年的大佬的工资。但是，也要看到那些选了计算机，最后却是学了个寂寞的一小撮人。另外，
互联网行业加班就是常态，1095我都觉得是很轻松的部门了。
怎么样才能最好的了解这个行业？
找个已经入行的师兄/师姐，请 
TA
 喝杯奶茶，坐下来详细聊聊现在的生活状态，工作状态，看看符不符合你的预期。
下面这篇文章就很好的展现了现在
真实的大厂程序员的工作状态
。
最后的最后
一句话送给你们
所有你走过的弯路，在合适的时间，都会变成你的捷径。","最努力的同学是如何学习的？这我不太清楚，但是我可以邀请
副院长来告诉你，如何努力学习计算机才不浪费大学4年。
身处教育行业，我们经常会从各种渠道听到学生们这样的困惑：大学四年怎么学习才能更好的掌握自己的专业知识，提升核心竞争力？计算机要不要考研？考研跟不考研有什么区别？每个计算机专业的学生总是不避开这几个扎心N连问...
每次看到这些问题，慕课君也很绝望，以我的知识水平根本解答不了这么专业的问题。随着越来越多的同学反馈出这样的学习的困惑，一合计，不如我们做场直播请慕课老师统一来解答一下吧。
于是有了这样一个福（guang）利(gao)：
我们邀请了：浙江大学计算机学院副院长
教授；吴教授是浙江大学求是特聘教授，博士生导师，浙江大学人工智能研究所所长。
主要研究领域为：人工智能、跨媒体计算、多媒体分析与检索和统计学习理论。
获得者（2016年）、教育部新世纪优秀人才支持计划入选者（2011年）。参加国家《新一代人工智能发展规划》和教育部《
》撰写工作、教育部人工智能科技创新专家组工作组组长。
同时，我们也将学生们最普遍的困惑进行了整理，
邀请吴教授直播解读一下计算机专业：
计算机专业本科生就业前景；大学期间如何系统学习计算机专业？计算机专业要不要考研？考研与不考研区别在哪里?以及如果要考研，有什么择校与方向建议呢？
相信这些问题足以解答大部分同学的学习困惑了，还有其他专业问题？那不如直接来直播间当面提问吧~
3.5日（周二）19:00-20:00 吴教授帮你免费直播解读计算机专业那些困惑的事。
错过了直播也没关系，回播一样可以看哦↓↓↓
还想学更多名校课程？搜索“中国大学MOOC”名校课程免费上~","@John Fish――哈佛学霸自律的一天
哈佛大学 计算机科学系本科生
最近，哈佛大学名叫John Fish的小哥在社交网络上火了。他用一个视频记录了自己一天的生活。
小哥对起床、学习、吃饭、锻炼、读书等每一项活动都列出了详细的计划并严格执行。
除此之外，小哥还给自己列出了每日的目标：
除了每天的学习任务外，哈佛小哥还留出充足的睡眠和锻炼时间。在学习的同时，保持良好的身体状态也至关重要。
@
沈天成
――学霸+体霸+舞霸
清华大学计算机系2014级本科生
大一结束时，出于对信息科学的热爱，沈天成从精仪系转入计算机系。
选择转系，面临着大大加重的课业负担、专业基础强的新同学、跌至第30名的年级排名带来的压力。但凭借坚持不懈的努力和钻研探索的韧劲，沈天成在大二和大三学年成功“逆袭”，最终60%的课程进入了课堂前5名，学分绩稳定在93分以上，三年综合排名位列年级前三。回首这一路走来的酸甜，沈天成说：“学业上这场旷日持久的‘逆袭战’，让我感受到追逐梦想的不易，更让我看到苦尽甘来的希望。”
其实，沈天成不仅是同学膜拜的“学霸”，也是在各种体育比赛中拿下20多个奖项的“体霸”，还是个名副其实的“舞霸”。
大学三年间，他代表院系参加10项
马约翰杯
比赛，还代表清华参加5项首都高校体育比赛，斩获过各项荣誉。他自如游走在毽球、跆拳道、围棋等大小赛场。在“马杯”毽绳运动会中，沈天成曾连续三年刷新盘踢校纪录，大四时更是打破单踢、盘踢、磕踢、三人踢毽四项校纪录。
如果在教学楼和操场没有见到沈天成，那他大概在舞蹈排练厅。同许多零基础成员一样，他需要无数次忍住疼痛压软度、练技巧，对着镜子琢磨动作，一招一式反复打磨。几百个日日夜夜的不懈坚持使沈天成从一个完全没有基础的“萌新”变成了神形兼备的舞者。几年来，他参加过新年晚会、迎新晚会等十余场大型演出。
@汪蕴哲――机会留给有准备的人
闽南师范大学
计算机学院网络工程专业2013级本科生，北京大学软件工程专业2018级硕士研究生
成绩平平，平时科目考试都是很一般的分数，甚至挂过科，这是大一时候的汪蕴哲。
与多数人在大学读好专业课、拿奖学金的想法不同，他大一开始就把心思放在
计算机程序设计
竞赛上，希望通过打竞赛提升个人能力。大学四年，他参加了计算机专业竞赛二十多场，获得了五次省级以上、十多次省级以下的荣誉奖项。
到了大三，汪蕴哲四六级还没过。他定下目标，大三要过四六级。大三上学期，课程比较多，还在准备创新创业项目，剩下的时间他就去图书馆学习英语，大三上过了四级。大三下边做项目，边复习英语，六级也顺利通过。
后来，汪蕴哲决定考北大软件工程专业硕士。
六月份开始真正复习，一整天泡在图书馆，看到别人搬箱子过去，他也搬了箱子过去。暑假期间因为宿舍装修，他在校外租房复习，租房内没空调，非常热，里面放着许多之前租房学生们留下的资料书籍，他就觉得不是一个人在战斗。
一开学，他就搬回宿舍住了。每天早上七点起床，去小卖部买一大瓶矿泉水和面包作为一天干粮，然后泡在图书馆，直到图书馆闭馆钟声响起才离开座位，也经常跟着在图书馆走廊来回走动背书的人一起背书，就这样一直坚持到12月份。
当然，他也会给自己一点娱乐时间，比如打游戏、弹吉他、画画等。
对于汪蕴哲考上北大研究生，与他朝夕相处四年的舍友作出如此回应：“他能考上北大研究生，我倒是不意外，因为机会都是给有准备的人，而他就是这样的人。”
@周知――经历丰富的计算机大神
华中科技大学计算机科学与技术学院
的2014级博士研究生
周知曾5次前往欧美以及香港地区参加国际学术会议。他说“刚好有机会就去了。虽然做研究是一件相对乏味的事情，但是参加这些学术交流却是无比快乐有趣的，因为确实可以开阔眼界。”
2016年，他以
访问学者
的身份去
德国哥廷根大学
。在德国，做了一些科研课题，和不同的学者交流，与领域顶尖人物近距离接触，参加一些学术经验分享会等等。（PS：哥廷根大学是全德TOP5，世界的名校，培养的诺贝尔获得者有47位之多，可谓是德国诺贝尔奖获得者的摇篮）
周知一共是发了5篇A类学术论文。有一段时间，他跟着导师在实验室一遍又一遍地润色写作、梳理逻辑、丰富内容、强化实验，以及与合作者邮件沟通。
那段时间是他最为“痛苦”的时候，长时间“烧脑”使他随时随地想躺下来休息，经常在最为疲乏时还需要一遍又一遍地思考没想明白的问题、弄清楚将没写清楚的语句。
在投稿前的第三天，他发现一个致命的漏洞，在冥思苦想了一天却仍无头绪的情况下，他甚至有放弃的打算。最终，连续10天的高强度工作后，他留下了9页纸的论文和80余封沟通邮件。
推荐阅读：
全栈工程师人才最缺？这份求职攻略请收好！
区块链人才成抢手货，新来者如何快速上车？
想成为网络安全工程师？如何“打怪升级”？
欢迎关注我的微信公众号：
九章算法
（ninechapter），帮助你了解IT技术前沿，通过面试、拿到offer、找到好工作！","感谢大家，追更了目前工作后的状态 ??
论努力，我不会输给任何人。
认识我的朋友都知道，即使目前在鹅厂的高压下工作，我也依然坚持利用午休和下班后的时间创作，每晚都是接近 2 点才上床休息。
朋友们总劝我，你别肝了，我说：大学的时候，可比这累多了。
下面分享一下我通过自学，最终拿到大厂 offer 的故事。
我是上海一所 211 学校的本科生，网络工程专业，虽然学校不算太差，但在各种 985 面前，是没有竞争力的，只能说学历不拖后腿。
我从小就对计算机很感兴趣（主要是喜欢打游戏），由于高考时失利严重，所以在进入大学前，就给自己定下了一定要进大厂的目标，决定要好好努力，不输其他名校的同学，我要证明自己不比他们差。
不过现在回想起来，当时确实是年少轻狂啊，也没有想到零基础学习计算机，竟然需要那么漫长的努力。
还好，虽然在追求目标时走了一些弯路，但总体还算顺利。
下面分享我大学四年的学习和求职经历、方法、技巧经验，在最后精心总结，建议大家收藏，并定期和自己的现状来对比，按照我的经历，你也可以进大厂！
大一
其实，我的大一比较滑水，新鲜的事物太多，让我渐渐忘了入学前的目标，忽略了学习的重要性，不过这也应该是大多数同学的真实写照吧。刚入学时我加了很多社团，每天就是和兄弟姐妹们开心滴玩耍，完全不在意自己的成绩。但幸运的是，我加入了一个给学校开发网站的工作室，老大给我布置了一些学习网站开发的任务，因此上学期也学到了一点课本之外的知识，但专业课的成绩着实一般。
寒假回家跟名校的朋友交流后，我意识到自己忘记了曾经的目标，于是决定洗心革面，发奋图强。和朋友的交流中，我意识到想要学好编程，仅通过学校的计算机课程是远远不够的。于是，我买了几本书，在大学的第一个寒假，学完了 Java 这门编程语言、数据库理论和 MySQL 数据库的使用。刚开始自学的确比较困难，所以整个寒假 
每天早上 8 点钟爬起来就是学习，一直学到晚上
，那段时间几乎是 
闭门不出
，所以感觉时间过的很快。自己对这个寒假也没有什么深刻的记忆了，有时 
因为一个 bug 熬到半夜
 的郁闷心情。
在刚开始学 Java 时，我看书上的例子是看一遍忘一遍，看了半天啥也没学会。于是，我就跟着书本敲代码，把每一个例子，每一行代码都理解、啃头，认真完成课后练习，并且将练习的代码结合自己的想法做了些修改，试着自己开发了一些小软件，比如整人儿程序，打开软件后就会在屏幕上出现无数个关不掉的窗口。自己开发和设计程序的过程是非常爽的，没有课本和作业的束缚，让我渐渐对编程产生了兴趣，也为后面持续努力自主学习埋下了种子。
在大一下学期，我首先端正态度，开始认真学习学校的计算机专业课程，希望能得到一个好的成绩。除了学校教的基础课外，我在网站开发工作室中学习了更多网站开发知识，主动承担校园网站建设任务，并且用学到的技术手动为自己开发了
个人博客
，来记录自己的学习过程。
随着前端学习的逐渐深入，我开始好奇前端页面背后的请求逻辑，于是开始自主学习 Java 后端的知识，刚开始接触后端，感觉像是打开了新世界的大门，我意识到， 握草，编程真的是这辈子都学不完啊，然后开始更努力地学习。
与此同时，在这学期，我抓住了两个机会，首先是作为队长申报了国家级大学生创新创业项目，这个项目的申报属实不易，我被老师拒绝了好几次，他每拒绝一次，我就重新提一个想法、设计一个方案，最终终于成功抓住了机会，带领团队开发了一个一站式校园信息整合系统。做这个项目的时候，正是课程最繁忙的时候，那段时间，光是做课程 oj，就让我很头疼了，但还好有责任心驱使我前进，每天晚上肝到 2 - 3 点，我也能够将项目做好。
第二个机会是，我加入了导师的研究生团队一起做项目，机会是靠自己争取的，简单的说就是毛遂自荐，虽然当时我只学了简单的 Spring 后端开发，但我相信自己能够通过爆肝，虽不奢望追上师兄们的步伐，也要不拖大家的后腿，为项目多做贡献。
光通过做项目，我就赚到了几万块钱，做到了经济独立，同时也积累了一些经验，在专业课上取得了不错的成绩。
当时的我，天真的以为，照这个节奏努力下去，已经足够了。
但随着我看到了身边更多优秀的人（比如我哥，在清华，
大一发论文
），学到了更多的知识，我发现，自己还是太嫩了，那个时候的自己，根本谈不上努力，只是个沉迷学习的傻子。
大二
大二这一年，除了担任班长，我还当了学生会部长、社团部长、网站开发工作室的负责人，因此，除了专业课学习外，还有非常非常多其他的事情要处理。但是，不论其他事情要处理到多晚，我都始终坚持每天留给自己几个小时用来自学技术，哪怕熬夜到凌晨三四点，然后第二天 8 点接着醒来上课。课上犯困的时候，我会做一些相对不用动脑的工作，比如记录一些实验课的报告。然后等回了寝室，躺在床上，把电脑放被子上，我便会打起精神，开始自主学习编程。
虽然此前我已经学了很多编程语言，但是，从大二开始，我坚定地选择 Java 作为自己的主语言。
大二上学期，我几乎每天都是在教学楼、学院楼或是图书馆度过的。为了巩固自己的 Java 基础，我不仅上网看了一套完整的 Java 视频教程，还读了《 Java 核心技术卷》这一经典书籍。为了检验自己的学习成果，我自主报考了国外的 Java 等级认证，特地办了张跨境银行卡来支付报名费，还好通过努力复习，高分通过。Java 基础打扎实后，我开始学习主流的 Java 开发框架、微服务技术等。我的记性比较差，但还好学编程不靠死记硬背，背代码的肯定是比不过自己做项目、多写代码的。因此我学编程知识时有个特点，就是边学、边敲代码做项目，每学完一个技术，我都会独立开发一个项目，比如团队协作系统、CRM 管理系统、校园通讯系统、即时聊天系统等。
哦对了，那会儿，之前的网站工作室负责人毕业了，临走时，把工作室托付给了我，当时工作室成员不多，光我自己，就独立做了 5 个以上的网站。在老师的推荐下，我还去给其他学院的老师开发系统，而且那段时间，在上数据结构和算法这门课，我还在研究 ACM 方面的题目，所以有时会忙到连中午吃饭的时间都没有，直接待在其他学院的老师办公室吃盒饭。
我会整理自己做过的项目，慢慢地竟也积累了不少，有一些项目改造改造，拿去完成课程大作业，或者参加比赛，都非常不错。
我也经常在自己写作的地方分享自己做过的项目和经验，欢迎大家来看一下。
大二寒假，我参加了一个计算机作品竞赛，有幸找到一位很优秀的学长，他做后端，我做前端，我们一起开发了一个大学二手置换平台。在这个过程中，我学到了很多团队开发的技巧，也从学长身上学到了很多编程小姿势。学长校招拿到了阿里的 offer，也是给我带来了不少的鼓励吧~
这个寒假，除了开发作品外，我看了一些计算机网络方面的书籍，补充自己的理论知识，基本也是全天都在学习，只有晚上跟朋友出去玩玩桌游，即使在玩时，可能抽空还会想想白天遇到的难题，痛并快乐着吧。
通过不断开发作品，我意识到自己的前端网站开发效率好像不太高，于是在大二下学期，我开始学习前端框架 Vue，比 jQuery 更加高效地开发体验带给我极大的学习兴趣，一口气学了一个多月，看完了 2 套 Vue 完整教学视频，并且自己动手写了几个 Vue 完整项目，同时还学到了很多打包工具，自己也实践了他们的配置方式。
当时觉得大二暑假好像没什么事做，就计划要不用技术赚点钱吧，因此我没有选择去做兼职，而是想找一份和自己职业目标相关的实习，于是我开始跑到大公司的官网去投递简历，即使简历上什么内容都没有。结果可想而知，像阿里巴巴这种一线大厂根本就不鸟我，
朋友们觉得真实么？
没办法一次进大厂实习，那就一步一步往上爬吧。那我就在各种求职网站去海投简历，终于有幸在实习僧上收到了几家公司的面试邀约，基本都是要坐几个小时地铁的公司，但肯定也都要去试试吧。当时自己虽然做了不少网站，但由于面试准备不充分，屡战屡败，结果只有一家公司肯要了我，岗位正好是 Java 后端开发。
于是那年暑假，我每天早上 6 点就要起床赶高铁去上班，学校在郊区，我要先骑着我的小、小电动车去地铁站，然后坐地铁，换乘 2 次，再走老长一段路，来回四个小时的车程。后来，为了省时间，我发现了一条更精妙的路线，公司在高铁站附近，那我干脆就坐高铁去！于是，每天可以节省近一个小时的时间来学习。
当然，在车上的时间我并没有浪费，而是利用这些零碎时间用手机刷 Java 等知识的练习题、看其他同学的
面经
、或者阅读公众号上的技术文章。我给自己定了一个每日任务，每天读 4 篇文章，刷 30 道牛客 Java 题目，经过两个月的时间，题目刷通了两遍，也学到了很多技术知识。
那段时间，我白天在公司上班，晚上还要回到学校去接着跟老师做项目或者自主学习，弥补面试时发现的自身的不足。
即使在工作中没什么活的时候，我也会刷算法题，带薪刷算法题，绝对不让自己闲下来，因为我怕我一放松，就会懈怠。等我走的那天，刷了估计也有几十题了。不过有一说一，那会儿网上的算法教程和经验分享都不多，所以我也走了很多弯路吧。给大家整理了一些学算法的资源，希望大家不要像我刚开始一样，随缘刷题，低效又无趣。
还好，整个实习真的非常愉快，虽然只有两个月，但我真的收获爆表。
学到了很多技术和业务知识，开拓了眼界，也明确了我今后的职业发展方向；学会了团队沟通和协作，懂得了诚信的重要，也收获了人脉。当然，最重要的是收获了人生一段难忘的回忆。
这也是为啥我建议大家在学了一些技术后，
趁早去找一份实习
，不用担心自己的经验不足，通过面试和企业工作的磨练才能让你积累更多的经验和技术，也能帮助你明确自己的目标。
不过遗憾的是，到最后也没赚多少钱，饭钱自己掏，高铁费J贵，哈哈。
在今年，为了解决学了就忘的问题，我开始使用一种新的学习方法 ―― 费曼学习法。每次学到一些知识，我会尝试用自己的方式进行复述，并和其他同学进行分享。只有能清晰地讲述所学知识，并让他人能够理解，才算是真正学会了。用这种方法，我不仅加深了对知识的印象，语言表达能力也得到了很大的提升，还有了更多给学院同学分享的机会，开过几场讲座，而这些都对我今后的面试非常有帮助！
让我欣慰的是，自主学习课外技术竟也帮助我理解了一些学校的课程，因为很多理论知识之间是有关联的吧，所以今年的成绩还算不错，拿到了国家奖学金。我用奖学金的钱，再加上之前做项目的钱，买了配置更高的电脑和设备，激励自己学习。
大三
在之前的几次面试失利中，我感觉自己的编程知识是缺斤少两的。一方面我要学习更多且更深层的后端知识，不能仅停留于 “会用”，而是要 “活用”。因此在大三这一年，我又学了像
消息队列
、搜索引擎等企业后端必备的技术，以及 MySQL 优化、虚拟机调优、Redis 底层，并且通过阅读源码，自己搞了一些框架。另一方面，我意识到了数据结构和算法的重要性，开始刷算法题目，每天早上花 2-3 个小时搞几道题，坚持了近一年，总共搞了 1000 道题吧，也顺便考了一些算法类证书。
学的技术越多，我越发现啊，学编程还真是得靠敲的！光说不练假把式，其实很多视频教程中的小 Demo 都蛮不错的，要注重积累，并试着将重复的代码进行抽象，避免重复造轮子。很多技术都是因为有实际应用需求，才被人创造，才需要你去学习，比如你要做一个支持用户登录的 APP，你就要学习登录机制；要做即时通讯，你就要了解 RTC、Socket；性能低了，你就要去优化；担心网站被黑了，你就要做安全措施；懒得写重复代码，你就要学低代码、
大前端
等等。
直到现在，我依然是一名兴趣驱动型 coder，会经常带着小伙伴们一起做一些好玩轻松的项目，提升兴趣的同时学到不少编程小技巧，欢迎朋友们来看看。
正因为明白兴趣和实践的重要性，所以我大三一整年都沉迷于做项目、找实习、参加竞赛，乐此不疲。
上学期先是在实验室跟着老师研究区块链技术，不得不说，实验室的环境更适合学习，从早上起床就来实验室，直到晚上十点多甚至是十一点才走，感觉真是很充实！几个月过去，终于开发出了落地应用并出版了一本教材（个人编写占比超过 50%），也是这段时间的研究让我浮躁的内心渐渐变得平静。
在寒假前我向字节跳动投递了简历，在一份实习经历和坚持刷算法题的加成下，我很顺利地成功通过了面试，开始了日常实习生活，在不敲任何一节课的情况下，每周上班 3 ~ 4 天。（好奇为啥没翘课还能一周上这么多天班么？后面详细给大家分享，欢迎关注我呀！）
实习部门是个新部门，地铁每趟要近 2 个小时。虽然使用的是自己不太擅长的 Php 和 Go，但学习起来很容易，导师和上级非常好，给我绝对的发挥空间，从入职起就参与项目的需求评审，甚至后来是自己一个人负责了一个项目的后端，和其他部门的同事打交道也非常多，成长非常非常非常快！而且字节跳动的待遇真的没话说，全员 Macbook +免费三餐零食下午茶。
后来快离职了，导师和上级也没给我安排什么任务，除了解决下之前写的 Bug 外，我不会闲着，有空就坚持刷算法，LeetCode、交大 OJ、浙大 OJ、牛客、PAT、北大 OJ，我都刷了几十道题，其中 LeetCode 刷了 600 多道！顺带一提，在来回四个小时的车程中我依然会看技术文章、背单词、看面经、或者刷刷面试题目。不得不说，字节跳动真的是一家很好的公司，他的价值观（字节范儿）也带给了我很大的激励吧，共勉。
实习四个月后，我跑路了，原因是自己还在纠结到底是保研还是就业，不妨两者都试试，到时候再选择一个更优解。所以回到学校后，为了丰富简历、给上海落户凑一些积分，我参与了一些大型竞赛，像挑战杯、互联网+、三创赛，在所有团队成员共同努力并让我抱大腿的情况下，也获得了一些奖项。
后来，某天在校溜达时，我突然收到了腾讯的电话面试邀请，总共只有两轮面试，都是些后端问题，还好我每天都在看面试题，有备而来，所以答得还行，也就顺利搞到了暑期实习的 offer。
大三这一年，我专门搞新技术的时间并不多，但是通过不断做项目、刷算法、不断发现和解决问题，我的基础和技术能力都有了很大的进步。有了更多的知识积累，在学新技术时，我可以将一些新知识和以前的知识对照和串联，从而理解的飞快！比如学过前端 Vue 框架后，再学习 React 框架就轻而易举，我的技术栈也因此变得越来越丰富了。
大四
大三暑假，我开始了在腾讯的实习生活，刚开始还是挺不适应的，总是在简单的工作上翻车，但后来多花了些时间学习，也渐渐能独立完成工作了。后来，我在实习转正答辩中取得了同组第一的成绩，顺利搞到了不错的 offer，并成功签约。不知道小伙伴们是否需要我出一期实习转正的视频呢？
整个大四，我基本都在腾讯实习，每天依然是坐地铁往返学校和公司，在路上坚持学习。疫情期间，我就在家里远程实习，下班的时间除了做毕业设计、写论文之外，我还独立开发和上线了一个完整的小程序【面试君主】。
等毕业证搞到手，我已经在腾讯实习了近一年，后面的转正也都非常自然。
不过转正之后，激动的同时，身上的责任和压力也大了许多。
想了解我转正经历的朋友，请点赞后在评论区告诉我吧，让我知道有人看了几千个字后，来到了这里~
这就是我的大学生活，一段平凡的奋斗史。
想要进大厂，只靠努力还是不够的，我认为进大厂需要以下要点：
兴趣，学自己喜欢的，这是你前进的主要动力
目标，有目标才有规划，才能避免像我一样走了弯路浪费了些时间
自学，只有持续自学，你才能看到更大的世界。其实现在网上好的学习资源非常多，为了帮助大家发现优质编程资源，我花了 200 个小时开发了编程导航，还整理了免费编程资源大全。
实践，纸上得来终觉浅，对编程来说更是如此，必须要多加练习
机会，在我的故事中看似有很多的幸运，但其实每一个机会都是要自己争取来的，你变强了，更多机会和幸运才会眷顾你。而每个机会都可能会改变你的命运。
突破，打破自己的舒适圈，这样才能给自己多一点选择，多一点成功的可能性。
时间，珍惜你大学的时间，这段时间的努力会在未来，给你带来更大的价值
生活，保持健康规律的生活，不要像我一样因为常年熬夜，记性越来越差，头发掉的越来越快。
最后再给在校的同学们一些建议。
建议
给目标直接就业同学的建议：如果时间还多，那么就按照自己的方式和兴趣去学习技术并实践，心无旁骛。你要知道研究生也才多一年多的项目/研究时间，如果本科你把别人准备考研的一年用于学技术，那么竞争实力完全不输研究生。
给考研同学的建议：提前了解目标院校考察的专业课，并在该门课初学时就下功夫。所有实践课要好好学，平时有空也多上
牛客
，避免考研失败后春招完全小白
给保研同学的建议：如果 
一心决定读研
，担心保不到好的学校，也可以准备下考研，顺便也能复习到一些面试知识总之，目的是给自己
多一个选择，多一条后路
。
我的座右铭：
相信自己有能力，那么你就真的会有！
希望这句话可以鼓舞到更多的同学吧。
--------------------- 分隔线 ----------------------
一天不到，点赞破百了，感谢大家 ??，所以我第二天就来补充答案啦~
很多同学对知识博主的生活可能比较好奇，我是怎么做到 
连续日更不中断
、同时维护两个公众号、又做视频、又写文章、又做直播，又能作为项目主负责人，和 一些小伙伴一起持续开发自己的网站
【编程导航】
的呢？
再补充下我工作之后的生活吧。
工作之后
在没有做技术分享前，我可以说是把 99% 的精力全部投入到工作和技术学习中，但是很快，我就意识到，对于刚毕业的同学来说，你应当努力工作，但完完全全把自己交给公司并不是一个正确的选择。
为什么这么说？
刚来公司实习不久，我就经历了一次大的组织架构调整，换了部门，也换了项目。而前段时间，因为部门的需要，我的工作又发生了调整，不再负责原来的项目了。我意识到，互联网果真如外界所说，太不稳定了！我负责了一年多的项目，说换就换了，身不由己。虽然在这个项目中我也学到了不少技术，但毕竟是自己花了一年养大的小孩，突然离家出走，还是非常难过的。
作为打工人，我就是一块砖，哪里需要哪里搬，这种无奈相信很多朋友都体验过。
因此，在完成工作的前提下，我选择投入更多时间在学习、或者培养自己的兴趣上，为自己今后的发展做考虑，而不是和公司的业务绑定。
我的兴趣是什么呢？
老实说，就是学习和分享，我喜欢分享自己学到的知识，让自己巩固学习的同时，也希望能帮到更多人。
因此，我开始了自己的创作之旅。
目前的状态
每天早上 8 点多，还迷迷糊糊的时候，我就会闭着眼睛思考今天要做的事情和时间安排。除了工作外，还要思考今天的创作形式、方向和内容。做好计划，白天我才能更高效地去完成这些事情。
思考的差不多了，大概 9 点多，我会挣扎着从床上起来，看一下昨天的消息和今日新闻，然后整理一下就出门上班了。
出租屋离公司很近，每天骑大概十五分钟的小电驴，大概十点左右到达公司，开始一天的工作。
随着加我微信的朋友越来越多，很久之前我就没有时间去一一回复了。毫不夸张的说，光认真回复消息，就足够我过完一天了，还不一定能回完。因此，我会尽可能利用零碎的时间回复消息，比如在等电梯、排队时。
在没开始写文章、剪视频的时候，我每天的午饭和晚饭都是和同事一起吃的，饭点食堂人比较多，每次要排很久。因此自从踏上了创作之路后，为了省时间，我就直接在工位上点外卖了，在工位也比较自由，还能看视频收集一些灵感。
但常吃外卖对身体不好，因此我现在一般会晚一个小时再去楼下食堂恰饭，再忙也要注意身体。
以前我一般会午休半个小时，现在我会利用中午的时间写作、和其他创作者或者读者朋友交流。
下午工作一般比较累，我有时会趁着编译的时间看一下微信消息，但需要保持高度专注时，我会把除了工作之外的所有通讯软件关掉，所以这个时候给我收到的消息基本都会被顶下去，一不注意就再也看不到了。
如果工作不忙的话，大概晚上 8 点左右，我就开始准备视频制作了，做视频真的是一件非常麻烦的事，比写文章要麻烦好几倍！从收集素材、确定方向、定大纲、写视频稿、优化稿子，再到设计标题、封面、简介，每一步想要精心制作都会花很多时间，稍微在某一步多纠结一会儿就做不完了。尤其是随着观众的增多，视频的质量也要提升，再也不是以前我随便录两下就能对付的了。
大概 22:00 到 22:30 左右，有时间的话，我会在 B 站和抖音开直播，一般是带大家看看好玩的项目，和大家交流一些编程方面的问题，有时还会做一些专题分享。
直播半个小时，我基本已经身心俱疲了，然后我要完善一下手头的项目，或者开发我的
【编程导航】
网站，继续为第二天的创作收集素材。
大概凌晨 1 - 2 点，准备休息了，睡觉前我会记录一下今天完成和未完成的事，并且提前预定制第二天的计划。每天的事情都非常多，计划都在十条以上，也让我的记性变得越来越差，不记录一下有些事情肯定就忘掉了。
给大家看下我的每日计划表吧：
好吧，这就是我的生活，我自己都觉得无聊。其实到现在，我都没有一个特别专心的打法，写文章、做视频、肝项目、日常直播，能做的我都做了，本来就是随便搞搞，自己开心就好。可如今随着我的读者朋友越来越多，让我不得不认真了，也增加了很多的创作压力。但我的初心还是不会变的，爱好分享，通过传递知识帮到更多人；同时以输出知识促进自己输入知识，变得更强，我相信大部分的创作者也都是这样吧，
都不容易
。
因为热爱，所以坚持。
白天在工作，码字于凌晨，希望大家可以点赞支持一下！??
也欢迎大家关注我，一个在变秃，却能带你变强的程序员。
有问题可以直接联系我，有问必答！
 
@程序员鱼皮","泻药。
利益相关：某一般 985 大三学生，零基础，大学才开始接触编程。
大二腾讯阅文实习，大三微软、携程实习，春招拿到微信、
、头条 offer。
----------------------------
我感觉身边的大牛们其实在 CS 相关方向上的努力可能和人们传统的观念中不太一样。
比如说早起，刷图书馆，认真听课（orz）之类的，可以根据个人的需要进行取舍。相反，兴趣驱动和坚持不懈可能才是更重要的一些特质。
比如某不起床室友
@邱宇航
 常年寄居宿舍，但是同样零基础的他拥有着极强的技术热诚和毅力，在春招中照样拿了阿里云数据库内核开发的 offer，这一点我是很佩服的。
---------------------------
关于能力提升的一些方法，我的经验是“实践与基础并重”。你可以选择翘掉一些课，但你一定要明白什么知识重要。其实这种观点很老生常谈了，但是可能不是那么好实现。
我经常出去实习，学校内的课程只能选择性地上，但是我会挑选一些比较重要的课程，把课本和相关的书籍下载下来，在地铁上或者晚上下班后看一看，这一点效果蛮好，毕竟地铁上手机信号不好，不如看看书打发一下时间（滑稽。
---------------------------
最后是我个人的一点点建议吧。
CS 这一行肯定少不了努力，但“最努力”是否一定能成为
？身边的经验告诉我“不一定”。所以与其追求“最努力”，不如追求“有兴趣”，“有目标”，“有毅力”，这样说不定能在这条路上走得更远。
祝顺利～","虽然大学不是计算机系，但也是大学自习的计算机，主要经历了以下几个学习过程中的事，让我更加坚定地要转行进入计算机行业：
1、用
诺基亚3100
（Nokia第一款彩屏手机）看完了《
Windows程序设计
》与《Windows环境下32位环境汇编程序设计》，因为当时在大学自己没有电脑，都是去网吧上网
2、大一期末考结束后，依然一人背上《深入理解计算机系统》一书自习去，整个暑假两个月，每天都在看《
深入理解计算机系统
》与《ASP网络编程从入门到精通》（说实话，现在有点后悔学了这本，应该直接去学PHP的），并且坚持看完并作了笔记（大一时的字还比较生硬难看），代码就用笔在大日历/记事本上写
3、在学校天天泡图书馆，中午基本不午休，有时也翘课去图书馆看计算机书，下图是我们学校的图书馆，藏书很多，可惜计算机书就几个书架而已，当年若是说个计算机书名，我可能都知道图书馆书架上有没有这书。
4、后来整个大学五年（医学）看的计算机书比医书还多，只找到下面这张当年的部分藏书了（都已看完），然后一毕业就去了腾讯工作","一年过去了…突然想起了知乎密码（手动狗头），所以来继续填坑
这一年个人感觉是自己成长最快的一年，就像被前期的投入的基础知识的学习打通了任督二脉一般。
这一年我做了些什么呢？
继续深入了对C＋+的学习，《
effective stl
》认真刷了两遍之后终于敢拿出在书架上已经放了许久的《stl源码剖析》，曾经的满眼天书已经在一次次的对stl内容的学习和实践中显得亲切了许多，读了大约一半后便开始着手去重构以前写的那个简化版的stl了，果然再回头看过去写的代码跟狗屎一样…
《
计算机网络:自顶向下方法
》，过去一直对计算机网络处于一个不感冒的态度，浅薄的认识让我认为要写网络程序调调套接字，最多再了解下TCP/UDP不就完事了？后来又想，在这个互联网的时代搞不懂网络实在是说不过去，加上学校也开设了计算机网络的课，为了考试也得学啊！后来看《
UNIX网络编程
》的时候，我才知道我的这个决策有多正确，还有的是，直到学习这本书之前我也从来没想过网络的东西还挺有意思的。
《QT create 快速入门》对，我实在受够了老师要喊实现点什么的时候，其他同学要么直接通过web，要么java……构造出来的图形化界面，而我的，一个看着就跟刚学C语言的弟弟做出来的黑框站在讲台上演示时的尴尬，另一方面也出于自己做了点什么小工具的时候，能有个图形化界面方便小白用户使用，所以这段时间…点歪了一点技能树（以前也没少点歪），最终的成果…emmmm，总之QT里的类关系我至今还是大多分不清楚的程度，也就只能凭着这本书的教程为例做出想要的东西来的程度。
好像是清华出的《编译原理》，学校发的教材，貌似这儿列出来的东西画风突变，要学编译原理我居然没买本龙书也好意思说自己学编译原理？，好吧，其实我也就是从这儿开始打消了继续学习编译原理知识和买龙书的念头的，虽然花了不少时间在这上面，最终也只是收获了一些基础概念…
《
UNIX环境高级编程
》、《UNIX网络编程》、《
Linux高性能服务器编程
》，这几本就不一一介绍了，相信各位也看出了我终于确定了自己的方向，后台服务器开发。
配合QT，简单的实现了一个轻量级的通讯软件
配合
陈硕
大大的《Linux多线程服务端编程》，花了大量的时间认真学习了muduo，第一次阅读工程级的源码，真的…很掉头发
简单的过了一遍《
head first 设计模式
》，收获…不知道该如何去描述，虽然也简单的去实现了一些，却总有种空中楼阁的感觉，或许这玩意就如某些前辈所说，得在实际场景中，才能真正去理解和运用。
简单的过了一遍老书《
人月神话
》，读完之后只想感叹一句，万恶的资本主义剥削。
对了…还偷闲刷了刷
leetcode
，嗯，还有一个学期要开始找实习恰饭咯嘛
还有…也偷闲学了学go…  如果go在中国的生态环境真的能发展起来，或许哪天我就转go了…
有缘江湖再见
待续…（TODO）
――――――――――――――――――更新分割线
很多朋友评论及私信问到关于刚学完C/C++语法部分，有什么好的项目可以上手实践...   
突然想到了
叶神
的JSON库的开源教程，强推:
miloyip/json-tutorial
_________________________________________更新分隔线
火车晚点了，闲来无事就强答一下大概说说我的历程吧。
首先我不认可有些回答下以学习时间来论努力的方式，得到的结果才是，所以我不会提及我是怎样花时间的。
    不比oi出身甚至小学就接触编程的大佬，大学之前的我对编程毫无概念。
    确定录取某渣二本的cs专业后，在家闲着也是闲着，就大概了解了下，然后通过mooc看
翁恺
老师的C语言入门正式开启了编程路(至今针对向我咨询的萌新，我也还是强推翁恺老师的这套视频)
    大一上:因为暑假基本懵懵懂懂的学完了翁恺老师的那套视频，大概半个月搞定了教我们的老师自己编写的C语言教材，然后花了二三天做了个控制台界面的贪吃蛇(没排行榜，当时实在没弄明白文件流)，然后又花了半个月细细品读了K&R(的确是品读，这本书让我感受到了一本好书带来的快乐和重要性)，也总算很浅的弄明白了文件流，这时候再做个控制台界面的东西让我提不起兴趣了，就了解到了
easyx
，花了二三天搞明白怎么用，然后花了一天又写了个图形界面的贪吃蛇，并且这次有了排行榜(我对贪吃蛇到底有多大的执念啊…)，然后又找了
c primer plus
看，很快的看到大概指针那块，觉得没啥难度，都是老生常谈，就放下没看了…
    至此，大一上大概过了一个半月的样子，因为领先班里绝大多数同学，加上没了方向，大概沉沦了一个多星期天天召唤师峡谷。有一天跟高中搞oi，当时acm实验室的室友吹水的时候，才发现自己屁都不懂…(至于为什么我没进acm实验室，因为当时自卑啊，听说还要考试，觉得自己铁定进不去，然后后来发现差自己很多的都进了，还是挺后悔的)
    然后开始重新寻找方向，根据了解，这时候摆在我面前的方向大概是:
1.学硬件搞嵌入式(但对硬件不感兴趣，否决)
2.学C#，可以搞windows平台的客户端(wpf),可以以此学unity搞游戏，还可以搞网页(前景不好，否决)
3.跟随大流学java(跟大流？不存在的，否决)
4.前端(搞网页没兴趣，否决)
5.移动端(没兴趣，否决)
6.C++(据说难度很大？就你了)
(ps:人生苦短，我用python，珍爱生命，远离C++)
     从此就开始了愉快的c++入坑之旅
     c++ primer plus 走一波
     嗯…这本书看到了临期末前的半个月终于算是弄了个大概明白，过程性语言部分因为有C的基础没啥问题，
oop
和template部分花了不少功夫，stl部分被虐得怀疑智商…
     接下来的半个月预习期末+在代写群里接单代写C和C++的课设
     大一上书单总结:
    《C语言程序设计》――学校老师编写的
    《K&R》
     一部分《
C primer plus
》
    《C++ primer plus》
    emmmmmm，写这个太耗时间了，手机码字不易，接下来的就直接列书单了
     大一寒假:《编码》《
csapp
》
     大一下:《effective c++》《算法》《离散数学及其应用》《C++ primer plus》二刷
     大一暑假:《C++ primer》《
C#入门经典
》
     大二上:《linux鸟哥私房菜》《现代操作系统》《
程序员的自我修养
》《C++ primer》二刷
     大二寒假:《C++标准库》，同时完成了一个很简单的mini stl
      大二下:《effective C++》二刷，
数据库系统基础教程
……待续
      真正的把书单列出来，才发现自己好像也没学多少…所以说一开始说的强答还是没毛病的…而且也没啥拿得出手的项目…
    大概就是这样…欢迎批评…","高三时看到这个问题，我便暗暗下决心：有一天，自己一定要有足够的底气和高赞答案一样说自己足够努力，并展示喜人的成果。
  现在大一上学期快要结束了，我来进行一下期末总结。尝试用英语写一下，我英语不太好，请轻喷。
I write this passage to conclusion this semester.
  For ease of reading, I will change the formatting of some fonts as appropriate. Italics bold represents the title of the book.
 If I were just describing what I've read, what I've learned, I'm sure you wouldn't want to read it either. I tried to summarize in my own language how the knowledge system was constructed step by step.
  During the summer vacation, I read ""
Beginning Python From Novice to Professional
"" written by  Magnus Lie Hetland.
  ""This book is for beginners in programming,"" says its author, but as far as I can see, it's a complete Python tutorial. I don't think telling a beginner about dictionary views, eight queens, etc., is the right choice. The author tries to teach beginners a lot of very profound python techniques, but because of the beginner's own level, he have to stop suddenly.This, in turn, makes the book harder to read and allows beginners to see some overly complex concepts in Python too early.
The other book I read about Python was ""
Python Crash Course:A Hands-On, Project-Based Introduction to Programming
"", written by Eric Matthes.By contrast, the book is lively and straightforward. From lists to dictionaries, from functions to classes, files, and exceptions, the depth is limited, but it's a good start for beginners. The second part of the book will teach novices to develop several classic projects, such as the alien invasion mini-game (although it took me two weeks), the use of API, and the introduction to Django, and so on.
After the beginning of school, I entered a new round of reading plan.
The first C Language book which is named ""
The C Programming Language
"" I read was written by Brian w. Kernighan and Dennis m. Ritchie.It comes with a book called ""
The C Answer Book
"" written by Clovis L.Tondo and Scott E.Gimpel.Unfortunately, this book is not suitable for beginners either. Even the author himself mentioned in the preface that this book is not suitable for people learning C language for the first time.Apart from the complicated Pointers and other concepts in C, this book even USES the knowledge of basic data structure and computer system structure to explain C syntax.Thanks to my Python foundation, I finally understood most of the book.Now read this book in turn, is really written concise, clear and easy to understand, is a depth and breadth of a rare good book.
But for ""
The C Answer Book
"", I don't think it's a good book.Much of the code in this book can be simplified without necessarily looking that complicated.At the same time, there are a few bugs in a little code.
In introduction to computers, I finished reading J.Glenn Brookshear Dennis Brylow's ""
Computer Science : An Overview
"".I had planned to finish reading the book in a month, but it turned out that I was wrong. I have read this book for nearly two and a half months.The density, depth and breadth of knowledge in this book are beyond my expectation. After reading it, I was deeply impressed by it. This book changed me from the inside out, from not knowing anything about computers to mastering the overall context of computers. This is by no means the undergraduate course teaching material that can learn under normal circumstances a semester, but I did, I am proud of myself !
I also read Thoma H.Cormen Charles E.leiserson and Ronald L.Rivest Clifford Stein's ""
Introduction to Algorithms
"".The depth of this book is much higher than that of undergraduate textbooks. To read this book requires a series of mathematical knowledge: mathematical analysis, advanced algebra, probability theory, discrete mathematics.I also hold to try the idea, the result reads quite smoothly. Of course, I haven't finished reading it yet. I've only read more than 200 pages, and I haven't encountered much mathematical demand at present.This is the first algorithm book I read. It's not easy to compare it with other books.
Recursive trees, strassen algorithms for matrices, divide-and-conquer strategies, hash tables, dynamic programming, and so on. I really think a good book can benefit people a lot.The introduction to algorithmhas cultivated my strong interest in algorithm. After all, the author makes me think that algorithm is such a funny thing. 
Kenneth H. Rosen's ""
Discrete Mathematics and Applications
"" is too simplistic. Most of it is what we learned in high school.For example, in the chapter of probability theory, I basically didn't learn anything, which was emphasized in the college entrance examination.Ironically, there are many translation mistakes in this book, which makes me have to make logical reasoning about the content itself when I read it.But the exercises and examples in this book are really well chosen. In order to complete them, I have to spend more than two hours every day. But the return is also certain, it can only say that no pains, no gains.Of course, I'm only halfway through the book.
Mathematics takes up the other half of my study time.
The first university mathematics book I read was the "" 
calculus course (volume 1) 
""written by phyrgengoltz in the selection and translation series of Russian mathematics textbooks.To be honest, I got down on my knees all the way.
This book builds the edifice of mathematical analysis step by step through successive layers, which is amazing. I must admit that analysis has a beauty unmatched by any other branch of mathematics.I remember the first time I understood the concept of an integer order variable (that was the second time I read it);  I remember spending the afternoon reading Lagrange interpolation, Hermitian interpolation, and the mathematical beauty that came to me; I remember how excited I was when I read about the application of differential calculus to geometry.
The 
calculus course (volume 2) 
is the thickest of the three books, and it contains a wealth of computing tricks and magic. When I finished the first book and read the second book with confidence, I was hit again. The book spends more than 70 pages on the mechanics of antiderivatives, more than 50 pages on the 
mechanics
 of definite integrals, and more than 70 pages on the applications of integrals in physics. I had to learn nearly two hundred pages of integration techniques.And just when I was done with integration, and I thought I could finally get rid of it, it led me to 250 pages of infinite series techniques, 70 pages of improper integrals techniques, 80 pages of parametric integrals techniques. After learning this, I looked again and found that the book was over.
The 
calculus course (volume 3) 
is the one I read the most smoothly, with plenty of examples to explain concepts such as curvilinear integrals (steeles integrals), double integrals, surface integrals, multiple integrals, and Fourier series. The book is full of an unspeakable beauty.
Walter Rudin's 
principle of mathematical analysis 
was the first original textbook of mathematical English I tried.Unfortunately, I only read the book until chapter 6. Because at that time, I thought that the knowledge from this book I would learn in the fulture, so I put the book down.
I'm now trying out Elias M. Stein and Rami Shakarchi's 
An Introduction to Fourier Analysis
. Stein deserves to be called the master of 
harmonic
 analysis, and this Fourier analysis (of course, I've only read about 70 pages) makes it easy to understand and easy to understand. However, the book is a bit of a test of the reader's mathematical analysis of the basis, there are some steps to prove a little jump.
I admit that I am too slow in algebra. I am currently reading costerliking's 
introduction to algebra (volume 1, basic algebra) 
and I have just read the concept of group loop fields.Well, when I first read that addition is essentially an Abelian group, when I understood that the greater than sign itself is a set, I admitted that I was overwhelmed by algebra.When I learned the geometric context of determinants, when I learned cramer's formula, plus the edge subformula, I recognized that algebra had a different aesthetic than analysis.
Soon, I will have an interview for the new engineering experimental class. Will enter a new collective. I hope that at the end of the second semester of my freshman year, I can write a final summary as confidently as now.
我希望在大一下学期时，我仍能有足够的底气说我足够努力，并在这里记录自己的成果。（2019年1月2日）
大一下学期：
  大一下学期我主要阅读的是数学。
  《代数学引论》三卷：
    大一下学期我读完了代数学引论三卷。总体来讲，这三本书是从一个比较高的视角解读比较低级的内容，所以阅读的时候会比一般的高等代数要缓慢一些。(假设在每个知识点都掌握扎实) 因为读这本书得人一般都是刚刚从高中数学上岸来得大学新生，再加上这本书比一般的高等代数教科书要抽象，所以可能一开始会感觉有点难以接受，但是习惯了这种抽象会让你受益匪浅(我现在已经感觉到了)。三卷书虽然薄，但是有一定的知识密度，如果不加以整理的话，应该会比较容易忘记。
    个人建议在阅读这套书的时候，每天晚上都要在笔记本上做一下总结。对于笔记，我最近突然想到的一种方法。(这里强调一下，因为这个方法是我最近才想到的。目前还没有经过足够的检验和分析，所以可能会有一定问题。所以只是提出来供大家参考一下)：
当你每天读完这本书的一部分内容之后，当天晚上，你可以在书本上找出你今天度过的所有定理、定义、引理、推论，并将他们记录在自己的笔记本上。
记录完之后，你可以在睡觉之前将他们复习一遍。复习的时候，若是遇到定义，你只需要简单地看一遍就好。除此之外，若是遇到定理、引理、推论，你不仅要仔细看一遍，你还要在心底将它们证明一遍。(如果你已经真正 "" 理解 "" 了一个定理，你应该可以在不依赖书本的情况下，独立将这个定理证明出来。所以这一个步骤考察的就是：你是否真正理解了书上的每一个定理。)
第一天复习完后，第二天可以再复习一遍，一周后再复习一遍，一个月后再复习一遍，一年后再复习一遍。
    方法不一定适合所有的人，需要自己去参考、修改和取舍。
  《复变函数论方法》
    
拉夫连季耶夫
的这本复变函数论方法应该不是写给初学者的。本书的第一章和第二章用了大量总结性的话语、大概150页的篇幅讲完了本科阶段复变函数的所有内容。第三章以后的内容便讲得比较详细。一开始我是打算将这本书当复分析学的，学了差不多一半之后，才发现它教的并不是复分析，而是偏微分。之后由于各种原因，这本书大概读到334页的时候我便停下来脚步。
  《实变函数论》
    那
汤松
的这本书是别人怂恿我读的。读完之后，感觉是帮你构造了一个和数学分析截然不同的体系。这本书文字比较通俗，难度不是特别高，但是相应的，知识容量相对较低。书中有很多很有启发性的证明思路，也有部分思路不是特别严谨。不从专业角度评价，仅从一个计算机本科学生的视角来看，推荐每一个有兴趣的大学生读一读这本书。
  《Fourier Analysis》
    这是我读的第一本英语数学专业书。Stein的这本傅里叶分析适合每一位想要初步尝试数学英语阅读的学生，因为他在这本书里的用词比较简单，句式比较单一，更容易让人理解。另一方面，这本书的内容并不难，你只需要数学分析的基础便可以阅读，知识点含量也不高，读完之后比较清爽。只不过他的有些证明。。。我后来发现是错的。。。
  《离散数学及其应用(第七版)》
    将所有内容全部看了一遍。相对于其他数学书，这本书比较像小说。。。所以读起来比较流畅。书中存在一些翻译错误，以至于在你阅读的时候，你会发现某些地方作者想要表达的意思有些前后矛盾。不过这些错误的影响也不大，因为你只需要联系前后文便可以将作者想要表达的含义猜测出来。我唯一感觉到遗憾的是，没有将每一章后面的习题做完(甚至许多章节的习题根本没有动过)。
  《算法导论(第三版)》
    算法导论读了两个学期，断断续续读了大概400多页。习题也做了大概70%的样子(只是这400多页的习题)，之后200多页的内容因为已经超出了本科的界限，而我当时又不是很想读(这是有原因的，因为我当时有点急躁了，后面会说的)，所以就先放在一边了。个人实际情况是，除了基础内容之外，习题里面的内容基本都忘了，但是做题所锻炼出来的能力似乎不会被忘掉。可能这本书的作者一开始的目的并非让你去记住习题里面所涉及的内容，而是希望教授你研究算法的能力，让你以后在遇到新算法时，可以迅速掌握并把握核心。
  《模式分类(第二版)》
  这本书对基础的要求比较高。由于我缺乏一部分前置知识，所以刚开始读的时候有一些吃力。不过通过在网上查询部分资料，最终还是学完了大概70%的内容。全书讲得比较详细，内容范围也比较广，但是总体深度却不是非常深，所以只能当作一本入门书籍观看。相应的，作者在每个章节的背后都提供了一些推荐的深入读物。这本书是我所读的第一本模式识别的书籍，基本上将之后我所见到的大部分机器学习算法都讲了一遍，所以对我之后的学习帮助非常大。
  《Pattern Recognition and Machine Learning》
    听别人说这本书是机器学习三圣经之一，所以便买了回来。只不过国内貌似没有引入，所以在淘宝上买了个别人的翻译版(不好意思。。。)。不得不吐槽的是，马春鹏先生的翻译版里面有很多的错误，比如说“ reinforcement learning ”应该翻译成“ 强化学习 ”，书中却翻译成了“ 反馈学习 ”。本书的内容具有偏向性，和《模式分类(第二版)》的全面性不一样，这本书的内容更多的偏向
贝叶斯学派
，内容上也讲解地更加深刻。同样也是读了大概70%的内容。
  《统计学习方法》
  因为之前的一本书更多地是偏向贝叶斯学派，所以我买了一本内容偏向统计机器学习的教材。
李航
老师的这本小蓝书比较轻巧(我怎么感觉我像是在打广告。。。)，知识含量没有之前两本那么多。在读这本书的时期里，我也是将其随身携带(毕竟挺方便)，可以随时阅读。可是在内容深度上，我觉得没有《Pattern Recognition and Machine Learning》那么深。
  之前有过一段反思，我认为这个学期我有点过于急躁了。事实上，因为过分地急于攀登数学地科技树，我已经很久没有感受到那种数学所给我带来的美感了。如果我丧失了对数学本身的喜爱，我又能走多远呢？另一方面，我所感觉遗憾的是，由于我太急躁地看书，这些书课后的习题我也没有做完，事实上做题不仅仅是一个深化知识的过程，也是一个利用自己所学的知识进行探究的游戏过程，逃过它们会损失一大乐趣。这是我应该反思和改正的。
  不用过于急躁地去学习新知识，我之所以读数学，很大一部分原因是因为我本身就喜欢数学。我之前所读过的数学经典――《
微积分学教程
》、《代数学引论》等等，它们大都像是一件被精雕细琢的艺术品，值得每一位读者去细细品味。我想，也许下一个学期，我可以将这些数学书再读一遍。不是为了学习知识，而仅仅是为了享受这种乐趣，感叹作者巧妙的思维。另外，下一个学期我打算在计划里面增加一些计算机方面的书籍(我可能快要忘了自己不是数学系。。。)，毕竟作为计算机系的学生，基础知识还是要打牢的。
  最后，共勉！
大二上学期：
  书都放在学校了，但是现在学校不能进去，只能等开学后再去学校拍照写总结
写在最后：
这篇文章不会再更新了，因为以前的自己真是太傻了。人生不是只有学习的，人生除了学习之外，还有很多很多的东西――爱情、友情、好吃的食物、好玩的游戏、好看的风景等等。
整个大学下来，我看了很多领域的相关知识，有心理学、哲学、数学、计算机科学、物理学、神学、历史学、生物学等等。我还学会了弹奏一门乐器、烹饪二十四种湘菜、学会了素描、速写、学会了健身等等等等。我深深地感觉到，人生其实可以很精彩。我曾经一门心思放在计算机和数学上，最后还是知识与思想改变了我，让我看到了更多的东西。劝勉每一位看到这里的人，如果有时间，不要过多地花在娱乐上。去关注自己的教育吧，人生会因此而具有更多的可能。
还有很多话想要分享给你们，可是我得先走了。我的人生还有很多东西等着我呢。","这问题让我想起大学同年级的大神，女的，所以是女神，真的是神，看起来普普通通，但是无论考试、编程、实践项目都比别人要强。
我觉得她学习的方式就是――废话少，专注。
别人还在浮躁地扯什么语言好什么方式不好的时候，她就不声不响把所有语言都学到精通了；别人在权衡课内课外生活如何均衡，她就专心把课程学得烂熟然后自然去学更高阶知识。
我真心佩服的人不多，她是其中一个。","本科四年完全荒废，双非学校读研期间疯狂学习计算机基础知识
凭借自己过去一年间的不断坚持和努力，在
没有任何大厂实习经历的前提
下，成功拿到
字节跳动SP、华为、百度、农业银行
等大公司的校招offer，年薪基本都在
25W+
，最后去了
字节跳动
了。
字节录用函
甚至后来还非常荣幸受邀去
牛客网
做了
计算机校招分享直播
。
宣传平台
嘉宾，也就是我啦 哈哈
你是不是觉得我的经历挺
曲折丰富
的？
其实我一点也不想有这样的经历，因为最宝贵的大学四年时间都被我浪费过去了
。
作为一名即将毕业的研三老学长
恨不能早点看到前面那些大佬们的回答
，这样也能早点被点醒，这样也不至于到今天！
作为一个农村出来的学生，今天我写下自己的
经验教训和总结
，希望能为后来学习计算机的学弟学妹们留下一点财富！
这就是我家后面的景色，一个十八线小地方
希望你们的大学四年过的
足够充实，而不是像我那样白白荒废四年
。
1、首先，为什么说学习计算机是我们这种大多数农村普通孩子最好出路了？
19世纪虎门销烟的林则徐被誉为“中国睁眼看世界第一人”，几百年过去了，我们睁眼看看现在的事业单位招聘环境吧。
黑龙江地方招聘信息，图片来源于网络 
黑龙江地方招聘信息，图片来源于网络 
招的是什么？
你没看错，全是计算机！
你在报考事业、国企的时候，一些垃圾专业
只能选择乡镇三不限
，上岸分数比省州任何限制专业的岗位都要高。
但计算机在军队文职，事业单位，公务员招聘依然吃香，可以说秒杀一大群专业，在军队文职中尤其如此。
你学金融？
没有985 211的学历，门槛就把你卡死了。
再来看看最新一年的互联网校招薪资吧，作为一名刚刚经历了校招的计算机专业应届渣硕可以很负责任的告诉你，图中薪资基本是对的。
可以看出来薪资是逐年递增的，而且越增越多.....
如果我当初学的是金融专业，以我
普通双非学校
的学历，连金融公司的简历都过不去吧。
对不起，我拉知乎后腿了，在清北满地走，985遍地跑的知乎，我可能是最底层的那一类人了
所以为什么不学计算机呢？
其实最重要的是计算机真正爽的并不是它的高工资，而是计算机专业投资与回报有着极强的线性性。
计算机由于大部分相关公司不存在过多的固定资产，起码起点收入就高，而且这行由于开源，是很容易获取到技术的学习路径的。
换句话说你付出多少，会多少技术，就能获得对应的收入，这点比其他行业好多了。
行，你就上，不行就一边去！这真的已经很公平了！
计算机行业是
真的凭本身吃饭
，你投入多大的努力就能获得多大的回报，有多大的本事就有多高的工资。
在我自己学习计算机的过程中，一直保持着学习，不断扩充知识面，坚持给自己充电，不至于被倒挂，平时看书的时候会去网上买书，但是那些书太贵了，所以就收集一些电子书来看。
后来也慢慢的养成了收集书籍的爱好，再加上前段时间从一个电子书网站上收集到很多的计算机经典图书PDF书籍，网址是这个：
https://www.
pdf246eook.com
，貌似现在已经停服了。
不知不觉间我已经收集
超过 1000 本，
吓了一跳！！
现在
已经分享在github上
了，这可能是
整个GitHub上最全的计算机经典PDF仓库
了。
其中涉及C/C++、Java、Python、Go语言等各种编程语言，还有数据结构与算法、操作系统、后端架构、计算机系统知识、数据库、计算机网络、设计模式、前端、汇编以及校招社招各种面经等~
这可能是整个GitHub上最全的计算机经典PDF仓库了。
地址1：
https://
github.com/forthespada/
CS-Books
（如果由于网络等等因素，如果不能访问可以尝试地址2） 
地址2 ：
https://
gitee.com/ForthEspada/C
S-Books
其中涉及C/C++、Java、Python、Go语言等各种编程语言，还有数据结构与算法、操作系统、后端架构、计算机系统知识、数据库、计算机网络、设计模式、前端、汇编以及校招社招各种面经等~
反观别的行业，你不仅仅需要努力与专业素养，你还需要所谓的
机遇，贵人，关系，人脉，情商
等等。
 还有一些人在说
计算机35岁危机
之类的话。
其实任何一行，比如土木 律师 金融 医生，如果35岁还在干25岁的活，不光计算机有这个问题，基本都有失业的风险。 
35岁中年危机永远是咱们大多数人要面对的
。除去类似医生这种大后期职业，相比其他行业，计算机的35岁并不算什么大坎，毕竟起点高。
收入就算下降也能轻松足够正常家庭生活和结余了，更不提之前高收入的存款了。
最重要的是我不仅自己学了计算机，我还
劝自己的表弟去学习计算机
，他今年大二，在
河工大
读书，去年我让他从通信转到计算机来了。
现在手把手的在教他学习，
不让他走一点弯路
，那些弯路都是我走过的啊。
说白了，计算机给如今我们这样的农村孩子一个出人头地、在大城市里安身立命的机会，还不赶紧抓住？？？？
所以说一句，
计算机是一个努力可以改变命运的专业毫不为过。
说句夸张的话， 
进可入大厂年薪百万，退可考公一堆好岗位
。
对了，如果你也是跟我以前一样，现在还在学校里读书，并且是打算在毕业后直接参加工作的话，
那么不妨看看下面这篇文章
。
这篇文章会告诉你如果打算毕业后找工作，那你应该准备些什么，需要提前做哪些准备，也会
安利一个很好用的网站，是纯免费
的，可以说每一个计算机专业打算找工作学生的福音。
这个网站主要是帮助应届生求职的，有笔面经、校招信息、大厂真题、各岗位练习题、还可以直接投递简历，都是和企业合作的，跟官网投是一样的，据我所知这是是现在校招网站做的最好的了，所以信息更新的非常快，里面有笔面经、校招日程、各种内推码以及很多大厂真题和练习题。
最重要的
他！是！免！费！的！
2、本科四年，我踩过的坑、走过的弯路
1、过早接触“高大上”的东西
我是 
2013
 年上大学，大一下，也就是 
2014
 年四五月份的时候，大一学期结束了。这个时候有一个学期课设大作业，我抽到的是供货管理系统。
当时我太稚嫩了，嫩的能掐出水，压根不知道 
XX管理系统
 就是大学里经久不衰的课设作业、甚至是毕设选题题目
当时我一点思路也没有，也不知道网上
XX管理系统
 的资源多的是，唯一能想到的，也是唯一能抓住的稻草就是图书馆。
我们学校图书馆不小，我也不知道这个
供货管理系统
该用什么技术实现，也不知道该翻哪一类别的书，我从自然科学类目里慢慢找、慢慢翻，最后终于在一本《
C#入门到精通
》里找到了类似的样例。
当时真的是
喜获至宝
，回去手把手得抄了下来，又改了改，最后交上去了，成品最后就是下面这个。
登录界面
运行主界面
这个窗体程序对于14年，刚大二的我来说，太
高大上
了，当时觉得很厉害，我居然也能做出来一个
Windows
下的窗体程序
那个时候计算机还不像2021年现在这样火爆，网上资源也没有现在这么多。
当时觉得自己做出来了一个
宝贝
，在后面的大二下的「Windows课程设计」、「大三上的C#的程序设计」、「计算机结课大作业」、大三下的「程序设计实践」中我都在这个
供货管理系统
的基础上进行魔改，改头换面成了
学生管理系统
、
图书管理系统
、
小商品销售管理系统
等。
这一些系列的愚蠢行为导致我在接下来的大学学习过程中不思进取、止步不前，
只会躺在以往的""功劳簿""上吃老本....现在想想真是应该给自己一个大耳刮子。
真的要保持学习啊！！！
带给我的教训
对于计算机行业从业人员来说，不往前走，那就是后退。如果你想学一门可以吃到老的技艺，那你不适合计算机这行。
前段时间的某天我突发奇想，想看看
知乎上计算机领域内评分最高的Top 20 经典书籍有哪些？
分别抓，哦不，
手动
收集了知乎计算机经典图书推荐问题下的高赞回答后得出的
好书集锦，
选择标准就是每本书都在推荐版上出现过 
5
 次及其以上！！
最终将抓到进行数据清洗和合并，得到一份计算机领域类的书籍榜单！
说实话让我觉得有些意外，因为Python类和机器学习类书籍确实不少，不过
Top 3却是一等一的经典
！
就是下面这三本，现在免费分享一下自己以前抓到的
豆瓣上计算机领域内评分最高的Top 20 经典书籍
深入理解计算机系统
（原书第3版）
计算机程序的构造和解释
(原书第2版)
程序员的自我修养
: 链接、装载与库
2、在象牙塔龟缩不出
对于像我一样的计算机肥宅大学生来说，大学生活基本就是三点一线：食堂、教室、宿舍。
英语晨读社团？我不去！
羽毛球爱好者协会？没意思！
计算机实践基地？不去不去不去，老子不去。
虽然和室友们在宿舍待着很好，但是还是没有什么足够的意志力走出宿舍，去图书馆啃大黑书、技术书。
毕竟坦克世界太好玩了，直播贼有意思，电影美剧也太好看了（网站下载下来看）。
你看那些大佬们的本科时候，比我强太多了，都有很强的意志力走出象牙塔、走出舒适圈，让自己做感到不舒服的事，所以人家毕业后成了大佬，我本科毕业后成了菜鸡。
我本科时期
浪费了太多的时间
了！真的太多了！
带给我的教训
如果你在本科时期，觉得过的很舒服，那很不幸，你在浪费时间。
嗯，就是这么扎心，真正充实的大学生活应该是觉得很累的，而不是很舒服的
。
3、术业没有专攻
你知道我本科学过多少种语言吗？
6
 种！我会 6 种 
hello world
 的写法~
VB、C、C++、Java、C#
，甚至还有一门上古语言 
Pascal
，估计很多人都没听说过这门结构化语言 
Pascal
。
这是我犯的另外一个错误，乱花渐欲迷了眼，猪油糊了心。其实也不能怪我，本科学校也不咋的，是个辣鸡学校
本科学校什么都教，一股脑儿全塞给你，也不管你接受不接受的了。现在回头看来不过是为了完成教学任务罢了，对学生个人成长没啥好处。
带给我的教训
不管你是学习
 C++
也好，
Java
也罢，再不济学一下编程语言的新秀
Golang
也罢，专攻一门语言即可。
不要像我这样，
桃子也摸一下，杏子也舔一下，梨子也尝一下，最后什么也没学会
。
3、正确的大学四年应该如何度过
让你们看看我买的书，哎，花了好多钱了啊，你们可以不花这个钱的，去上面那个仓库就能免费白嫖书了，有用的话点个star哦，比心！
我的实验室一角
宿舍里放的书
大一，应该好好打基础
学什么？
好好学习计算机基础课程，比如
C语言、数据结构
等。
我知道大多数人大学第一门编程语言就是 
C语言
。
C语言是一门很好的编程语言，好好学习C语言有助于你以后理解计算机整个系统，阿秀学长这里建议学弟学妹们好好学习C语言这门课，下文推荐学习资料。
现在貌似也很多学校开始把 Python作为第一门学习语言了
多说无益，你来看看编程语言排行榜就可以知道了，C语言占据着毫无争议的第一名。
编程语言排行榜，图片来源于百度
至
于数据结构
那更不说了。
目前国内对于算法的考察有点到病态的地步的，面试必考算法、算法不过关基本
GG
，别扯其他的了，你如果想进
BAT、TMD、快手
这样的一线大厂，算法是你必须要好好学的一门课程！
说到这里推荐大家一份
算法学习资料
吧：
最强算法刷题笔记！谷歌大佬的100%打败600余道力扣的算法小抄，还能更强吗？
C语言怎么学？
视频
：这里我推荐
B站郝斌老师
的
《C语言自学课程》
，质量没的说。
是的，你没看错，足足
422W
的播放，质量没的说，C语言跟着郝斌老师，闭眼学就完事了。
那么书籍方面，
C语言
我推荐这三本书。
答应我，把你手中的
谭浩强
C语言放一边好吗...
推荐指数：
五颗星★★★★★
书名：
C和指针
理由：指针方面的经典好书，这本书覆盖了数据、语句、操作符和表达式、指针、函数、数组、字符串、结构和联合等几乎所有重要的C编程话题。而且每章后面有针对性很强的练习，附录部分则给出了部分练习的解答。这本书适合C语言初学者和初级C程序员阅读，也可作为计算机专业学生学习C语言的参考。
推荐指数：
四颗星★★★★
书名：
征服C指针
理由：C语言最为核心的点莫过于指针了，在一些大型项目里指针经常指来指去，多重指针容易弄得一些小白云里雾里不知所云，这本书是讲指针的经典书籍，笔者学习完后重新认识了指针，看完再不懂指针可以来揍笔者。
推荐指数：
五颗星★★★★★
书名：
C陷阱和缺陷
理由：这里搬运一段百度百科上的介绍和说明：“本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。全书分为8章，分别从
词法分析
、语法语义、连接、库函数、预处理器、可移植性缺陷等几个方面分析了C编程中可能遇到的问题。最后，作者用一章的篇幅给出了若干具有实用价值的建议。本书适合有一定经验的C程序员阅读学习，即便你是C
编程高手
，本书也应该成为你的案头必备书籍。”，从这段介绍中就可以感受到这本书的分量了。
数据结构怎么学？
数据结构与算法是相辅相成的关系
，学好算法有助于理解数据结构，学好数据结构也更有助于理解好算法。
对于经典的数据机构与算法大家都要掌握，对于一些常见的数据结构：树、链表、队列、栈、哈希表等要有一定的了解。对于常见算法如二分法、
贪心算法
、分治法、动态规划、
深度优先搜索
、广度优先搜索等要将思想学会，并且加以练习。
不得不否认，人都是一种
视觉动物
！相比较于自己去看书学习，人类还是更喜欢去听别人来给我们讲课，通过被动的形式来学习。
这里推荐一个比较友好的数据结构与算法的视频，我比较推荐的就是《
青岛大学的王卓老师的数据结构与算法
》
青岛大学王卓老师的课，也就是下面这个，可以看出全集一共 
173P
，我已经事先看过了，这个视频确实挺好的。
这个视频将
线性表、栈、数组、二叉树、图、哈希、查找、排序等
知识点从头都脚，掰碎了、揉开了，把每个知识点都给你讲清楚了。
不只是我推荐王卓老师的这个视频，同学们也可以看一下已经看过的那些人的评论，甚至还有人说“
这是他所能找到的全网最详细的数据结构与算法的教程
”。
还有以前的同学们看完视频做过的笔记，作为后来者的我们在看这些视频的时候，要记得
学会站在别人的肩膀上，利用好前人的总结和经验
，这都是别人的经验和结晶，能节省不少我们的学习时间的。
 这是王卓老师的视频链接：
至于
书籍部分
，我推荐以下几本书：
推荐指数：
四颗星★★★★
书名：
大话数据结构
理由：对于一些小白来说这本书是福音了，大话系列的典范之作。将数据结构中比较晦涩难懂的链表、树等知识讲得通俗易懂，对新手比较友好。有一定数据结构基础的可以忽略了。
推荐指数：
四颗星★★★★
书名：
啊哈！算法
理由：与大话数据结构一样对于新手比较友好，是一本很有趣的算法入门书，如果你有一定算法或者coding基础就不必看了。
推荐指数：
五颗星★★★★★
书名：
剑指Offer
理由：这本书不需要多做介绍，校招必备！可是还是要自己看起来、刷起来，不要放在那里吃灰，如果这本书上的题目你都没有做过或者也不会的话，算法这一关基本是送人头的存在了，阿秀学长在秋招过程中这本书看了3遍。
推荐指数：
五颗星★★★★★
书名：
挑战程序设计竞赛
理由：吹爆这本书！！！也是唯一一本系统看完的算法书籍！！这本书比
啊哈算法
算是进阶一点的算法书籍了，作者是ACM-ICPC全球总冠军，国内的ACM大神巫泽俊译的，汇集了世界顶级程序设计高手的经验总结，里面有很多题都是很经典的题目，比如有一题是两只蚂蚁相对运动就曾经出现在某算法平台的周赛中。看这书不能急，得慢慢消化。
大二，应该好好进阶
学什么？
大二是很关键的一年，因为很多学校都是在大二时期开始学习计算机专业的主要专业课程，比如操作系统、计算机网络、数据库甚至是计算机组成原理，而在
面试过程中问的比较多
的就是操作系统、计算机网络以及数据库了。
所以在大二时期应该学操作系统、计算机网络、数据库、以及一门主攻语言（C++/Java之类）了。
操作系统怎么学？
操作系统是一门在面试过程中问的不算很深的课程，因为这门课往下走的话深度太深，也不好展开，面试官不好尝试，甚至于一些面试官对于某些具体的知识点也不熟悉（大佬除外），操作系统必须深入学习，才能学明白学透彻。 
在工作中，如果能够深入理解底层技术，那么对于真实线上系统的稳定性是很有帮助的。在实际的面试过程中问的比较多的莫过于进程线程、死锁、虚拟内存等问题了。
视频推荐
南京大学
袁春风
老师的计算机基础课程一二三
（这三个课程很不错，看完基本对于计算机的了解就有了一个新的认识）
除此之外，我还推荐：
清华大学向勇老师的操作系统视频课程
，这个课程讲的通俗易懂，十分不错。
这里主要推荐几本我看过的
操作系统书籍：
推荐指数：
五颗星★★★★★
书名：
深入理解计算机系统
理由：被誉为“和金子一样重要的计算机基础书籍”，就好像学霸考试只能考100分是因为试卷只有100分一样，这本书推荐指数为五星，那是因为最高就是五星了。这本书十分经典，每一次看都会有新的体会和感悟，这本书从程序执行的计算机角度开始，介绍了处理器的体系结构、程序的机器级优化、虚拟存储器、系统级IO、网络通信等等多个方面。还有一点就是不要放过课后的各种Lab，这里推荐大家和 
MIT6.828
以及
CMU 15-213 CSAPP
 这门课一块看。
推荐指数：
五颗星★★★★★
书名：
现代操作系统
理由：同样是讲操作系统的一本好书，《深入理解计算机系统》有些操作系统的知识讲的比较泛没有这本书细致，如果赶时间的话可以把这本书中进线程、死锁、缓存等重要知识点先看一下，后续有时间了再补上其他章节。
推荐指数：
四颗星★★★★
书名：
自己动手写操作系统
理由：很好的一本实践书籍，看这本书的前提是要有一定的汇编知识，如果不懂一些基本的汇编知识容易看的迷迷糊糊。本书亲自带你走一遍操作系统的具体实现，打造一个简易版的操作系统，我在学完汇编后花了二十余天跟着走了一遍，感觉很多东西豁然开朗了一样，值得一看！ 
计算机网络怎么学？
我个人学习计算机网络的路线是先看一些有意思的计网相关视频，然后从书籍入手，毕竟视频中的知识都是别人总结好又给你讲解的，自己在听的时候可能会觉得“嗯嗯，说得对，我也是在这么觉得的”。
可是临到自己实际场景中遇到了就会一脸懵逼，两手无措。只有自己亲自揣摩亲自动手实践得来的知识才是自己的，毕竟“
纸上得来终觉浅，绝知此事要躬行
”的。
这里也推荐一些不错的
视频
：
韩立刚老师的计算机网络视频
（韩老师的视频是计算机网络视频推荐的常客了，很多人都推荐他的视频，因为韩老师讲课很有意思。我当初在看的时候就咯咯咯笑个不停，在哈哈大笑中学到了很多知识）
湖大教书匠的计算机网络视频
（这个视频是这两年的计算机网络新起之秀，讲的也挺不错的）
书籍推荐
推荐指数：
四颗星★★★★
书名：
图解TCP/IP、图解HTTP
理由：日本人写的两本科普书，很适合计算机网络入门，书很小并且书中图画很多，看着有300多页挺多的，其实没有多少内容的。看完这两本书对于场面的秋招面试题都能够答得上来，但对于一些细节问题还不太够比如TCP中的滑动窗口、拥塞避免等还是需要看别的经典书籍加以补充。
推荐指数：
五颗星★★★★★
书名：
网络是怎样连接的
理由：强推！同样是日本人写的一本书，本书紧紧围绕一个问题：输入一个URL，按下enter键，直到我们在网页端看到请求的内容，这中间发生了什么？这本书抽丝剥茧般将这个问题逐步细化，亲手带你自顶向下的走完整个网页访问的过程。不可多得的一本好书！强烈推荐！
推荐指数：
五颗星★★★★★
书名：
计算机网络：自顶向下方法
理由：别的常见介绍计网的书籍是从底向上即物理层到应用程序介绍网络，这本书另辟蹊径，是自顶向下介绍整个网络的。这样做的好处是从我们所接触的应用层开始逐步深入，而不是从离我们最远的物理层开始。如果不是网络安全相关专业，大多数人看重点章节也就是第三章传输层那一章，重点看TCP/UDP的各种细节基本也够用了，剩下的可以后期再补，为自己节约时间。
推荐指数：
五颗星★★★★★
书名：
TCP/IP详解 卷1：协议
理由：确认过眼神，是经典中的经典，没错了。不过就是，emmm太厚了…阿秀学长买来翻了翻TCP/UDP知识点就用来垫电脑了…..对于TCP的各种机制介绍的很细致，看了之后对于TCP/UDP感觉明显上升了一个台阶。如果不是信息安全、网络安全相关岗位的，可以作为一本工具书来使用的，需要用到某些知识再来补就行。
数据库怎么学？
数据库在校招中考察主要就是三种形式：
1、SQL语句考察 2、MySQL 3、Redis
对于
第一种考察形式
，也就是SQL语句考察，比如给你一个学生表、一个课程表、一个成绩表，让你统计出选了XX课程的前十名学生的情况，这是比较常见的SQL语句考查形式，主要会涉及到嵌套子查询、左连、右连等知识点。
对于
第二种考察形式
，也就是MySQL的考察，主要问你一些关系型数据库的问题，比如:
数据库ACID是什么？分别代表了什么？哪个是终极目的？如果缺少A会出现什么情况？如果缺少C会出现什么情况？
一条SQL语句执行的特别慢，会是哪些原因？如何去修缮它？
你了解哪几种常见的数据库索引？
数据库底层为什么要用B+树而不是
红黑树
呢？B+树比其他的数据结构有哪些好处呢？
缓存一致性你知道是什么吗？为什么会出现缓存一致性？
数据库
第四范式
是什么？？BC范式代表了什么？
....
校招过程中
MySQL
考察常见问题有很多，以上是几个比较典型的。
针对
第三种考查形式
，也就是Redis，问法就更多了，我随便列举几个：
Redis为什么这么快？
Redsi底层的五种数据结构是哪五种？
跳表，你知道吗？是如何实现的？有哪些好处？
缓存击穿、缓存穿透、缓存雪崩分别是怎么回事？
AOF、RDB持久化分别在什么情况下适用？
....
这些都是很常见的Redis问题，需要你好好去理解MySQL和Redis相关的知识点，这里我主要推荐一些不错的网络资源。
书籍推荐
：
推荐指数：
五颗星★★★★★
书名：
MySQL必知必会
理由：同《图解HTTP》一样也是袖珍型书籍的典型代表，书虽薄但是很经典，是一本很小的小册子，笔者当时不到一周就看完了，看完基本的SQL语句没什么问题了。需要注意的是千万要记得自己手敲一遍其中的SQL语句，要实操才能理解的更深。
推荐指数：
五颗星★★★★★
书名：
Redis设计与实现
理由：Redis方面的好书，算是Redis入门资料吧，认真看完的话就对Redis的五种数据结构以及缓存等常见问题有大概了解了，包括其中的底层数据结构，其中的跳表需要特别注意，是Redis面试知识点常问之一。Redis在如今的互联网中很多时候都充当缓存中间件来使用，其中有不少设计很巧妙的地方，推荐推荐！
推荐指数：
四颗星★★★★
书名：
Redis实战
理由：Redis系列的第二本书。前一本书偏向于理论讲解，这本书偏向于实战讲解，学了不能就完事了，毕竟还是要实操的，不能只停留在理论层面上，书中除了通过一些实例讲解了Redis的用法，还讲述了一些Redis的优化方法以及扩展方法，确实不错！ 
推荐指数：
四颗星★★★★
书名：
高性能MySQL（第3版）
理由：首先肯定这是本经久不衰的数据库方面的好书，但是，也是真的厚，垫书桌都嫌厚的那种厚度..笔者买来只看了其中的索引以及优化两章，对于常问知识点有个大概了解后就放一边了，在面试过程中够用了，其他的后面再说，哈哈。
推荐指数：
四颗星★★★★
书名：
MySQL技术内幕：InnoDB存储引擎
理由：作为MySQL内置引擎的InnoDB能够满足绝大多数情况下常见业务的需求，本书从源码角度带我们深度解析InnoDB的体系结构、实现原理以及工作机制，对于更好的理解MySQL有很好的帮助，如果你是数据库相关从业人员，更不能错过这本书了，相信这本书能带给你很多全新的认知！
C++怎么学？
C++的知识点比较多，也比较细，其实C++并不容易学好，如果你只是简单拿的学习一下语法比如for循环、变量类型之类的，那么一两周你就可以上手，但是如果想要学好C++还是需要持之以恒的coding。
我个人学习C++的方案是先看书，再实践，再看书，然后找一些优秀的源码阅读。
其实在自己的专栏文章中已经写过了，大家有需要可以去专利看，更加详细一些。
不断地坚持下去，
每当在看其他人的优秀源码的时候，觉得自己真的是太蠢了
，上辈子可能是只猪。下面推荐一下我看过的资料： 
视频推荐
我推荐的视频主要都是黑马机构的C++课程以及侯捷老师的视频，我就是看黑马机构的C++视频入的门，然后看侯捷老师的视频进阶。
B站黑马C++入门级视频：
黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难
这个视频可以说是
B站对新手最友好又不废话的C++教程了，简称我认为的B站最好教程
 ，不是我说的，是底下的人评论的，这条评论也有 2000多人点赞了 哈哈
这个视频相当不错，大概有314话，在最后也会教你做一个机房预约系统，而不是五子棋和贪吃蛇这种小孩过家家的玩具。
这位讲课的老师很有耐心，很会仔细的讲清楚课上的代码，不断地重复其中的一些重要知识点，如果你是个小白，你真的应该感谢在看视频初期就遇到这样一位仔细的老师，跟着多看几节基本自己都可以写出来了。
还有一点就是千万记得要自己动手敲，自己动手做而不是只看不动手写，一定要自己动手慢慢开始实践。
光说不做假把式，
眼睛看会了不代表你真的会
了。
总是有人问我该怎么开始写代码？
其实最开始不是叫做写代码，而应该是抄代码才是。
视频主要有：
01 - 侯捷 - C++面向对象高级开发（上下两部曲）
02 - 侯捷 - STL标准库和泛型编程、
03 - 侯捷 - C++设计模式、
04 - 侯捷 - C++新标准C++11&14、
05 - 侯捷 - C++内存管理机制_60_侯捷、
06 - 侯捷 - C++程序的生前死后
07、算法原理与实践（选修）
08、系统设计与实践（选修）
09 - 辅导课：
10 - 陈硕的 Linux CC++网络编程实践视频
本来这些视频在 B 站上都有的，但是 B站这段时间全部下架了，就很可惜。不过我以前下载过，放在在CSDN上了。链接如下：
侯捷C++系列视频（STL标准库与泛型编程、C++新标准C++11&14、C++内存管理）、陈硕Linux C++网络编程实践视频
书籍推荐
推荐指数：
五颗星★★★★★
书名：
C++ Primer 5th
理由：我愿称之为C++圣经，这本书对于有一定C语言基础或者有其他语言基础的人来说是最好的入门书，没有之一！大概800多页，笔者前前后后读了大概两遍半，建议至少通读一到两遍。如果你能够将这本书吃透，那么下面的《Effective C++》你看的就会非常轻松了。
推荐指数：
五颗星★★★★★
书名：
STL源码剖析
理由：C++大师侯捷老师的经典之作，源码方面的好书！虽然里面的很多知识已经不再适用如今的C++11 甚至C++17了，但是我们所要学习的是设计思想，对于其中的两级空间分配器，vector扩容，map/set底层等都是面试时常问的知识点，笔者看过两遍，现在还偶尔会翻翻，建议放在C++Primer这本书之后，有过一些coding经验后再去看。
推荐指数：
五颗星★★★★★
书名：
Effective C++
理由：C++是一门很严谨的语言，这也导致了如果出错bug也是不好找的，当初看这本书的时候，笔者一遍一遍的刷新对于C++的认识：这居然可以？这居然不可以？？这居然会报错？？有不少内容与C++ Primer 5th那本书是相同的，可以在看完C++Primer后再看这本书。
推荐指数：
四颗星★★★★
书名：
More Effective C++
理由：同Effective C++一样，也是一本会揭露一些你不容易察觉到的会犯的一些错误，可以再看完Effective后再开始看这本书。
推荐指数：
四颗星★★★★
书名：
深度探索C++对象模型
理由：这本书会帮助你对虚函数有一个全新的认识，虽然网络上有不少类似的讲解虚函数的博客，但还是建议同学们自己看一下其中的虚函数那章，看完可能会忘，得多看几遍。面试过程中问的也基本只有虚函数，其余章节可略看。
Java怎么学？
虽然我并不是Java技术栈的，但我查阅了很多资料，这里简单给大家推荐一些不错的可以白嫖的视频和书籍。
不知道大家的学习计划是怎么样的，我比较喜欢先看视频入门学习，然后再自己慢慢看书，最后看一些博客加深印象，查漏补缺。
视频推荐
尚硅谷_Java零基础教程-java入门必备-适合初学者的全套完整版教程(宋红康主讲)：
黑马Java基础就业班-2020最新idea版（完整带资料）
北京尚学堂高琪（推荐）
书籍推荐
推荐指数：
五颗星★★★★
书名：
Head First Java 第二版
理由：趣味性十足的一本书，在如今这个快餐时代，没有多少人愿意读一些大黑书，特别是机器工业出版的那些书籍。。。这本书可以说是图文并茂做到了极致。
推荐指数：
五颗星★★★★
书名：
深入理解Java虚拟机
理由：
周志明
老师的这本书还需要介绍吗？你如果没听过这本书，那你一定是个假的Java程序员了，这本书被无数Java开发者认为是Java领域内的必读经典书籍和畅销书。
推荐指数：
五颗星★★★★
书名：
Spring实战
理由：这里借鉴一下豆瓣的介绍语：“ 本书从核心的Spring、Spring应用程序的核心组件、Spring集成3个方面，由浅 入深、由易到难地对Spring展开了系统的讲解 。本书适用于已具有一定Java编程基础的读者，以及在Java平台下进行各类软件 开发的开发人员、测试人员，尤其适用于企业级Java开发人员。”
推荐指数：
四颗星★★★★
书名：
Java并发编程实战
理由：这本书主要介绍了Java线程和并发编程的点点滴滴，Java是做高并发一大利器，这本书也完全可以作为你的Java并发参考手册。需要提示你们的事，这本书很厚，确实很厚，而且并发编程本来就比较难，所以还是要做好准备的。
推荐指数：
五颗星★★★★
书名：
深入分析Java Web技术内幕
理由：这本书想很像一个大纲，会囊括很多知识，比如计算机网络、数据IO、虚拟机以及一些容器，适合作为一个不错的指引路线，但是只是过于分散，单页不妨碍它成为一本好书。
好家伙，已经 
14,549
 个字了，不写了不写了。
大三大四部分先保留
，今天就先写这么多好了，以后有空就写一些
研究读研、简历撰写、校招求职、面试窍门
等部分好了，坚持将此贴更新下去。
艾玛，码字太累了，
各位彦祖亦菲们，
如果我的上述回答对你有所帮助的话，帮
@阿秀学长
点个赞吗，感谢！"
,,,,,,,,,,,,,,,,,,,,,
你的编程能力从什么时候开始突飞猛进？,None,"百度多了
你就明白：它也许有用，但它封印了你精进计算机英语的机会。
Google多了
你就明白：各地大佬们的文章很Nice，但它们仅是你技术知识体系的精华补充。
开始读书了
你就明白：你以往东拼西凑几十篇烂文才明白的事，书上那几页纸都写着，而且详细的很。
接触到国内外大社的经典书后
你就明白：那些烂大街的21天宝典，7周速成，都是些什么玩意，误人子弟！
图灵牛逼，动物牛逼，Manning牛逼。
好书读多了
你就明白：技术是一环扣一环的，有牢固的技术知识体系，学啥都事半功倍。
多做业务
你就明白：所学的技术该用在哪。
多做用户量大的业务
你就明白：光会用技术，和用好技术是两码子事。
多找第三方开源
你就明白：原来工作摸鱼不是梦。
太随便用第三方
你就明白：某天需求一变，它兼顾不到，可以把你往死里坑，坑到你得去看源码。
第一次看完源码
你就明白：开始还是很讨厌的，等全盘搞明白了，发现“咦~有点意思”。
源码看多了
你就明白：自己的
查克拉
莫名的增多了。而且吐槽文档不全的习惯也渐渐少了，一个不服就跑去观摩别人的源码，顺便偷个师。
再往后，或许你的技术确实突飞猛进了，然而你却只会觉得编程本来就是这个样子的。
因为，但凡通过点滴付出，累积出来的结果，都是平淡无声的。
突然获得这么多支持，十分感谢大家。
知乎就是师兄的心得记事本，喜欢的可以
关注
哦~
「卫星｜ktshixiong，深度职业规划＋」
关于书籍的推荐，师兄挑几本常看常新的经典
一、新手进阶，可看
《
重构 改善既有代码的设计
》
本书的优点：
篇幅短小，示例经典，讲解细致。最重要的是新手读起来不费力，可以作为长久阅读的床头书，开卷必有益。
本书的作用：
帮助你学会如何写出有层次的好代码，让你在工作中赢在细节，更容易获得有实力的前辈的认可，职业发展更轻松。
二、寻求职业长久发展，可看
《人月神话》
本书的优点：
偏重于讲述编程哲学，几乎无代码阅读成本，笔者像一位睿智的导师，以亦师亦友的口吻，有条有理地为你分析各种项目问题，分享各种工程与人的权衡，还有可靠的处理准则，有志于在编程事业上长久发展的朋友推荐阅读，可以少走很多弯路。
本书的作用：
主要是打开你规划工程的格局，次要是积累行业谈资，一石二鸟
《UNIX环境高级编程》
本书的优点：
就是全书都是优点，UNIX作为经典中的经典，它的设计理念，基础功能的实现方案，都是值得熟透于心中的，无论往后有多少新系统，最底层的东西都是大同小异。书的内容量大，适合长年小口啃。
本书的作用：
打牢基本功，基本功是你技术高度的基石，永远要记住这一点。
广告
《UNIX环境高级编程》
京东
￥147.10
去购买
?
此外，不要局限于自己是什么IT岗，只要能帮助你积累优秀的技术思维，好资料再多也不嫌多，职业路走宽了，在IT行业，你什么时候都能走得雄赳赳气昂昂。
更多优秀技术书籍，请看师兄这篇新文章就够了
适合程序员入门与进阶，阅读目的都有说明
→ （持续更新）
相关 IT 高赞干货：
师兄总结的一波行业经验（精华版）
→ 
师兄多年来对编程的小感悟
→ 
→ 
师兄谈自学编程的小心得
（带过 10 来位新人入行的经验）
→ 
→ 
师兄关于职场的经验分享
→
以下为冷门，但我自己很喜欢的知识点。
师兄讲编程的难，有趣又真实得心痛
→ 
师兄实践了多年的
自律方法论
→ 
师兄关于优秀书籍的分享
→ 
最后，
还是万分感谢大家的支持^_^。
 ","update:
评论区很多学弟学妹要求整理一个学习路线，刚写了篇文章：
从小白到后端工程师的自学之路 - MutexLock的文章 - 知乎 
https://
zhuanlan.zhihu.com/p/13
0364187
---------------
在啃掉一本本计算机经典书籍和写下大量代码以后。
疫情原因回不去学校，作为一个马上毕业，即将入职腾讯的大四生，分享一下自己的学习历程吧。
本人在大学之前从未接触过编程，最开始的编程学习还是在高考完后，从书店买了本
C Primer Plus
，然后暑假开始啃，前前后后也就看了几十页。
大一上的时候，来到了华中师范大学，还没有转专业到计算机，一直在自学C语言和看一些计算机入门书籍（编码、
计算机科学概论
）。当时也很迷茫，不知道以后道路如何，所以也学了一些杂七杂八的东西（前端 python啥的），所幸的是，当时坚持把C Primer Plus结结实实地精读了一遍，而且几乎练习题都做了，算是比较好的开端。
大一下，转专业到计算机了，开始自学数据结构，算法和C++，部分看完了 数据结构与算法分析，并且把书上的数据结构实现了一遍，记得当时五月份给自己的flag是看完
C++ Primer
，然后每天上课看，晚饭吃完后也跑去七号楼刷书，最后囫囵吞枣似的看完了大部分。
大一暑假，txr大佬 
@杏仁糖
 给我说他面试通过了华科的联创团队
Unique Studio
，而且给我说他们团队都特别厉害，有些人在军训的时候就把C++ Primer给蹲着看完了，当时十分钦佩，幻想也能够进入贵团队。于是打算在大二上的时候，去报名他们的秋招。所以，那个暑假在学校自学，呆了五十多天。最初，拿起一本
APUE
，看了一章后感觉看不懂又放下了。然后，又拿起一本红色封面的算法第四版，这本书看完了，并且用C++把上面的算法都实现了一遍。另外，听知乎大佬说
CSAPP
是必看的神书，当时也懵懵懂懂地看了前面三章，做了lab。为了学习linux，还看了一本叫
linux命令行大全
的书。武汉的夏天很热，只能寂寞待在宿舍的我，打开了
LeetCode
的世界，写了一百多道题。
大二上，十月，忐忑迎来了
联创
的面试，前面两轮都过了，直到其特色的“熬夜测试”环节，因为实力不足+精力不足，测试败北，没有通过。清晨七点，在回学校的公交车上思考自己不足，总结是知识体系仍然不够完全，而且深度也不够。后来这个学期有点“误入歧途”的意思，入了
Machine Learning
的坑，记得当时花了好几个月刷完
西瓜书
和吴恩达机器学习课程的讲义（真佩服当时的毅力，都是英文和公式推导），后来想了想，ML/DL这个东西有点玄学，于是毅然决定成为一名做工程的程序员。总的来说，虽然这个学期的时间都投入到ML的学习中，没有学习工程方面的东西，只有用python写了一点好玩的爬虫，但是给了我以后坚定走工程方向的决心吧。
大二下，这个学期是打下计算机知识基础的关键时期。从知乎找了一系列书单，看完了CSAPP（做了lab，为了bomb lab还通宵了，强迫症想让自己把炸弹都拆了）、半本算法导论、
effective C++
、计算机网络系统方法（前三章）、部分TCP/IP详解等，做了一些项目，比如
正则引擎
（这个是参考了轮子哥的教程）等等，尝试写
JSON库
（未遂）。其实，因为学校只是一个普通211，找到好工作的学长学姐先例很少，一直是没有信心自己能去大厂，直到当时了解到myk 
@孟永康
 学长在春招收割了一系列offer后，才有了些许信心，相信自己如果能够像他那样努力，那么也能够找到好工作（感谢myk学长那时的鼓励和指导）。所以，定下了一年把自己水平提升到能够在大三下春招的时候拿下大厂offer的目标。
大二暑假和大三上也一直为这个目标奋斗，补上了APUE、部分UNP、深度探索C++对象模型、STL源码剖析、操作系统概念、操作系统真象还原、Linux
多线程服务端编程
、部分C++ template、部分C++ Concurrency in Action等书籍。然后，也一直没有放弃刷题，LeetCode写到了三百多道。同时也做了一些项目，跟着操作系统真象还原写的操作系统、简单的协程库，阅读了一些优秀的
开源项目
，SGI STL、muduo、libgo、
libco
等。中途还对haskell产生过兴趣，打印了一本
Learn Yourself
 Haskell For Great Good，看完后感觉坑太深，还是专注找工作吧，
haskell
对我一直都有很强的吸引力，但是这种也只能作为爱好吧。另外，编译器也是有这种魔力，看了部分编译原理（龙书）、部分现代编译原理（虎书）和部分
Engineering a Compiler
，多次尝试写自己的编译器，多次未遂（不过现在有空了，在补上之前的烂尾项目）。当年的笔记哈哈：
部分学习笔记
时间到了12月份，9号楼某个自习室内，txr大佬一直鼓励我去投简历找实习，本来我一直畏畏缩缩，对自己不太有信心，被鼓励后想着投就投吧。当时投了字节跳动和
momenta
的实习，面试都比较顺利，于是在大三上就在字节跳动开始了愉快的实习，比自己的计划早了大半年。当时为了准备面试，看了好多
牛客网
的面经，查漏补缺式地补齐自己的知识盲区。
大三下，基本都是在实习，学习了很多工程实践上的东西，接触了go的技术栈，并且对
devops
和软件工程方面有了认知，包括代码管理、发布流程、微服务啥的。然后实习的时候骑驴找马，找到了腾讯的暑期实习。因为这个时候没有了找工作的压力，所以开始学一些自己感兴趣的东西，包括Rust（至今水平还是不太行）、分布式系统（DDIA、MIT6.824等），零零散散学了点东西。
大三暑假，腾讯实习了两个月，开始学习
kubernetes
、各种中间件等实际业务用到的东西，这个时候就感觉拥有到扎实的计算机基础是最重要的东西。
最后，顺利拿到了腾讯转正和字节跳动的秋招offer，两家都给的比较高，选择了工作体验更喜欢的腾讯哈哈。
总的来说，学习计算机是需要积累的，花一两年时间啃下那些厚厚的经典书籍后，才能构建自己的知识体系，然后阅读大量优秀源码，做一些有趣的项目，编程能力就能突飞猛进啦。
现在回头来看，大学时光真是如此宝贵，这是人生中为数不多可以静心学习的一段时间，可以不用考虑任何其他事情，每天学习十多个小时。
部分藏书：","大概……是为了追女生而写了一个游戏的时候吧。
大概七年前，我为了追一个女生，以她和我为主角写了一个战棋类RPG游戏（其实还做了很多别的事情hhhhh），灵感来源于小时候玩的世嘉版《水浒传》。故事的背景是我大学，游戏名字叫做《
凌工路2号
》。
我一直都觉得，在大学，生产力的来源主要有两件事情：
deadline；
荷尔蒙。
这个游戏有对话系统：
有战斗系统：
有职业/升级/转职/职业相克系统：
职业/转职系统
职业相克系数表
有角色属性、物品、存档系统：
有剧情：
视频资源加载失败
视频资源加载失败
地图背景是我的学校
有作战系统和敌人的AI：
视频资源加载失败
故事的背景是我的大学，这是中心食堂和足球场：
看到这个毛主席像有人应该会觉得很熟悉吧
我甚至还在综合楼的自动售货机上做了一个物品买卖系统：
视频资源加载失败
这个游戏大概不到一万行
Qt
代码，没有用任何的框架和引擎，现在看来相当原始，所有的移动和动画效果都是用Qt的定时器+一堆if/else判断徒手撸出来的（当时不知道更好的办法，就这么一根筋地写了几个月）。我自己的感觉是，写代码超过5000行的时候，自己的能力会有一个飞跃――以前从没有注意过的东西开始觉得费解，从而逼迫自己思考和学习，然后进步。在我参加校招的时候，这个游戏的代码量占我当时的代码量的差不多一半……现在回想起来，我校招能进阿里，这个游戏带来的能力提升功不可没。
这个游戏没有最终完成，也从未发布，静静地在我的硬盘里躺了七年。
四年前我跟游戏设定的女主角结婚了。
这周二我无意中看到它，拿到现在的机器上重新编译通过。在吃晚饭的时候，我问她：
“你知道我当时给你写了个游戏么？“
她说：“不知道啊”。
代码在这里（我知道它很烂），遵守WhatTheFuckPublicLicense，随便修改：
最后放几个全地图的场景，如果你和我是一个学校的，会觉得相当亲切。不过，大部分的地图都不是我做的，我自己做了中心食堂、综合楼、研教楼、校医院、一馆五个场景的室内地图。
视频资源加载失败
视频资源加载失败
视频资源加载失败
评论区炸出了很多同道中人：
@杜凯
 说：
我去，天涯何处无知己啊，我做过一个类似的玩意 
http://www.
dklogs.net/xiaoming
@ Authur  说（at找不到这位老哥，刚刚at错一次）：
是rpg游戏。
还记得98年和曾经大学同学一起在dos下用
turbo pascal
写过类似的rpg游戏 红楼梦，扒的
剑侠情缘
的图片库（分析后发现都是去掉调色板头部的bmp图片），还自己做了地图编辑器可以编辑地图，背景音乐在dos单任务系统下是用中断来持续播放，640k内存不够用，还用到了高位内存和扩展内存，由于dos下声卡驱动问题，代码只能在寝室机器上运行，曾经学校软件大赛前把寝室电脑主机搬到网吧通宵撸代码调试，把门卫大爷还有网吧老板惊得外焦里嫩――没见过来网吧还自带主机的。后来幸不辱使命，参加大赛得了二等奖（因为学校评委说一等奖不能是游戏…）
往事历历在目，恍如昨日，但转瞬间已经二十载过去了，感叹…
如果赞能破万的话我就把可以运行的二进制版本release到
GitHub
上……","大学时浑水摸鱼，毕业后大约半年，在网络上寻找自学资料时，发现了
GitHub
和一些程序员论坛，自学了
py
，然后打开了新世界的大门。
包括购买了梯子，独自啃下两套纯英文官方文档，在GitHub上友好亲切的交流，刷题，看最新的软件工程实践书，等等
===========更新2：===========
一些人问
《哈弗大学幸福课》
在哪里看
我是在这里看的：
https://www.
bilibili.com/video/BV1G
s411o71d?p=1
其他的我不知道
=========== 更新 ============
断断续续的收到一些赞，写一些可能对大家有帮助的东西吧：
1、提高知识最好的途径是读书，包括但不限于计算机四大名著
《操作系统》
《计算机网络》《数据结构》
《计算机组成原理》
。经典书籍不仅仅有完善有效的知识，更重要的是这些书里的计算机经典思想，一直到现在都没有过时，十分的有用。
2、
Github
是个好网站，值得习惯性的到上面搜索需要的东西。比如awesome系列和一些质量很高的资料整理项目（整理常见的面试、刷题、常见工具链的git repo）
3、
v2ex
和知乎都是很好的网站（尽管审核方面被吐槽很多），论坛上有很多很厉害的大佬，关注认真答题大佬的动态对开拓知识领域是有一些帮助的。
4、善用搜索引擎（专指Google），最好能把自己最常用的工具的官方文档啃一遍。主要是习惯英文文档的表达方式+系统的认识自己所用的工具，对自己写文档也是有很多帮助的。
5、因个人有长期的抑郁经历，所以对心理方面关注得也比较多，十分推荐学习《哈弗大学幸福课》。这门课的综合内容十分丰富，实践性很强，能够有效的提高生活、职场中的软技能（沟通能力、抗压能力等）（这门课另外一个很厉害的地方在于，仅仅是上课的方式，也能提高你的逻辑思维能力，毕竟据说是哈弗学生选修最多的课，课程质量极其的高）。
6、有一个我自己打算做但实践得还不太好得地方：看经典
开源项目
得源码和架构。只看过一些小的玩票性质的开源项目，也学到了不少东西，大型的经典的开源项目还没能看（
STL
、Git等），这些项目对我来说主要是太庞大，时间上有些不够用。
7、最近在坚持做
Leetcode
每日一题，也推荐大家一起刷呀。保持手感，很多题看起来简单，但评论区也能看到有趣的知识。
8、关于职业规划这种事情，我以前是没有的（主要还是抑郁+低自尊影响的吧）。现在获取的信息太多太多，没有职业规划很容易被带偏。我是在做了长期的心理咨询+《哈弗大学幸福课》，工作、生活上都有一些经历了之后才慢慢想清楚自己将来的生活与工作要怎么打算。这种事情想清楚过后，做自己想做的事情目标会比较清晰，不会得过且过。
感谢阅读，祝好。","学了OO, 熟悉了“设计模式”, 领悟了
IoC
和DI, 让我大概感觉到了程序应该有一些结构, 而不是简单的把逻辑用
if-else
写进去, 这是我感觉自己能力提高的第一次飞跃;
看
SICP
和
CTM
让我开始理解程序和编程到底是什么, 特别是对CTM里的最小表达力原则的理解, 这是我编程思想的第二次飞跃;
学了
函数式编程
思想为我打开了另外一个世界, 引导我去了解
haskell
, 去稍稍的学习了些category theory(这个是真的难...), 这解放了我编程思想的另外一个纬度, 抽象能力有了质的提高(主要体现在generic programming的能力提高, 高级类型的灵活运用), 我开始有意识的去降低核心程序的""熵""(程序的可能性越多, 各种可能性的概率越均等, 熵越高), 使得程序更容易理解(熵越低信息含量越低则越容易理解), 而把系统的灵活性(比如状态, 
config
等)隔离在核心逻辑之外(这样使得变化可以在一个地方, 比如系统setup时, 集中理解, 然后用理解的setup来很简单的推理核心逻辑在这种setup下会怎样运转), 这样就使得程序的核心复杂度更加接近于核心业务的复杂度(业务的熵是本质复杂度无法用调整程序结构的方法降低, 但是, 本质复杂度也是可以降低的, 请往下看), 但是又没有写死整个系统的灵活度; 这是第三次飞跃;
然而, 最大的飞跃是当我最终把重点从编程本身转移开来之后
, 当我开始去看分布式系统算法, 去理解各种云服务的特性, 去深入了解我所工作的领域或者说业务, 去了解和我们组有关系的其他部门的业务, 去了解ML(由于业务相关); 去了解需求获取, 怎样拒绝不合理需求, 怎样调整和简化需求(降低业务本质复杂度的关键), 甚至创造合理需求，去了解测试, 监控, 部署, 构架, 运维,  项目规划和人员部署, 思考为什么junior SDE会犯错, 帮助mentor别人,  甚至开始关心组内的技术文化建设;
这是因为“编程是最重要也是最不重要的事”
这是因为编程作为把思维变为实现的这个循环的最后一步
(然后写好的程序会成为新的思考输入和基础，开始新的一轮迭代开发)，它和一个项目一个系统的
所有其他方面
都息息相关：需求获取，问题抽象，测试，监控，部署，框架运用，系统间集成，灵活性，未来拓展性，易用性，系统健壮性，多版本实验性，高层业务决策等等，这使得编程变得
无比重要
(所有的一切都需要编程来最终落到实地)，也
毫不重要
(编程被所有其他一切所约束和指导)。能够支撑这些所有上层思考的程序才是“好程序”，能够支撑所有这些思考的程序员，才是好程序员。学好/学会编程这件事是把所有需要思考的东西都弄明白都学好之后的自然结果。
而把这些思考留给别人，自己只做思维和程序的翻译器(区分创造者和工具人的关键)，根本无法写出好的程序来。这也是DDD(Domain Driven Design) 的精神之一 （
关于DDD的精神，参见此文的最后一段， 
阿莱克西斯：在做程序员的道路上，你掌握了什么概念或技术使你感觉自我提升突飞猛进？
 
）
以上引用出自
自学编程需要注意什么？
我觉得: 我们在积累技术能力的同时一定要开阔眼界, 这样才不会陷入一个""
局部最优解
"" (随便逮着一个点都能开阔人类边界的天才除外); 眼界太窄以至于学了一点点东西就觉得自己""天下无敌""了, 是我们进步的大敌 (也是曾经是我最大的敌人); ","回顾一下，我的技术能力（不仅仅是编程，而是
解决问题的能力
）的进步大约有几个重要的节点:
1. 刚入行时的入门练习题
这个是当年
狼厂
网页搜索部门的传统，不知道现在还有没有，入职第一个任务是完成两道练习题。一题是在Linux上用纯C（不许用C++，没有
stl
可用）完成一个多线程的网页抓取器，另一题是同样的环境语言完成2G大小的query（搜索查询词）的top100提取，有时间要求。
入厂之前我在Linux上没有写过代码。
两天时间从Linux基本命令的熟悉，vim gcc gdb的使用学习，从
malloc
和free开始搞内存管理，从0开始码
hashtable
(还得自己写hash函数），从
socket
开始实现http client和各种协议码解析，使用
pthread
多线程和信号量互斥同步，基本把操作系统计算机网络复习了一遍。
这两天把我四年本科三年研究生没搞扎实的工程基础全部补上了。
结论:有目的的练习，尤其是一个完整的应用问题的解决，是学习的不二法门。
2. 接手一个完整的模块（子系统）
搞完入门练习，leader过来跟我说：小胡，现在有一个重要的模块交给你，赶紧熟悉一下，然后完成如下功能升级。
这个模块是前厂存储网页的核心模块，在当年内存4g的奔腾主机上单机存储几千万网页，几台机器存下了当时整个中文互联网。支持高性能的随机存取和顺序读，可以说把机器性能压榨到了极致。
3w行，纯C。
啃了几天终于搞明白了结构，（多年以后我还得感谢
source insight
），同时也对写这个模块的大牛佩服的五体投地，为了压榨内存把每一个bit都物尽其用，各子模块之间的分工又是那么的优雅。
然后是上手改，看懂了之后功能升级很简单，只改了十几行代码，但上线的时候真是手发抖！
后来才知道这个模块好几个前任都没成功接下来就被fire了....
后来又经历了若干次升级，解决各种诡异bug（搞过高并发存储系统的应该知道坑有多深），编码和解决问题的能力突飞猛进。
结论: 学习系统设计的最佳途径是看一个优秀设计的源码，检验成果的方式是改造它应用于你的实际场景。
3. 接手一个完整的系统
搞定存储模块之后，我的下一个任务是升级喝扩展一个完整的抓取系统。
和入门练习做的抓取器不同，这个完整的抓取系统（又称
spider
）是工业级的，需要每天完成千万级的抓取量，还需要考虑并发压力控制，网页更新调度，垃圾网页处理，去重等等诸多现实的工程问题。
大大小小十来个模块，十来万行代码，大部分是C，还有接近一万行的
bash
脚本（用bash实现分布式的网页去重处理你信？）
这时会发现很多模块内部都有不少实现不尽如人意的地方，但是由于借口定义的好，模块直接容错性强，整个系统还是work的。
这促使我思考系统级的架构，最需要关注的重点是什么，良好的结构远胜于细节的雕琢。
大约小半年后，我对这个系统基本做到出任何问题能立刻反映到是那个模块出的问题，对问题的分析定位能力又上了一个台阶。
结论: 理解了接口定义和系统结构重于实现细节，就迈出了架构师的第一步
4. 设计一个完整的子系统
此时大概工作快两年了，原来的抓取系统有一个很大的问题，就是积累的网页数太多，更新资源分配不过来，导致系统中大量网页在互联网上已经404但仍然会进到线上被检索出来。我们称之为死链接问题
通过对死链的规律分析，我发现互联网上大部分死链存在站点或目录级聚集的现象，这个其实很好理解，一个网站无力维护了，自然就全部挂掉，目录级很可能是网站改版了，或者一个子频道关闭了。利用这个规律，我们可以大幅度降低死链检测的资源耗费。
在这个认识的基础上，我设计了一个独立的死链检测系统。上线效果很不错，检查死链的流量开销降低到原来10%，网页库中死链还下降了。
结论: 架构师首选要解决的是待解决问题的精确描述，和对问题域的分布规律的挖掘，然后才是结构设计。
5. 设计一个新的系统
 工作第四，五年间，hadoop在业界逐渐流行起来，基于Google三件套的设计，当年的hadoop最上层的table还很不完善，但是
mapreduce
和hdfs已经很可以用了。  如何利用分布式基础框架改造系统，让系统更健壮（以及永更廉价的硬件o公司省钱），成了当时的一个重要问题。
整个抓取系统和建库系统的分布式改造，相当于重新设计一个新的大系统。需要考虑方方面面，如何逐步升级兼容原有系统？如何保证功能的完整性？原有设计中有一些不合理的地方，如何利用这次迁移同步改造？
主导完这些工作后，系统架构方面再也没有遇到搞不定的问题。
结论:  好的架构师需要在合适的时机解决重要的问题，业务发展才能给你这样的机会。
上面5个节点，大致是T3 T4 T5 T6 T8的水平。
新冠在家隔离，半夜睡不着码字这么多。看完给个赞呗。","阶段一：啥也不会，抄代码都运行不起来，学会了百度+google，学会了舔着逼脸去求大神。
阶段二：学会天坛看教学视频，得瑟能写一些页面，停留在
CURD
阶段，顶多培训毕业水平，疑难杂症无能为力。
阶段三：开始了解底层，看书研究底层，原来发现全是数据结构算法、操作系统、网络底层，开始沉迷研究底层技术，用优雅的设计。
阶段四：知道一些底层，开始跟别人喷技术的优雅性，忽略了我们技术是为了业务带来收益。
阶段五：能灵活判断业务的情况，给出合理的技术架构。
总之，突飞猛进的时候是自己会实践用起来，同时在项目环境中碰到问题，研究底层最终解决疑难杂症，随着经历无数个疑难杂症的积累，也就是这时候。
说明：很多小伙伴都在问，就是抛出了现象没说每个阶段怎么解决问题，大家可随便评论区问问题，我收集完统一系统性回答。
没想到瞎写写这么多赞，谢谢大家！
01
近年来，有些读者会问我一些形形色色的问题，让我很难去回答，甚至给不出建设性的意见。
举个例子：
1. 我学习什么能进入优秀的互联网公司工作？
2. 我想做研发我应该学习什么？
众所周知，这问题就像你问学霸说你这么厉害一样让人难以回答。我作为一个双非软工本科学生，经过大学自己摸索和不断试错，毕业开始在百度从事研发工作。其实，我当时也有很多的疑惑，在这里给大家讲讲我的踩坑历程。
记忆中，我当年逛知乎、求助高人、甚至我的导师，都无法给出一个可操作的建议。除此之外，在我那种二本学校，知名企业都不会去咱学校校招，我和学长们对春秋招的概念微乎其微，进大厂是件很困难的事情，概率与踩狗屎不相上下。
作为探路者，求助知乎和论坛，给出的结论几乎都是好好学习数据结构/算法、现在大数据很火你应该学学Hadoop/
Spark
、你要是会微服务、docker、
k8s
一定会很加分。
让我想起了我当年问学霸题目如何解？学霸说：这个题目是来源于第X章第X例题，你这样解，答案就出来了，很容易的。
至于为什么他能想到，鬼也不知道。
当时，我真的是花里胡哨的啥都学，啥都去倒腾，不知道是不是梁静茹给我的勇气。前端、后端技术栈、Hadoop/Spark、docker/k8s这些几乎都实操过，只是很多只是入门并没有深入研究，效果自然也十分有限。
这些概念，对于小白或者在校生来说，这仿佛在对说你不用学了，除非你天生技术欲望特别强烈。这对于大多数普通人来说，明显是劝退的节奏，可操行十分有限，几乎没有参考价值，不知道从何下手。
其实，道理是没有错的，多研究底层和热门技术栈是有益的。但是，脱离实际情况谈技术就是扯犊子，就像让中国男足拿世界杯冠军显然不符合实际，更应该是根据实际情况，做产出最大的事情，否则会信心全无。
接下来，我系统性拆分问题，在不同阶段应该「学什么」、「如何学」、「学到什么程度」，重点讲我当时遇到的问题，还有我是如何去思考的，最终如何解决的，思路比结论重要。
02
根据问题归类来看，主要在我自己的角度谈谈普通本科如何实现进入Top级互联网工作？
首先，说说在大厂工作都是些什么样的人，他们当年都是背着什么光环混进去的？
经过我的调研和分析，重点说一下在校招中面试官看中和考察的东西。
学历/专业、扎实专业基本功
有成果的科研经历
省/国家级软件设计大赛
丰富互联网公司实习经历
小有名气的
开源项目
经历
大概思路就是，要么你证明你令人信服的天赋如逻辑系统思维、聪明，让人觉得你可以被快速培养；要么你有丰富的工程实战经验，证明你具备优秀工程师的潜质。
当然，你可能会说这么多要求，恐怕神仙也做不到啊，简单太苛刻了。在这里，并不是上述要点全部满足，只是满足其中两项证明你的实力即可，毕竟面试时间十分有限必须有点让人信服的东西啊。
举个例子：
1、假设你是上海交大、华中科大大学毕业的学生，你可能只需要重点复习数据结构/算法等专业知识，辅之把学校的科研经历说一下。可能进入什么阿里华为百度问题都不是很大，专业知识对于你们来说自己不再话下，毕竟考理论就是你们的特长。
2、假如你是双非大学毕业的学生，那么你必须用国家级大赛、开源项目、互联网公司经历证明自己。
总之，多做项目，专注于技术本身，让自己更早具备职业软件工程师的实战技能。
简而言之，你没有光环，那就比别人多努力点，提前做好职业规划，把时间投入技术本身不要投机取巧。
03
鉴于上述分析，知道需求是什么？对于我们来说，主要把精力投入在技术本身。
接下来，我们将面临一系列问题。 1. 我应该做什么方向？（方向） 2. 我应该学习什么内容？（规划） 3. 我如何学这些内容？（方法/策略） 4. 我应该学到什么程度？（量化） 5. 如何把理论用到实际项目/产品中？（产出）
不同方向，意味着不同领域不同，学习的知识和实战项目有共性也有差异。
在这里，我主要讲一下通用的思路。重点拿我擅长方向举例，其他方向可按照同样思路举一反三。
根据我的经验，可将内容分为原理、应用、擅长方向三个纬度。
原理和应用纬度必须学习，方向纬度根据自己擅长方向深入学习。
原理：计算机网络、操作系统、数据结构/算法，这些东西都是专业课好好学即可，数据结构/算法可以偶尔刷题。校招的时候再重点复习，初级阶段不必花太多时间深究。
应用：它是最基础的内容，不管你从事什么领域都将离不开它们。这也是小白入门重点花费时间的地方，你将在这里不断与程序斗争如调试、验证、异常、解决。
方向：不同方向本质上就是在基础应用上扩充，发挥它们擅长领域和特性去解决特定问题。在这里，简单列一下涉及的技术栈。
后端开发：消息队列、缓存、rpc、微服务。
大数据开发：Hadoop、Spark、Storm、
Flink
自动化运维：elk、ansible、
zabbix
、docker、k8s
04
基于上述分析，主要讲了整体思路，大家可能会觉得有点不太好理解。接下来，拿我当时遭遇的处境进行举例阐述，这样让不同水平或时期的同学有不一样的体会。
假如有时光机让时间往后倒退3年，时间来到我刚上大二的时候，作为一枚小萌新开始学习JAVA走上后端开发之路。
对于我来说，操作系统原理、计算机网络先战略性放弃，毕竟刚接触编程，看高大上的原理，每次上课都想睡觉。当然，数据结构/算法我还能好好听听，毕竟我数学功底还行让我不排斥。
为什么不先学习基础性原理？
举例：假设你学骑自行车，你是直接上去就蹬？还是先把轮子拆下来研究清楚原理再去学习怎么蹬？
重点：根据我的经历，在新手阶段不管是接触新的语言，还是新的方向。
最快的方式就是先把自行车蹬起来，等你蹬熟练了再去研究轮子是怎么造出来的。
根据上述策略，刨除我踩的一些坑，我把学习征途划分四个阶段，实现学习效率的最优解。
第一阶段：新手入门
在我入门的时候，我遇到的最大困难是代码不会写，DEBUG不会做，程序报错不会看毫无头绪，甚至大家常说的百度一下的关键字我也不知道搜。
这时候，最大的目标就是根据百度/查文档/看视频，把程序调试出预期结果，甚至你抄代码都行，很多时候抄代码你都不一定能DEBUG出预期结果。这就是现实，主要就是要把对编程的排斥消磨殆尽。
这个阶段，不需要太关注底层实现原理，
最重要的工作就是把应用层面的技术，不断练习直到熟练掌握上面提到的应用纬度「 编程语言、Linux、数据库、HTTP网络协议 」。
时间：3-6月
目标：会调试、会查文档、会用搜索引擎
内容：JAVA基础语法、MYSQL数据库、Linux操作系统、HTTP通信协议
方法：只关注如何使用技术，难以理解的背下来，不关注底层原理。
成果：实现常见的管理系统模块，能部署在服务器上，供他人访问。
对于现已从事计算机行业的同学，其实这部分内容非常简单，可能按照正常水平少则几天，多则不超过一周就能开发出简单模块。简单说，它顶多是普通本科毕设设计水准，主要是让新手在感官上体验软件产品。
本质上，在计算机世界里，抽象来看就是数据的计算、传输、存储。随着你的经验增多，你会发现很多技术都是诞生或优化性能都是在解决计算、存储、传输的问题。
 在这里，主要让大家在系统的角度感受最简单、最初级的技术模型。
Linux操作系统：承载应用程序、数据库的运行，提供CPU供应用程序计算。
应用程序（Java/Python/
Php
）：JAVA主要采用
Servlet
、JDBC承载网络的传输、数据库连接管理。
数据库（MYSQL）：主要理解关系类数据库的存储，对数据进行操作。
HTTP/
TCP
：熟悉重点网络协议，它分为包头/包体进行传输，包体格式可能分为form、json、pb、二进制。
作为小白，我们不得不面对一个现实，小白阶段中大多数人对计算机了解几乎为零，尽管你小时候玩游戏贼牛逼。就像写个HelloWorld，你起码要安装好环境，安装好
IDE
，可这简单的两步都能捶死在坐的各位弟弟。
幸运的是，我们在互联网如此发达的时代，市场如此火爆，视频资源可以随便搜索，甚至自动给你推荐。
我是特别推荐这个时期，大家去完整找一套视频来系统学习。尽管新手视频对于现在的我来说很费时间，但是对当时小白的我来说，这是新大陆，它能带你简单过下计算机体系导图。我在课余时间学习视频，让我在课堂上学习理论的时候，能够有豁然开朗的感觉，自然就比别人强了。
在这里，我就简单给大家推荐一些学习资源。
假如你学习java，推荐你去尚学堂/
尚硅谷
/网易云课堂，它们会有成熟的学习路线，视频也是那种手把手敲的，新手学习比较友好，我狂喜的是可以不投币白嫖。
第二阶段：项目练习
通过第一个阶段学习，你对编程从一无所知到有所斩获，对计算机世界充满了好奇，甚至有所开心。这时候，你最应该做的就是去满足你装逼的梦想。
假设你是爬虫方向，你应该去爬表情包、爬知乎数据、自动抢票，去满足你无数个装逼梦想。
假设你是算法方向，你可以去研究推荐算法、图像识别模型，去做个商品推荐、人脸识秀一秀。
假设你是后端方向，你可以去研究下
网络编程
/网站开发开发个仿微信聊天应用，体验下lowB版微信。
画外音：多做项目，坑是一步一步踩出来的。
作为大学生，实验室、软件设计比赛、
开源社区
都是你发挥现象力的天堂，这些倒腾的经历将是你毕业时最宝贵的经历。
第三阶段：强化理论
经过前两个阶段实践，时间来到大三，这时候基本的软件开发已入门差不多达到普通培训班毕业水平。同时，专业课如数据结构/操作系统/计算机网络也上的差不多了，对概念多多少少有初步了解。
这时候，你会发现很多原理你不懂，将很难更上一层楼。
你不知道使用ArrayList还是
LinkedList
？
你不知道为什么要使用线程池？
你不知道为什么分层设计使用分布式场景？
你将处于写代码一时爽，一直写一直爽，遇到性能问题直接土崩瓦解。所以，你不得不去学习理论知识让你走得更远。
问题：为什么在这个阶段强化理论知识？
在新手阶段去强化理论知识，会让你兴趣骤减且产生学了有何用的错觉。同时，这是最好的时机，学校专业课学完你有基础概念，你有实际软件应用场景，这些东西让你深挖理论的时候会快速给你构建起基础图谱，让你兴趣激增不断体验学会的东西，将戳痛你最痛的神经，瞬间把你以前遇到的问题有新的认知，这就是答案。
简单说，面向问题，解决问题，让你实实在在感受到成长，这就是成就感的力量。
问题：如何高效的学习理论？
其实，编程语言和计算机基础都是相通的，只要你学透一门编程语言剩下的就大同小异。当然，计算机基础毕竟是枯燥无味的，学习毕竟是有方法的。
举个例子：
站在编程语言的角度，你用心去总结，你会发现不管什么编程语言，变来变去都是换了个花样在谈以下内容。
程序结构（数据类型、控制语句、面对对象、异常处理）
集合（list、set、map）
文件操作、网络通信（io、bio、
nio
）
线程、线程池
不管在面试还是技术探讨，重点考察的都是集合、网络通信、线程/线程池。源自于它跟计算机基础有紧密结合，你要优化它们你必须具备扎实基本功。
基于我的研究经验，我建议大家在学习计算机基础的时候，不要因为理论而理论。你应该去通过编程语言源码去学习计算机基础，只学你当前认为最重要的。
举个例子：
当我去学习数据结构/算法的时候，我会一边学习源码一边思考数据结构，这样就让我有实际应用场景不会因为理论而理论。我学习list、set源码的时候，我就学会链表、栈。我学习map的时候，我就学会了
红黑树
、散列表。
当我去学习计算机网络的时候，我会一边学习
socket
的用法，学习Linux网络通信模型
epoll
，这样就重点把网络协议学会了。同时，很多应用场景极少的理论知识，我就粗略记忆或者跳过，这样就节约了很多时间。
当我去学习线程/线程池的时候，我会学习锁机制、生产者/消费者模型这些操作系统原理的重要知识，跟编程语言中关联不大的我就粗略记忆。
第四阶段：深究专长
经过前面三个阶段的学习，你已经具备扎实基本功和项目实战经验。接下来，你需要做的就是更加的专业化，研究一些有生产意义的东西。如果你一直写学生管理系统，这些没有价值没有意义的东西，那么毫无意义。
这时候，你应该去互联网公司验证你学习的技能。除此之外，你可以去学习额外的成熟先进技术栈。
这样，你就有实际业务经验，就有技术的宽度，同时又有深度，这就是你核心优势，毕竟算法/数据结构这些东西在竞争的时候大家都会。
画外音：去实习，最好去大厂实习，接受互联网软件开发的挑战。要是不能，那么去研究实际企业技术栈的应用与底层研究。
举个例子：
假设你是后端开发，你就可以去学习微服务的技术栈，
springboot
、dubbo、docker、hadoop都可以去学习。除此之外，设计模式，redis原理都可以去学习研究，只有这样当你去面试的时候，你有很多话题和故事讲给别人听，你的专长研究既可以让你说业务场景，你又可以讲底层原理，对答如流。
05
经过上面的训练，已经具备了解决问题、快速学习、编写代码能力，也就是具备软件工程师的职业素养和扎实基本功。
这时候，进入互联网公司开启职业道路，你将会很快有产出，不会陷入徘徊自闭的状态。更何况，你的职业素养已经能够让你遇到问题，能快速的学习克服困难。但是，要是让你去参加面试可不一定能独善其身，毕竟工作拧螺丝，面试造火箭可不能疏忽大意。
接下来，重点讲一下如何应对面试？
面试也就是把自己卖出去，让别人觉得你值。简历是至关重要的环节，所有的知识和技能全都是围绕它展开，否则毫无意义。因为在面试中，面试官关心你有什么，也就是面试完全围绕着你会的东西展开提问，所以你就把你的优势发挥到极致就行。
环节一：准备简历
简历一定要认真对待，一定要简介精炼，尽可能把内容压缩到一页，毕竟简历筛选就30秒不到。这时候，简历排版、简历字体、简历模板都有讲究，细节决定成败。
在写简历的时候，主要分为个人资料、实习经历、项目经历、专业技能。其实，没什么技巧，参考
STAR原则
，重点体现你在项目中的价值和思考。
要体现做了什么事情？
遇到什么困难？
怎么解决的？
产出是什么？
假设有读者需要简历模板，可关注提供给大家。
环节二：梳理知识体系和刷面经
以前，学习知识是零散的，学习策略更多是面向解决问题，以至于知识不系统，表达逻辑层次有限。面试官逻辑思维强，所以你必须做好充足准备才能脱颖而出。
最好的策略就是梳理知识体系和准备面经，我们都知道要是你面试官问的问题是你刚好熟悉的问题，你岂不是轻松闯关成功？所以，准备考纲、梳理知识体系、疯狂刷题这就是最好的策略。
按照互联网面试流程大多数分为三轮面。
一轮面试：主要是考察计算机基础知识和擅长语言基础知识，重点考察数据结构/算法、网络编程、擅长语言基础。但是，绝对不是死记硬背的东西，一定是深度和广度紧密结合，环环相扣直到把你肚子里的东西全部挖出来。
举个例子：
获取链表倒数第N个节点的值，只许遍历一次。
有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，返回频数最高的100个词。
谈谈
HashMap
，说下它们的数据结构？
Key
在HashCode取余以后，它可能全部堆积在某几个Key对应的链表上，这样就会造成该数据结构存储或者查询低效，那怎么解决呢？
为什么会链表要变成红黑树，什么时候从链表变成红黑树，什么时候从红黑树变回链表？
假设多个线程并发访问，那可能造成容器更新或者操作出现问题？
除了使用synchronized加同步锁，还有没有其他办法解决呢？ 8. 为什么采用
CAS
，能说一下ConcurrentHashMap的具体实现吗？
你会发现每个问题都是环环相扣，从简单到难，目的就是挖掘出你的极限。大多数情况都是，从数据结构/算法入手，扩展到编程语言特性，再扩展到并发/网络编程不断进行深挖。当直接问实际用法应试者答不出来的时候，就会再次引入到计算机基础知识，这样不断反复调度试探应试者的是深度和广度。
二轮面试：这轮考察实习/项目经历，重点考察你的面试储备。众所周知，大部分应届生项目经验十分有限，大多数是图书馆管理系统、电商系统这样。重点说一下应对策略，可以去网上找你做的项目可能遇到的领域难题，去找解决办法，最终扩展补充到你的项目中。
三轮面试：这轮面试更多是经理考察应试者的基础能力。也就是逻辑思维、抗压、时间管理等基础能力，看下是否能融入团队，毕竟适合团队的才是最好的。
这里主要讲了思路和应对策略，至于篇幅有限，面试题只能读者自己梳理，假设有需要后续再聊。大体的思路： 1. 梳理知识体系看面试可能考哪些东西？ 2. 去网上搜寻和整理面试题？ 3. 把数据结构/算法、并发编程、网络编程串联起来，还要学会理论知识和实际实战中来回串联。
总之，作为普通学校的同学，你只有花更加多的时间在项目实战中，实习/打比赛/逛开源社区，这些时间让你更快接近成为职业软件工程师。当机会来临的时候，你抓住机会就踏入大厂的大门了，幸运永远不会无缘无故眷顾你。
5月24日，读者问题解答更新：
经过读者提问，再附之我的思考，我大概总结出来分为这么几类问题。
计算机专业需要学什么？
找工作，那些计算机专业课学了有用？
学不会，我到底适不适合学编程？
找工作有那些方向，我应该选择什么方向？
专业课和课外编程学习，如何权衡时间？
学历普通，我到底是找工作还是考研？
不卖光子，直接说下整体解决思路。
对齐认知：计算机学什么。
学习方向：确认学习方向。
执行路径：具体学习内容。
学习答疑：如何坚持下去。
3.1 对齐认知：计算机学什么
问题：那些学了有用？
有用：计算机理论（算法、网络、操作系统）、项目、实习。
企业招人就一个目标：来了公司能干活，培养完能干活。
软件研发这职业，像奖学金、三好学生、学生会主席、英语四六级，对于咱们这职业来说用处不大，有只是能彰显有亮点可作为加分项，锦上添花。当然，你能去拿到这些东西尽量去拿，毕竟别人能拿到，你拿不到你怎么证明你比别人强？
3.2 学习方向：确认学习方向
前端、后端（产品或架构）、测开、运维、大数据开发、数据分析
3.3 执行路径：具体学习内容
从大学时间角度，每个学年会拆分出目标。
从专业知识角度，根据不同解决学习不同知识。
总的来说，实际操作起来还算清晰。
阶段一：找培训机构视频学习，只要能独立实现可让人访问的应用如仿微信聊天软件。
阶段二：做项目，你可能会学习崭新的技术栈（springboot、redis、
kafka
），需要什么学什么。
阶段三：通过做项目使用了很多新兴技术，计算机理论知识也学了很多。这时候，你核心目标就是把学过的东西总结归纳，拿着他们去面试找工作，这时候你要能说出怎么用，还要说出为什么要用。
开源学习网站：
https://
github.com/Snailclimb/J
avaGuide
https://
github.com/CyC2018/CS-N
otes
要是觉得还得写不错，点击 
@码农皮邱
关注，有惊喜！ ","我有幸有个姑父在腾讯做的蛮高。。。我曾经请教过他这个问题，他的回答是 ”
读顶尖代码
“
他有个观点，好的 programmer 不是教出来的，更多是师傅领进门。这个东西就像武侠小说，真正的高手不用你出手，光是走几步，就看得出来了（代码风格）。而所幸一切顶尖的”招式“都在 github 上有对应
要做什么事情 ---> github看看做的最好的是怎么做的 ---> 代码一点点拆分、阅读、分析，看看有什么可以学习、借鉴、模仿，甚至蒙住看自己会怎么写 ---> 自己动手做，学习，比较，学习
具体来说，多关注一些 github 上的技术狂热者，热衷分享技术和代码，比如 
lucidrains 
https://
github.com/lucidrains
 ，用 
PyTorch
 复现了VIT、AF2、styleGAN、DALLE2、imagen、
denoising diffusion
 等等各种前沿，真的是
宝藏男孩","作者：阿秀
计算机校招八股文网站：
https://interviewguide.cn
每个人的编程能力应该都是在不知不觉间慢慢提升的，仿佛“随风潜入夜，润物细无声”一般.
我想正常情况下应该也没有“风如拔山努，雨如决河倾”的瞬间提升和突飞猛进。
作为一个本科双非，研究生也是双非，即将入职字节跳动核心部门的普通学生，来分享一下自己在过去一年时间，也就是校招开始前一年的时间里通过自学 C++ 、操作系统、计算机网络、数据结构与算法、数据库等科目，最终顺利上岸的历程吧。
身边朋友说我是
逆天改命的典范
，因为一个普通二本的学校学生不仅能够拿到华为、百度、B站等互联网公司的offer，还能拿到一线大厂字节跳动的
SP offer
！！！
在如今这个十分看重学校和出身的时候，这几乎是不可能的事。
老实说，我真的觉得真的有点夸张了，我只是比别人多花了点时间而已，仅此而已。
他们所谓的“逆天改命”，不过是在自己坚持不下去的时候，告诉自己，再挺一下，再挺一下下就可以。
首先问大家一个问题，不知道大家有没有这种情况的出现：“在实验室或者图书馆怎么想也想不出来某道题/某个 bug 的解法，但刚出实验室/图书馆，立马就想到了”。
在过去一年这种情形出现在我身上太多次了。。。。
话说阿秀自己经历了2021届的互联网秋招，在面试的过程中，被问过各种各样的问题，但是大部分都是基础性的题，所以基本功很重要，也很关键。
在我以前通过校招上岸字节跳动后，将自己的秋招找工作笔记开源在
github
上了。
可以说我能够
凭借双非的学历进入字节跳动
全靠我自己总结的这份笔记，后来我将这份笔记制作成了PDF，并且同步到了自己的
校招学习网站
上，
现在免费分享给学习学妹们
！
自己以前的学习笔记包括
操作系统、计算机网络、数据库（MySQL、Redis）、常见情景题、智力题以及计算机面试中需要注意的问题
。
下面是我的校招学习笔记网站内容大纲
《阿秀的校招学习笔记》网站内容大纲
不少学弟学妹们在这个网站的帮助下，顺利进入BAT、TMD，甚至去了字节跟阿秀一起做同事，都跑来找我报喜！
这是我的学习笔记网站：
说回自己当初的学习，这种感觉，就很奇妙。
回到问题本身，就我自己而言，我想应该是在我绞尽脑汁克服一些困难的时候提升的，没有某一个瞬间、某一天、某一周或者某一个月忽然提升了自己的编程能力的说法。
比如：
B 站的教学类视频收藏多了、也看多了的时候；
周日别人跑出去玩，我却在实验室里看各种技术书的时候；
力扣上的刷题数量从 0 开始逐渐变为 400+，通过从 40% 逐渐提升到 70% 的时候；
《
剑指offer
》中的每道题过了一遍又一遍，以至于都可以出一个刷题笔记专栏的时候；
大冬天的早上别人还在被窝里睡大觉，我早早来到实验室复盘昨晚没做出来的算法题的时候；
导师有时候疯狂 push 项目、催进度，只管提需求不管如何实现，搞得我崩溃得受不了的时候；
纳闷钱包越来越薄、支付宝余额越变越少、实验室书桌上的技术书越来越多以至于放不下，一看当当网消费金额被吓一跳的时候；
在食堂吃饭排队打菜，忽然想起来刚才那道题/那个 bug 怎么解决，大叫一声“卧槽，我知道了”被女朋友嫌弃，被别人当作傻子的时候；
我就按照 
2019.8 - 2020.8
 这十二个月来分享一下自己的自学和找工作过程吧，想到什么就说什么，没有大纲，写到哪就算哪，不煽情也不贩卖焦虑，就写出自己的文字就好。
2019 年 8 月
说来惭愧，在 8 月之前，我对 C++ 的影响还停留在 “Hello World” 上，本科时期老师教过的 C++ 基本全忘光了。
C++ 三大特性的“ 封装、继承、多态”我真的只记得一个多态，还是死记硬背的那种。
当时选择 C++ 而不是 Java作为自己的学习语言除了因为实验室项目的需要，还因为 C++ 比 Java 要难学一点。
是的，就是因为 C++ 比 Java 难学一点，大家都贪图入门快、简单、易上手，我偏不这么干，简单易上手也代表着跟你竞争的人更多。
思虑再三，我还是选择了 C++ 作为我的主攻语言， C/C++ 能让我见识到整个计算机体系结构是如何被搭建起来的、程序是如何跑起来的、程序是如何被编译链接在一起的、函数的底层构造是怎样的....
说干就干，我经过再三比对和考究，选择了某马的 C++ 入门教程，于 2019 年 8 月 17 日，我开始了 自己的 C++ 自学之路。
我是一个喜欢动手操作的人，一边看着授课老师在上面讲，一边在底下自己开始学，跟着视频敲代码，他怎么写，我就怎么写。
没吃过猪肉，还没见过猪跑吗？
自己一个字一个字当时跟着视频中做
我看的很快，我记的开的是 1.5 倍速看的，十天左右的时间我就看完啦，当时还去留了个言，现在想想也确实感谢那个时候的自己。
说到这里，也分享一下我自己以前准备校招过程中做的一些
学习笔记
，比如C++、计算机基础等的笔记分享给你，也正是因为这些笔记的存在才顺利拿到的字节跳动SP的offer！
 阿秀个人在学习C++过程中的笔记链接:
https://
pan.baidu.com/s/18XAu8O
TsJmX_sfZ1qpmCcw
   提取码：fw8s
还好当时正值暑假时候，老师的项目暂时停滞，也没什么事情需要我去做。所以自己也能够有一个多月的时间去入门和学习，这是一段很完整的学习时间了。
对于每一个 C++ 技术栈的同学来说，《C++ Primer》几乎可以说是一本圣经，我当时在看完上面的视频后就直接去看这本大黑书啦。
月末的时候，我去 LeetCode 写下了自己的第一道题，也就是“两数之和”的题解，从此自己就走上了一边看书 看视频，一边刷题复盘的不归路。
2019 年 9 月
转眼就到了九月，这个时候也开学了，研究生老师也开始慢慢安排事情了。
由于白天需要帮老师做横向项目和看论文，所以我一般都在周一到周五的白天去干活写代码做项目，傍晚去跑步溜达溜达的，而在每天晚上八点之后看 C++ 书籍和刷力扣题，周六周日两天则是自己的全部学习和复盘时间。
在九月自己在看完《C++ Primer》的前八章后就开始疯狂得在力扣刷题了。因为刚上手的缘故，自己刷题速度也比较慢，对于一些不会的题往往需要两三个小时之久。
2019年力扣提交记录
自己能顺利解出来还好，解不出来就跑去评论区看别人的解答。在刷题过程中真的是感觉到人和人之间是有差距的，实在不明白有些人的脑子在呢么那么好使。
我现在还记得力扣第一题的评论区有一句名言“
有人相爱，有人夜里开车看海，有人 Leetcode 第一题都做不出来。
”
有时候对象邀我一起回宿舍，我也会说你先回吧。就觉得这道题没做出来回去了也睡不着，一定要把它做出来为止，为此搞到半夜一两点也是常有的事。
整个九月我都沉浸在 C++ 的世界里，也没去学别的科目。
我前段时间整理了很多不错的书籍，包括数据结构、操作系统、数据库、C++、Python、Java还有关于简历修改、面经笔经、大厂高频考点等等，简单统计了一下，已经有超过1000本书和各种干货了~
这可能是整个GitHub上最全的计算机经典PDF仓库了。
地址1：
https://
github.com/forthespada/
CS-Books
（如果由于网络等等因素，如果不能访问可以尝试地址2） 
地址2 ：
https://
gitee.com/ForthEspada/C
S-Books
其中涉及C/C++、Java、Python、Go语言等各种编程语言，还有数据结构与算法、操作系统、后端架构、计算机系统知识、数据库、计算机网络、设计模式、前端、汇编以及校招社招各种面经等~
2019 年 10 月
进入十月了，在七天假期里除了第一天跟对象出去吃了顿饭，剩下的时间都用来看书学习了。嗯，是的，七天假期我也没出去玩，也没打游戏，都用来看书学习啦。
在经过九月一整月的学习我对于 C++ 有大致的了解后，就没那么把心思和时间都花在 C++ 上了。
我开始着手学习操作系统和计算机网络了，比如哈工大的操作系统、清华大学的操作系统、南京大学
袁春风
老师的计算机基础课程都是在这期间刷完的。还有
韩立刚
老师的计算机网络视频，韩老师讲课确实有意思，整个课程欢声笑语不断。
除此之外我也看了一些比较经典的书籍，像《图解HTTP》、《
图解TCP/IP
》、《网络是怎样连接的》都是在这个月看完的。前期有了视频的铺垫，看起来很快的。
老师依旧还是那样，我们每周五还有组会要开，要汇报自己一周的进度，包括项目上的，学习上的。
说实话挺烦的，有时候自己一周明明啥也没干，也没啥进展还要在组会上吹牛逼，读研读了三年别的没咋学会，写 PPT 、美化包装自己工作的本事倒是精进不少....
2019 年 11 月
时间在指缝中不断流逝，自从开始有计划地学习后，感觉时间过的更快了，有时候一周在不知不觉中就过完了。与之相对的就是视频越看越快、PDF 越滑越快、桌子上的书也越堆越多，吃饭速度也越来越快，每晚回宿舍的时间也基本都在十二点之后了。
那段时间，我是我们宿舍回去最晚的一个，还好自己的室友们都给我留着门哈哈。
走在回宿舍的路上，我都会想哪一个知识点还没搞懂，明天要再重点看一遍；还有视频中讲到的某一个题，为什么自己没有解题思路；还有哪些书自己还没有看到，规划一下自己的未来一段时间的进度.....
十一月的时候我慢慢的开始去看操作系统的书籍资料了，像《现代操作系统》、《
深入理解计算机系统
》都是这段时间看的。我本科时间干的为数不多的正确的事就是硬着头皮把 《深入理解计算机系统》啃完了，真的是为数不多的有价值的事了，二刷的时候就很舒服~
前段时间的某一天我忽然突发奇想，想看看
知乎上计算机领域内评分最高的Top 20 经典书籍有哪些？
分别抓，哦不，
手动
收集了知乎计算机经典图书推荐问题下的高赞回答后得出的
好书集锦，
选择标准就是每本书都在推荐版上出现过 
5
 次及其以上！！
最终将抓到进行数据清洗和合并，得到一份计算机领域类的书籍榜单！
说实话让我觉得有些意外，因为Python类和机器学习类书籍确实不少，不过
Top 3却是一等一的经典
！
就是下面这三本，现在免费分享一下自己以前抓到的
豆瓣上计算机领域内评分最高的Top 20 经典书籍
深入理解计算机系统（原书第3版）
计算机程序的构造和解释
(原书第2版)
程序员的自我修养
: 链接、装载与库
2019 年 12 月
转眼就进入十二月了，《C++ Primer》也快啃完了。看书过程中，除了记录自己的所思所想，在看这本书的过程中有些课后题我也没放过，很多人说没必要做课后习题，对此我持否定意见，每章课后习题数量不等，前三道我基本都是必做的。
这样一本经典的书籍，它的课后题都是经过精挑细选的，你看完一章学没学会检验一下就知道了，
不是你觉得你自己学会了你就学会了的。
喜欢写写画画
到圣诞节前后，《现代操作系统》和《深入理解计算机系统》也看了一大半了。力扣刷题也一直没落下，在刷题过程中，自己也知道了 C++ 中还有 STL 这种神奇的东西，也知道了另外四本经典的 C++ 书籍《Effective C++》、《
More Effective C++
》、《
STL源码剖析》、《深度探索 C++ 对象模型》。
我一口气全部买回来了，兴冲冲的直接去看源码剖析，差点把当场我劝退。。。。
我又去搜索大家在看这本书的时候是怎么看的，有没有什么值得借鉴的方法。由此知道了侯捷大师，也知道了侯捷老师的几门经典课程。
 侯捷老师几门经典课程：C++面向对象高级开发（上下两部曲）、STL标准库和泛型编程、 C++设计模式、 C++新标准C++11&14、 C++内存管理机制、 C++程序的生前死后
------更新一下---
很多同学说侯捷老师的视频以及下架了，不能看了，还好我以前有保存过侯捷老师的全部课程，给大家分享一下！
主要有：
01 - 侯捷 - C++面向对象高级开发（上下两部曲）
02 - 侯捷 - STL标准库和泛型编程、
03 - 侯捷 - C++设计模式、
04 - 侯捷 - C++新标准C++11&14、
05 - 侯捷 - C++内存管理机制
60
侯捷、
06 - 侯捷 - C++程序的生前死后
07、算法原理与实践（选修）
08、系统设计与实践（选修）
09 - 辅导课：
10 - 陈硕的 Linux CC++网络编程实践视频
-------------------
就跟我开始学习C++时会选择从黑马C++教学视频入手一样，在学习STL的时候，我也选择了从侯捷老师的 STL 讲解视频入手，依旧是 1.5 或者 2.0 倍速看的。
十二月的时候我除了看操作系统的书籍之外也另外看了“STL标准库”和“C++内管管理”这两个视频。
感觉时间真的不够用啊，想看的书和视频也越来越多，可是自己一天只有 24 个小时，还要帮老板做项目和看论文。
2020 年 1 月
元旦那天，我和对象去吃了四川串串晚上去看了电影，然后继续看书、刷题。
在放寒假前我特意把两本 《Effective C++》 带回家了，现在想想还好自己带回去了，没白白浪费那个寒假。
因为
疫情
的存在，2020 年的寒假注定是不同寻常的一个寒假，很多学生跟我一样都到了四五月份才开学。
一月份回家的时候，把侯捷老师的 STL 源码剖析视频下载下来了，存在 Ipad 里，因为以前就看过一遍，在火车卧铺上迅速过了一遍，也没花多长花间。
回家的时候家里有人生病了，一直在医院接受治疗，外出打工的爹妈也还没回来我就去陪护了。就类似下图这种病房，但我们那是十八线小县城，没有这么干净整洁。
图片来源于网络
一个病房四个床位，每天来探病的人络绎不绝，在那种嘈杂的环境下不可能看得下去书，我又掏出自己的 Ipad 接着看视频，比如尚硅谷的 MySQL 视频、Linux视频都是那个时候看的。
一月下旬的时候，家里人出院了，我也能顺利回家不再继续陪护了。也终于能有一个相对安静一点的环境看书学习了，我捡起闲置了大半个月之久的 《Effective C++ 》和《More Effective C++》开始囫囵吞枣起来。
也许是《C++ Primer》 打的基础比较好，看着两本书的时候并没有花很多时间，很快就看完了。
在家的时候，每天早上八点起床，吃过早饭修整一下就开始看书了，一直到中午十一点左右，中间也没什么人来打扰我；下午吃过饭就午休一会，醒了就径直去医院拿中药回来，然后就开始下午的学习了，下午我一般不怎么喜欢看书，我比较喜欢写代码，我会选择做一些课后题或者复盘一下以前做错的力扣题。到了晚上则是看教学视频，十点多了就玩玩B站，看一些比较有意思的吃播，比如华农与竹鼠的爱恨情仇、硬核厨师阿远、还有大姨绵羊的视频。
睡前会跟自己的对象视频一会，然后就不知不觉的睡着了。。。
多说一句， B 站真的很多优秀视频，总是有人问我该看什么资料看什么视频，其实你自己去 B 站输入一些关键字，直接找播放量比较高的视频来看就可以的，播放量比较高的视频，质量一般都过得去。
话说阿秀自己经历了2021届的互联网秋招，在面试的过程中，被问过各种各样的问题，但是大部分都是基础性的题，所以基本功很重要，也很关键。
在我以前通过校招上岸字节跳动后，将自己的秋招找工作笔记开源在
github
上了。
可以说我能够
凭借双非的学历进入字节跳动
全靠我自己总结的这份笔记，后来我将这份笔记制作成了PDF，并且同步到了自己的
校招学习网站
上，
现在免费分享给学习学妹们
！
自己以前的学习笔记包括
操作系统、计算机网络、数据库（MySQL、Redis）、常见情景题、智力题以及计算机面试中需要注意的问题
。
下面是我的校招学习笔记网站内容大纲
《阿秀的校招学习笔记》网站内容大纲
不少学弟学妹们在这个网站的帮助下，顺利进入BAT、TMD，甚至去了字节跟阿秀一起做同事，都跑来找我报喜！
这是我的校招学习笔记网站：
2020 年 2 月
后来到了二月，这时候国内疫情已经进入了比较严重的时期了。武汉全城封锁也已经好多天了，每天起来第一件事就是看看疫情发展情况。
在学习的时候不断的有新名词冒出来，就好像在学习 C++ 的过程中，网络编程这个词也慢慢出现，我也是知道了 C++ 后台开发跟网络编程有关。
第一反应就是直接去知乎看有没有推荐的资料，在看过差不多二十多个高亮回答后，我发现有三本书出现频率最高：《TCP/IP 网络编程》、《Linux 高性能服务端编程》、《Linux 多线程服务端编程：使用 muduo C++ 网络库》。
我最先看的是游双老师的那本《Linux 高性能服务端编程》。讲真，确实有点云里雾里的，因为以前也没怎么接触过这个。后来转头去看了《
TCP/IP
 网络编程》，你别说，真的越看越有意思，就有时候可能不是自己脑子有问题，是因为没在恰当的时候看合适的书。
在看这本书的过程中，我知道了一个简易版的 
Web
 服务器是由服务器和客户端两方组成的，也知道了回声服务器是什么意思。
这是本很不错的书，我一边看一边记笔记
这本书上例子很多，我很快就看完了，然后就开始看《Linux 高性能服务端编程》和《Linux 多线程服务端编程：使用 muduo C++ 网络库》了。前者我好好看完了，收获很多，但后者我没怎么看完，随便翻了翻就没看了，我也不是很推荐这本书。
后来疫情逐渐严重起来，接到学校通知说要延迟开学，我有点不爽，可也有点高兴。不爽是因为在家呆久了，老妈整天唠叨我，干啥都有错，高兴是因为自己有更多的时间来学习看书了，一回学校就要开始做老师的项目课题了，就没有这么多空闲的时间了。
2020 年 3 月
进入三月后，因为一直没能回学校也复习不了C++，我的笔记都在书上，看不了就很难受，只好转头去看操作系统和计算机网络的知识。同时力扣上的题也开始二刷了，当时我重点刷HOT 100 的那 100 道题，来来回回的刷，一道题最多的时候来回刷了七八遍。我并不是什么算法大佬，自己脑子也很榆，一遍记不住我就刷两遍，两遍做不出来我就去做三遍，总有能做出来的一天。
老是有人说什么算法太难，你先看看自己下够功夫了没？对于每道题，你是真的会做了没？是不是你自己做出来的？对于你不会做的题目，你有没有及时复盘和总结？
如果你的回答全部都是 
Yes
，那你不可能做不好算法题；如果有 
No
，你可以看看自己缺的是哪一步。
最多在刷题的过程中你可以选择性的看一些别人总结好的资料，比如这种前人准备好的一些刷题笔记之类的，支持三种语言就很不错，如果算法题有障碍可以多看看。
2020 年 4 月
在复习完操作系统和计算机网络后，我除了开始继续刷力扣
HOT 100
，也在慢慢刷《剑指offer》，这本书上的题目都比较经典，经常出现在一些笔试面试中，可谓是经久不衰。
再者，虽然我已经有一个实验室的项目可以写在简历上，但一个项目还是不太够看，思考再三，我决定走前人走过的路，我也选择做一个 
WebServer
 服务器。
emm，真香！
我是根据 TinyHTTP 和 游双老师的《Linux 高性能服务端编程》的课后大作业为基础，这两者结合后做的自己的 
HTTP
 服务器，后来我把它作为我简历上的第二个项目了。简历上的第一个项目是实验室的项目，跟了快两年了，终于能发挥点用处了。
可项目还没做完，学校已经给消息了让尽快回去，本来想在家把这个项目做完的，没办法匆匆买票，赶紧滚回去了。
2020 年 5 月
可能谁也想不到，一个寒假居然能放 150+ 天的。回去学校第二天，我就立马把《C++ Primer》捡起来看，因为第一遍看的时候比较用心看，所以第二遍过的时候即非常轻松加愉悦了，很快就看完了。
然后又把以前的《STL 源码剖析》这本书捡起来看，因为寒假时候已经看过了相应的视频，看的很快，不到十天就看完了。随后又看了《深入探索 C++ 对象模型》，重点看了一下第三章，至此 C++方面的几本经典书籍都看完了，这几本书对于校招足够了，基本不会考察这几本书之外的知识点。
在此期间也是把自己的服务器项目完成并且开源到 
Github
 上了。
2020 年 6 月
因为我是在一个普通二本学校读的研，历届的师兄师姐没有去大厂的先例，师兄师姐们貌似对于秋招找工作也不上心
。
按理来说金九银十，他们一般在九月份就应该开始找工作的，但以前的师兄师姐都是在十一月份才开始写简历找工作，去的也都是一些愿意来我们学校进行校园招聘的企业，
所以找到的工作质量可想而知
。
我也私底下问过他们，得到的解释和答案就是学校比较差，然后 balabalabala 之类的。
emm，我信了，因为师兄师姐比我多上一年学，见识也多一些，但还是想努力一把，想着万一能有一点机会呢
。
万幸，自己努力了一把。还好，自己坚持了一下。
在六月份校招提前批的时候，我就兴冲冲的投了简历，结果全部石沉大海，后来才知道提前批是选拔优秀人才的，提前批能上岸的也都是一些好学校的学生，比如各种
本硕985、211本985硕
的。
投完简历没有后文，我也在找自己的原因，除了学校不行是一个因素之外，在思考有没有其他可以改进的地方。后来看了一些比较优秀人才的简历，我觉得问题有可能出在自己的简历上，因为自己的第一版简历写的着实垃圾。
所以后面又迭代完善了自己的简历，足足写了 26 个版本的简历，也正是自己精心打磨的简历使得自己在接下来的秋招正式批中能够收获到不少胜利果实。光是修改这 26 个版本的简历，就足足花了我十来天的时间。
说到这里，分享一下我自己以前准备校招过程中做的一些
学习笔记
，比如C++、计算机基础等的笔记分享给你，也正是因为这些笔记的存在才顺利拿到的字节跳动SP的offer！
自己一个字一个字当时跟着视频中做
 阿秀个人在学习C++过程中的笔记链接:
https://
pan.baidu.com/s/18XAu8O
TsJmX_sfZ1qpmCcw
   提取码：fw8s
2020 年 7 月
去年的秋招正式批是在 7 .15 号开始的，在经过提前批投递简历的全盘皆输后，我开始有些畏手畏脚不敢投递简历，因为每个校招学生可以投递一个公司的机会是有限的，比如京东，每个学生都只有一次投递的机会，每次可以投递两个岗位。所以投递简历的机会，不能随便浪费。
在别的小伙伴开始大势投递简历的时候，我总觉得自己还没复习好，一直在不断复盘以前学过的知识点。我自己的经历告诉我，永远不可能有复习完的那一天的。
因为你每次面试都有可能遇到你不会的题目，所以最好的方法就是在实战中成长，多去投递简历。当然投递顺利是有技巧的，前期去投递一些小公司，积攒积攒经验，后期再投递一些互联网大厂！
所以小伙伴们不要抱着把全部的知识点复习完事后，再去开始投递简历，等你复习完了，黄花菜凉完了，校招早就结束了。
整个七月我都是在复盘知识点 + 刷题中度过的，7.15 号正式批一开始我就立马开始投递简历了。
如果是往届的师兄师姐们，他们投递第一份简历很可能要到十月份去了。
还好自己没听他们的话....
2020 年 8 月
不知道你们是否体验过笔试全部会做的感觉？就是我所投递的互联网公司发来的笔试，我居然都会做...这不是装逼或者凡尔赛，就是我当时的真实情况，来一道过一道，来两道过一双。
在牛客网看到他们发帖讨论今天 XX 的笔试题好难，求交流求解答之类的时候，我下意识地以为他们是不是在夸大难度，因为我觉得貌似没他们说的那么难；
傍晚在操场跑步，听到旁边的人在讨论今天的 XX 公司的笔试题怎么这么难，我停下来随口说道：今天这笔试第一题是力扣
No.200
，岛屿数量那题，很经典的;第二题是回文子串，在力扣上也有，你们也可以去查查，具体题号我记不清了，都是原题的。
然后我就在他们惊愕的眼神中扬长而去，接着跑我的步去了。。。。
在我过五关斩六将一般通过一场场笔试后，随之而来的就是一场场面试邀约，为了避免漏掉笔试或者面试，还专门用备忘录记录了一下。
最多的时候一天我面过五场面试，上午两场，下午两场，晚上一场。那天面试完后，感觉身体好像瞬间被抽空一般。
然后就是笔试、面试、复盘的交替进行、循环往复。那是真难熬啊，也真难受啊，在面试过程中遇到很多自己不怎么会的知识点，有时候也会被问到崩溃或者被面试 PUA ，可来不及伤心和怀疑自己，因为可能一会就要进行下一场面试了。
心态真的会崩，当我心态崩了的时候，我一般都是去操场上跑两圈，然后回宿舍洗个澡，再来到实验室看个电影或者看看吃播，然后第二天接着干！
还好，最后终于有所收获。
意料之外的果实
写在最后
如果你能看到这里，确实很了不起。我罗里吧嗦说了一大堆，每个人的成功都是不可复制的，
我也不敢说自己的经历或者学习过程一定就是正确的，但我确实是这样走过来的
。
我写下这篇回答的时候是2021年的五一期间了，距离那段时光已经快过去一年了，确实挺快的，还有一个多月自己就要毕业了，时间真的很快。
有时候我就在想，“
玩也一天，学也一天，为什么不试着学一下呢？万一你就成功了呢
”
我是小镇做题家长大的，我记的上大学第一天代班问我们有什么才艺。
我惊奇的发现，我好像没什么才艺。但我想，我的孩子不会再像我这样了，我保证。
希望我的下一代除了会做题，儿子会跆拳道、轮滑、散打，女儿会弹古筝、弹钢琴、吹葫芦丝、唱歌、跳舞等。
文中涉及到的资料如下：
 1、黑马C++视频链接：
https://www.
bilibili.com/video/BV1T
b411j7uM
 2、个人所记录的黑马C++笔记、《TCPIP网络编程》笔记、文中所涉及到所有书籍的 PDF 电子书地址：
https://
github.com/forthespada/
CS-Books
 3、自己做的 WebServer 服务器开源链接：
https://
github.com/forthespada/
MyPoorWebServer
王爽老师的《汇编语言》，好书，强烈推荐
按照力扣的标签来刷题，并认真记录
书桌一角
更新1
1、有很多人都问我，学了多长时间？有没有1000/2000个小时....
讲真的，我也不知道有多少小时。在校的时候，周一到周五白天都要忙老师的事情，基本没时间自学，都是晚上八点之后学的。周六周日两天好好利用，各种节假日好好利用。
2、你咋不出去玩？学习不累吗？
可能是习惯了吧。以前跟师兄坐同桌的时候（他现在在华师大读博，今年该博二了），师兄很用功，每天早上八点十分就来了，每晚十二点多才走，每周工作七天，很少见他休息。我真的很佩服他，所以我慢慢也养成了这种习惯。
读研三年，差不多在校期间都是 8:30-23:30 的作息，每周 6.5 吧。这是什么概念我也不知道，只是华为二面面试官听到我在校期间的作息后，露出了欣慰的笑容。。。。
说学习累的，体验过夏天拔花生拔到腿抽筋，后背被晒得红通通的就不会觉得累了；
体验过春天弯腰插秧，秋天弯腰割稻子到晚上直不起腰来就不会觉得累了；
体验过抗 120 斤重的电缆上 20 楼就不会觉得学习累了；
体验过装灯管一天都得抬着头，到了晚上睡觉都不能躺着睡，也不会觉得累了；
体验过因为电线走线走错了，需要砸墙重来，抡大锤轮一天到晚上吃饭的时候筷子都拿不起来的时候，可能也不会觉得累了；
太多了，真的太多了，所以我觉得学习不累。
真的，学习真的已经很轻松了
。
更新2
码字不易，觉得这篇回答有帮助的话，不要只收藏不点赞呀！
耽误这位准大厂人0.1s的时间，希望认真看完的你可以点个赞再走。
我是
@阿秀
，编程程序员话题下获20W点赞+收藏+喜欢，分享计算机学习、编程知识~
1、相遇即是有缘，我最近发现github上有几本不错的算法刷题资料，支持Java、C++、Go三种语言，其中对于面试中考察较多的链表、树、动态规划、数组等知识点讲解的都很全！
如果你算法能力比较弱，比如互联网大厂面试中手撕算法比较差的话，那要好好看看了。
Github高星！支持Java、C++、Go三种语言版本的Leetcode刷题笔记~
2
、对于一些想要转行或者读研的朋友，下面两个回答肯定能帮到你！
3
、建议多看经典书，而不是什么《
21天学会XXX
》系列，完全是浪费时间！
4
、Linux C/C++ 方向自学的完整路线，很多人不知道学习完 C++ Primer 能做什么项目练手，这个回答不可错过！
5
、如果你准备时间不多，就抓住重点，在最短的时间内搞定必要的数据结构和算法而去面试
6
、我自己在学习计算机过程中看过的优质网课，你的基本大学四年绝对够用了。
7
、如果你决定不了到底学习C++还是Java，不妨来看看这个回答！
8、
我在自己八九年的计算机学习生涯中收藏了不少数据，
前段时间整理一下居然有1000多本了！！！！
后来就干脆把它分享出来造福每一位学习计算机的小伙伴，包括下面推荐的书籍全部都包含在内了！
5、分享一下自己在字节跳动工作的感受
不定时更新自己的社畜日常，记录一下自己在字节工作和一线漂泊的真实经历
最后如果同学们觉得有帮助的话，不要
白嫖
阿秀学长的回答啊！！！
双击屏幕就是最大的支持啦！一个赞就足以！这样也可以让跟多的同学看到了。
如果同学们如果还有什么问题，比如计算机考研复试、相关互联网大厂求职、技术方向等等问题，
可以在下方评论区给阿秀学长留言
，或者
点击下方个人主页关注阿秀学长
即可，不打算在知乎向同学们开通付费咨询！","在我的码农生涯中，一共有2个节点，感到自己有一种技术上「突飞猛进」的感觉。
第一个节点，发生在我写了一年代码的时候。触发点是读了两本书。
那时候刚刚转行一年，熟悉了同事，大致理解了公司产品的
技术栈
，知道整个流程是什么样的。按我现在的角度来看，当年的水平也就是个过得去的实习生（然而当时已经全职了……）。
我全心全意地想提高技术水平，然而总不得要领，也反思为什么自己对于技术的理解深度和同事们有那么大的差距。在熟悉了Python语法后，我所会的其实仅仅是将自然语言和逻辑翻译成代码，然而并不能从计算机的角度去理解代码执行的原理，当然更无从理解
性能优化
之类更深奥的事情。
那时候带我的数据工程师，手边经常放着一本《
编写高质量代码:改善Python程序的91个建议
》，我就有样学样买了一本，并且老老实实用上班的空隙时间+下班的休息时间，缓慢地啃完了整本书。再后来，觉得意犹未尽，又买了同系列的《
Effective Python
：编写高质量python代码的59个有效方法》，用同样的方法缓慢而持续的啃完。
广告
编写高质量代码：改善Python程序的91个建议
京东
￥51.90
去购买
?
这两本书讲了很多巧妙的方法，
让我搞懂了同事代码中很多写法的具体原因和目的，同时自己的代码也在加持下变得更加简洁和规范起来。
从这时开始，我才开始学习代码之下潜藏的更多计算机原理，逐渐能够从计算机而非人类的角度去理解代码。
打个比方。
算法、数据结构这些硬功夫像《九阴真经》，学会以后妙处无穷，耗时很长。上面这两本书比较像《九阴白骨爪》，可以速成，憾之深度有限。
但对于刚刚接触软件工程不久的人来说，通读这两本书，确实可以有功力大增的感觉。所以我强烈推荐，无论新老工程师，都要读一读这两本，起码要做一个 Pythonic 的程序员。
第二个节点，是我第一次独力写完并维护公司产品的核心服务。
有一天CTO突然把我和另一位前端负责人叫到一起开了个3人小会，讲了一下要写一个新的后端数据读写服务。这个服务非常核心，对性能和健壮性都有很高要求。
当时会议的情况我记忆至今：CTO和前端负责人你一言我一语地说着架构，我在旁边听天书，都是没见过的词。聊到最后，CTO问我一句，「你能听懂么？」
我像美剧《硅谷》里面的Dinesh一样……
我是右边那个……
不过赶鸭子上架，用了大半年的时间写完并打磨这个组件，最后好歹完成了一个靠谱的东西（在早期还有另一个大牛同事帮我搭了脚手架，非常感激）。这也是我码农生涯中完成的最重要的东西。开发这个组件遇到无数知识盲点、踩了无数坑，数据库、运维监控、通讯协议、性能调优、单元测试……这些全折腾了一遍，感觉像读了个加速版CS本科。
做完这个项目，我的编程水平终于从一个实习生无限逼近于工业级了。回头看看，像做梦一样，居然这么熬着熬着就成为同事口中的「
谷老师
」了。
有些事情，还真的要靠时间来打磨。
在毕业多年后开始学习写代码，让我理解了很多事情，不仅仅是计算机，也包括了「如何把事情做好」的方法。
「突飞猛进」往往是自然发生的。
你在某个夜晚苦熬一个知识点时，不会觉得自己「突飞猛进」；只有在多年后某日熟练的给别人讲解这个知识点后，内心才会小小的波动一下，猛然忆起当年深夜中的青灯一盏。
总结一下：用力地啃好书。专心地做好项目。剩下的，时间会帮你搞定。","先说结论：
1、一定要接触最好的编程体系，好的体系可以达到事半功倍的效果，否则即便智商再高，也有可能要走很长的弯路；
2、切勿有畏难心理，在学习的过程中会遇到数次平台期，期间有可能会怀疑人生，需要熬过去；
3、编程水平的提升需要经过大量的练习，不存在不劳而获；
4、要和优秀的人一起学，遇到不会的问题，要放下面子，敢于提问；
5、遇到不会的知识点，需要硬啃，今天不解决的问题，明天不会自己解决；
6、数学对于编程非常重要，请学好数学；
7、教别人会让你自己水平变高；
我是从初一开始学编程的，一开始学编程只是为了多玩会游戏。2010年在三线城市的普通初中，编程这个事情压根就没有普及，我也不知道学这个东西有什么用，那时就是学着玩呗。因为也没有人教，我就买了一本清华大学出版社出的
Pascal
的教材在那边瞎折腾。那时候网上也没什么资料，所以我学了三年啥也没整明白，像搜索、最短路这些算法我连名字都没听过，更不用说会写了。
进入了
绍兴一中
，我突然发现，原来编程不是我以前认为的那样子的，是另一个样子的。因为周围有一些很牛逼的人，就是那些能拿国内甚至国际奥赛金牌的人，我才意识到差距不是一般的大，他们五分钟十分钟能解决的问题，我自己搞了两三天都不知道在干什么，就只能拼命地学，每天压力也很大，因为周围的人都比我水平高，他们都是从好的初中过来的而我的初中水平差，我每天就担心自己会不会垫底，所以心态很不好，人就很焦虑。
我那时从初三暑假开始在绍兴一中学，一个暑假就学会了很多东西，因为有学长带着，就把
动态规划
、图论基本上都学会了。后来想一想好像我也愿意走这条算法竞赛的路，就继续学了。
我人生有三次编程水平大飞跃的时期，我的高中时期是第一次。但这次背负了太大的压力，因为世界第一次向我敞开了大门，我之前根本就不敢去想清华北大之类的学校，因为我的人生目标一直都只是考上一个一本学校，然后回老家做一个公务员。突然间，看到了不一样的希望，因为太想要，所以最后也得不到。每天就是失眠，两三点要嗑安眠药才能睡着。大冬天下着雪，我穿一件衬衫也会流汗，但我就在那边拼命地学，因为我相信努力还是能出成绩的。那时候确实也学到了很多东西，每天早上七点就到机房，晚上怎么也得到十点十一点睡觉，有比赛的话就要到凌晨两三点，第二天又是七点去机房，每天重复这样的生活，大概过了一年多的时间。最后高中我水平也比较高，小比赛都很牛逼，但由于心态的原因，一到大比赛就会全线崩盘，差点就没大学上了，也受到了很多的质疑，质疑我平时在作弊，因为我平时的水平和比赛的水平差距实在太大了。我受了很大的委屈，我从小就很看不起作弊这件事情。
最后我运气比较好，进了上海交大，进交大的时候，我心里其实是有一股气的。我觉得我要证明我自己，因为高中相对来说还是有点失败的。那我得告诉以前那些小瞧我的人，他们是错的。
很庆幸我进了上海交通大学，无论是从能力上还是思想上都极大地改变了我的一生。
大学的时候，比赛是三个人一队，有两个队友，每天都在一起学习一起训练，这样的道路就不会觉得太孤单，以前一个人的时候会害怕，总会患得患失，现在队友就是坚强的后盾，你就不会再恐惧，因为你们三个人是一个整体。
那时候我也学了很多的数学，因为高中的学习其实很多是建立在猜上的，很多都是靠直觉，直觉就是依靠多次训练之后锻炼出来的，你觉得它是对的，它也确实是对的，但就是不知道为什么。大学学了线性代数、数分等等之后，第一次知道这些为什么是对的，而不是仅仅只会用它们。这件事情让我养成了一个很好的习惯，就是写代码之前要从数学上证明自己的想法，这会让你在写代码、打比赛的时候犯更少的错误。于是我实现了第二次飞跃。
那时候，我和队友们经常一起睡机房，也经常半夜到处翻墙，因为管机房的大爷要赶我们，我们每天要和他打游击。但那时候的生活是快乐的，为什么呢？因为我心中有一个目标，我就是要去战胜世界上最强大的对手，去追求那种一览众山小的感觉，所以你不会觉得那是一种苦，相反你会觉得非常有乐趣。最后的结果说好也不好，因为各种各样的原因，最后到一半我自己就把这个事情停掉了，就去做科研了。
在这个过程中，我花了五年的时间，也慢慢地自己治好了自己内心的不安和焦虑，重新获得了小时候那种平静。最后，我也发现，我压根就不需要向世界证明什么，压根就不需要去打败任何人，我唯一想做的就是，去探索更多的东西，去探索自己的极限到底在哪里，我的人生没有那么多的观众，做好我自己就行了。
又过了几年，当我开始教别人写程序的时候，我的编程水平又实现了一次飞跃。在这个过程当中，我神奇地发现，我对一些基础的理解其实并没有那么深刻，所以就经常讲了一半会讲不出个所以然来，于是就迫使我重新回去思考，突然就发现，自己又能做一些以前做不到的事情，又学会了一些以前好几年都学不会的算法。那就是说，我以前学不会是因为自己对一些事情的基础理解是错误的。所以大家在学习的时候，也要把自己的想法和理解告诉别人，这对你来说也是一个检验和提升的机会。
还有，在学习编程的过程中，我自己遇到了非常非常多的瓶颈期，就是那种半年一年啥都没提高的状态，每天练练练就是过不了那道坎。最后其实发现，其实熬熬就过去了，编程水平的提升好像就是这样的状态，你缓很久，然后突然上一个台阶，然后又缓很久，再提升，如此循环。所以现在大家学不会也不要着急，再熬一熬，也许过一段时间就上去了。
回首往事的时候我觉得自己是幸运的，为什么呢？
第一，我确实遇到了一批世界上最好的人，无论是高中还是大学，大家因为共同的爱好聚在一起，每天不分日夜地去努力，在这个过程中互帮互助；
第二，我接触到了很好的编程体系，因为无论是高中还是大学，都拥有全世界最好的编程训练体系。我为什么对这个事情有很深刻的理解呢，因为我初中三年真的什么都没学会，初中三年做的事，高中一个礼拜就全都能做到了，如果我不进绍兴一中或上海交通大学，我可能一辈子都不会知道编程到底是什么、算法到底是什么；
第三，也是感谢命运给了我那么多的失败，让我非常早地就理解了，成功不是我追求的东西，我追求的是变成一个更好的自己；
第四，在过程中我也抵挡住了很多的诱惑，因为我的初中老师和我讲，我的天赋是低于平均水平的，但就是熬熬熬，好像把比我聪明的人都熬走了，因为他们都去做别的事情了，就我继续在干这个，好像熬一熬我也熬成了这个圈子里水平不那么差的人。所以我相信，很多事情是因为坚持，你才能够与众不同。天赋只能帮助你一时，但只有热爱和坚持才能帮助你一世；
第五，那时候我经常会死磕，经常下一个狠心，我不吃饭不睡觉一定要做完一个事情。如果没有这一次次的死磕，我想我也不会是今天这样。
后来，无论是科研也好工作也罢，我真的看到了很多很多东西，每天都抱着一种好奇心，想要对世界多了解一点，但如果不是因为遇到了编程，遇到了这么多非常优秀的人，遇到了这么多优秀的老师，我这样天赋的人是压根不可能走到今天的。所以，现在我们想把我们的好东西分享给更多的人，我们真的想要把自己了解到的东西开放出来让大家少走一些弯路。因为我们知道走弯路是什么样的感觉，我们知道那种苦涩。那么既然我们有能力，我们就应该帮助更多的人。我们后面做的很多事情都是基于这个逻辑。","18年开始编程，从一个连for循环都写不利索的跨专业小白，到后来21年秋招能拿到不错的offer。在这两年多的时间里，从0到1，我感觉自己水平突飞猛进的节点主要有三个：
第一个时间节点是能够合理地使用搜索引擎，特指Google。
其实能够从巨量的互联网信息中搜索出想要的信息并不是一件很容易的工作，哪怕是有了百度和Google。当出现bug的时候，总是会有一堆的报错信息，而搜索引擎的信息检索是有字数限制的。
如何选择关键的字眼放到搜索框中搜索
以及
如何从已经排序过的网页信息中找到想要的内容
，这两个问题其实并不简单。
对于第一个问题而言，其实首先需要将报错信息好好看一遍，大概地明白可能是哪个地方出了问题，再把最重要的关键字挑出来进行检索。关于检索的关键字，最重要的是信息量尽可能地大，有位答主说得很好，相关链接在这：
对于第二个问题而言，其实核心在于按照自己的经验如何在大脑中对网页结果进行一次再排序。一般而言，网页边上有广告两个字的就不用看了。在debug的时候，最重要的网站莫过于
, github,
 相关开源软件或者商业公司的
官网
，但这些都要求使用者具有一定的英语水平，所以大家尽可能地提升自己的英语水平，尤其是阅读能力吧，可以有效地提高自己debug的能力。
第二个时间节点是将一个大型项目编译通过。
说到这个，一下子又回忆起被环境配置等各种问题支配的恐惧。当初读研究生遇到的第一个任务就是将一个大型工业软件跑起来。而当时的我刚跨专业考进来，代码量大概是一千行不到这个量级。连命令行是什么东西还不太清楚，只明白一些基础的概念，刷过几十道leetcode。我对编程的接触只局限于写一个函数，也就是在大括号填点东西。
如何将几十万行的代码组织起来，变成一个完整的可执行文件，并把这个可执行文件运行在机器上
，这些东西，我一无所知。那个时候有点像刚学会在地上爬就得去参加马拉松一样。但没有任何办法，只能硬着头皮去搞。
现在想来，最核心的问题在于
看懂Makefile
。其实正常的软件编译，出了问题Google一下总是会有一堆的教程。但我要编译的软件是一个存在了几十年的用Fortran写的工业软件，在网上什么信息都没有。只能硬生生地去啃Makefile，从最外层目录开始看，一层又一层地链接，一共有几十个Makefile文件，都只能一行一行地看。不断地make，不断地报错，不断地解决问题。各种软件依赖问题，各种链接问题。真的是令人痛苦不堪。
这是我从事计算机行业遇到的最大的问题，每天一睁眼就是想着如何解决bug，有的时候一个礼拜都解决不了一个bug。对于自信心打击巨大，常常失眠。不过硬啃了将近一个半月的时间，终于把软件跑通。也是从那以后，我开始有了强大的自信，
相信自己能够解决任何bug，对于一个程序员而言，这一点真的是特别重要。
通过这么一个事情，我感觉自己的技术水平有了突飞猛进的进步。也开始把课本上的那些知识点一步步地串联起来，我熟练了Linux的各种命令，明白了如何用将几十万行甚至更多的代码组织在一起，知道了各种静态链接、
、编译参数的作用，搞清了一堆的字符串文本如何被转化为一个巨大的二进制文件，然后如何从磁盘中将这些二进制文件加载到内存中，最后控制器将这些二进制文件按照格式一条一条地从指令cache中取出，加载到CPU的ALU中，搭配着寄存器进行计算。所有的代码都被翻译成指令集中几十条乃至于两百行的指令。
那个时候感觉计算机的知识就像一条汹涌奔腾的洪流，无比壮阔，涌进我的脑海中。从那以后，即使面对着大型程序中的数百万行代码也不再有恐惧感。我终于树立起信念，相信自己能够解决一切问题。
第三个时间节点是使用acwing系统性地学了算法。
 
这个部分在我其他的回答中详细地聊了一下。
我在这里再简单地说一下，
为什么我们学算法觉得难
，刷leetcode觉得难。主要是因为两点：
一是没有系统性地学习知识点
。计算机不像数学或者物理，有着大量的初高中老师，有着详尽又充实的教辅材料。带着大家学完知识点a，而后学知识点b，难度层层递进，科学又合理。而我们刷题的时候，刷了一道题，有一个知识点a，瞅一瞅。又刷了一道题，有一个知识点g，再理解理解。这个学习的过程是散乱的，而是并不是线性的，有的很简单，有的特别难。这种学习曲线简直就是噩梦。
第二点就是没有特意去训练自己的肌肉记忆
。正常学数学，高中数学，都是一个知识点，无数的题目，五花八门，不断变化，就是那个知识点，做了一遍又一遍。大家不用动脑子就知道。比如立体几何，第一步建直角坐标系，第二步，转化为坐标系的一些运算，然后blabla套公式直接算。而刷算法的时候，每一个题都像是一个新的内容，得去记，去背。但题是背不完的呀！真正的方法应该是总结出一套模板，把各个题映射到不同的知识点，再用对应知识点的模板，改一改，调一调，拿去用。不断地重复这个过程就是形成刷题的肌肉惯性。
总之，通过Acwing，针对这两点问题，开始
系统性地进行学习
，然后
养成刷题的肌肉惯性
。当然，也通过刷题积累了大量的编程经验，可以较快地解决一些常见的bug。当我学完相关的基础内容和部分提高内容，又在leetcode和acwing上刷了几百道算法题，写代码的感觉不再生疏，越来越得心应手，这也为我后面找工作提供了巨大的助力。
码字不易，觉得对您有帮助的话，恬不知耻地想要个赞哈。","经常学习到凌晨后，看完一本本大黑书，做完一个又一个的lab，整个大学不敢谈恋爱，不敢有其他爱好，全力投入到学习编程中！
垃圾本科，非985/211学历！
就只靠自己一个人的努力，本科毕业前实习过多个大厂，拿到字节跳动，腾讯等多个大厂offer。
从大一开始，知道自己学校不好，只能靠自己，疯狂努力，经常学习到深夜。
所有计算机相关科目课程的成绩全都拿到90+满绩点的分数，努力参加各种计算机相关比赛，蓝桥杯，
天梯赛
，PAT获得若干奖项。
本科毕业前实习过多个大厂，拿到字节跳动等多个大厂offer....
我知道我其实算不上计算机系最厉害，最努力的同学。
现在回想到当年努力的自己，顿时一种热情油然而生。
出身农村没有富裕的家境，不能报高档的培训班，没有过人的天赋，高考成绩也不好，比不过985/211的同学。
要么自己拼命努力毕业近大厂，要么躺平毕业去干销售，最后没有选择只能背水一战。
大学计算机系的同学努力一些的，要么专注于比赛论文成绩绩点，保研出国，要么只专注于计算
机技术毕业拿到大厂offer到手软。
一路走来，我也踩过不少坑，走过不少弯路。学长作为一个过来人，给计算机专业学弟学妹们分享计算机专业学习的一些经验。我会从校内学习，再到校招各个技术岗位的求职学习，再到求职找工作一一分享。无论你现在是大一研一还是大四研三，真心希望下面的内容都能帮助到你们。
一、计算机真的是一个努力可以逆袭的专业
大部分的专业，大学里主要的优秀就是学好专业的课程，取得一个优异的成绩，考试排名班级考前，然后再参加一些专业相关的项目比赛拿到奖项，就足够代表这你在学校内很优秀了，毕业找工作求职也够了。你的待遇也完全和你学历成正比。
但是计算机专业属于强技术类的，就和普通专业很不一样。
学好数理化，走遍天下都不怕
计算机专业技术岗位的求职几乎跟校内的成绩没有什么很大的关系，甚至可以说校内的学习成绩对于找工作来说几乎真的没什么用，每次排名垫底，毕业照样拿大厂offer。
产生上述现象的原因：
就是国内的计算机专业课堂上所传授知识，跟企业里的面试官要求的标准相差太多了，
大学里面学的比价杂，需要自己专门深入学习一门技术才行。
大学教育是为了拓宽学生的视野，学习基础知识
每年计算机专业都会出现很多奇葩的现象，就是成绩比较不错的同学反而求职并不成功。
天天只顾读死书，没有搞清学习和面试的区别，也没有取了解的一些校招和面试的情况。
我有见过一个985大学，计算机科班，成绩排名全班第一，面试连一个最基础的
冒泡排序
都写不出来，具体一些技术内容也是模棱两可。
但另一方面，我还见过有的同学，大学天天逃课，成绩排名办理倒数，学校里所有的活动都不参与，只专心低头学技术。最后毕业的时候成功拿了很多大厂offer。
有很多双非本科的学校，
ACM
校队实力超群，每年都会有很多能力超强的选手在ACM编程比赛上摘金夺银。
但是尽管他们并没有非常牛的学历，甚至有些选手校内成绩也一塌糊涂，但是并不影响他们毕业找工作时疯狂收割offer，甚至本科就可以进入谷歌微软等知名外企。
也正恰恰因为如此，计算机专业也是不限出身，不看成绩，最可以通过努力就可以逆袭的专业。
下面分享下自己的学习经历，希望可以帮助到大家，如果对你有帮助，可以帮忙点个赞呀！
二、我大学的学习经历
1、大一上学期
我在大一的时候，也跟所有普通的新生一样，面对崭新的大学生活，各种社团，学生会，活动及其丰富，当时也很迷茫，不知道以后道路如何。
各种社团，学生会加入进去后，很浪费时间，对你其实没什么帮助。除非你先想去里面找个对象，哈哈
大学刚开始在C语言课程，遇到有些不懂的，我就去找学长请教。通过一两个月的时间，我就发现真正厉害的学长学姐们都特别的忙碌且低调，他们一般并不在各个社团里抛头露面，也不谈情说爱。而是一有空就去泡图书馆，我每次去图书馆都能看到学长的身影，学长的书桌上堆着很多计算机书籍。
每次向学长请教，学长也会很耐心的回答，并指导你如何学习计算机，以及一些学习路线。
自己也去了加一下编程学习网站，加学习交流群。偶尔在一次
CSDN
上评论某个腾讯工程师的博客，竟然得到了回复。以后经常关注他的博客，跟着前辈一起学习技术。
前辈看我很努力，最后还加了微信。
前辈给我分享学习路线，解答一些技术问题，分享一些他学的技术，大厂需要储备的计算机知识。还指导写博客，说了一些写博客的好处，收获很多。
我大一上学期学了C语言，python，
计算机科学导论
，第一本学习C语言的教材是
谭浩强
老师的C语言程序设计。
这本书可以算是C语言入门的初级书籍了，经典的入门级程序hello world!程序就是从这里开始的，哈哈。虽然这本书比较基础，但对于刚接触编程的我，一开始没看太明白。上课根据老师讲的，自己敲代码运行程序，课后也会花时间自己琢磨一些。待整本书学习之后，又重新看了一遍，才大致看明白一些。
这本主要讲解一些C语言变量，函数，循环，数组，指针一类的基础知识。刚开始学指针的时候也比较疑惑，不知道为啥要使用指针这东西。对指针的用法也不甚了解，自己甚至写过返回局部变量指针的这种低级问题。
在学完谭浩强老师老师的书籍后，自己也在学长的建议下买了一本
C Primer Plus
，当时坚持把这本书结结实实地精读了一遍，而且几乎练习题都做了，算是比较好的开端。自己也会用C语言编写一些计算器，
万年历
等一些小程序！
看了C Primer Plus之后，个人觉得C Primer Plus更适合入门学懂C语言，书中有穿插一点C语言的历史故事和应用背景，更贴近实际。书的语言更像一位老师循循善诱你一步步理解C语言，一开始给出代码例子，可以让你上机体会，然后一步步逐渐深入讲解这段代码各语句各函数的作用。这样学起来个人觉得更能吸引学生学习兴趣。
2、大一下学期
大一下学期就开始学习
数据结构
和算法
，C++。对于计算机在校的学生来说，首先最关键的就应打下坚实的编程功底，提前尽早扎实的掌握算法与数据结构基础。
数据结构和算法，从各个方面影响着 CS 学生，不可谓不重要
学业方面
：如果你大学里想要超过很多同龄人，在成绩比赛等加分方面超过别人，大学计算机专业里有非常多程序设计类比赛都是非常有含金量的。蓝桥杯，天梯赛，PAT，ACM都是着重对算法的考察。学好算法，并在这些比赛中摘金夺银对你以后考研，找工作都是不少的加分。
考研方面
：如果你有意向大学毕业进入高等学府继续深造，那么无论你是保研还是考研。现在国内著名的计算机高等院校复试均有上机
在线编程
考试。无论你大学里成绩多优异，无论你考研初试多高，
研究生复试
机考永远是你不可避免的一关。大学里热爱算法，热爱编程很多的同学们，往往都会在机考中取得优异的成绩，甚至可以弥补你初试分数低的不足。
找工作方面
：随着国内互联网行业的发展，对编程人员求职者编程能力的考察越来越重视。如果你以后希望去国内互联网大厂工作，你会发现大厂非常注重对求职者算法与数据结构基础的考察。算法属于基础，算法题过不了，其他一切面谈，就是这种模式。很多面试题背很多，很多开发框架了解多少，面试造的火箭对你以后做的工作。
大一下学期就比较忙了，课程逐渐增多，要学的东西也变的很重要了，难度也加大了。这个大一下学期就没怎么休息过，上课，做实验，下课去图书馆。图书馆闭馆后，晚上回寝室继续学习直到转钟，有时候也不能学习的太晚，会打扰到室友休息。
我是一个非常喜欢早睡早起的人，我的本科室友们都是会玩游戏到很晚，早晨起得也晚。我为了不
打扰他们，同时又不让自己懒床，我天早晨都定两个闹钟。
一个是
金属闹钟
放到床下桌子上：
闹钟设置成06:00, 手机振动设置成05:50。
这样每天就能05:50被手机振动叫醒，同时因为10分钟之后，床下闹钟就要响了，自己还不能贪
睡。这样就能做到，既让自己早起，同时又不打扰到室友。
同时起床之后洗漱完毕，我也会静悄悄的收拾好书包，然后迎着6点的清晨第一个冲到自习室。几乎
无数个日子每天都是在这样的晨曦中开始。
我学习学习算法的第一本书记是
《算法（第四版）》
这本也是比较今典算法方面的书籍,读完的感觉真是感觉爱不释手。总体难度难度相对较低，当然这是后面感受到的，刚开始学的时候不这么认为。有些知识越学到后面就会发现哪些简单，哪些困难。这本书需要通读，里面知识比较全面，各种数据结构都有涉及到，里面全是Java实现，自己需要用C代码重新实现一遍，方便自己理解。
还有我看的难度较大的算法大黑书，就是《
算法导论
》
这本书我并没有全部看完。这本书里面有很多算法
复杂度分析
，会让人觉得读起来很困难。算法导论看完前面17章即可（到贪心那章），算法复杂度分析的部分可以尝试去看看，如果实在讨厌
公式推导
也可以跳过，但是要能够掌握推导一些常见算法的复杂度。
为了应付公司面试时的算法题，同时也是为了积累自己的代码量，我就开始去力扣刷题了，这个刷题一直持续到我找到工作。当时我按照题目的tag来刷，这样更容易增强自己的解题能力。
大学期间，我就已经在力扣上刷了300道题目了。
Github 疯传！史上最强！BAT 大佬「LeetCode刷题手册」电子书开放下载了，有助于你提升数据结构与算法的功底。
学习C++语言，我用的
《C++ Primer》
，感觉这一本书就已经很全了，里面各种C++的知识都有。由于这本书比较厚，当时学习也花了挺多时间。上面每个程序都自己实际运行一遍，学完一遍又头头开始看了一遍。总体感觉学这本书不能求快，一个一个章节的搞懂才能继续往后面看。 这本书值得收藏，堪称C++学习字典。
3、大二上学期
大二上学期主要学一些编程基础，拓宽学习视野，算是平稳度过。
尝试多种编程语言，每中编程都有适合的领域，学习中也平添了很多乐趣
大一学完C/C++，算法之后。大二上学期学校又开设Java课程。
Java在当时看来是一门非常牛逼的语言，初学习Java后，发现Java里面又大量的类库，开发起来及其方便，而且快捷很多。Java里面没有指针这种难搞的东西，用引用代替。当时学习Java看的 《java语言程序设计》，后面没准备往Java方向发展，Java的学习也就到此为止。
那个时候Python也开始火起来了，我也开始学了下Python。自己买了本
《Python基础教程》
，学习了下基本语法。
然后就开始尝试使用Python爬取百度热搜，
当当网
和豆瓣的一些数据，感觉还挺有意思，在学习的过程中，也可以对html、
http协议
等有一些了解。
当时运行的一些调试程序 ，哈哈！
在学习和了解学习多种语言，自己也会去尝试做一些项目提高自己的编程兴趣。
自己大学和工作后看的书籍和一些面试资料学习经验都在这里了，可供下载：
我做的项目:
在学习C++的时候，自己尝试使用
QT
写了一个3000多行的带图形界面的桌PC端软件，把这个当成实验项目交给老师，老师直接就给了我90分的成绩让我学习兴趣倍增。
自己在学习C++网络编程的时候，用C++实现过一个简单的IM单聊，群聊群聊，消息推送，消息同步功能。
麻雀虽小，五脏俱全。把这个
网络编程
与协议的知识统统用上了，加深了对其理解。
然后同时用java写过web，搭过电商网站......
回忆起来最开心的事情，是我曾经还花了一个通宵的时间帮别人搭建了一个网站，大学第一次通过技术赚取了300元。
当时一晚上赚了300元了，我还请室友一起吃饭了！
大二上学期算是收获满满，经历也比较丰富，每次回想起来都感觉意犹未尽。
3、大二下学期
时间来到大二下，这个我选择
linux C++
方向发展。这个学期是打下计算机知识基础的关键时期，看了很多书，这里由于书籍太多就不一一列举了。一下课就直接奔去图书管，图书馆有我一直占的座位。图书管关门后，就去寝室学习到凌晨2点。
这是宿舍夜战，当时拍的照片。
图书管长期占的作座位
晚餐饿了就去附近食堂吃个简单的饭，然后继续看书学习。
大二下学期看完了
CSAPP
、effective C++、
计算机网络系统方法
（前三章）、计算机网络：自顶向下、部分TCP/IP详解，做了一些项目，比如
正则引擎
，尝试写JSON库（未遂）。
APUE
、部分UNP、深度探索C++对象模型、STL源码剖析、操作系统概念、
操作系统真象还原
、Linux多线程服务端编程、
Linux内核设计与实现
、计算机网络：自顶向下、部分C++ template、等书籍。同时也做了一些项目，跟着操作系统真象还原写的操作系统、简单的协程库，阅读了一些优秀的开源项目，SGI STL、
muduo
、redis、libevent等。
CSAPP 
《深入理解计算机系统》
，这本书涵盖了从一个bit到一个网络应用的系统知识，初学者会有很多概念都难以理解，建议是尝试检索相关内容去理解，实在学不会就先跳过，继续后面的内容。读书过程中，也不需要一定按照其安排的章节顺序，可以先挑自己喜欢的读，例如为了理解计算机中的
cache
，就去读第六章。这本书是
CMU
 CS15213 课程（Introduction to Computer Systems）的配套书籍，该课程相关的资源也可以用来辅助学习，另外，最精髓的就在于配套的Lab了，难度不低，这个一定要做，如果做的很困难，也要坚持去做，完成后会发现自己的能力有很大的提升。这本书也不用一口气读完，有些章节不太感兴趣，或者读不下去的话，可以留着，等后面知识更加丰富了再回头来看（例如网络那章，我看的是很难理解一些概念，后来学习了计算机网络和网络编程后，就发现读起来比较简单了）。
《Linux内核设计与实现》
，当然这种书不必通读，挑自己感兴趣的章节看就好了
对于计算机网络的学习计算机网络的学习，理论先看
《计算机网络：自顶向下》
，可以只看前面三章，即应用层和传输层，做下每章后面的lab。再就是对TCP/IP协议的学习，推荐
《TCP/IP详解：卷1》
，也是为了节省时间，可以只看TCP相关的章节。这本书英文版是第一版，中文版是第二版，个人是先看的英文第一版，然后再看第二版，挑了新加入的内容看。学习的时候，建议用
wireshark
来抓包，感受一下这些协议是怎么工作在这互联世界的网络中的，会很有趣的。
4、我的整个大三
当我踏入大三年级的时候，我的成绩已经在专业排名里比较靠前，综合素质排名全系第一。
因为自己真的大一大二太辛苦了，自己原计划在大三可以休息一下。
但是学长得知的一个消息，彻底改变了我的整个大学轨迹。
因为我本科的学校是一个垃圾本科，没有很多985名校那些学生自带光环的学历。
之前一直觉得这样的学校是不可能有机会进入阿里腾讯这样的大厂的。
但是自己大三的某一天突然得知，自己上一届有一个一直非常低调的学长毕业拿到了阿里巴巴的offer。
自己永远记得当时自己那个惊讶的程度，在那时的我眼中，垃圾本科学校跟阿里腾讯这样名企是根本毫无关联的事情。
然后我就详细跟这个学长请教了好久好久，那时候我才刚刚知道什么是互联网校园招聘，什么是大厂求职面试，什么是秋招春招。
同时学长也告诉我，去大厂实习非常的重要，不仅可以学到学校里学不到的企业里真正的研发技
术，同时还可以作为简历上很大的加分项。
我在大三上学期花了三个月的时间，每天早睡早起，除了上课以外，放弃所有的课余休息时间，复习准备冲刺。
看了无数本重要的技术书籍，学习并跟着做了好几个比较优质的项目，在csdn上写了400多篇读书笔记，现在总共已经写了超过1000篇了。
然后开始准备在网上投递简历，寻找实习。
原本以为普通垃圾本科的我不可能又大厂会看上我的简历，真的没想到在投递后，竟然有很多公司
的hr电话联系了我，其中还有很多大厂。
原以为自己能找到一个实习就很错了，但是真的没想到最后经过了非常多公司的忐忑的面试后，自己竟然几乎全部通过了，其中还拿到了多个大厂的offer！！！
下面分享下我整个大学看过的书：
我这里整理学习近百本计算机经典书籍，包括各种编程语言，算法，网络编程，数据库，分布式等等各种技术。对于学习计算机的同学帮助非常大，且十分系统！面试找工作的资料汇总都打包放在这了，这套资源可不是一般那种网上找的资源，非常宝贵，不要错过！
书单：
三、后记
别人的人生我不了解，至少我看到的世界里，我周围所有的同学，同事，小伙伴们都是: 越优秀的人越懂得努力，越极度的自律。经常学习到凌晨一两点，基本没啥其他课外活动，专注学习。
正如
马斯克
所说：一天只工作8小时的人怎么改变世界
同样越早的掌握信息，越早的找到努力的方向和学习路线，也是很重要的事。
作为计科学生，大学期间一定多看书，老外的大黑书很全面，有的不要全部看，但事至少要知道一些。
大家买书一定不要吝啬，这是回报率极高的投资，对于一些喜欢的书，买下来！推荐给大家一个很好的购书渠道，就是关注京东图书的活动，经常会有400减300、300减200的活动，十分划算。大概统计了一下，大学期间我花了五千多块钱去买书，这算是我花的最值的一笔钱。
计算机专业真的是一个不看出身，甚至连专业都不看的行业。你只需平时多努力学习并早早的关注求职，校招，面经等。早早的出去实习，学校里的很多无意义的事情，甚至成绩你都可以不用关心！毕业的时候拿到bat大厂offer不一定是遥不可及的事情。
无论你现在处在任何阶段，请卸载手中的王者荣耀，关掉电脑中开着的游戏，好好对未来规划一下，我觉得一切都还来得及。
写到这里.....感觉手好酸.....
看到结尾的同学，如果觉得有收获，不要只偷偷收藏白嫖盼学长， 给盼学长留一下一个赞呀，这样也可以让更多的小伙伴看到呀！
推荐阅读
c++硬核学习路线和学习资料
我是女生选的软件工程，真的感觉压力很大很大，不知道怎么办了....?
423 赞同 ・ 8 评论
回答
记得帮我 
@盼盼编程
 点个赞哟~","每次信息流刷到这个问题，都会拨动我记忆的缓存，让我想起那段大起大落的时光。
自从写完那个项目后，我没再怕过任何代码。
19年夏的某一天，在各大公司陆续推出自己预训练的BERT，并开始用它们做离线任务时，
lead
把我叫进会议室，说老大想上线BERT，需要尽快写一个
C++版本的BERT
服务。
不是那种用tfserving或者libtorch哦，是直接用C++写。
我面无波动地答应了下来，实则内心已经裂开了。
自己不是CS科班出身，压根没写过完整的C++项目，虽然有些Java基础，但到底几斤几两我还是蛮清楚的。
打比方的话，就是让第一次玩塞尔达、刚开完四个神庙、出了新手村的我直接去打盖农，悲壮之感难以言表。
P.S. 小伙伴们要的Cuda编程入门资料放在文末啦～
整个人都不好了
但我作为新时代的自强女性，还是开启了冲向海拉尔中心的旅程。
第一步，就是搜集可以参考的
开源项目
。
Fortunately，我找到了知乎开源的cuBERT项目，作者写得特别清楚，并且同时提供了GPU和CPU版本，但老板看了速度之后仍不太满意，最终我靠着极强的搜索技术又找到了英伟达刚开源的fastertransformer，用Cuda C++直接实现了transformer底层运算，速度秒杀其他方案。
在经历了各种make、install的折磨之后，我终于摸清了如何在服务器配置相关lib并运行c++代码，也顺利跑通了官方demo，性能完全符合预期。但不能高兴得太早，因为这个库只有transformer层的实现，前面的
tokenization
、embedding、pooling都没有写。。所以，这意味着我要读懂源码，然后自己把剩下的补全。
第二步，我开始读源码改项目。
这里有碰到了第一个难点，就是跑官方给的模型没问题，但运行我们自己的模型后就出现了 nan 这个恐怖的结果。于是我开始使用 print 大法，但惊讶地发现 cuda 底层全是并行的，一打日志都是乱的。。。于是我学会了 synchronize，在每个 operation 之后同步再打印结果，最终花了两天时间定位了问题：原来是
Softmax没加溢出保护
。立刻给作者提issue，不过在等待作者回复的过程中我居然自己给改好了，还默默学会了 Parallel Reduction 算法。
期间我还会卡在各种各样的事情上，经常会卡上一两天，陷入自我放弃的漩涡。
最终还是搞懂了源码，搞懂了
cuda运算
，并加上输入输出层搞出了完整的C++ BERT。
但仅仅有个程序还是不够，服务接口在哪里呢？
第三步，整一个服务。
于是我又搜啊搜，找到了一个宝藏：TensorRT Inference Server。当时的版本提供以下超赞的功能：
支持单GPU上的多模型&单模型多实例
支持多种backends框架（TensorRT、Tensorflow）
动态Batch增加吞吐
提供负载均衡及状态监测
所以又花了几天把C++ BERT适配TensorRT框架，成功变成了服务。
变成服务之后又有问题，就是每次换机器都要重新配置环境并部署，于是我又学会了docker，减轻运维负担。
通关了！
整个改造差不多耗时小两个月，也是我工作至今记忆最深的一段时刻。
我永远忘不了，那种看着看着代码就想站起来掀桌子的感觉
。可以一起体会下：
template <typename T>
  __inline__ __device__
T blockReduceMax(T val)
{
  static __shared__ T shared[32]; 
  int lane = threadIdx.x & 0x1f; // in-warp idx
  int wid = threadIdx.x >> 5;  // warp idx

  val = warpReduceMax(val); // get maxx in each warp

  if(lane == 0) // record in-warp maxx by warp Idx
    shared[wid] = val;

  __syncthreads();

  val = (threadIdx.x < (blockDim.x >> 5 )) ? shared[lane] : -1e20f;
  val = warpReduceMax(val);

  return val;
}

当然也忘不了身边同事牺牲自己时间给我的帮助，还有lead和我一起翻了半天C++ Primer 才解决问题的欣喜。
故事的后来很圆满，压测效果满意，成功服务了团队的BERT上线。包括后来我在20年初和其他两个大厂团队的人交流，都没有听到过更快的速度，甚至有同学直接质疑了我，因为他们的延时是我们的两倍。。。
去挑战一座山吧
现在回想起来，这段经历真的太宝贵了。虽然不想再经历一次，
但自那以后我再也没怕过任何代码
。
做算法也有了底气，我可是搞过CUDA C++的女人，别叫我调包侠
。
如果想快速提升，那就去挑战一座山吧
，找一个高质量的项目，读懂并进行修改，在一次次自我放弃中成长。
就像走过高考、走过考研、走过校招那样，过去那道坎就没什么了。
另外，为了push大家学习，
奉上我总结的cuda编程入门资料
：
一些参考：","很多次。
大二时和同学吵架，气得看了一遍菜鸟教程。
学会了前端三剑客，学会了php，学会了自己建站。
然后就开始接各种项目玩，有小程序，有物业管理系统，甚至还有澳门皇家赌场(做完了怕被抓没交付)。
第二次是进鹅厂，负责重构我们所有jq系统的前端项目。
花一个月写各种方案被老板叼得破防大哭。
上手踩了不少坑，吃了无数bug，挨了无数骂，背了无数锅。
天天喊辞职，不过终于搞出来了，收获颇丰。
觉得还能再加油加油。
第三次是成为负责人开始带队。
对整个软件工程有了更多的理解。
开始站在更高的视野看各种事情，以前不理解的也开始理解了。
做事慢慢也形成了各种方法论。
开始重新
review
之前的代码，从架构层次开始局部重构。
开始系统的完善工程化，系统的优化性能和用户体验。
第四次是遇到各种奇葩问题。
于是开始看各种框架源码，开始看chrome源码，开始看各种牛批的库。
学到了很多技巧和想法，并且应用到了工作中。
发现之前觉得无从下手优化的东西现在就是一坨shi。
又开始做各种优化。
第五次是开始准备搞自己的独立游戏。
我脑海中有了一个有趣的世界，我想实现它。
自学了unity，学习了gpu和
shader
，学习了各种姿势。
同时也理解了绘画，音乐，写故事等辅助技能。
不得不说，很多时候跨界的知识也会带来很多有趣的思考。
第六次还未来，不过我还活着，还在努力。
等发现了再分享分享。
不难总结，所有的经历都有一个共同点。
那就是离开舒适区，向外探索。
哪怕很难，哪怕很苦逼。
只要有正确的大方向，只要不死，就努力找方法去解决，去踩坑，哪怕走点歪路，吃点亏。
所以我虽然在鹅厂混得还可以，也似乎有点机会往上更进一步。
我渐渐意识到，打工是有天花板的。无论是职业上的还是身体上的。
我也渐渐意识到，打工只是在某个经济系统中扮演其中一个角色。
我更想跳出看看要怎么才能创造出属于自己的经济系统，从生产到销售到售后。
我更需要有自己的产品，虽说这条路也很难。
但我想试试。
4月初更新，感觉终于算是跑通了独立开发这条路，虽然没啥钱，但是很快乐。
俺发布了一个Vscode插件――
XMouse
 
〔拖拽导入代码片段、项目文件、
npm包
〕
简单推广了下，用了几天，虽说用处没有那么大，但还是有点快乐的，欢迎一起来体验。
(づ ●─● )づ  大致如下图，直接商店里搜索安装就行。
咳咳，言归正传。
一开始其实很多想法。
比如因为前端已死，我要做一个前端地府，一个失业前端互帮互助论坛，但是备案太麻烦放弃。
比如我要做一个摸鱼插件，一个chrome宠物，他可以帮你分析网页，陪你聊天，给你推荐你喜欢的热点，但是token太贵了做了一半放弃。
比如写一本书，讲讲前端进阶、架构与升职加薪那点事( 不卖课，慢慢写，后续更新到个人博客上，等有缘求个打赏。或者看有没有实体书出版的机会，看能不能装个ac去吹牛 )
比如我要做游戏，一个黑暗世界里城建生存的游戏，但技术不到位还在学习。(真没放弃)
等等等等，很多很多想法，其中很大一部分也花了不少时间(比如摸鱼插件和写书)
但是想了想，最终还是做了减法――想法越多，进度越慢，先上线再说。
然后我就减出了XMouse，第一个版本很简单，只有代码片段的crud与拖拽。
自己用了下还挺好玩，分享给了朋友们反馈也还行(也可能是照顾我面子)，然后也写了篇文章推广，没想到真吸引了一些用户，还有朋友希望共建。
不得不说，把我当时高兴坏了。
虽然没啥钱，但确实比发工资爽。
当然也欢迎朋友们打赏投喂加鸡腿。
ps：项目开源，请放心食用。
今天先说到这，后面再更新。
都看到这儿了，点个赞和关注吧。
有兴趣也欢迎来找我聊天，联系方式如下 ( 'ω' )  
免费多个朋友不是坏事，反正一键能拉黑。","啃完一本本书, 做完一个个lab
没有突飞猛进, 一切都是量变最终累积成质变!
但是会有那样一些时间节点,你会明显感觉到自己的编程能力确实有提高不少,能够实现更多的想法.
不过老实说，就编程能力上确实没有“突飞猛进”的感觉，都是逐渐的进步，量变引起质变嘛。
我们都是普通人，不可能像
张无忌
一样因跌落悬崖，意外获得《
九阳神功
》，从此开挂，走上巅峰。
只有靠不断的看书、coding、学习优秀
开源项目
，构建自己的计算机知识体系，并且在特定的领域不断专研，这样才能成为一个优秀的工程师。
滴水穿石非一日之功，学习计算机还是需要沉下心来好好啃书、看源码、写“轮子”，逐渐构建起属于自己的计算机知识体系，学习一定要系统，这里推荐一个计算机系统学习网站，有Java、C++、Python、操作系统、网络等学习路线，计算机必读书籍PDF、C++、Java、计算机基础面试题等：
我在大学之前完全没有编程经验，高考后，填的专业前几个也是清一色的传统工科，被软件工程录取纯碎是意外。
当时甚至很担心完全没有编程基础的我，上大学会不会跟不上。
后来大一，第一门编程语言就是学的C语言，怎么说呢，老师讲的，书上写的我都能看懂，但是一让我写一个大的程序，我就摸不到头脑，不知从何下手，学了半学期，也只能写写课后习题，算算水仙花数什么的。
而且当时对计算机缺乏系统认识，即便我知道指针就是变量地址，也很难理解它到底有啥用。甚至分不太清数组和指针的区别，以至于会出现对函数局部变量取地址返回这样现在看来很低级的错误。
大一上考完C语言后，我便在心里默默念想，这辈子再也不写C了，只是没想到的是，后来这成了我最爱的一门语言。
大一下开始学习数据结构与算法、数字逻辑这些计算机核心课了，此外，还学了一门当时我看来非常牛逼的语言―Java。
为啥说我当时觉得它牛逼呢？因为刚经历过C语言的摧残，发现Java丰富的类库，各种方便的工具类。再也没有指针了，变成了对象引用。
Java我学得很认真，当时还看过
马士兵
的Java Se教程。
自己也用Java写了不少好玩的东西，比如联机五子棋、HTTP服务器等等。这让我第一次感受到编程这么有趣，俗话说兴趣是最好的老师。
在学java的时候喜欢在网上搜资料，但总觉得各种博客上的知识过于零散，为了学好Java，我在知乎搜索各种书单，先后看了《Java编程思想》《Java核心技术卷》《Java并发编程》好几本书(不是全看哈，大部分主干章节
大一暑假在家自学了安卓，并写了几个app玩，但发现自己不太喜欢客户端，于是大二开学就开始学 Java 后台开发，从 Servlet 到 SSH SpringBoot，基本上都过了一遍，后来越来越觉得这条路就是在学各种框架，总觉得不太对劲。
在这里也分享一本帮助我拿到BAT 等一线大厂 offer 的算法笔记，是一位阿里大神写的，对于算法薄弱或者需要提高的同学都十分受用，算法一定是计算机学习的重中之重：
编程指北：Github 疯传！史上最强！BAT 大佬「LeetCode刷题手册」电子书开放下载了！
同时，大一暑假有大四学长学姐在学校广场摆摊卖书，我也买了些，其中有一本就是被称为计算机神书的CSAPP。
大二在上一些无聊的课时，我总把这本书带着，每节课可能会翻个几页，那时候看到汇编、内存管理、存储器层次我是真的云里雾里，因为还没学操作系统，C语言也学得很差。所以断断续续的看了几章，说不上学到了什么，但让我对这种枯燥的基础知识第一次产生了兴趣，有一种想彻底搞懂它们的想法。
为了看懂这本书，又去看了
王爽
那本《汇编语言》，重学了C语言，由于已经学了汇编，指针对我再也不是问题了，同时看完了《c和指针》、《C专家编程》、《
C陷阱与缺陷
》，C语言使用得也愈加的熟练。
大二上那段时间，学院里突然刮起全员学机器学习的风气，虽然不至于全部，但是真的是很多人都在学，于是我也不例外的加入了，先后看了点
吴恩达
的视频和西瓜书。跟着写了手写数字识别这种入门必做的项目，但是后来总觉得对机器学习、深度学习提不起兴趣，原因之一就是我觉得无法完全掌握每一步，了解每一步背后的原理。这让我学得不安心。于是ML的学习之路也止于大二。
大二是学习内容最丰富的时间，当时室友用 Python 写了抢课脚本，感觉很好玩。然后又跑去学Python，学爬虫。写了一堆爬虫，什么爬豆瓣电影、抢课脚本，玩了一段时间也没太大兴趣了。
时间来到了大二下，按照课程安排，开始上操作系统了。于是我又在知乎搜索“操作系统怎么学”，顺着一堆回答，我发现原来还能跟着别人写一个 mini OS，这对我吸引力太大了。于是我买了一本《
操作系统真象还原
》，这本书真的非常仔细，把写 OS 需要用到的前置理论知识、汇编、内联汇编全都给你讲清了。我一路跟着书写，写到了汇编开机打印出我的名字，再到后来进入C语言写内核各个模块，写到内存管理我就中断了，没有继续写下去，这也算个遗憾吧。
当时真的对这个入迷了，为了写Min os我还去看了Linux0.11的部分代码。把我的QQ签名改成了 jmp 0x7c00 
(这句汇编就是将跳转到0x7c00这里，BIOS开始引导操作系统。
于是就这样，我越来越喜欢偏底层一点的东西，所以决定走 Linux C/C++ 路线，然而现在看来确实太年轻了，Linux C/C++ 在鹅厂好多也是用来写业务滴。。。
大二下在知乎、牛客网搜索学习路线，我大概清楚了需要看些什么书。于是开始了非常标准的 Linux C/C++学习之路。
也非常推荐大家尽早去刷一下牛客网，上面很多大三、研二的正在找工作的学长学姐们分享的帖子，早点接触这种就业的氛围，自己也会更加有动力去学习，也知道学习的方向，另外上面可以针对校招刷算法题、刷SQL等等，还挺方便的，现在很庆幸自己在大二的时候就在刷这个网站：
前前后后看了《
C++ Primer
》、《APUE》、《UNP》、《深度探索C++对象模型》、《STL源码剖析》、《C++设计与演化》、《
Linux内核设计与实现
》、《Linux内核完全注释》、《effecitve C++》 、《effective modern C++》、《
程序员自我修养
》、《Linux高性能服务端编程》、《Linux多线程服务端编程》(知乎
陈硕
大佬写的)......，顺便还看了点muduo源码，自己模仿着基于epoll写一个reactor模型的web服务器，跟着知乎Milo大佬写Json库，总之，这段时期是写了一些小”轮子“的。
学习计算机一定不要想着速成，要下苦功夫，去啃那些经典书和源码，然后自己动手写，我大学整理了一套计算机必读的经典书籍，对于CS学习的同学帮助非常大，且十分系统，这部分我是会不断把它完善的，当成自己的小电子书库，不多，但贵在精。
我整理的这些书大家可以在这里获取，对于学习计算机的同学帮助非常大，且十分系统
：
编程指北：计算机必读的书单（含下载方式）
看的书越多，其实你越能找到自己的方向，大三上我就给自己学习定位：
深入C++语言（多线程）+ 存储（学习redis、leveldb）+ 网络编程（学习muduo，各种网络编程模型）+ 学习分布式（mit 6.824、ddia、google三大论文等）
基本上是沿着上面几个方向去展开学习的，有的看书，有的论文，也有的看博客看源码。总之，知识面在大三不断扩充，自己开始关注C10K、C100K这样的后台服务器开发高性能、高并发的解决方法。
值得一提的是，大三上我们学院有门System Programing的课，教材就是使用的CSAPP，因此我之前大二草草看完的书，得以再次翻开，这一次我把附带的是个实验也挨着挨着做了，收获良多，有位运算各种奇技淫巧，有Bomb lab刺激的打怪通关、也知道了buffer overflow attack.... 还有实现基本的内存管理等等。
印象最深的便是做bomb lab，一个个 phase 的通过真的很让人兴奋，我几乎是连着把这几个phase过掉的，当然头发也没少掉。
当时还写了个记录：
再到后来，我拿到了微信实习offer，然后顺利转正。
在我大三下拿到实习offer后，我开始做一些国外计算机课程lab，一方面有钱拿，而且还不低，靠这个我在大三下就实现了经济独立，另一方面这些lab很有意思，对提高基础和编程能力很有帮助。
现在我开了一个公众号「编程指北」分享编程学习方法、技术相关的一些东西，感兴趣的同学可以去关注下～
在这里列举一些我做过的觉得有意思的lab：
第一个是文件系统
这个玩意挺有意思的，就是要让你自己去设计一个文件系统，比如文件、数据块、目录等等，而且你要提供创建、读写、删除、随机读、随机写等等接口，然后通过 Linux 的 VFS（虚拟文件系统） 机制挂载到 Linux 内核中，然后就可以用系统调用 open、read、write 这些来在你的文件系统上进行读写。VFS 是Linux一个机制，它规定了 IO 接口，然后你去实现这些接口，你就可以挂载在上面。通过这个东西我深入的学习和了解了文件系统，报酬也是非常值的。
第二个是SVC
就是版本管理系统，类似 SVN 和 GIT的，但是相对 GIT 做了很多简化，核心的就是创建分支、分支合并、回滚、commit 这些，通过这个我又去详细了解了 GIT 的实现原理，并且自己写了一个简单版本的 GIT，受益匪浅，也赚到了几千大洋。
第三个是操作系统的锁实现
这个就是让你基于硬件的原子指令 xchg、cmpxchg 这些实现一个锁，这个需要内联汇编、汇编等知识，简直是硬核！！！做完这个也解开了我对锁实现的一些疑惑。
还有个是 Web Proxy
这个就更有意思了，要求用 C++ 写一个代理服务器，类似 Nginx 的代理功能，当然，相比 Nginx 弱鸡很多，
 但是麻雀虽小，五张俱全，而且老外最有意思的是要求代理服务器对一些图片和 HTML 恶作剧，就是代理服务器随机的在原始服务器，返回的响应里 插入一些图片和文字，因为那天是愚人节。。。 不得不说老外还是很有趣的。
还有模拟实现 TCP 可靠传输的
这个就更硬核了，人家老外老师就是给力，直接做了一个网站，这个网站你可以通过 TCP 连接上去，然后你需要运行几个节点，互相发消息，他们之间的消息都会经过老师的网站，所以通过网站上是可以控制丢包率的，也能控制节点的拓扑结构，要求就是让你基于这种不可靠的信道，做出可靠数据传输！这简直就是翻版 TCP 嘛，超时重传、ACK、滑动窗口啥的都给我上！就是像下面图中一样，圆圈就表示你可达的范围，不同节点形成各种网络拓扑，可以调节网络 丢包率 Loss chance。
当然也有很多写算法的，数据结构实现的，图搜索的，也有做机器学习、深度学习的，反正各个方向都有。对这些Lab感兴趣的可以去我公重号「编程指北」后台回「lab」，我会不断更新汇总做过的一些lab和课程网站链接。
如果对这些lab感兴趣的，自己也想做的话，可以看看我的这篇文章
大学靠技术经济独立的方法，全部分享给你
 做这些 lab 真的实实在在的提高了我的编程实践能力，也算是检验了前期看那么多书还是有效果滴。(顺便还让我大学期间就月入上万。。。
所以写了这么多，再点次题吧，我认为自己编程能力突飞猛进就是在看完一本本大黑书、做完一个个lab、写下一行行代码之后。
附上大学期间买的一些书，毕业的时候大部分都卖了，因为实在不便携带：
这是带去图书馆自习室的书（常占位置）
这是毕业整理的书：
买这些书花了我不少钱，大家都知道计算机这些书一本就是五六十、七八十起步。大学四年光买书就花了几千块。不过我一直认为这也是我花的最值的一笔投资。
下面就是我自己整理的电子书，绝不是在网上那种打包下载的，而是自己需要学到某个方向的时候去网上挨个找的，最后汇总而成。这部分我是会不断把它完善的，当成自己的小电子书库，不多，但贵在精
我把大学时候这些电子书库、简历模板、博客汇总、谷歌大佬的刷题笔记都打包放在这了，点击下方可以直达。
书单推荐，少即是多（含下载方式）
当然了，多刷题也可以提高编程能力，所以在这里也推荐一份我看过的谷歌大佬开源的刷题笔记：
最后给大家分享一下计算机系统学习网站，学习路线大全，包含各个方向的学习路线和资源推荐，以及学习方法，强烈推荐收藏：
如何自学篇
   
计算机专业如何系统自学？
如何高效阅读计算机类书籍？
如何快速学习掌握一门编程语言？
计算机基础篇
   
操作系统超详细系统学习路线
操作系统系统书籍分类推荐
计算机网络超详细系统学习路线
如何系统学习网络编程
编译原理系统学习路线
C++方向学习路线
   
C++ 语言超详细系统学习路线
Linux C++ 后台开发系统学习路线
Java方法学习路线
   
Java 后台超详细系统学习路线
C语言方向学习路线
   
C 语言超详细系统学习路线
后台中间件(MySQL、Redis、MQ等)
   
Redis 超详细系统学习路线
Python方向学习路线
   
Python超详细一条龙版学习路线
Python Web 开发系统学习路线
大家觉得有帮助的话，也可以帮我点个赞，笔芯~ 记得关注我哟 
@编程指北
 
――――分割线――
很多小伙伴在评论区问学习路线, 我找来了Linux C++ 后台开发方向的,强烈建议看看这个回答,一定对你有帮助!
Linux C++ 服务器端这条线怎么走？一年半能做出什么？
700 赞同 ・ 17 评论
回答
评论区还有小伙伴想要我的书单，这里也给出我以前写过的一篇文章，大家感兴趣可以去收藏下：
另外，推荐一篇我写的关于指针的文章，绝对深入浅出~
万字长文带你从内存看指针 | C语言指针完全解析
2217 赞同 ・ 143 评论
文章
在这顺便推荐一个 Github 开源仓库，基本包含了常见的 CS 编程学习书籍，可以 star 一下，需要的时候直接去上面找书：
imarvinle/awesome-cs-books
?
github.com/imarvinle/awesome-cs-books
觉得有帮助的话，帮我 
@编程指北
 点个赞哟~","垃圾本科，非清北复交985牛逼学历，
智商平平，非ACM拿牌sci论文天才光环选手。
编程从来没有什么突飞猛进，都是在
一道又一道的算法题，
一场又一场的算法比赛，
一本又一本的技术书籍，
一篇又一篇的技术博客，
一个又一个的项目Demo中.... 逐步成长起来的。
作为一个出身非常一般的计算机本科同学，就只靠自己一个人的努力，本科毕业前实习过多个大厂，拿到字节跳动，网易等多个大厂offer。
从大一开始，只靠自己，疯狂努力。
不仅所有计算机相关科目课程的成绩全都拿到90+满绩点的分数，
同时，在大学用拼命的两年的时间, 做完了其他优秀的学长学姐三年才做完的事情，
努力参加各种计算机相关比赛,获得若干省部级，国家级奖项，
拿光了学校里所有学年的各种奖学金，
并在大二就以综合素质全系第一名的成绩就拿到了学院唯一的国家奖学金。
大学四年时光，整整两年没有回过家，不是在实习就是在兼职。
保研曾在某985院校复试排名第一，最后以排名靠前的成绩保送至浙江大学计算机硕士。
本科毕业前实习过多个大厂，拿到字节跳动，网易等多个大厂offer
......
我知道我其实算不上计算机系最厉害，最努力的同学，
但是当我毕业后看到这个知乎上的这个问题，
脑海中回想到当年那么努力的自己，心里是真的如翻江倒海，五味杂陈。
一个从十线小城市出来，
没有优渥的家境，没有过人的天赋，没有从小就受到精心的培养，良好的教育的普通人，
要么拼命努力
，
要么自暴自弃
，好像就没有其他选项？
平淡无奇的普通人，拼不了爹，拼不了妈，只能拼命。
大学计算机系的同学努力一些的，要么只专注于比赛论文成绩绩点，保研出国，要么只专注于计算机技术毕业拿到大厂offer。像老学长这样两方面都有一些经历的，应该是比较少的人。
同时一路走来，我也踩过不少坑，走过不少弯路。既然问题是如何学习的，那么我也作为一个过来人，给计算机专业学弟学妹们写一写计算机专业学习的一些经验。我会从校内学习，尤其到校招各个技术岗位的求职学习都抽空写一写，无论你现在是大一研一还是大四研三，真心希望下面的内容都能帮助到你们。
一、说在开头，计算机真的是一个努力可以改变命运的专业
首先相比于其他大部分专业，我真的觉得计算机计算机是真的可以通过努力改变命运的专业。
其他大部分的专业，大学里主要的优秀就是学好专业的课程，取得一个优异的成绩，然后再参加一些专业相关的项目比赛，或者本科能有一些科研论文，就足够代表这你在学校内很优秀了，毕业无论找工作求职还是继续升学深造都足够了。
但是计算机专业真的特别不一样。
计算机专业技术岗位的求职几乎跟校内的成绩没有什么太大的关系，
甚至可以说校内的学习成绩对于找工作来说几乎真的没什么用。
产生上述现象的原因，
就是国内的计算机专业课堂上所传授知识，跟企业里的面试官要求的标准相差太多了。
甚至计算机专业还会出现很多奇葩的现象，就是成绩比较不错的同学反而求职并不成功。
我甚至见过一个985大学，计算机科班，专业里排名前几名的女生，面试连一个最基础的二分查找都写不出来。成绩单上门门课程都写着90+，但是具体一些技术内容完全都回答不上来。
但另一方面，我还见过有的同学，大学几乎不上课，挂科无数，学校里所有的活动都不参与，只专心低头学技术。最后毕业的时候成功拿了很多大厂offer。
于此同时浙江省有很多双非本科的学校，ACM校队实力超群，每年都会有很多能力超强的选手在ACM编程比赛上摘金夺银。但是尽管他们并没有非常牛的学历，甚至有些选手校内成绩也一塌糊涂，但是并不影响他们大学里提前早早的苦学技术，看面经，毕业找工作时疯狂收割offer，甚至本科就可以进入谷歌微软等知名外企。
这里额外提一下，原来有太多的计算机专业的同学不知道什么是
互联网校园招聘
，更不知道
面经
是什么东西。
面经是指很多其他同学在互联网校园招聘中面试各个互联网大厂的
面试经验
，面试
真题总结
。
面经对同学们来说简直太太太重要了！！！
是同学们复习准备互联网校园招聘面试的关键法宝。
你首先要知道互联网校园招聘面试重点问了什么？你才能有针对性的准备吧！！！
有无数同学都来问猪学长：不知道互联网校园招聘技术岗位面试都问什么，面对计算机厚厚的书籍不知道如何阅读，侧重点在哪里？
这些问题都能在面经中找到答案，
里直接分享给同学们：
同时猪学长还要额外说一下，推荐大家去多看面经，并不是让大家只看面经，死记硬背面经，投机取巧。这种只简单被面经的同学面试也是无法通过的。面经只是大家学习的一个参考。还是要踏踏实实的去多认真学习技术，多看优质的官方技术文档、书籍、博客。
也正恰恰因为如此，计算机专业也是不限出身，不看成绩，最可以通过努力改变命运的专业。
金融行业一直流传着一句非常有名的话:
清北复交以下无金融
如果你是金融专业，普通本科的同学，
那么毕业很难进入头部金融名企去工作，而只能是去卖保险推理财。
但是计算机专业这些年来双非本科进大厂的故事每年都在上演，只要你肯努力，一定会得到回报。
二、掌握信息源，打好基础的大一
我的大一在其他同学还在游戏中疯狂战斗的时候，我做了
两件
让我整个大学受益4年的事情。
1、结识了很多优秀的学长学姐
物以类聚，人以群分
如果你认识很多优秀的人，你自己就会慢慢变优秀。
到了大学的时候几乎每个人都会迷茫，我也是一样的。
但是迷茫的本质是你没掌握到足够的信息。
我的开头有写到我在大学里非常非常的努力，做了很多很多的事情。
但是这些的前提是你首先要知道要了解这些事情。
我在大一的时候，也跟所有普通的新生一样，
面对崭新的大学生活，各种各样眼花缭乱的社团，并不知道在大学里该做什么。
这时候我选择走出寝室，去多结识学院里很多优秀的学长学姐们。通过一两个月的时间，我就发现真正厉害的学长学姐们都特别的忙碌且低调，他们一般并不在各个社团里抛头露面，当什么部长团长，而是都把时间投入到非常重要的事情上。但是，当你真的找到他们向他们请教问题的时候，他们都非常的友好热情而且热心，告诉你很多大学里关键的事情。
我在大一上学期的时候就认识了我们学院当时大三拿到国家奖学金的优秀学长，并向他请教很多经验。很早就知道了
国家奖学金
的评比条件，准则要求，大学里有哪些比赛含金量非常高需要参加。同时我在大一的时候也认识了
保研名校
的优秀学长，早早的在其他同学还不知道保研是什么意思的时候，学长就给我分享了当年他们那届的保研文件，对里面的要求细节了如指掌。
也正是因为我在大一就知道了很多信息，所以我才能早早的准备，因为知道自己不是天才，就只能比别人更早的行动！
每次评奖学金的时候，当你刚刚知道别人申请表上有某个荣誉的时候，有可能他一个月前已经出结果拿到了，三个月之前已经去参加比赛了，六个月之前就开始实施准备了，一年前已经提前知道了。
掌握信息很重要。
2、大一就开始早早刷题，打下了扎实的算法数据结构基础
我看了这个问题下面的很多回答，都推荐了很多各种各样的巨厚无比的计算机类书籍或者非常高深的项目。但是我觉得对于计算机在校的学生来说，首先最关键的就应打下坚实的编程功底，提前尽早扎实的掌握算法与数据结构基础。
说大学
：如果你大学里想要超过很多同龄人，在成绩比赛等加分方面超过别人，大学计算机专业里有非常多程序设计类比赛都是非常有含金量的。如果你能在大一就多刷一些题目，打下坚实的编程基础，绝对可以让你在大二大三在各种别赛中崭露头角，最后大学里各种评奖评优奖学金都不是梦。
说深造
：如果你有意向大学毕业进入高等学府继续深造，那么无论你是保研还是考研。现在国内著名的计算机高等院校复试均有上机
在线编程
考试。无论你大学里成绩多优异，无论你考研初试多高，研究生复试机考永远是你不可避免的一关。大学里热爱算法，热爱编程刷题很多的同学们，往往都会在机考中取得优异的成绩，甚至可以弥补你初试分数低的不足。学长还见过大学里非常优秀的其他同学，就是因为只注重考试的分数，疏忽了对自己编程能力的训练，最后导致复试机考爆冷，与自己心仪的大学失之交臂的。
说工作
：随着国内互联网行业的发展，对编程人员求职者编程能力的考察越来越重视。如果你以后希望去外企工作，你会发现外企非常注重对求职者算法与数据结构基础，编程能力的考察。国内互联网早些年可能不会要求职者面试时编写程序，现在几乎各大公司面试都会模仿外企的模式，考察求职者的编程能力。很多面试题背很多，很多开发框架了解多少，面试造的火箭对你以后做的工作不一定影响很大，但是你的编程功底是否扎实直接影响了你以后的工作效率。如果你没有通过编程题目的考察，几乎很难通过心仪公司的面试。
自己虽然不是ACM选手，但是也同样深知打好扎实的算法数据结构基础的重要性，在大一早早的就开始刷题。让我之后在大学中的各种程序设计类比赛，保研复试机考，大厂求职面试都受益匪浅。
说完了重要性，那么该如何做呢？
学长之前在工作闲暇之余随手回答过一个关于编程的问题，没想到帮助了很多的同学，收获了800多个赞同，这里我就不重复写了，如何做可以看一下这个：
猪学长这里分享给大家一个谷歌学长精心整理的LeetCode优质的题解小册:
里面详细的把LeetCode热门的高频面试题目按照知识点做了分类整理，同时给出了最优的题解！有需要的同学记得保存起来，日后一定会用到。由于内容太多，下面这里查看：
二、没有休息的大二
回想一下大二的我，好像真的没太休息过......
我们大学中大二的课程是非常非常满的，因为自己大一就定下了要拿国家奖学金的目标，所以在专业课程方面丝毫不肯松懈，不仅不能轻易翘课，就连平时作业都需要尽可能的都高质量的完成。与此同时我还给自己计划安排了大量的校内项目，国内比赛要参加。
我是一个非常喜欢早睡早起的人，我的本科室友们都是会玩游戏到很晚，早晨起得也晚。我为了不打扰他们，同时又不让自己懒床，我天早晨都定两个闹钟。
一个是手机振动放在枕边:
一个是金属闹钟放到床下桌子上：
闹钟设置成05:30, 手机振动设置成05:20。
这样每天就能05:20被手机振动叫醒，同时因为10分钟之后，床下闹钟就要响了，自己还不能贪睡。这样就能做到，既让自己早起，同时又不打扰到室友。
同时起床之后洗漱完毕，我也会静悄悄的收拾好书包，然后迎着6点的清晨第一个冲到自习室。几乎大二的无数个日子每天都是在这样的晨曦中开始。
因为自己要参加很多的计算机类比赛，大学中的比赛主要就分为程序设计类比赛与软件设计类比赛大类。
算法比赛方面:
自己在大一打下一定的算法基础之后，大二又阅读了很多算法相关的书籍:
比如非常经典的
刘汝佳
的紫书,第一次学习这本书简直太爱不释手了，里面有大量的精彩的高频算法题目的归纳与精彩的讲解。记得当初非常认真的去复现里面好多的题目，然后跑去oj平台上去提交。
还有蓝书，有一段时间我对图论相关算法特别痴迷，觉得紫书里面题目还太少了，就买了蓝书去专攻图论相关算法题目。另一方面也是为了后面要参加的算法比赛做准备。蓝书里面有大量的不同算法专题的ACM经典例题与讲解！
巫神的挑战程序设计竞赛，这本书也是非常棒的！里面分为不同章节，由浅入深的介绍各种算法。最关键的是，里面给出的很多算法模板都非常非常的经典。是一本不错的算法比赛学习书籍。
其实此刻在写这些的时候，回想当年的自己也是觉得走了不少弯路。当年因为我本科学校是垃圾弱校，学院根本没有ACM队伍，其实上面这些书籍的内容有些偏深了，比较适合ACM选手。但是作为普通的计算机专业学生，我当初花了好多精力练习的很多偏深，偏难，偏怪的题目其实后面也不太常用到了。还不如多刷刷LeetCode实在hhh。
然后还有剑指offer
很多同学发私信给猪学长求上面这些计算机学习的
书籍推荐
以及
字节、阿里、腾讯
的校园招聘面试
面经
，这里先分享给同学们：
点这里, 计算机优质书籍项目免费推荐分享！
大厂高频校招面经合集免费分享，点这里！
我是在大三时候才知道
剑指offer
这本书的，其实上面的那些ACM级别的算法书我都阅读过之后，剑指offer其实就有些更偏基础了，好像60多道题目，都不算很难。
在这期间，我一直活跃在各个oj平台上，然后积极参加各种算法比赛。我贴我一直比较喜欢，一个冷门一点的oj:
哈哈当年的账号都已经找不到了。
项目比赛方面:
同时因为项目比赛我不太喜欢依靠别人，抱别人的大腿，所以一般我都是自己一个人是队伍中的主力。
大二那一年我涉猎了非常多的不同方向的软件开发技术，几乎比赛需要什么，我就立刻学什么，然后就开始上手开发。
搞过Qt，当时看的是这个，顺手也把c++期末大作业给搞了。当别人的c++大作业还是控制台的某某管理系统的时候，我用QT写了一个3000多行的带图形界面的桌PC端软件，老师直接就给了我98分的成绩让我印象非常深刻。
玩儿过Android ，为我当时还在上小学的小弟开发了一个数学算数训练小游戏的App。同样不仅参加了一个小比赛，而且同时还作为了java课程的期末大作业。我记得当年好像是用安卓写了一个小的游戏机app，里面有别踩白块，
汉诺塔
等几个小游戏。现在app已经找不到了。
上面这些书籍与项目如今都免费分享给同学们：
计算机优质书籍项目免费推荐分享！
然后同时写过web，搭过电商网站......
这其中有的是自己对技术感兴趣，有的是项目比赛需要。
回忆起来最有趣的事情，是我曾经还花了一个通宵的时间写了一个游戏脚本，30元一份的超低价，一晚上卖出去
500
多元，后来才知道贩卖游戏脚本不合法，吓得我赶紧就收手了。
哈哈哈，但是我当时一晚上写游戏脚本赚500块钱的事情还是在学院里传了很久。
悲催的期末:
因为自己要参加的比赛，项目太多，有时候当比赛与期末考试周赶到一起的时候，简直就是如噩梦一般的存在。
单片机期末，通宵到天亮。
还记得当初大家都觉得单片机好难好难，我好像是全班为数不多把功能都实现的。
终有收获:
我只记得我大二那一年课真的是巨多巨多，然后真的是好忙好忙。但是努力的付出终究是有结果的！！！
长风破浪会有时，直挂云帆济沧海
当大二下学期结束，大二一年的成绩几乎满绩点4.0，同时辛苦很多时间参加的非常多的比赛都有了收获。
然后终于等来了我们那年的国家奖学金的评选。
按照当年我们学院的规定，学院每年有四个国家奖学金名额，大三学生分配三个名额。只分配给大二学生一个名额。
我当时怀着忐忑的心情像辅导员提交了申请表，因为当时并不知道系里其他同学的实力情况如何，自己能否当选。
当评选结果公布，我在公示栏上看到了自己名字的那一刻，
我感觉一切的付出都有了结果。还清楚的记得当时每个公示的时候，我的个人信息是跟三名大三的当选的学长学姐并列在展览栏里，我大二的履历栏里的经历就和他们大三时候一样多。
那时候我才发现，我用两年的努力，做完了他们三年的事情。
三、说好""休息""的大三？
当我踏入大三年级的时候，我的成绩已经在专业排名里比较靠前，综合素质排名全系第一。虽然我们学校非常差，保研名额不是很多，但是只要自己大三正常上课，自己不作死，几乎保研是十拿九稳的事情了。
因为自己真的大一大二太辛苦了，同时也实现了拿到国家奖学金的这个目标。自己原计划在大三可以休息一下。
但是学长得知的一个消息，彻底改变了我的整个大学轨迹。
因为我本科的学校是一个垃圾本科，没有很多985名校那些学生自带光环的学历。
之前一直觉得这样的学校是不可能有机会进入阿里腾讯这样的大厂的。
但是自己大三的某一天突然得知，自己上一届有一个一直非常低调的学长毕业拿到了阿里巴巴的offer。
自己永远记得当时自己那个惊讶的程度，在那时的我眼中，垃圾本科学校跟阿里腾讯这样名企是根本毫无关联的事情。
然后我就详细跟这个学长请教了好久好久，那个学长人非常非常好，耐心的跟我说了好多他的经验以及准备过程。
那时候我才刚刚知道什么是互联网校园招聘，什么是大厂求职面试，什么是秋招春招，才发现校招技术岗所考察的东西跟学校里学的东西几乎完全不一样。
自己虽然是学校里“成绩优异”的好学生，但是竟然与企业里要求相差甚远。
同时学长也告诉我，去大厂实习非常的重要，不仅可以学到学校里学不到的企业里真正的研发技术，同时还可以作为简历上很大的加分项。
然后我的大三就开始又放弃了休息，再次开始进入疯狂的模式，
我时隔好久再次又在大三走进了考研自习室......跟着所有大四考研的学长学姐一起，他们准备考研复试，我开备战大厂的实习。
我在大三上学期花了
三个月
的时间，每天早睡早起，除了上课以外，放弃所有的课余休息时间，复习准备冲刺。
看了
无数本
重要的技术书籍，学习并跟着做了
好几个
比较优质的项目，在
csdn
上写了
400多篇
读书笔记，刷题笔记，
首先最开始的时候，
我先通过校招面试题了解到，原来想要面试一个大厂技术工作岗位，原来需要在一个方向上深入的精通，而不是像自己之前那样瞎搞，所有方向都会一点儿，并不深。我就开始锁定的方向上大量的，先结合面经，然后深入的看很多很多的书。
因为计算机相关书籍实在是太贵了，就一本一本的去网上寻找电子版的。你们可以看到我的截图里，每个书籍前面都标明了页数，这些都是我自己认认真真阅读过的书籍，并不是像其他人随便搜集到的资源。
然后项目方面，我花了好几百块钱在某宝上买了很多的优质的项目课程：
上面这些书籍与项目如今都免费分享给同学们：
计算机优质书籍项目
免费
推荐分享！
然后这块真的是采坑太多了！！！
网上好多的卖项目资源的都是骗子，买到手里之后发现项目都是非常差的那种，技术也非常落后。
这块真的是踩了好多的坑，浪费了不少的钱。最后终于找到了一些跟自己方向一致，比较优质的项目。
上面的每一个我几乎都是先点进去大致了解，然后最后挑选出最好的几个项目自己深入去学习，同时在电脑上配置相关环境跟着实操，以此来充实自己的简历。
然后开始准备在网上投递简历，寻找实习。
原本以为普通垃圾本科的我不可能又大厂会看上我的简历，真的没想到在投递后，竟然有很多公司的hr电话联系了我，其中还有很多大厂。
在之前我那个时候，好多公司的日常实习还都没有远程面试，都要求必须去现场面试。
因为联系我的很多公司都不在一个城市，我只能选择面试机会最多的城市跑过去面试。
最后在大三上学期结束的那个寒假，其他同学都回家过年的时候，我放弃了回家，自己一个人跑去了北京面试。
原以为自己能找到一个实习就很错了，但是真的没想到最后经过了非常多公司的忐忑的面试后，自己竟然几乎全部通过了，其中还拿到了多个大厂的offer！！！
那时候我刚刚大三上学期......
当人生中第一个offer进入我的邮箱的时候，我真的不知道我的人生从此被彻底改变......
千淘万漉虽辛苦，吹尽狂沙始到金。
四、后记
别人的人生我不了解，至少我看到的世界里，我周围所有的同学，同事，小伙伴们都是: 
越优秀
的人越懂得
努力
，越极度的
自律
。
但是如果你能看到了这里，透过我的大学经历你会发现，不仅仅只能低头的努力，越早的掌握信息，越早的找到努力的方向，是远比努力更重要的事情。
知道怎么做远远比低头去做更重要。
同时你也会发现我的大学里也走了不少的弯路，我是少数既花时间在国奖保研上，又拼命找工作求职的。在计算机专业这是两种截然不同的维度。
如果你在大一就决定今后想要去国内外更好的学校读研深造
，那么你就应该像我大一大二时候，早早的掌握保研，考研，留学相关的信息。像我大一大二那样努力的搞好成绩，然后了解清楚学院内评奖评优的各种规章制度，制定好计划，去实施！
如果你决定毕业想要早些工作
，那么计算机专业真的是一个不看出身，甚至连专业都不看的行业。你只需要早早的关注求职，校招，面经，岗位等相关信息。早早的出去实习，学校里的很多无意义的事情，甚至成绩你都可以不用关心！毕业的时候拿到bat大厂offer不一定是遥不可及的事情。
在我后来的读研以及毕业后工作的期间，无数的学弟学妹们都来问我许多非常经典的问题:
我的学历不好，不是985、211有机会进大厂吗?
我本科专业并不是计算机的，有机会进互联网公司吗？
等等......
我在多家国内头部互联网大厂，跟无数面试官聊过，在校园招聘中，
几乎没有一个技术面试官会因为学历专业出身去歧视候选者。
互联网技术面试官就是会认真的去考察候选者的真正实力。
985/211计算机科班硕士毕业拿不到大厂offer的人比比皆是，
双非本科逆袭进大厂的故事每年都在上演。
我知道有很多
学校非常差
的同学，
有的在ACM赛场上挥洒汗水艰苦努力，有的甚至早早的就在大二从学校溜出来去大厂实习的。
而还有的同学身在
985
甚至
C9
这样的计算机名校里，
昏天黑地
，
游戏里激情人生
，
浪费四年
，
一无所知
。
都已经毕业了，待在家里的时候才开始到处投简历。
无论你现在处在任何阶段，如果你能看到老学长的这篇回答，同时还真觉得有收获，
放下手中的手机，关掉电脑中开着的游戏，好好对未来规划一下，我觉得一切都还来得及。
最后留下一句我一直特别喜欢，一直用来鞭策自己的一句话，送给大家:
10698字
....我吐了....就先写到这里吧.....手好酸.....
到这里
10698字
都看完的同学，如果觉得有收获，不要只偷偷收藏
白嫖
猪学长， 给猪学长留一下一个
赞
呀，这样也可以让更多的小伙伴看到呀！
后面老学长的经历还有很多很多，
保研读研，校招求职，方向专业，工作经历
......之后有时间再更啦。
五、赠人玫瑰，手有余香
上文中提及到的所有
技术书籍
，
项目课程
，
校招优质面经
我之前一直都有认真整理，其中有很多某课上的优质课程是我曾经花了很多钱购买的，现如今也已经毕业啦，都分享出来直接分享给有需要的同学们。
如果同学们还有其他什么问题，欢迎在评论区给我留言呀，不忙的时候我都会回复的。
然后所有对字节跳动实习，或者求职感兴趣的同学，
想找学长内部推荐的，也都统统都可以联系猪学长，记得点一个关注呦 ","大概有三个时间点。
第一个是很久以前一个宁静的下午，我对着电脑屏幕发呆，因为我被分配了一个和地球正对面的团队合作的任务。而该团队代码之烂罄竹难书，回复速度之慢让我时常感到便秘。我还没有权限去check in代码和部署测试环境。一筹莫展之际我想干脆先去看看他们代码库把逻辑理清楚，之后能调试了改起来也快。
没想到我看懂了。一个破request在三个service之间弹来弹去的路径和副作用被我一下午读明白了。
当时我喜悦的心情约等于解了十个复杂的bug。
在这之后我打开了一个新世界的大门。无论是工作中的代码还是开源代码，各种工具库，系统底层，想看就看。
能够脱离调试环境深入理解代码这个能力的达成条件是长期
独立
解大型代码库中的复杂bug，磨炼自己对代码的感觉。有些答案说写代码是没有肌肉记忆的，有些答案说写代码是没有熟能生巧的，这些我是不同意的。
学习编程即使走对了方向，也仍然需要大量反复的磨砺才能达到一定的高度
。如果一个人还不能无障碍阅读代码，我是不承认ta有较好的代码能力的。
阅读代码的能力大概需要四到五年来培养，天赋较好的情况下，科班出身毕业一两年就应该已经有很强的阅读能力，而转行的在入行五六年左右也应该能够有这样的能力。
如果能大概一周时间在没有文档辅助下，允许每看懂几步去调试一下验证想法，能看懂
Cassandra
的写路径是怎么工作的，那代码阅读能力就算合格了。之后无非是更加娴熟和自然的问题，如果跨不过这道坎，那就还欠磨练。
第二个时间点是第一个时间点之后三年的一个冬日。
以前写代码的时候我都倾向于听Two Steps From Hell这种比较激昂让人想要骑狗上战场的音乐，沉浸在一种纯粹的释放的感觉中――因为我编程多数情况下实现只是在已经想好战略后的即兴创作。有几次一下午写千行上下的代码，十分酣畅淋漓。然而这一次，我突然想听Richter的悲伤小曲。
那一天我仍然写了很多代码，几乎重构了整个service。当我提交
code review
的时候，我很清楚地知道我的代码能力又提高了。因为我不再过多依赖我的直觉，而是有心地去衡量代码层面的权衡取舍。再去看之前写过的代码，有质朴的严谨和小聪明，却缺少了精巧有心的取舍和大智慧。
换句话说，从前我知道如何不写坏代码，但是这之后我知道怎么写好代码了。
这方面的磨练大概就是需要不断的review别人的code和被别人review，逐渐能够站在不同角度去看问题。同时阅读大量的生产代码以及
开源项目
也是必要的。“不坏的代码”是一个很大的解空间，要在其中选出“好的代码”来写，是需要持续的努力和耐心的。这里特别感谢当时的同事东欧大哥，他不留情面的code review和耐心跟我讨论我的review意见的过程使我受益非浅。
我在早年学习编程的时候读过
《重构》
这本鼎鼎有名的著作，它教会我如何不写坏的代码，并且能够把坏代码变成不坏的代码，对我影响深远。后来我读了一本叫做《
A Philosophy of Software Design
》的小册子，让我开始了对好的代码层面的设计的探索。
这里特别说一句，我个人是不喜欢
设计模式
这种分门别类的玩法的。我对它们的态度是去理解，但是实践中仍然从
高内聚低耦合
，可读可维护的原则出发思考代码结构。因为写好代码是一种在利弊之间权衡取舍的有创造性和艺术性的活动，抱着教条写不好代码，只能写出教条。
第三个时间点主要是涉及到对分布式系统的理解，因为题主问的主要是编程能力，所以就不细谈了。这部分主要是读书读paper以及读代码，动手推公式，动手写
prototype
。
最后强调一下：即使方向选对，即使平台不错，不下苦功，靠投机取巧，写不好代码。","当时我还在学
微电子
，我调查了一下比我高几届的师兄的就业情况。
然后我的编程水平就突飞猛进。","那是一个很普通的下午，第一份工作。当时的上司把我叫过来说：这块的逻辑这么简单，怎么写了这么久啊。我来带你写一遍吧。
接着，他一步一步讲解，边讲边写。先把他想的思路告诉我，然后就直接动手写，卡住了就再退回去重新想，其间不时我也会有疑问，他直接回答。写完了又review了一遍，把能优化的地方优化完并把格式排版好看后，提交，搞定。
整个过程让我明白了，实际项目中的编程和大学里做题做作业是完全不同的：
好的逻辑需要设计；
好的数据结构也需要设计；
debug是最平常不过的事，不是每个人都能一次性写对；
好的代码不是一口气写完，也是需要迭代和优化的；
结对编程是最好的教学/学习方式。
编程实际上是一门设计的艺术，如何把现实中的事物抽象成二进制考验的是设计功力。经此一役，好像打通任督二脉一样，后来的学习都一马平川无比畅快。同时还学会了一句很经典的名言：
A language that doesn't affect the way you think about programming, is not worth knowing.――Alan Perlis
如果一门计算机语言无法对你的编程思考方式产生影响，那么它就不值得你去学习。
PS：看完下面的视频记得回来点赞。
告诉你什么叫结对编程 [开眼Eyepetizer-150401期]_哔哩哔哩 (b-b)つロ 干杯~-bilibili
?
www.bilibili.com/video/av3987709/"
,,,,,,,,,,,,,,,,,,,,,
编程新手如何提高编程能力？,本人国内某重点大学渣渣专业大一在读，专业对编程要求较高。大一刚学编程（C/C++），感觉有点吃力，求指点。我们平时练习都是做的OJ(老师负责选一些题让我们做，也可以自己随便刷），一些题还好，可是有些题难度感觉很大，有时好不容易有了思路，转化成代码都要老半天，别人一个小时就搞定的事情，我可能要花三四个小时，而且我本人比较粗心，经常被一些小错误坑了很久。最后就算千辛万苦地做出来，感觉也不值得，毕竟时间消耗太大。还有些题一些思路也没有，但是其他人（也是新手）就能搞定，基本就是别人过10道我过7道的水平。这个时候就会发现智商上的差距真的无法弥补。所有这一切，都让我对自己的前途产生了怀疑，这样下去，我可能只是一个中等水平的苦逼程序员，无法进入顶尖行列。我知道会有人叫我说要努力，可是怎么做？刷题？想看个答案都找不到？问人？哪有那么多人闲着没事干，而且解答正确，使你能够理解？做产品实操？写个两百多行的代码就已经快乱得不行了，不行。看书？终究只是纸上谈兵，没有实际操作的感觉。求救各位大神指点迷津，看看本人是否要转专业？（补充说明，其实我对IT还是比较有兴趣的，特别是人工智能和图形学（游戏开发），也有过很多好的app点子但苦于能力低无法实现。数学自我感觉良好，主要是初高中搞过点数学竞赛，成绩也还可以，所以基础算是比较扎实，但是不想去数学系。）话说回来，我没什么理想和目标，可能还在寻找中吧。总之，请各位提出点建议，关于大学的任何方面都行，学习、生活、理想、交际（谈情说爱的就算了），指点迷津，先谢谢各位了。,"学习编程, 既要考虑诗和远方, 也要考虑眼前的苟且。
每年像你这样的学生不计其数，大一刚进校，一门C语言，学校发一本垃圾C语言教材，按时上课，老师在那里念念PPT，讲讲浮点型变量，
malloc
啥的，你若认真听了，那你可能懂了，但是发现不会写，你若没听，玩手机了，你是既不懂，也不会写，上来上去，蒙在鼓里的人出不来，水平就一直这样，龟速增长。
有的学生学的一头雾水，开始怀疑自己，准备转专业，放弃计算机，有的学生学懂了，写程序一直报错，开始怀疑自己，有的学生觉得教材写得不好，去书店转了一圈，买了三四本C语言的书，但最后厚厚的灰尘盖在了书上，再也没翻过。
这三种学生，如果继续这样，最后都要凉凉。
马克思教给我们要具体问题具体分析，那我今天就来分析一下，计算机专业的学生，到底应该怎么学计算机，才能效果最好，进步最快。
如果你要学习物理，我推荐你顺着物理的发展史学习，先学习牛顿经典物理，再学习热力学，电磁学这些不那么经典的，再学习相对论，量子力学这种彻底推翻经典物理的，再学习
量子电动力学
这种硬核的，比较前沿的，整个学习过程，是
自底向上
。
但是学习计算机，真的适合这样吗？
先学习电路，
冯诺依曼结构
，造一台计算机？然后再用
汇编
写个小操作系统？写个小编译器？最后一步一步往上走，最后开始用高级语言编程？
你要是这么学，必然爆炸。
计算机的学习最好应该是
自顶向下
。
这个顶，顶到什么程度？
有人说，C语言就是高级语言了，从C语言开始学就好了。
但是如果让我教计算机，我第一节课教学生们的，绝对不是C语言，而是教大家如何使用
Github
，
Stackoverflow
，告诉世界上正在发生什么，程序员之间是如何协作的，告诉你在这个大社区，你可以读到这个世界最牛逼的程序员写的代码。
我还要告诉大家如何使用
云服务
，告诉大家可以买一个一个月十块钱的学生服务器，自己做点有趣的事，我还要推荐大家去用
Visual Studio Code
，
而不是简单粗暴的在机房装一个VC6，或者
CodeBlocks
，美其名曰，“我们当年用记事本还XXXX，现在的学生被惯坏了”这种话。
如果可以，我还会教同学们如何科学上网，让英文编程环境成为习惯，让遇到问题google，而不是百度成为习惯，让大家在第一节课上完，就能进入这个世界编程大社区，哪怕什么都不懂，你也能保证所在的社区，就是世界程序员的大家庭当你进入Github，看着各种有趣的项目的时候，相信我，你的视野就会在此为起点，快速打开，不断增长，进入一个良性循环。
而当刚上大一的学生第一次进入
github
时候，被眼前的各种没听过，没见过，但感觉很厉害的项目所吸引的时候，当他两眼冒光的时候，我就知道，他这四年，成了。
有人会这样说我：
“Github还用教？刚才你说的那些学生，如果能被C语言的困难打倒，那他也不适合做程序员，转行正好。”
像这种话，我想说，在很多时候，佛和魔仅在一念之间，你在最开始的时候点到了，给了他引导，他以后可能会马上进入一个正反馈状态，如果你没点到，马上可能就负反馈了。
我一直觉得国内的计算机专业的学生很可怜。
当
VScode
表现越来越优异的时候，学生们还在机房用着VC6，看着密密麻麻的报错无可奈何。
当Google搜索可以精准定位你的问题的时候，学生们还在为百度搜索出来乱七八糟的搜索结果无可奈何。
你用百度，用中文搜索，你连
stackoverflow
都搜不出来。
但是你可以去问问，做一个调查，有多少大一结束的学生，没上过
stackoverflow
，不知道怎么在github里提交issue和pull request，你统计一下，看看这个比例有多大？
你再统计一下有多少比例的大一结束的学生没用过google，并且对其用不了的原因不太清楚？
视野打不开，一切都完了。
有人说，刚开始直接学了python这种很简单的高级语言，以后遇到C肯定被吓跑了。
事实恰恰相反，在你了解到python的性能问题时，你才会了解python是
解释型语言
，C是编程型语言，你才会思考为什么C更快，进而，如果需要用C，去学C。
在你在编程语言中涉及到了“原子性”，“同步”，“异步”，“线程”，“进程”，“内存分配“等概念的时候，你会自然而然地产生很多疑问，进而去学习操作系统，在学操作系统的过程中，你之前的一系列疑问逐渐被解决，这个过程是很爽的。
当你发现某个算法，人家的实现比你快很多的时候，你会自然地去思考，为什么我的程序运行这么慢，然后发现对方用的数据结构与你不同，甚至用了一些算法，比如
动态规划
等，这也会驱使你去学习算法，学习数据结构。
有了需求和疑问，再去学，这样一个过程，是学习的
金钥匙
。
你指望学生自己打开视野，但是那些自己打不开，需要你帮忙开下门的呢？
在你的视野被打开之后，我还希望你懂这些：
比如你学C语言，与其去做那些OJ题，不如在github上找个C语言项目，然后阅读，理解，修改，模仿。
个人认为在知识爆炸的年代，两不要：
学个啥都要买本教材，试图线性地，从头读到尾。
（真实情况：经典教材都能下载到免费pdf，语言，框架，文档往往已经写的很好，而且最新，github上有无数优质开源学习资源）
不读优质代码，不参考最佳实践，啥都要自己从头开始搞。
三个要：
要读文档，英文文档
做知识输出，用文字总结自己的学习内容。
多用命令行
我曾听过一种论调，说程序员不会用命令行也没关系。
我想说的是，第一，这个世界没有那么美好，什么都要给你做一个图形界面，第二，对于命令复杂，命令多的工具，就算做出来图形界面，往往比命令行更难用，而且命令行可以用命令行脚本进行批文件自动化执行。
两个原则：
有问题，先文档，再stackoverflow，再技术文章
要用实例驱动学习，不要说你会什么，要说你做了什么
我希望所有程序员明白一个事实是，”我会什么”这句话，其实是最没用，最虚飘飘的东西，你说你会java，python，c，
rust
，go，然后呢？你怎么证明？写个hello world？会用
api
？
但是你要说，XX著名项目作者，那你就牛了，我也不需要让你证明什么了。
大概随便说了点，还有很多内容可以补充，先就这样了，谢谢大家。","其实很多人学编程都会遇到困难，我觉得其中一个根本原因是他们没搞明白学编程到底是学什么。
编程不是一种知识，而是一门手艺。
我们从小到大的学习都是学习知识，流程一般是课前看书预习，上课听讲，下课做作业，然后复习考试。但是学手艺可不是这么学的。
我们先拿游泳举例，游泳不是知识，而是技能，也可以算门手艺吧。
需要预习吗？需要上课听讲吗？不需要，因为两岁小孩都能学会游泳，他们连话都不太会说呢，怎么可能听课预习呢。游泳是通过在水里的练习，教练手把手地传授动作，一点一点提高熟练度学会的。
我们再来看看弹琴，学钢琴一定要有钢琴，音乐基础知识也是老师在练琴间隙传授的，并且一定会结合练习，另外练琴时间是很重要的，必须保证一定的练习量，有些理想远大的琴童练琴时间可以用惨无人道丧心病狂来形容。
千万别把编程看作知识，计算机科学是知识，但是编程是手艺。
既然是手艺就要用学手艺的思路去学习。
以动手练习为主，看书学习为辅，甚至极端点，初学的时候除了看必要的文档都可以不看书，等有了一定编程基础后再去看书，看完书立刻动手编程去验证书上的理论知识。
练习一定要循序渐进，把手艺分解成几个简单的动作，反复练习直到熟练，然后再把基本动作组合起来练习直到熟练。拿C语言举例，比如从认真写好一个Hello world开始，然后去熟悉 if  for while 等基本关键字，然后熟悉字符串操作，内存操作，练习查找 排序 
二叉树
等基本算法数据结构，然后学习一个小型Framework。。。。
找个师傅，手艺的一大特点就是自学是很慢的，而且容易走弯路，而有人手把手教要快得多，手艺有很多细节，实际操作经验，需要去体会感受的东西，这些细节书上基本不会有。
坚持做大量的练习，以代码行数为例，每年50000行左右是比较一般的练习量，有毅力的话可以挑战10万行。（有人说代码行数不代表什么，行数多不见得程序就对，写得好的程序代码很少blablabla，滚，去跟朗朗说去，告诉他其实不用练那么长时间琴。）
回忆下自己当年是怎么学会骑自行车，学会游泳，学会打篮球的，按照那个思路去学编程，而不是用你学大学课程的思路去学编程。
记住，编程是手艺，不是知识。
＝＝＝＝＝＝
最后再强调下，对编程能力本质最好的比喻就是弹琴。但是有了编程能力还不能算优秀的程序员，优秀的程序员是作曲家，他们不仅能想出优美的旋律，并且能弹奏出来，就像优秀的程序员不仅能想出优美的算法架构，而且能把它变成可执行代码。你很难想像作曲的人不会任何乐器。
很多人的问题是想当作曲家却不肯下功夫去练琴。
打个预防针，估计有人会举出反例说我就知道某某某作曲家不会乐器（其实真的有）。
我要说的是，等你成了公认的著名作曲家之后再说自己不会乐器，那你牛逼。
在成名之前就这么说那是煞笔。","当你提出这个问题的时候，总有人会告诉你，你应该学习这个，学习那个，亦或者是刷题根本没用，你应该去做项目，亦或者你看这个视频没什么卵用，你应该自己去实现一遍，亦或者是你应该使用xxx框架，xxx语言，做一个xxx系统，这样你才能学到很多。我想说
这些跟放屁没什么两样
。对于一个编程新手，很多事情都是陌生的，即使拿到一个文档，也不知道如何去使用它们。因为根本找不到切入点，找出我该如何入手，万事开头难。
这个问题可以做如下分解，
对象是编程新手，他要提高，提高的是编程能力，首先我们要知道什么是
编程能力
。能把程序写出来就是编程能力高了么，ACM总冠军选手编程能力就高么，他们高，高在解决
脑经急转弯
问题的能力上，这是遗憾的，当然什么是编程能力这本身就是一个很大的问题，这里不做过多展开。
编程
本质就是一门技术，一门手艺活
，最好有老师傅带着你，告诉你这部分你可以先完成，那部分你也可以先入手，一点一点的积累，从小部分做到整体，孰能生巧游刃有余。
但是很不幸，你的生活中不会有这样的老师傅，你
需要靠自己寻找机会
，我把这样的
寻找机会的步骤分为三步
：
疯狂的积累代码量，疯狂的刷题，疯狂的积攒你的自信心。
寻找实习，找到自己感兴趣的地方，跟着别人做，了解工业届到底在使用什么技术。
当你实习结束的时候，你将不会再对那些名词感到陌生，你有了一定的经验，你可以尝试独立的尝试用一些开源框架做一些简单的project。
具体该如何做呢？
当你还是一个
新手
的时候，你需要
疯狂的积累你的代码量
，你可以从基本的问题出发，做一些简单的问题，怎么输入数据，怎么输出数据，然后熟悉各种数据结构，各种常见算法，疯狂的刷题，比如
http://www.
lintcode.com/
 就是一个很不错的刷题网站，不会怎么办！看答案，了解怎么写，然后自己实现一遍。你可以先从easy难度的问题做起，每一个程序也就20-40行左右，甚至你可以一旦AC，反复提交，以增强自信心，虽然这只是一个玩笑，但是它可以让你提高你对编程的自信，对编程的喜爱，当你有自信的时候，你才能真正的把一件事情做好。当你反复解决一个又一个的问题的时候，你要告诉自己我是个天生的编程者！然后你就可以挑战更高难度的问题，当你积累到10W以上的代码量的时候，你会发现你会有一个质变。一切将变的顺手。当以前要想半天的语句，现在信手拈来。恭喜你跨出了很重要的一步。
你该去
找实习
了。当你有了第一步作为铺垫以后，你应该
去业界提高你的编程能力
，这个很重。什么是编程能力，用程序去解决真正的问题，你的程序写的更让人能读懂，这是编程能力，你的程序高效可维护，这是编程能力，你的程序被review的次数很少，质量很高，这是编程能力，你能快速理解一个小项目，小模块在做什么，怎么做的，这也是编程能力。所以你应该去公司，有
mentor
指导你的情况下，去做一些事情，参与到团队中去。同时实习生的面试门槛比Full time会低很多，只要你把第一步做好了，好好的准备面试，拿到一个不错的实习也问题不大（实习生也更容易拿到return off）。
当你
实习结束
以后，
做一下总结
，业界到底在干什么，业界使用的技术到底有哪些，他们平时的编程工具等等这些都是值得你学习的地方，你可以用你学到东西尝试着去做一些简单的project。你会发现原来毫无头绪的事情，慢慢变得清晰起来。疯狂的训练，超强的自信心，去工业界实习一下，你就会明白我要什么，我要为了我所想要的我该怎么做。
-----补充-----
有人问在哪里看答案，这里给大家提供一个看答案的网站，是我觉得比较高质量的答案：
LeetCode / LintCode 答案查询
-----3月21日补充-----
看了评论里有人说，
我在学校老师那里按部就班学不到什么
。我想多说几句，虽然说大学教育和社会有一些脱节，但是并不是所有都是无用的。首先谈一下为什么会脱节，没有一个大学的校长会站起来说我们设置计算机相关专业就是为社会提供码农的。大部分学校的目的都是培养计算机科学家的，只有培养残的，成为了码农。当然这就玩笑的成分，但是的确真正有用的可能20%都不到，就是因为少我们就可以否定么，有一些课是很重要的，它们奠定了你的计算机素养，那些课你不用很深入的学习，而是扩展你的广度。虽然你现在觉得无用，但是不要否定它们的价值。
说说另一个问题
“我需要刷题么”
，如果一个有科研前途的人，我会毫不犹豫的说，停下来，搞你的科研去，不要在刷题上浪费你的时间。但是当你问这个问题的时候，我会毫不犹豫的告诉你，你不适合做科研，你在科研的道路上注定成为一个次品，何不早点做好成为码农的准备呢？刷题不是目的，刷题是一种手段，为了积累代码量， 为了找到实习，为了面试，为了走向业界，为了拿到好的offer，为了打开成为码农的大门，它是简单的，它是适合大部分人的，它适合成为码农的你。如果你还表示怀疑的话，你可以去了解一下，当今国内外各大IT互联网公司是如何面试的，我相信你会有一个明确的答案。
更多程序员相关问题解答，请关注我的
微信公众号
：ninechapter","其实这是新手程序员的普遍问题，如果你中招，我只想说很正常。除了其他帖子里强调的技能锻炼，其实另一个大问题是编程能力测评。
彼得德鲁克
说过一句话：如果不能测量，就没法管理。技能发展的一个痛点就是你不知道自己好有多好，差有多差，学习了一段时间后技能有没有进步。
虽然大学也会诉诸考试，也有厂商的认证考试，但这些测试方法都只能解决评价知识水平的问题，没有办法评价真实的技能水平。交规背的再熟也不能开车上路，
乐理知识
再好也没法弹琴，计算理论再通，跟实际编程能力也是两回事。但编程能力评价一直是编程教育里最难的一环，你看了一本Java书，在线修了一门课，也做了练习题，但还是不知道自己的问题在哪儿。是不会定义问题？数据结构不扎实？面向对象设计不理解？还是基本的查询排序算法用不对？抑或开发工具用得不熟？人学习是要积小胜为大胜，不断自我激励的；问题太多无处下手，造成挫折感，学得没有成就很乏味，所以很多人学不下去，中途放弃了。
怎么帮不具备能力的新手，真正获得编程能力，迈进软件开发的大门？老美一直在寻找一个可量化的科学方法，直到美国
卡耐基梅隆大学
(CMU)计算机系的一个大牛教授Phil Miller带领团队基本解决了这个问题。他们多年来一直对CMU每年参加编程课的1000多学生进行评估分析，研究出了一个自适应学习的RDS模型，并于2013进行商业化，研发了一个通过全自动分析程序代码，对程序员真实开发和操作水平进行评估的智能评价系统。配合这项技术他们在美国和印度推出了一个考试认证，暂时还没进入中国不过应该很快。
都知道熟能生巧，技能是练出来的，但具体练什么，怎么练呢？CMU教授也给出了办法。他们做了一个供学习者练习的
虚拟机
镜像，可以免费从网站下载：
http://www.
proxor.com
。我玩了一下，虚拟机提供了eclipse和netbeans开发工具，一个code base，十几个专门设计的小任务，任务难度是分层的，全套的Java SDK，学习者可以反复练习任务，可以使用环境提供的JUnit test或者自己设计JUnit test进行测试，能把这个学习系统玩熟的，基本编程能力肯定可以保证。大力推荐一下。
最后，不知道卡耐基梅隆大学的，捎带科普一下：他们是美国计算机四大名校之一（其他三个是麻省、斯坦福、
伯克利
），尤其在编程教育方面全球第一，CMMI就是他们做的。还有第一个计算机科学系，第一个
图灵奖
，都是给到CMU的，
李开复
也是CMU计算机系毕业的。","哇，已经有25个答案了，估计我的不太会被看到。。
就针对题主的疑惑说说自己的感想吧~以数字罗列的是我的观点~
-----
有些题难度感觉很大，有时好不容易有了思路，转化成代码都要老半天，别人一个小时就搞定的事情，我可能要花三四个小时，而且我本人比较粗心，经常被一些小错误坑了很久。最后就算千辛万苦地做出来，感觉也不值得，毕竟时间消耗太大。
-----
最近我也在刷，刷 Peoject Euler（
https://
projecteuler.net/
）。第129题我已经想很久了，一点也没头绪。有时候灵机一动，哗啦哗啦写了3，4个小时，最后发现还是错的，就很懊恼。一方面是觉得自己笨，另一方面是因为我在心中给自己树立了一个假想敌：
有一个很牛逼的人，他1小时可以把这题做出来；而我需要5天，那我和他的差距不就越来越大了么？！
可能这感觉在遇到挫败的时候会十分强烈。但我要说：
（1）
懊恼是对的
：它让你明白了自己的不足。这种对自己不足的羞耻感和不愿再无知下去的上进心是我们进步的原动力！
（2）
过度
懊恼是不对的
：编成的事儿大家都明白，我不动手的话，想3天也不会把代码“想”到机器上去。要动手！要动手！要动手！
-----
还有些题一些思路也没有，但是其他人（也是新手）就能搞定，基本就是别人过10道我过7道的水平。这个时候就会发现智商上的差距真的无法弥补。
-----
我有个英国的讲师，是个Java大神。但是！在Project Euler 的第139题那边，我光是讲一元二次方程的求解公式就给他讲了1个小时（本人英语也是相当捉鸡）。最后我做的比他快。如果他也这么想，他一定崩溃了：
为什么一个小菜鸡会比我做得快？！
对此我想说的是：
你怎么知道别人是“新手”呢？说不定人家只是“扮猪吃老虎”（形容看起来很蠢但十分牛逼）呢？
退一步讲，人的经历千差万别，说不定人家以前就做过这个问题呢？
再退一步讲，人家说不定刚好灵光一现呢？
再再退一步，
你就没有比别人牛逼的时候么？
如果没有，就证明别人确实比你牛；
如果有，请狠狠骄傲（一下下）
！
（3）
不要因为一些特例做得不如人，就怀疑自己
：你也有比别人牛的地方，每个人都有。
（4）（
个人观点，存疑
）
对普通人来说，没有智商高低这一说
：所有能用来测试智商的题目都是可以攻略的，所有分析问题的方法都是可以训练的。比如有30题
智力测试
，我智商为0，但我就是恰好知道这30题的答案~~~~
-----
所有这一切，都让我对自己的前途产生了怀疑，这样下去，我可能只是一个中等水平的苦逼程序员，无法进入顶尖行列。
-----
我现在还是中下等苦逼程序员，但我不怀疑我自己，因为：
（5）
刚学习就开始想前途，一定看不到未来
：能学习本身就是一件很愉快的事情，当你从中收获快乐，你就入门了；当你从中无法自拔，你就有未来了。
（6）
进入顶尖行业的人，都是把职业当乐趣的
：有了乐趣才愿意多想多看多实践。挑灯夜读，废寝忘食，孜孜不倦等，吾等当为之敬佩。
-----
我知道会有人叫我说要努力，可是怎么做？刷题？想看个答案都找不到？问人？哪有那么多人闲着没事干，而且解答正确，使你能够理解？
-----
确实好像大家似乎都不太愿意“浪费时间”，而没有答案更是一件令人悲伤的事情，那么你需要：
（7）
找个靠谱的好训练系统
：比如我觉得Project Euler 就还不错（觉得我在打广告了有木有！！），要有知名度，实在不会也能搜到答案的。
（8）
加强你的英文
：我觉得世上好人还是很多，你看你这个提问就有很多回答了不是？大家还是很热心的~（自己给自己一张好人卡。。。）放眼世界，这样的人只会更多，放心，大家不会嘲笑一个心怀梦想虚心求教的人的。
-----
做产品实操？写个两百多行的代码就已经快乱得不行了，不行。
-----
不知道这里要怎么吐槽了。。请大家配吐槽语。。预留空间：
（⑨）
-----
看书？终究只是纸上谈兵，没有实际操作的感觉。
-----
（10）
学而不思（实践）则迷惘，思（实践）而不学则怠
：书看多了确实让人会迷惘：这玩意儿有什么用？   但是！光是写写写代码，会让人一叶障目不见泰山哟。
Coding is not programming
。
-----
求救各位大神指点迷津，看看本人是否要转专业？
-----
我的建议是：
（11）
并没有领略到编程的美而放弃，是一件很遗憾的事儿
：这点通用。假如你转专业去学医，一时半会儿没有进步，你还是会问这些问题，然后再继续转专业？
（12）
不管学什么，会一点编程都是重要的
！很多大学把编程设置成了通用必修课，我很赞成。因为都到这个时代了，你可以不从事计算机行业，但你要有点计算机思维。
最后的最后，如果因为我这个让你坚持下去修成正果了，请一定要记得我哟~祝好！
啊嘞嘞，快下班了！走咯~ 报告组织我又成功安利了一些小朋友进入了程序员大军！
谢谢大家！~别忘了那个吐槽语~","去每天花两小时写代码，去研读各种
开源项目
源代码。
去写技术博客，去蹭技术讲座、会议、公开课程。
去逛Github，去StackOverflow上提问，去论坛上找技术大佬聊天
去参加
软考
，去参加ACM等正规编程比赛。
去尝试自己写一个个人网站，或者开发一个游戏APP。
......
只要你愿意提高代码能力，有无数种方法能帮到你，但你需要让你的意愿充斥整个身体，并相信能做好。
俗话讲，不积跬步无以至千里，新手想要成为高手，疯狂的练习是第一步。
很多事都是孰能生巧，没有足够多练习不要提天赋。
编程应该是最能体验prctice make perfect的技能之一，在前期积累的阶段，往往要大量的去刷题、比赛、模仿，才能显得游刃有余。
资深码农就像是老师傅，哪个不是键盘敲到发白。
可能练习不一定会让你完美，但大量的练习会让你产生
髓磷脂
，一种神经元外侧的脂质，能让你的脑回路更加灵活。
人的大脑可以分为反射、思考、记忆三个功能，大脑可以通过大量的反复练习让思考演变成习惯，最后跳过思考只需要反射的指令操控就能完成，从而达到“生巧”的效果。
当然作为程序员，练习不是一味的重复，或者去完全复刻别人的代码，每一次练习都应该增加难度，有突破自己认知的成长。
这样经过反复的输入、评估、输出、纠正，你会有惊人的变化。
记得工作第二年我和组里同事一起参加某个交通数据科学比赛，根据历史数据预测未来车流数据。
为了找到好的算法模型，我高强度地开始使用google，翻遍了kaggle、
stackoverflow
、github等编程网站，也看了很多相关的交通车流论文。
前前后后代码写了有上万行（包括数据探索、新老方案），比赛后发现自己在编程和算法上比以前通透了不少，也知道哪里有宝藏，哪里有大神。
这是我编程能力第一次开始突飞猛进，发现编程真的是一门熟能生巧的手艺，不管是比赛、项目、习题，哪怕是抄代码（初学），都会让你快速进步。但真正想要成为大佬，还得要勤于思考，不然久而久之会变成没有灵魂的代码机器。
以学习Python为例，有很多网站可以提供练习精进的资源。
Github
Github是全球最大的代码托管网站，也是Python资源最多的网站。
各种Python相关的教程、开源项目、技术书籍、数据资源层出不穷，比如说大名鼎鼎的
pandas
、django、tensorflow、pytorch、requests等都在github上有开
源代码
。
还有诸如awe-some python、Python-100-Days、ML-For-Beg
inne
rs等这样的资源教程，有十几万的star，非常适合初学者去学习。
你用Python关键词搜索，会出来300多万的相关仓库，足够你花一辈子去学习。
牛客网
牛客网是国内很火的免费刷题网站，上面拥有众多关于Python的面试真题，也有适合小白初学的训练题。
Python练习题不仅包括语法，还有数据分析、机器学习、爬虫、可视化等
你可以在牛客网上的编程环境里写代码，无需自己安装Python软件，非常方便，可以试试看。
kaggle
Kaggle是世界上最大的数据科学比赛网站和社区，里面有成千山万个比赛项目，涉及数据分析、机器学习、深度学习、
数理统计
、可视化分析等全方位的数据
科学知识
。
kaggle还有各种各样的免费数据集、模型、教程文档，提供给数据科学爱好者使用。","除了看经典书和看优秀的源码之外最重要的一点是刻意练习。刻意练习包括两个层面，从「写不出来」到「写的出来」，从「写的出来」到「写的很好」。
从「写不出来」到「写的出来」的练习过程大家都知道并愿意实践，而从「写的出来」到「写的很好」这个过程往往被大家忽略。比如写完了一个类，会不会回过头仔细考虑这个类设计是否合理，接口设计的是否清晰好用；写完了一个函数，会不会考虑这个函数是否单一职责，是否与函数名语义匹配；写完了一段循环代码，会不会想想有没有更简练和清晰的写法。这个过程可能比前一个过程更耗时更费精力，如果回过头仔细考虑的时候没有发现可以改进的地方，那么可以从优秀的源码中学习。
当经过长时间的刻意练习之后能够写出清晰易读的代码，编程能力自然有很大的提高。","这个回答想写很久了！昨晚熬了个夜终于写完。
如果你看到这个回答，恭喜你！不论是初入编程领域的小白，还是已经在工作几年的老手，下面的内容都将对你有很大的帮助。
建议看到最后。相信我！一定会有收货。
这个回答我会试着给你带来一个更加不一样的编程能力提高实战指南。如果你觉得这个回答对你有用的话，也不要白嫖好吧！点个赞就是对我最大的鼓励。欢迎转发让更多人看到这个回答，一起变强！
先来说一下自己的情况！我从小学就开始接触电脑，不过到了大学之后才接触编程，整个大一都很迷茫，编程很少，也不知道如何提高自己的编程能力。大二的时候，自己加入了学校的一个技术组织，自此之后，便真正开启了自己疯狂的大学自学编程之路。
自学编程路上，Github 绝对对我帮助最大。 我在大二就开始接触 Github 了，当时就觉得上面有太多不错的学习资源了。到了大三下学期，自己就想着说要不也尝试着做一下开源呗！然后，我就从比较好入手的 Java 学习和
面试指南
入手。 到目前未知，我的所有的
开源项目
累计接近 90k star，并且收获了 4.6k 的关注。
 说到 Github 其实也挺惭愧的！因为我的大部分项目都没有提供英文版本。实际上，如果你要做开源的话，本着开源精神，最好能有一份英文翻译版。
 
好的！下面我们就开始正文！想要自己编程变得更强的小伙伴记得多记笔记。
1. 选择一个合适的电脑
学习编程前至少要有一个稍微适合一点的电脑吧！
关于电脑选择，我觉得不要纠结是买 Mac 还是 Windows。作为一个使用了 Windows 开发 4 年，Mac 开发一年的人客观地说，两者对于编程效率的影响没有你想的那么大。特别是在你初学编程的阶段，是完全没太大区别的。
Mac 的性价比更低，一台合格的 Mac 开发本 1 万 2 起步。虽然它确实好一些，但是选择电脑的时候还是要根据自己实际经济情况来决定。
另外，一定不要选择内存低于 8g 的电脑，有条件的话最好能 16g。
2. 六个黄金原则
很多人可能会觉得说，我们学习编程，首先是要找一门编程语言好好开始学，比如我在上大学的时候最开始接触的是 C 语言。
我觉得非也！就我自己作为一个从大学自学编程一路一路踩坑的过来人来说，
我觉得学习编程第一步应该是要搞清楚学习编程有哪些必备的网站？我们是如何查资料的？我们是如何解决问题的？国内外有哪些技术社区比较好？......
初次之外，你还要搞明白
学习编程不是参加应试考试。
2.1. 了解常见的学习编程网站
了解学习编程有哪些必备的网站之后，你才能更好地进行自学。
一般情况下，但凡是初学编程的同学，往往都需要课后进行持续学习的。一是因为你可能刚学编程，老师教的东西你听不明白。二是因为程序员这个行业本身就需要不断学习。三是因为大学里面教的东西往往和社会实际需要脱节，只有自学才可以让你技术和社会不脱节。
推荐几个我常用的学习编程的网站：
a.中国大学 Mooc
上面有很多名校的课程和
国家精品课程
比较适合我们夯实编程基础。比如下图是南京大学的一门关于软件工程的大学选修课。
b.
慕课网
上面有很多比较适合入门的免费课程。另外，如果你需要实战项目视频资源的话，也可以在慕课网找到（慕课网打钱！！！）。
c.
哔哩哔哩
是的，你没看错！看 B 站也能学习！B 站上面有很多优秀的学习资源以及优秀的 UP 主比如 Guide 哥。
d.LeetCode
国内的公司慢慢开始向国外的面试形式靠拢，
手撕算法
已经是很多大厂的标配了，不论是社招还是校招。LeetCode 这个网站的话，是我们平时刷题必备的一个网站。
在你初学编程的阶段，也可以经常去上面找一些简单难度的算法题来做。
e.极客时间
主打付费学习的一个付费学习社区（极客时间私聊我打钱哈！）。不过课程的质量大部分都挺高的，我自己也看了里面很多的课程，并且很多课程都是 Java 领域大佬级别的人物讲的。
2.2. 拓展视野，好的技术社区是你成长的助力器
了解了国内外有哪些比较好的技术社区之后，你才有机会认识到更多更优秀的程序员，看到更多对你有帮助的东西。而不是说，整个人的思想都局限在学校。这点是很重要很重要的! 比较好的技术社区的话有：
Github
（稳居第一位好吧！开源项目交流社区）、
Stackoverflow
（一个程序设计领域的问答网站，网站允许注册用户提出或回答问题。和知乎很像，重大的一点不同是 Stack Overflow 可以对问题进行打分）、
v2ex
、
掘金
、
csdn
、
segmentfault
 、
知乎
......。
3.学会使用 Googgle 搜索，学习和解决问题效率提升一个档次
知道了要使用 Google 搜索之后，你学习编程的和解决的问题可以提升一个档次。如果你实在是无法越过那道墙的话，可以试试必应搜索。
2.3. 不要把学习编程还当做学生时代的应试考试来看
你或许也发现了。很多成绩特别特别优异的同学，他们的编程能力其实并不好。在大学的时候，那些编程能力最强的往往是那些成绩比较一般的。
为什么会这样呢？
我觉得主要是一个思维的转变问题。很多人学习编程的时候，总是想着我要把这个 API 记下来，把这个库的用法记下来。这样学习，导致的结果只有一个那就是你会很难受！因为，这些根本不是要死记硬背的东西啊！真还当这是上课考试啊！
你要从如何用你学的东西来解决实际编程问题出发，站在做一个实际的项目的角度来学习。
拿我自己来说：我平时也会写 Python，基本就是自己看着官方文档或者一些书籍的教的语法跟着写。如果哪个地方不会了，我就去查一下。
2.4. 不要害怕阅读英文文档
大部分最新的资料/技术都是国外那边的，基本上大部分都是英文的。据说 90% 以上的程序员都不习惯直接看英文文档，都会选择看别人的翻译/总结或者书籍。但是，书籍或者别人的翻译/总结都会比较慢，而且难免会有个人主观因素影响翻译效果。
这个时候很多人就会说了我的英语不好啊！完全看不懂英文文档。
别担心！
有道翻译和谷歌翻译就是你最好的老师。如果是使用 Chrome 浏览器的话，我还推荐你安装一个 Mate Translate 插件。
 这个插件对于网页阅读英文文档太友好了，可以一站式翻译您的网页以及标记的文字段落。使用效果如下图所示：
2.5. 多看优秀的代码
不看优秀的代码，你写的代码质量很难提高。
虽然要多看优秀的代码，但是也不要被 “
最佳实践
” 所束缚，很多时候实际是根本不存在适用于任何场景的“最佳实践”，
没有银弹
。
有哪些优秀的代码值得学习呢？
拿 Java 来说，不知道阅读什么源码的话，可以先从 JDK 的几个常用集合看起。另外，我比较推荐看 Dubbo 的，因为感觉会稍微相对容易一点，模块划分清晰，注释也比较详细。搞清楚了 RPC 的基本的原理，知道如何自己实现一个 RPC 框架之后，看起来就没那么吃力了。
另外，随便一个框架的源码都 10w+行了，都看一遍是不可能的。要挑选比较重要的地方看，就比如看 Spring 源码的话你一定要看 IoC 和 AOP，要知道一个 Spring Bean 是如何一步一步被创建出来的。你要看 Spring Boot 源码的话就要知道 Spring Boot 的启动机制是啥，Spring Boot 是如何实现自动配置的。
2.6. 多读好书
一定要多看好书！像《重构》、《代码大全》、《
代码整洁之道
》这类书是程序员标配、必读的书籍。
看书相比于零散的看一些文章学习更加系统。当然，网上也有很多比较系统的学习资源，比如你要学习 Java 的话，可以看我开源的 
JavaGuide
 （「Java 学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识）。
3. 选择一门适合的编程语言入门
初学编程第一步就是选择一门适合自己的编程语言入门。
选择的时候，无非是要从下面几点考虑：
难易程度
：一般建议初学编程应该选择一门稍微简单点的比如 Python、 C、Java。
发展前景
 ： 确定你要学习的编程语言发展前景是不错。就比如相比于 PHP ，我肯定更推荐你学习 Java。
市场需求
 ： 有了市场需求之后，工作岗位才会多，找工作也会相对容易。
薪资水平
 ： 薪资水平实际和编程语言不是那么相关，和个人实际能力相关。不过，相同能力下某些编程语言的薪资确实要稍高一些。
下面这份数据来自 
TIOBE
 官网统计的 2020 年 7 月份编程语言排行榜，也可以作为你的参考。从统计结果可以看出，C、Java、Python 还是很强势的，这弟兄仨基本常年就是前三(Java 和 C 经常争第一)。另外，R 语言的进步也很快，同样值得关注。
再来看一下 
PYPL 指数
。 这份指数数据主要描述的编程语言的受欢迎程度，具体受欢迎程度是由分析 
 Google Trends 
 得出。从统计结果可以看出，Python、Java、Javascript 三者稳居前三。
再来看一下编程语言的平均薪资水平和使用年限。这份数据来自于 
Stack Overflow 2019 Survey 
 。我们需要格外关注的是 Go 语言。Go 语言背靠谷歌，薪资比较高也不奇怪。并且，国内现在很多大公司比如腾讯使用 Go 进行项目开发的越来越多了。
相信你看了上面这么多关于编程语言的介绍之后，你一定可以选择一门适合自己的编程语言进行学习和深入。
4. 不要被编程语言所束缚
编程语言只是工具。我们的确需要有一门比较擅长的编程语言，但是，不是任何时候，我们做任何东西都要使用这一门编程语言来做。比如 Java 适合网站开发而 Python 更适合做数据分析。
选择合适的语言做合适的事情很重要。
 再比如你想要做
全栈开发
的话，还可能需要掌握多门编程语言。拿我自己来说，也算是半个全栈开发，我主要是以 Java 做后端开发，Javascript 来进行前端开发。
5. 多实践
我见过很多人学习编程一年多了，自己敲的代码可能还不到 1000 行。然后， 你让他做用自己学的编程知识做个什么东西，他就蒙了。
学习编程以及提高编程能力最直接的办法就是实践！不断实践！特别是在编程初期的时候，积累代码量格外重要。
就比如你学习 Java 后台开发的时候，能不能通过自己学过的知识独立做个网站呢？再比如你搞懂了某个
框架原理
之后，能不能模仿着去写一个简单的呢?
我们实际项目开发中是比较忌讳造轮子的，但是，实际学习过程中造轮子绝对是最自己百利而无一害的！
 就比如我之前搞懂了 RPC 的原理之后，就自己动手写了
一个简单的 RPC 框架
。我的 RPC 框架肯定是无法和 
Dubbo
 这类已经这么成熟的相提并论。但是，在自己去写 RPC 框架的时候，更加加深了自己对于 RPC 框架的认识。实现的过程中，遇到了很多问题，解决问题的过程中也提高了自己的编程能力。总而言之，
造轮子是一种特别能够提高自己系统编程能力的手段。
多实践不是说拿到问题就直接开始写代码、不是不学习理论知识。多问自己 why ，而不是 what。
 就比如技术选型的时候，相同的功能可能有不同的解决方案，你是人云亦云地不顾项目实际需要去选择，还是自己经过详细的对比呢？想当然肯定是根据自己项目的实际需要，然后经过各种对比之后选择！
“ talk is cheap, show me code”这句话虽好，但是请不要忘记思考！换句话说就是：多写代码虽好，可不要贪杯哦！
6. 多修炼内功
不要沉迷框架，多花点时间去修炼内功――底层技术。很多人觉得在学校里面学的数据结构和算法、
计算机组成原理
、操作系统这些东西工作之后根本用不到。然后，就想当然地觉得这些东西不重要。
如果你暂时觉得这些东西没有用，很可能是现在学习某门技术只是浮于表面。举个例子:如果你要看懂框架或者某个类库的源码，那数据结构是必须要搞懂的吧！如果你要培养和提高自己解决问题的能力，那算法肯定是必须吧!
为什么要修炼内功？
技术更新换代快
 ：我们前几年可能还在用 Spring 基于传统的 XML 开发，现在几乎大家都会用 Spring Boot 这个开发利器来提升开发速度，再比如几年前我们使用
消息队列
可能还在用 ActiveMQ，到今天几乎都没有人用它了，现在比较常用的就是 Rocket MQ、Kafka 。技术更新换代这么快的今天，你是无法把每一个框架/工具都学习一边的，底层技术就是你快速上手他们的瑞士军刀。
懂得底层技术的人更有竞争力
 ： 现在的程序员这么多，你如何能和别人拉开差距？单纯就靠使用框架的能力么？这些随便从培训班抽一个人可能都会做的工作无法成为你的核心竞争力。
拿 Java 举例子，有哪些比较底层的技术呢？
算法和数据结构、计算机网络和操作系统(适用于任何编程语言的底层技术)；
框架的源码；
Java 程序运行的基础―JVM;
......
7. 多总结、多分享、多输出
总结知识不是把自己学到的东西按照老师的说法完完整整的整理下来，而是结合自己的理解和补充整理下来。
将自己学到的东西分享出来，一方面能检验自己是否掌握，另一方面还能加深自己的理解和认识。
分享和输出的方式有很多种，给大家推荐几种最常见，同时也是我最常用的学习方式。
7.1. 写博客
可以养成写博客输出的习惯。我在之前有写过一篇文章来说为什么要写博客:
程序员写博客很重要吗？
 。
简单来说，主要有下面    几点原因:
对知识有更加深的认识，让自己的知识体系更加完整
督促/倒逼自己学习
可能会带来不错的经济收入
提升个人影响力
拥有更多机会
好的博客会成为面试加分项
这个时候，你肯定就纠结了： 
我该在哪里写博客呢？
作为一个从大二开始就坚持写博客，期间折腾了无数次个人网站的我来说: 
我推荐先找一个不错的博客平台比如掘金，然后在博客平台上写博客，后面可以自己搭建自己的博客网站。
这个时候，你肯定又要纠结了：
我该怎么搭建自己的博客呢？
Emm...这部分要格外好好看，适当记笔记哈，小伙伴们！给大家推荐几个最好也是最常见的搭建博客网站的方法，想要免费高速个人博客网站的小伙伴们不要错过。
搭建难度是否需要服务器易用性SEO
Hexo易非必须中一般Vuepress易非必须易友好Docsify易非必须易不友好Wordpress中必须易友好Halo中必须易一般
综上，我还是比较推荐 Vuepress 和 Docsify 的。
 关于如何使用 Docsify 搭建一个自己的博客网站，我还写过一篇文章手把手教你搭建：
《手把手教你搭建一个文档类型的网站!免费且高速！》
 。而且，我还提供了
配套的视频教程
。就很贴心好吧！记得给 Guide 哥点个赞  ！
有了自己的网站后，你可以将自己的文章整理成一个系列，然后部署在自己的网站上，自己想看的时候就可以随时查阅。你也可以将文章同步到其他博客平台来扩大自己的影响力。
我整理 7 个常见的技术平台供大家参考：
7.2. 项目组内分享
一般公司都会有内部的技术讲座以及博客平台。
你可以在公司或者项目组内部组织技术讲座，这样不仅可以增加自己的存在感，还能提高自己的表达能力。
你也可以在公司内部的博客平台分享自己写的博客，这样你写的东西就能被更多人看到了！
7.3. 做开源项目
你可以在 Github 分享很多东西，你的学习笔记、自己做的实战项目、自己造的轮子......（资源类的不太推荐，太容易侵权）。虽然，现在 Github 被很多人单纯玩成了引流工具。但是，整体来说 Github 整体技术环境和氛围还是很不错的！
另外，最好的话是要给项目弄一个英文版本，项目代码中的注释最好也要是英文的。毕竟是开源，最好是能准守开源精神使用世界通用语言（这一点我自己也没做好，反思！）。
总结
我站在自己的这些年自学的角度，掏心窝子地说了很多话。看了这我的回答之后，哪怕你只学会了要使用 Google 搜索我都觉得开心，也希望这篇文章能够影响到更多人。
另外，文中讲了很多编程领域不可争的事实或者说正确姿势比如：不要以学生时代应试考试的方式学习编程、多实践、
造轮子
是一种特别能够提高自己系统编程能力的手段等等。说了这么多，如果你没有将这些学习编程的正确姿势用到自己平时学习中的话，这篇文章对你的帮助可能非常有限。
这一期原创分享就结束了！让我们一起变强！！！
2020-07-15 1:36","【绝大多数人努力程度之低，根本到不了拼天赋的程度。】
现在IT界的大佬里，马化腾公认天赋不高。在深大读计算机时，小马不显山露水，他不是编程最强的也不是成绩最好的，但完全不妨碍其后来的发展。同时，小马本身也是一名合格的程序员，据说写了第一版的OICQ Dialog。后来小马总结自己编程的学习方法，是用抄代码来打基础，我觉得他的方法对题主也是适用的。
不知道怎么学？觉得自己天赋低？想做APP?那就用笨办法，看点基础的知识语法入门，然后上网搜一下别人做的相关例子，或者教学视频什么的都可以，有源码简单点的。看别人是怎么实现的，把别人的实现过程自己在电脑上实现一遍。调通OK了，改一下其中的某个模块实现一些新的功能，就这样一步一步的往前走。多写代码多积累，有一定的基础了再回去看书，和别人交流，参与到一些学校组织或者社会上的开源非
中。在这个过程中不断动手、总结、积累、看书，螺旋式上升，即使你的天赋不如别人，我相信你的编程能力最后一定不会比别人差。
谈到天赋，在我读书时，学校很多编程大牛都是没日没夜在实验室干活，在各种科研创业团队里做事。隔壁宿舍的大神基友每天晚上11点从实验室回来，睡前的爱好是看Android源码，题主扪心自问，你真的尽力了吗？如果没有尽力谈天赋又有什么意义？从题主的问题描述里我感觉题主的意志还是太薄弱了点，校园里比起社会已经舒服很多了。
对于程序员来说，编程是基础，是敲门砖但不是全部，如果你想往更高的层面发展，学习能力、努力程度、情商缺一不可。建议题主先把心态摆正，静下心来，参考我和 
@姚冬
老师等人的方法，再努力一段时间试试。
附上一个小马问题的链接，当年他也是很拼的：
马化腾写代码的水平如何？ - 腾讯","无它，唯手熟尔！
很多同学，尤其是大一大二的学弟学妹们，还在拿着高中的学习方法学习编程。
每天看课本记忆语法，殊不知编程实际上是一种技能，
技能都是熟能生巧的，
大一最重要的就是掌握基本语法后，不断的写！
我大学四年做的练习、项目、外包加起来，累计写了10w+行代码。
写什么？可以是OJ上的题，也可以是课后的编程练习题，总之先把代码量堆上去！
比如你跟着这本刷题笔记练习编程，那肯定是事半功倍：
最近很多新关注的小伙伴，私信问我，说大学很迷茫，不知道该学什么。
在这里统一回复下。
既然是学习CS，那么在这里，我粗浅的把计算机编程领域的知识分为三个部分：
基础知识
特定领域知识
框架和开发技能
基础知识是指不管从事任何方向的软件工程师都应该掌握的，比如数据结构、算法、操作系统。
特定领域知识就是你从事某个细分方向时需要掌握的知识，比如做游戏引擎的需要掌握图形学；做前端的需要掌握浏览器渲染原理、前端三大件；算法工程师需要更多的数学知识。
毕竟计算机各种门类挺多的，需要选个细分方向专研下去，什么都学只会什么都不精（大佬除外啦。
上面那么划分可能有同学还比较疑惑，再细一点，我认为需要重点掌握学习的就是 ：
2-3门编程语言（1-2
静态编译
型：C/C++、Java + 1-2 动态/脚本语言: Python、shell之类）
算法与数据结构
System（OS、计算机组成、memory、cache等等）
工程开发能力（git、linux、shell、环境搭建、部署等）
计算机专业的核心课几乎都是围绕着构建上诉这些能力来的，比如：
计算机学科导论和 C 语言
汇编、操作系统、C++、数据结构、离散数学、数值分析和计算机组成原理
计算机编译原理
和数据库
计算机网络与安全和软件工程
还有高数、线性代数、离散数学、网络原理、网页设计、多媒体技术、汇编语言、面向对象的设计语言、Java 编程、ASP、SQL等
总的来说是
先学习 C 语言和 C++。教材有：C programming language-K&R、C traps and pitfalls、Algorithms in C 和 Expert C Programming
学习数据结构。清华大学
严蔚敏
《数据结构》，目前还未找到经典的国外教材
学习算法。
算法导论
和具体数学及其应用
计算机组成原理
。Computer Organization and Design The Hardware-3rd-David Patterson
计算机系统。CSAPP
操作系统。鸟叔的私房菜和计算机网络
另外，对于还在大一、大二的很多学弟学妹们来说，可能觉得刚学会一点编程语言，什么都做不了，更不知道和实际工作的差距在哪。
那么最好的方式就是先按部就班的把学校安排的基础课程学好，再在课外自己多练习编程，了解一些业界的技术、框架。
把时间充分利用好。
要相信，人生没有白走的路，每一步都算数。
就拿我自己来说，在高中，我完全没有想过自己会学计算机，成为程序员。
我在大一之前完全没有编程经验，高考后，填的专业前几个也是清一色的传统工科，被软件工程录取纯碎是意外。
大一开学，第一门编程语言就是学的 C 语言，怎么说呢，老师讲的，书上写的我都能看懂，但是让我写一个大的程序，我就摸不到头脑。不知从何下手，学了半学期，也只能写写课后习题，算算
水仙花数
什么的。
大一上考完 C 语言后，我便在心里默默念想，这辈子再也不写 C 了，但没想到的是，后来这成了我最爱的一门语言。
整个大一，一个词语就是“迷茫”，一个字就是“混”
混到什么程度呢，王者荣耀打了几千场，线代考试前一晚才在 mooc 上刷完所有章节，因为平时上课我基本都没听的，这也是我最后悔的事情。
转变大概从大一下开始吧，那时候好几个室友都拿到了奖学金，于是，我自己也开始慢慢反思，觉得这样下去，大学可能就废了。
默默的把王者荣耀卸载（当然，后面又下回来了，反反复复十几次。。。）
大一下，开始学习
数据结构与算法
、数字逻辑这些计算机核心课了。
此外，还学了一门当时我看来非常牛逼的语言：Java。
为啥说我当时觉得它牛逼呢？
因为刚经历过 C 语言的摧残，发现 Java有丰富的类库，各种方便的工具类。
再也没有指针了，变成了对象引用，简直是新大陆。
所以我学得很认真，还记得当时看过
高琪
的 Java 300集 教程，也是从那里算是正是开始了我编程学习之路。
自己也用 Java 写了不少好玩的东西，比如
联机五子棋
、HTTP Server 等等。 类似这种：
这让我第一次感受到编程这么有趣，俗话说兴趣是最好的老师，Java 也算是帮我解锁了对于编程的兴趣。
在学 Java 的时候喜欢在网上搜资料，但总觉得各种博客上的知识过于零散，为了“精通” Java，我在知乎搜索各种书单，先后看了《Java核心技术卷》《Java并发编程》好几本书，自觉 Java 基础还算可以，不过现在已经快两年没写了，成功转入C++阵营。
而且我有个习惯，就是每天早上基本都是六七点起床，八点多对我已经算赖床了，所以和我室友显得有点“格格不入”。
早上起太早的话，他们还在睡觉，我在寝室写代码的话，难免会发出各种声音吵到他们，尽管我做什么都是蹑手蹑脚，生怕发出椅子摩地，或者碰撞的声音，这让我也觉得不太方便。
所以，后面没有课的早上我一般都去图书馆五楼自习室了，在那看书，看书觉得烦了，就写会代码或者刷刷知乎，看看博客。
这是被我长期占领的一个位置，因为书太多，不方便每次都背来背去的，所以就找了个考研自习室。
就这样从秋天，到了冬天，桌子上多了围巾手套，还有 C++ primer（误，我从大二才开始学C++的）
那时候，每天上午的盼头的就是早点到中午，我就可以去吃饭，然后去学校散步了，我经常把中午饭菜拍下来，感觉蛮有意思的哈哈哈：
一般我都是赶在中午下课高峰之前去吃完，然后去学校绿荫道散步
大二时，在上一些无聊的课时，我总把这本书带着，每节课可能会翻个几页，那时候看到里面的汇编、内存管理、存储器层次我是真的云里雾里，因为还没学操作系统，C 语言也学得很差。
所以断断续续的看了几章，说不上学到了什么，但让我对这种枯燥的基础知识第一次产生了兴趣，有一种想彻底搞懂它们的想法。
后来在知乎大佬的指引下，为了看懂这本书，去看了
王爽
那本《汇编语言》，也在上图。
重学了 C 语言（主要是指针和内存），由于已经学了汇编，指针对我再也不是问题了，同时看完了《C和指针》、《
C专家编程
》、《C陷阱与缺陷》，对 C 语言使用得也愈加的熟练。
大二那段时间，学院里突然刮起全员学机器学习的风气，虽然不至于全部，但是真的是很多人都在学，明明 16 年大一时客户端安卓开发还挺火的，到了 17 年各种机器学习、神经网络就席卷而来。
不能不感叹，IT 行业日新月异呀，不学习就可能被淘汰。
当然了，我也不例外的加入了，先后看了些
吴恩达
的视频、西瓜书。
跟着做了手写数字识别这种入门必做的项目，但是后来总觉得对机器学习、深度学习提不起兴趣，原因之一就是我觉得无法完全掌握每一步，了解每一步背后的原理，再加上自己数学也学得不太好，这让我学得很没底气。
于是机器学习之路也止于大二。
大二是学习内容最丰富的时间，当时室友用 Python 写了抢课脚本，感觉很好玩。
然后自己又跑去学 Python，学爬虫。
写了一堆爬虫，什么爬豆瓣电影、知乎回答、抢课脚本，玩了一段时间也没太大兴趣了。
时间来到了大二下，按照课程安排，开始上操作系统了。
于是我又在知乎搜索「操作系统怎么学」，不得不说知乎上各位前辈大佬的回答对我的指引作用极其的大。
顺着一堆回答，我发现原来还能跟着别人写一个 mini OS，这对我吸引力太大了。
于是我买了一本《
操作系统真象还原
》，这本书真的非常仔细，把写 OS 需要用到的前置理论知识、Intel手册、汇编、
内联汇编
全都给你讲清了。
我一路跟着书写，写到了汇编开机打印出我的名字，再到后来进入 C 语言写内核各个模块，写到内存管理我就中断了，没有继续写下去，这也算个遗憾吧。
这本八百多页的书，我花了两个月时间啃了五百多页，一下课就跑去图书馆，在我的虚拟机中跑 qemu，那时候就沉浸在类似下图这种界面：
当时我真的对这个入迷了，为了写 mini os我还去看了 Linux0.11 的部分代码，看了哈工大李治军老师的 OS 公开课，原因就是哈工大 OS 实验课是用的 Linux 0.11 来魔改。
还很奇葩的把我 QQ 签名改成了 jmp 0x7c00
(PS: 这句汇编就是跳转到 0x7c00 地址，BIOS 开始引导操作系统
于是就这样，我越来越喜欢偏底层一点的东西，所以决定走 Linux C/C++ 路线，然而现在看来确实太年轻了，Linux C/C++ 在鹅厂好多也是用来写业务滴。。。
大二下在知乎、牛客网搜索学习路线，我大概清楚了需要看些什么书（
搜索
敲黑板，一定要学会主动搜索各种信息。
专注的大三
于是在大三左右开始了非常标准的 Linux C/C++学习之路：
前前后后看了《
C++ Primer
》、《APUE》、《UNP》、《深度探索C++对象模型》、《STL源码剖析》、《C++设计与演化》、《
Linux内核设计与实现
》、《Linux内核完全注释》、《effecitve C++》 、《effective modern C++》、《程序员自我修养》、《Linux高性能服务端编程》、《Linux多线程服务端编程》(知乎
陈硕
大佬写的)......
顺便还看了点 Muduo 源码，自己模仿着基于 Epoll 写一个 Reactor模型的 Web 静态服务器，跟着知乎 Milo 大佬写 Json 库，总之，这段时期是写了一些小”轮子“的。
（PS：知乎上有朋友问我是如何看完这么多书的，其实在之前的文章中就写了，看书我会有选择的挑章节看，不会从头看到尾的，而且大三开始课就少了，我基本就在刷这些书，其实时间还蛮多的？毕竟我也没参加什么社团、学生会之类，也没女朋友。。。
那时候会每天记录看书的进度，感觉特别有劲：
书看得越多，其实你越能找到自己的方向，大三上我就给自己学习定位：
深入C++语言（多线程）+ 存储（学习 Redis、leveldb）+ 
网络编程
（学习muduo，各种网络编程模型）+ 学习分布式（MIT 6.824、ddia、google 三大论文等）
基本上是沿着上面几个方向去展开学习的，有的看书，有的论文，也有的看博客看源码。
总之，知识面在大三不断扩充，自己开始关注学习 C10K、C100K 这样的后台服务器开发高性能、高并发的解决方法。
当然了，还有些到现在还没开始，比如 
leveldb
 的源码、6.824 的 lab，可能是变懒了......
也可能是学习变得不那么纯碎面向技术了，变成面向工作、面向赚钱了哈哈哈。
值得一提的是，大三上我们学院有门 System Programing 的课，教材就是使用的 CSAPP，因此我之前大二草草看完的书，得以再次翻开，这一次我把附带的是个实验也挨着挨着做了，收获良多，有位运算各种奇技淫巧，有 Bomb lab 刺激的打怪通关、也知道了buffer overflow attack.... 还有实现基本的内存管理等等。
印象最深的便是做 bomb lab，一个个 phase 的通过真的很让人兴奋，我几乎是熬夜连着把这几个 phase 过掉的，当然头发也没少掉。
当时还在简书写了个万字长文记录： 
再到后来，我拿到了微信实习 offer，然后顺利转正。
在我大三下拿到实习 offer 后，开始做一些国外计算机课程 lab，一方面有钱赚，而且还不低，靠这个我在大三下就实现了经济独立，另一方面这些 lab 有些很有意思，对提高基础和编程能力很有帮助。
在这里列举一些我做过的觉得有意思的 lab（之前有篇文章写过）：
第一个是文件系统
这个玩意挺有意思的，就是要让你自己去设计一个文件系统，比如文件、数据块、目录等等，而且你要提供创建、读写、删除、随机读、随机写等等接口，然后通过 Linux 的 VFS（虚拟文件系统） 机制挂载到 Linux 内核中，然后就可以用系统调用 open、read、write 这些来在你的文件系统上进行读写。VFS 是Linux一个机制，它规定了 IO 接口，然后你去实现这些接口，你就可以挂载在上面。通过这个东西我深入的学习和了解了文件系统，报酬也是非常值的。
第二个是SVC
就是版本管理系统，类似 SVN 和 GIT的，但是相对 GIT 做了很多简化，核心的就是创建分支、分支合并、回滚、commit 这些，通过这个我又去详细了解了 GIT 的实现原理，并且自己写了一个简单版本的 GIT，受益匪浅，也赚到了几千大洋。
第三个是操作系统的锁实现
这个就是让你基于硬件的原子指令 xchg、cmpxchg 这些实现一个锁，这个需要内联汇编、汇编等知识，简直是硬核！！！做完这个也解开了我对锁实现的一些疑惑。
Web Proxy
这个就更有意思了，要求用 C++ 写一个代理服务器，类似 Nginx 的代理功能，当然，相比 Nginx 弱鸡很多，
但是麻雀虽小，五张俱全，而且老外最有意思的是要求代理服务器对一些图片和 HTML 恶作剧，就是代理服务器随机的在原始服务器，返回的响应里 插入一些图片和文字，因为那天是愚人节。。。 不得不说老外还是很有趣的。
还有模拟实现 TCP 可靠传输的
这个就更硬核了，人家老外老师就是给力，直接做了一个网站，这个网站你可以通过 TCP 连接上去，然后你需要运行几个节点，互相发消息，他们之间的消息都会经过老师的网站，所以通过网站上是可以控制丢包率的，也能控制节点的
拓扑
结构，要求就是让你基于这种不可靠的信道，做出可靠数据传输！这简直就是翻版 TCP 嘛，超时重传、ACK、滑动窗口啥的都给我上！就是像下面图中一样，圆圈就表示你可达的范围，不同节点形成各种
网络拓扑
，可以调节网络 丢包率 Loss chance。
img
当然也有很多写算法的，数据结构实现的，图搜索的，也有做机器学习、深度学习的，反正各个方向都有。
做这些 lab 真的实实在在的提高了我的编程实践能力，也算是检验了前期看那么多书还是有效果滴。
所以写了这么多，再点次题吧，我认为自己编程能力突飞猛进就是在看完一本本大黑书、做完一个个 lab、写下一行行代码之后。
附录
附上大学期间买的一些书，毕业的时候大部分都卖了，因为实在不便携带：
这是带去图书馆自习室的书（常占位置）
这是毕业整理的书：
买这些书花了我不少钱，大家都知道计算机这些书一本就是五六十、七八十起步。大学四年光买书就花了几千块。不过我一直认为这也是我花的最值的一笔投资。
最后真心想说一句，滴水穿石非一日之功，学习计算机还是需要沉下心来好好啃书、看源码、写“轮子”。
逐渐构建起属于自己的计算机知识体系，然后选择一个专业方向不断专研。
觉得不错的话，可以关注下我 
@编程指北
 ，记得帮我 
@编程指北
 点个赞哟！","请原谅我使用英语作答，因为我的中文没有比英文来的打字更快。以下我将分享一些我对国外的线上学习
coding
的网站的整理，如果觉得是良好的咨询请关注我吧，谢谢。
OpenCourseWare
2013 Mooc Revolution:
Hackerupt
Codecademy
CodeHS
Coursera
edX
Khan Academy
Saylor Academy
CodeCombat
Scratch
Physical Academies:
Dev Bootcamp - Learn Ruby on Rails in 9 weeks.
 - SF, Chicago, NY
Hack Reactor - The CS Degree for the 21st Century
 SF
Coder Camps- SF Bay Area, Houston, Seattle, DC
T
he Starter League - 
Learn to code, design
 - Chicago
Starter School - 
Learn the technology, design, and business skills to launch a web application
 - Chicago 
Hacker School
 - NY
MakerSquare
 - Austin, San Francisco
Deep Dive Coders - Learn PHP in 9 weeks
 - Albuquerque
Anyone Can Learn To Code
 (without quitting your job) - Chicago
Program for a Brilliant Future
 - San Antonio
Software Craftsmanship Guild - Akron, OH: 
Web Development With a Focus on the Enterprise at Software Craftsmanship Guild
Coder Vox
 - Austin
PARSEC Group - 
Ruby Immersion
Blended Learning:
Learn Web Development with a Mentor
 <
Bloc.io
  [Web Dev+Ruby on Rails]
Become a web developer | Thinkful
 <
Thinkful
 [Web Dev, Ruby, Python, iOS tracks]
theFirehoseProject
  <theFirehoseProject> Web Dev & Ruby on Rails
Ruby on Rails Online Bootcamp
 <Tealeaf Academy [Web Dev+Ruby on Rails]
Harvard
CS50: Intro to Computer Science 
David J. Malan
CS50.tv
 or
https://www.edx.org/course/harva...
University of New South Wales (Australia)
COMP1917 Higher Computing: 
http://www.youtube.com/user/UNSW...
MIT
Scratch: 
Scratch - Imagine, Program, Share
http://ocw.mit.edu/OcwWeb/web/co...
6.00.1x 
MITx: 6.00.1x - Introduction to Computer Science and Programming (Oct 2013)
Stanford
CS106A Programming Methodology: 
http://see.stanford.edu/see/cour...
 (also available on iTunes U)
CS106B Programming Abstractions: 
http://see.stanford.edu/see/cour...
 (also available on iTunes U)
CS107 Programming Paradigms: 
http://see.stanford.edu/see/cour...
 (also available on iTunes U)
IITs
NPTEL Official Website : 
NPTEL PHASE 2 - Courses
NPTEL Youtube Channel : 
nptel Youtube
Computer Networks : 
IIT Kharagpur - NPTEL Online
Computer Organization : 
NPTEL :: Computer Science and Engineering
Others
Software Carpentry: 
Software Carpentry
 - Online material on Python, R, MATLAB, SQL, Git, Mercurial; also provides on-site workshops
Norm Matloff's Debugging Tutorial: 
http://heather.cs.ucdavis.edu/~m...
Structure and Interpretation of Computer Programs: 
http://
mitpress.mit.edu/sicp/f
ul
...
Learn Code the Hard Way
Learn Code The Hard Way -- Books And Courses To Learn To Code
Safari Flow 
http://w
ww.safariflow.com
Language Specific
Ruby
Learn Web Development with a Mentor
 <
Bloc.io
  [Web Dev+Ruby on Rails]
theFirehoseProject
  <theFirehoseProject> Web Dev & Ruby on Rails
What's a good way to learn Ruby?
LearnStreet: 
http://learnstreet.com
What's the best way to learn Ruby? (Stack Overflow): 
http://stackoverflow.com/questio...
Try Ruby: learn the basics of the Ruby language in your browser.
RubyMonk: 
RubyMonk
- Interactive Ruby tutorials
Thinkful - 
Learn to Code With a Mentor & Become a Web Developer
MakerSquare - 
MakerSquare - Programming Bootcamp and Coding School in Austin and San Francisco
Safari Flow - 
Safari - The best books and video courses from the brightest minds.
/t/ruby/
ACLTC Screencasts - 
http://anyonecanlearntocode.com/...
PARSEC Group - 
Ruby Immersion
Ruby on Rails
http://
Stuk.io
 - 
Learn how to code and create amazing apps | Stuk.io
MakerSquare - 
MakerSquare - Programming Bootcamp and Coding School in Austin and San Francisco
Tealeaf Academy - 
Intensive Online Bootcamp for Web Development
Code Academy - 
Welcome to The Starter League
Hungry Academy - 
hungry academy
DevBootcamp - 
Dev Bootcamp
Bloc.io
 - 
Bloc | The World's Largest Online Programming Bootcamp
Thinkful - 
Learn to Code With a Mentor & Become a Web Developer
theFirehoseProject - 
theFirehoseProject
PHP
PHP Bounce
Polycademy
Deep Dive Coders - Learn PHP in 9 weeks
Safari Flow - 
Safari - The best books and video courses from the brightest minds.
/t/php/
Coder Vox - 
www.codervox.com
Python
LearnStreet: 
http://learnstreet.com
Beginner Guide to Python: 
Begin Python: Python Tutorial for Beginners
Codecademy: 
Learn to code
Pyschools Online Tutorials: 
Python Tutorial
Learn Python the Hard Way: 
Learn Python
Thinkful - 
Learn to Code With a Mentor & Become a Web Developer
Safari Flow - 
Safari - The best books and video courses from the brightest minds.
/t/python/
javaScript
Learn Web Development with a Mentor
 <
Bloc.io
  [JS and AngularJS]
LearnStreet: 
http://learnstreet.com
CodeHS: 
CodeHS - Learn to Code at School or at Home
Codecademy: 
Learn to code
CodeAvengers: 
Code Avengers: learn to code games, apps and websites
CoderCamps: 
https://www.codercamps.com
MakerSquare: 
MakerSquare - Programming Bootcamp and Coding School in Austin and San Francisco
Hack Reactor: 
Coding Bootcamp in San Francisco. JavaScript focused programming school.
Polycademy
KhanAcademy: 
Computer programming
Thinkful - 
Learn to Code With a Mentor & Become a Web Developer
Safari Flow - 
Safari - The best books and video courses from the brightest minds.
/t/javascript/
.NET
Coder Camps: 
Coder Camps - Programming and Coding Boot Camp
Software Craftsmanship Guild: 
Learn to Program
Safari Flow - 
Safari - The best books and video courses from the brightest minds.
/t/net/
Java
Software Craftsmanship Guild
Safari Flow - 
Safari - The best books and video courses from the brightest minds.
/t/java/
iOS
Learn Web Development with a Mentor
 <
Bloc.io
  [Swift]
Mobile Makers Academy: 
Learn To Build iPhone Apps
Thinkful - 
Learn to Code With a Mentor & Become a Web Developer
Safari Flow - 
Safari - The best books and video courses from the brightest minds.
/t/ios/
P.S.以上这些都是学习coding的，如果想了解一些关于英语的线上学习网站的话，也可以到我的网站观看我给其他用户的留言，谢谢，麻烦请你关注我吧。
美国学生是不是很容易就能够上哈佛、斯坦福这样的著名大学？ - rose mel 的回答","虽然我不是重点大学的，只是渣渣学校毕业出来的，但是我还是想分享一下观点。
首先要多加练习――这一步并非是指有意图的练习，而只是普通的练习。这是我用了两年不到的电脑的
Command键
。。
以及GitHub上的提交――都是练习为主，天天练习。
然后就是： Tasking与学习能力
作者：phodal
链接：
http://
zhuanlan.zhihu.com/p/20
626395
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
能做到你想做的: Tasking与学习能力
虽然这看上去是一件很难的事，但是也不是一件很难的事。这也不依赖于你是否对某一个
的理解，这只实际上只是学习能力的一种体现。
在扯这些废话之前，先让我们来看看我们是如何实现一个功能、应用的。这也是在Growth里提到的Tasking：
有一个明确的实现目标。
评估目标并将其拆解成任务(TODO)。
规划任务的步骤(TODO)
学习相关技能
执行Task，遇到难题就跳到第二步。
以本文的写作为例，细分上面的过程就是：
我有了一个中心思想――在某种意义上来说就是标题。
依据中心思考我将这篇文章分成了四小节。
然后我开始写四小节的内容。
直到完成。
而如果将其划分到一个编程任务，那么也是一样的：
我们想到做一个xxx的idea。
为了这个idea我们需要分成几步，或者几层设计。
对于每一步，我们应该做点什么
我们需要学习怎样的技能
集成每一步的代码，就有了我们的系统。
所以，实际上这并不是考验你技术能力的点，而是考验你如何划分任务和学习能力的点。在我不断地实现一个个系统的时候，最后我才意识到了这一点――学习能力和Tasking才是最重要的。换句话说，你现在学会什么并不重要，重要的是你以后有没有学习的能力。
有了一直想着过安逸的生活，所以就会安乐的死去。不过反正人生在世，自己开心就行，不要管别人怎么说。随后，我发现大部分我想到的都可以实现。
那么问题来了：
用铅笔写字也是写，用钢笔写字也是写，用电脑打字也是写――到底要用哪个工具来写。
用楷体来显示也是显示，用宋体显示也是显示――到底要怎样的实现。
这实际上就是：用更好的方法来实现功能。","大学毕业，在一线互联网公司代码也写了五六年了，给几点建议：
1、代码靠写不靠背
那些早上6点起来在那背代码的，放心，最后还是不会写代码。
一门语言写几万行的代码量，就上手了。
有空多逛逛github：
https://github.com
2、用一个开发环境先学如何调试
码农每天都要跟bug打交道，学习如何调试，代码出问题就知道怎么找bug了
解决 bug 的社区：
https://
stackoverflow.com/
3、写一点编译执行一下
几乎所有的编程新手都会犯的一个错误就是，把所有的代码逻辑都写完了，再开始跑。
相信我，这样写代码会让你调bug到怀疑人生。正确的姿势是，写一点编译一下执行一下。
4、好记性不如烂笔头
平常把有用的代码、遇到过的问题等记在
云笔记
。写代码有大量的ctrlc、ctrlv操作，代码在你的笔记里，找得一定比别人快。遇到同样的问题，笔记搜一下，直接搞定。
最后，真的很庆幸当初大学选了计算机专业。刚开始学也很痛苦，现在已经是真爱。","说点没用的： 
@vczh
  轮子哥的堆时间论 深以为是。
窃以为，编程就是织毛衣，再精美的织品，分析到最后终逃不过一个唯手熟尔。
至于用什么方式达到手熟……
楼上诸位已经说得很多了
只是希望楼主认准一个方法后，能够坚持下去。
毕竟，我们的
征途
可是星辰大海啊【逃……","目前赞同最多的两个答案很有道理,但不适合题主的状况.
不知道诸位答题前有没有读题主的描述,题主作为""国内某重点大学渣渣专业大一在读"",属于刚入门,的过程.
题主欠缺的不只是理论,方法,还有编程熟练度.
题主的问题是
阶段问题
,题主处在入门阶段.也许他刚刚掌握了基本语法,
,架构都很懵懂,现阶段你和他说多看github,或者让他接触更高级的知识体系(比如目前排名最高的答案,给出了很多三方框架,并且跨多种语言),我觉得这不会让他有大的进步,反而会形成压力,甚至更加迷茫.
能够救题主的,不是捷径,而是(基础)代码量.
你能看到的大牛,除了少数天才外,大多数还是一行行代码积累起来的.
题主说:
""一些题还好，可是有些题难度感觉很大，有时好不容易有了思路，转化成代码都要老半天，别人一个小时就搞定的事情，我可能要花三四个小时，而且我本人比较粗心，经常被一些小错误坑了很久。""
但是题主指出:
""最后就算千辛万苦地做出来，感觉也不值得，毕竟时间消耗太大""
其实作为一个过来人,回头想想,刚开始编程的我也是这个样子(
请参考
:
C++好学吗？ - C++
),然而题主有""感觉不值得""的感慨,或许并非因为过程不值得,而是没有得到""惊艳""的成果吧.
所以给楼主的建议是如下几点:
1.坚持,学好基础,2.积累代码量,3.忍耐(甘于平淡枯燥的学习).
度过这个阶段,自然拨云见日.",数据结构和算法本身就是比较难的，转化成代码还需要你对语法比较熟悉，初学者多花些时间是正常的。另外我们周围经常会有比我聪明的人，要调整好心态，至少在编程这件事情上我觉得还是勤能补拙的。把自己编程过程中遇到的所有坑都记下来，每隔一段看一次，积累多了就能避免越来越多的坑，你对这门语言也就越来越熟悉了。如果真喜欢，那就坚持下去，编程是一个熟能生巧的过程。我周围好多同事专科学校毕业的，技术都很牛，也没见他们智力超乎常人，但他们都很努力，很热爱自己的工作。编程这件事上，英雄不问出处。本人鹅厂码农一枚。,"       oj上a题目远不能判断你是否有天赋，这方面初期的弱势完全可以通过时间弥补。
       你太急功近利了。
       答主某理工大大二程序猿一枚。专业是调剂的，一点点基础都没有，当初hello world wa了三次。所幸对这个专业还有兴趣。
       一开始和题主情况一样，好几小时a不出题目，被各种小错误坑，等等。但是，但是！现在大二，最近的校新生赛(本科大二大二参加)已经可以排到10+左右的名次。   原因就是，学院在每个寒暑假会挑选一部分人组织为期二十天左右的集训(高强度码代码，每天训练时间10小时，实际专注代码时间也至少六小时)，第一次参加集训经过选拔垫底进了集训队，当然，那个假期的各次检验比赛也一直垫底。但是，第二次集训我依然参加了，并且选择了算法实验室(每天的任务依旧是oj刷题)。经过两次集训，即使当初那么渣，现在oj a题也可以勉强算在学院前面的那一部分人里。集训的日子里，有过坐一天只a一道题的经历，所以你能想象到，所谓被小错误坑这种让你抓狂的事情，已经怎样地磨练了一个程序猿的耐心了吧
最后，要说一句，安心刷一段时间oj吧。
       即使你不搞acm，但是一次次debug的过程，一次次查出所谓小错误的经历，能培养你许多程序猿需要的素养，心理或生理。并且，通过oj做题也是能让你初步熟悉一种语言特性的比较好的方式。
       祝早日进入状态～！","有些朋友给我留言说，兴致满满的开始自学编程，但是拿到一堆书，却不知道从哪开始，最后的结果就像下面这个图：  
下面结合我之前的学习经历，如何从零基础慢慢提高。
1.首先，给你的学习编程一个重要的意义
做任何事情前，你都要首先明白为什么要做？这个理由不是学校开了某个编程课，你为了应付考试。或者看到其他人都在学，你没事干，也学下吧。这都是盲目的表现，就好比你追一个女孩，不是因为她家有钱，最重要你追她的原因是：你真的喜欢上了她。
所以从一开始，就给自己的学习定一个大的意义，这会让你不会中途放弃。而且能带给你前行的动力。
我当年学习编程，是因为觉得未来很多互联网的行业都于编程有关，意识到这是个基本技能，而且技能在手，不会哪天饿死街头。同时，编程的世界很纯粹，不像其他行业需要很多关系去维护，要想往上爬，的整日琢磨如何混好。但是，在编程的世界里，全靠技术说话：你行就行，不行就不行。
而且现在是人工智能时代，编程已经变成了像excel那样每个人都需要掌握的技能，你觉得学校编程意义大不大？更重要的是，学会编程你的收入概率会比其他人高。
2.如何选择你人生的第一个编程语言
很多人一开始是对编程有兴趣的，但是之前很多大学一上来就教C，C++。里面复杂的内容，也让很多人从入门到放弃。到最后连兴趣都没有了。没有兴趣是最可怕的敌人。
如果你是刚开始学编程，选一个比较人性化的编程语言，我建议从python开始。它足够简单，而且容易上手。而且现在连小学生都开始学python了。
我们再看看各大兵器排行榜上的python排名，它已经是人工智能的第一编程语言。相信它的火热程度还会持续升温。
3.选择一本经典的书进行系统学习
很多人一开始为了追求快速，会选择一些比如xx天学会Python，xx天学会机器学习的书。这些书看上去高大上，其实是在误导你。世界上哪有xx天就能学会的，记住一条原则：越是有价值的知识，越难学，不然很多人都能学会了。
一般来说，一本书要比公众号的文章系统性强，一本某个领域的经典教材要比很多快销书系统性强。一个系列课程要比一次1小时的分享系统性强。所以从一开始就摆正心态，不要急于速成，有时候慢就是快。有了这个心态，就老老实实选一本这个行业经典的书，最好是国外的书。
既然在这个领域你是新手，就不要指望自己能把散落的信息整合成系统了，那是高手要做的事情。要想系统地学习，那就踏踏实实地拿出几个月的时间来，看几本这个领域的经典书，选一门系统课，或者跟着一个系统学习过的老师把这个领域的骨架摸清楚。
你又不比别人聪明几倍，却想用几分之一的时间，就掌握人家花了好长时间下了硬功夫，系统掌握的知识，怎么可能呢？
先接受一个已经存在的系统，再在上面修修改改，对于新手是最适合的方案。
3.选择一个有界面的
编程环境
很多编程的书，一开始安装后，都是教你在命令台下写代码。面对这么一个黑洞洞的东西，你的兴趣又降下来了。
一开始编程不要在这个不友好的命令行下做。而是找一个集成开发环境（IDE），在里面敲代码。人对有界面的东东天然有好感和兴趣。比如学习Python，一开始用notebook就很容易敲出代码，而且运行结果也能实时的反馈给你。
当然最开始要做的事情就是先把环境搭起来，开始输出你人生的第一行代码：“Hello World”。这是简单的第一步，但是对于很多完全自学的同学都非常难了。好事情是，现在网上很多教程可以帮助到你。  
4.重要的事情说三遍：多敲代码
编程是门手艺活
，什么意思？就是你的多练习。这就好比，一个懂得再多泡妞理论的单身狗，都没有一个谈过恋爱的人，更懂得如何追女孩。
不要光看书，或者光听课。要多撸代码，在实践中成长。遇到不明白的地方，就多联系生活中的事情就类比想明白了。比如我在学习数据结构：队列，不明白的时候，就联想到了餐厅外婆家的排队叫号系统，就立马明白了。
其实编程中很多东东，都是为了解决现实生活中的问题，所以很多知识都能与现实生活中的实际事情对应起来。
5.学会记笔记
很多人刚开始学编程以往里面的很多东西都要记住，其实这是错误的做法。
不用去记住这些代码，理解代码比记住代码更重要。这里我们能理解代码是干什么用的就可以了。如果后面用的时候忘记了，反过头来知道在哪查找答案就可以了。这是学习的重要思想之一：知道在哪查找答案比记住更重要。
很多时候你感觉自己学会了，但是其实并没有掌握。我个人解决这个问题的办法就是记笔记。记笔记不是简单的罗列知识，而是将学到的知识，用自己的语言整理出来。同时，记笔记还能通过输出倒逼你的输入。下面是几个写实践笔记的讨论，对你应该会有帮助：
6.学会使用搜索引擎
刚开始学习编程，看到代码报错，就会茫然失措，脑子中立马闪出一个'funck'。
其实解决编程代码问题也是有套路的，这个套路就是：
能不用百度就别用百度，你要学会在宇宙第一大搜索引擎，和全球最大的技术问答平方：stackoverflow上搜索问题的答案。
一切的学习都是学习能力的提高。对于编程，真正的高手，就是遇到问题能从搜索引擎中找到答案。
7.多看
大牛
的技术专栏
平日多关注这个领域顶尖高手的技术专栏（博客），选择你认可的人成为你心目中的榜样和导师。因为导师可以降低你加入一个新行业的成本，帮助你熟悉环境和行业规则，也会鼓励你完成心理方面的转变。
同时你也要 建立新的学习社交网络。如果你周围没有和你同样喜欢学习编程的人，会阻碍你的进步，更糟的是，有的人自己学不会，还会嘲笑你。过去的人脉关系会阻碍你的前进，因为他们是以过去对你的认知来评价你。感谢这个互联网时代吧，你可以在网上找到志同道合的朋友和你一起前进，新领域的人脉，会给你提供各种各样新的机会和情感支持，帮助你融入。
人都是都是
“快感型”物种
。再加上学编程是一个长期的过程。所有需要你自己列个长期计划，并把长期计划分成段目标，每个目标完成后给自己进行激励。
8. 比知识更重要的是什么？
如果你有机会去互联网工作，就会发现你不会一直用一种编程语言工作的。很多时候，新项目来了，需要用新的技术，这时候老大会让你快速学会这个知识，然后在项目中应用。我之前做过的不同项目用到的编程语言来就有5种，而且是边学边用的。
回过头来看，比知识本身更重要的是你的学习能力。那什么是学习能力呢？
学习能力其实就是你能够做到“学什么会什么”。
有学习能力和没有学习能力的人差别是很大的。这就好比，你玩《王者荣耀》花钱找人替你通关，和你自己拼个人能力通关，所习得的技能和体验是完全不一样的。
提高学习能力的至少关键知识是什么呢？
其实就是两点：
1）习惯使用搜索引擎的能力
2）
不做伸手党的能力
这两个能力看起来简单，但是长期养成却很难。
投机与投资的差别就是投机看重的是短期的股票涨跌，而投资看重的是一家公司长期的发展，希望你在学习编程的路上采用的是“投资”战略，并且培养了自己的学习能力。加油，你并孤独。","我跟题主一样，做题手速特别慢，室友一两天就能完成的数据结构题我能卡住好几天。。
那种憋着的感觉的确不好受。。而且还会胡思乱想，怀疑自己，听了好多大道理，却写不出程序。。
没啥解决方案，弱就是弱，笨就是笨，承认了吧。先想通这点，然后该看书看书，该刷题刷题。另外，注意一下自己时间和注意力的分配，长时间卡住了就换别的任务做。
共勉。","前言
你太过在意周围的人了。当然，我们得承认这个世界是有天才的，普通人与天才的差距是很明显的，这个时候一个普通人如果过于陷入天才的模式里，那往往导致自我毁灭。而普通人与普通人进行比较是人之常情，但凡事要有度，过于陷入别人的BGM里是不可取的比法。就好比你和一堆
剑客
比谁出剑快，你总觉得自己慢，然后你苦练剑法……你就没想过万一你是个狂战士呢？万一你是个法师呢？所以不要过于陷入别人的节奏，要找到自己的节奏(必要时把别人引到你的BGM里来)。
对于编程语言
一个真正的程序员水平高低看的不是他做出来的东西有多“光鲜亮丽”，一个优秀的程序员应该是依靠编程语言但又脱离编程语言束缚的存在。所谓依靠编程语言是因为程序员的工作不能离开编程，编程自然需要编程语言。所谓脱离语言的束缚是指程序员不能依赖于某一两种语言想吃遍天，语言只是作为权衡项目需求和团队状况后做出的合适的选择。
语言本身没有高低贵贱，没有抛开需求谈优劣的必要。语言只是程序员用来向计算机表达自己思想的工具，那么这里面就有两个很重要的客体，一个是“计算机”一个是“思想”。你面向的是“计算机”（或其它电子设备），要表达好你的思想你需要对“计算机”有非常清楚的认知，否则你空有一身辞藻但是不知道要描述什么。然后，你要表达的是“思想”，那么这个思想是什么样的逻辑，怎么组织这个逻辑，将直接影响你表达的效果。所以针对“计算机”我们开设《操作系统》、《
微机原理
》/《计算机组成原理》、《数字电路》、《模拟电路》、《数据库原理》、《计算机网络》等等课程，目的就是让你了解计算机的软件以及硬件原理。然后针对“思想”我们开始《高等数学》、《线性代数》、《概率论》、《离散数学》、《数据结构》、《算法》、《数值分析》等等课程，用以组织你的思想。
对于编程能力
编程能力的提高点到底在哪？其实我上面已经指出来了。做程序就像做人一样，你需要掌握的最重要的部分往往就在最开始的地方。对于一个人来说，幼儿园是一个人第一次“上学”的地方，其实仔细想想会发现，幼儿园老师教授的很多东西已经够生而为人的基本了，很多成年人都未必做得到，如“上完厕所要冲厕”，“外面玩回来和饭前便后要洗手”，“要爱爸爸妈妈”，“懂得分享与分担”，“面对疼痛与困难要勇敢坚强”，“小朋友之间要团结友善”，“借东西要还”，“做错事要勇于承认”，“要诚实守信”等等等等，这些都是幼儿园老师每天要教的东西，试想又有多少人能用一生学会？
而作为程序员来说，最重要的知识也来自于其“原点”。想想大学时我们最需要学习的专业知识是什么？“高数线数概率”，“数字电路和模拟电路”，“各种编程语言语法”，“操作系统”，“数据库原理”，“计算机组成原理”，“
编译原理
”，“数据结构”，“算法”，“计算机网络” 等等等等，这些东西如同上学之初老师教你做人一样，这些计算机学习之初的知识线将决定你在计算机这个技术领域所能达到的高度（转管理不算）。你会发现，随便任何一门或几门配合编程语言深入研究下去都可以独当一面。如果你数学好，配合数据结构和算法，你将能解决很多别人不能解决的计算机领域的算法问题。对操作系统、计算机网络、编译原理等的深入研究都可以使你达到一个很高的高度。所有这些基础知识都相辅相成，俗称程序员的基本修养。
而即使你不想在这些方面有更高的建树，比如你说我就想做一个优秀的游戏设计的程序员。那么，除非你是做动画或美工之类的，否则核心编程都是相通的，都需要数据结构和算法，而诸如操作系统、编译原理、
数据库原理
等方面知识储备将能让你更快准稳的理解各种大项目中的问题。
所以你想成为优秀的程序员的话，从你该学的地方一步步做起。你需要了解很多语言的语法，掌握它们的特点。你还需要了解计算机的各方面理论知识，不了解这些就好像一个大夫不了解人体各组织结构就妄图做手术一样，做手术比的可不光是刀法，同样写程序比的也不是语法。而如果没有算法和数据结构，你恐怕连把合适的刀都没有。
总结
很多时候我们置身其中，并不能知道我们所学之用途，因为它们还没有在你脑海里融会贯通起来。而它们之所以没有融会贯通起来，是因为它们每一项你都没有学到可以触类旁通地步。这些知识点在你脑海里还都只是知识点，并没有连成知识体系。你需要将点连成线，将知识贯通起来。那么我们就“刷题”吗？就“看书”吗？ 
是，也不是。知识精进自然少不了必要的反复练习，和不断的扩充储备。但是就像你说的，刷题看不到用途，看书经常纸上谈兵。这个时候你需要的就是“实操”，在“实操”的过程中不断反向发现基础知识的不足，然后补充。现在的你们多么幸福，网上有数不清的开源项目，甚至有数不清的“带你走进
开源项目
”的项目。比如我曾经参加过的
Little Penguin Challenge
（现在已经下线了），还有我曾经帮别人参加过的Google Summer of Code (GSoC)。类似这样的东西有很多。即使你不喜欢这些活动，直接阅读和修改上游代码，为其添加feature也是十分推荐的。我写过一个回答关于怎么简单的给一个上游项目发送
patch
的步骤：
退一万步说，就算你真的只是看书刷题。那些经典教材书籍所留的homework、课程设计你真的做了吗？恐怕纸上谈兵的不是书籍本身，而是我们自己吧。
补充回答："
,,,,,,,,,,,,,,,,,,,,,
突然意识自己曾经引以为豪的编程其实是一种工具，这是一种悲哀吗？,None,"大学的时候，常常看央视的天天饮食，看完再吃食堂的饭，都觉得更香了。工作了，在国外，想自己做饭，又想起天天饮食，在线看太慢，就自己写了个下载软件，下载了做饭前看看。后来还给小孩下过动画片，给我妈下过养生保健。
后来炒股，不知道那些指标策略有没有用，写个软件，把自己想的，书上写的，大师们吹的策略都实现出来，在真实的历史数据上跑，没一个赚钱的，遂退出股市，这么多年，省了不少心力。
后来有了孩子，老婆嫌空调夜里温控不好，孩子容易受凉。我用
Arduino
连个温度传感器和红外发射器，自己写温控逻辑，为自家空调定制，热了调低，冷了调高，还考虑到
体感温度
随时间的变化，调优到完美契合。这都好几年了，上面一层灰，照样工作。
用虾米听歌，想找点没听过的歌，但各个歌单总是有大量重复的歌，听一会才能发觉，筛歌效率巨低，就写个脚本，自动筛除歌单中听过的歌，找歌的效率立马提高，个人乐库从几百首到两千首，我还给网站首页上加个筛歌的按钮，好像官方为我定制得功能一样。没多久，虾米就倒了。
后来思考人生的意义，干什么这一天才没白过，才睡的安稳，才不空虚。经过认真的琢磨，我觉得意义是在学习，生活，工作，健康等八个维度上的价值，把有价值的事列出来，赋上意义值，安排到每天的生活中，就不用愁今天干什么了。然后就写个app，起个名字叫“有意义”，放在app store里。迄今我用了五六年，导出来的excel文件，只有十兆大小，却包含了这几年每一天里我身边的事。
这几年胃不舒服，吃药也是这次有用，下次照疼。让我心烦，决定要解决这问题。说是胃病要养，但我也不想吃的太无趣。就写一个app，列出伤胃和养胃的东西，记录下自己日常饮食和胃部症状，建立一个数据模型，画出图来，预测每日的胃痛风险，今天风险高，就老老实实的吃，风险低，就可以吃的潇洒点，刺激点。不但胃好多了，还发现自己的一个特点，越吃越馋。
从读书到工作，我们在实现父母的期望，社会的安排，老板的想法。有哪一次，我们是在真正的实现自己的想法呢。一件事，我想做，我去做，我做出来，对于普通人来说，有几次这样的机会呢？
编程是实现想法的工具！当你会编程，不用求助于人，你就可以单枪匹马的实现自己的想法。可以验证想法，进化想法，也可以敝帚自珍的欣赏自己的想法。这个过程，是极具娱乐性的。这是编程的魅力，也是创造的快感。
有几个人想下载央视的视频？我想。
有几个人想要重写空调的温控？我想。
有几个人想要计算人生的意义？我想。
有几个人想要预测今天会不会胃不舒服？我想。 
无论需求多小众，我想，我就可以做出来，这大概就是工程师的超能力吧。
更新：养胃app已经上线 App Store，有兴趣的可以试试","我发现有些同志总是在下面说什么“我们都是工具人”“编程不是工具是什么”，
我觉得你们的思路错了。
我没有和其他答主一样，强调“编程就是一种工具”这个概念。因为我试图站在提问者的角度去看这个问题，尝试理解大家或多或少都存在的一些困惑。
你们不能因为我没有强调这个概念，就认为我是错的
，我在熬毒鸡汤；
不能因为我没有给出随大流的回答，就对我进行人身攻击
。是的，有些人在评论区和私信骂我，不过评论区让我给清干净了。
你们总是在强调“自嗨”“鸡汤”，仿佛自己已经站在了理性的鄙视链最顶端，殊不知没有人是绝对理性的，你们也不例外。
理性的思维并不比感性的思维要高级，我们灵魂的画像上也绝不应该只存在某一种色彩。
以下是原回答
恭喜你，意识到了编程和程序员的本质。
罗曼?罗兰
说过一句话，可能不太适合回答这个问题，但我觉得还是有必要写在这里：
世界上只有一种真正的英雄主义，那就是在认清生活的本质之后依然热爱生活。
或许你发现酷酷的python作为工具，大部分时候做的都是一些excel表操作，微信好友数据分析，爬网页，
或许你发现成就了许多大神的各种
开源项目
，比如spring boot，最后只是在互联网公司的服务器上做做增删改查，
或许你发现刚开始学习C#时带给你很多成就感的winform，
wpf
，blazor，相较于各种开源的UI框架和成熟的java生态体系，并没有啥特殊的，
或许你发现，曾经在一块单片机上点亮一堆LED灯泡时的成就感，在
嵌入式
开发者眼里啥都不算。
引以为豪的永远不是，也永远不应该是什么编程，什么语言，更不是什么开源。
各位应该引以为豪的永远是，在处理各种各样繁杂的业务之后，在解决各种各样复杂难以解决的问题后，在日复一日的生活带来的摧残下，
仍然保有对未知的好奇心，和改变现有框架的技术和勇气。","一句话给我整懵三次：
编程究竟哪里高人一等了；工具究竟哪里低人一等了；上述一大串跟悲哀究竟能扯上什么关系？","・
深受我国某些思想毒害罢了。
『工具』是很高贵的，是人类存世的意义之一，也是人类最伟大的发明和贡献。
现在的话术里面，『工具』反而成了个夜壶，不上台面的解决问题的消耗品定位。这是社会经济文化风向变化所导致的。
为什么？因为社会性质慢慢变了。大家越来越发现，工具不值钱，或者说再值钱也比不过背后的资本。资本可以啥都不会，只有钱，甚至不懂经营也可以找到『经营工具人』，不懂技术找『技术工具人』，至于别的更没技术含量的那简直满大街都是工具人。
为什么会这样呢？很简单，拥有资本的人，在社会框架里面占了过大的优势。一个很简单的例子，老板开公司，工人的劳动剩余价值100，公司总收入200，老板分走了100，打工人拿到100 。老板没出力就获得了100的剩余价值。
很多给老板『洗地』的人总会这样告诉你，老板承担了『风险』，工人不管货能不能卖出去，他的工钱是死拿的，绝不会亏。亏钱都是老板在背。
这些纯属扯淡。就不提老板卷钱跑路亏欠工资那种了。就正常的老板，你以为是200块钱回来，打工人和老板都拿100，老板不劳动担风险赚了100块钱。实际上是老板作为投资人，话语权被社会框架极度放大，他把你打工价值100直接压到20，不干拉倒。
20这个数字怎么来的？不是他编的，而是社会成本决定的。简单来说就是一个人不用住桥洞，不用挨饿，所必须的最低成本。20年前刚上社会的打工人，一个月拿1000，10年前拿2000，今年拿3000，但是跟物价比较，永远都是刚够你租一间单人房，每天吃最便宜的盖饭，坐最低价的公交车，年底剩不下来什么玩意。这个就是社会最底层劳动力的最低成本。
那么你想想，几十年科技进步，生产力发展，为什么这些『基本单位』打工人，相对价值成本还一直是那么多呢？发展带来的红利呢？进步呢？为啥没发展到刚毕业的年轻人干一年能买半套房呢？
投资的永远不会给你打工人应得的那点价值，因为他给你，就意味着社会进步生产力进步带来的资本红利也分给你，你出一样的劳动，却能获得和资本一样的增值。这是做梦。
能听懂吗？不用考虑细节，你就宏观看看就会知道：如果打工人能获得增值的好处，那么打工人和顶级资本家之间的贫富应该是按照不变的比例前进的。打工人月薪1000，马云1000万；月薪2000，马云2000万……这么下去贫富差距一直是成比例的，怎么可能拉大呢？
所谓的贫富差距变大，一定是你1000元，马云1000万，你2000元，马云一个亿，你3000元，马云100个亿……
资本家有了资本，就有了压价的能力；打工人的工作量不能存储，只能按天按次花费大量时间慢慢释放，一天不干就亏一天，所以毫无溢价能力。你今天不干活，白亏一天，而资本放着不动是不会亏的。两者讲价，哪个会先受不了？
所以资本家（这个群体、这个阶级），可以用压价的手法把工具人控制在一系列标准内：干一年能攒下来一点钱；干十年可以攒几个平方，干30年外加贷款可以攒下一套房……
打工人也就成了『工具』，因为『工具』是不参与分红的。只考虑它的损耗而已。
既然是『工具』那还用给你什么好脸色吗？都是螺丝钉而已。
实际上的工具是什么？它应该是人类最高目标之一。人类的科技、文化等发展，也不过是在不断完善一些『工具』而已。
别说科研生产里面工具多重要了，就算是文化领域，能开发某个具体技巧『器用』的，那也不是一般的大师。比如
希区柯克
对剧情玩法的种种技术，说起来也是器用，但这种改进整个电影领域能有几个这样的大师呢？凤毛麟角。所以说真正能让『工具』有一丁点实质发展的人，大致都成为了大师或者精英。
从这个角度来看，当不上资本家的，也就只能向内索取意义，以改进工具为人生一大目标了。
这个世界就是这个样子：在我们眼中的『大师』比如
手冢治虫
、宫崎骏，可能在那些资本家眼里也不过是『出色』的工具大师而已。高贵不到哪去。
希区柯克？他有几个亿？
・","之前跟导师讨论一个项目，基于之前发现的某种材料的一种牛逼的性能，我们打算把材料做出来试验一下。由于可选的成分太多，用传统的
正交试验
（俗称炒菜法）来做太过费力，于是我给导师天马行空地描述了我的材料设计思路，包括用机器学习的方法进行成分筛选，模型优化，机理嵌入，
特征分类
等等等等，我俩一下午从办公室讨论到酒吧，越讨论越心潮澎湃。等喝完酒准备回家的时候，导师拍着我肩膀问我：你说的这些，实现起来要多长时间？虽然已经喝醉但我还保持着理智，回复道：我得先花个把月把Python学一下，加上实验怎么也得半年吧！导师摆摆手说：等不了那么久，我明天就帮你雇两个程序员。","嗨，发现了事情的真相，你却不愿意接受？
你想想当年咱们为啥想要有计算机来着？不就是为了把人从复杂的计算中解脱出来么？computer的目的就是方便人们computing呀！
昨天还和小伙伴聊天呢。关于我每天搬的砖。
大部人写的东西，其实就是工具类呀。尤其是我们
data infra
的，我们不少人干的就是为了把底层服务封装起来，调用的人按照规定把参数传过来，然后底层就给他们想要的结果。
他们并不需要关心你底层到底是用的什么引擎工作的，经过了哪些步骤。
只不过，作为写infra的你，就需要把你的螺丝钉拧好了，有哪些实现方式，需要考虑哪些因素，有哪些现成的工具可以复用？
然后你处理好这些之后，就把你这一阶段的API定义并实现好。你工作就完成了，你这一环也就okay了。
然后你就可以写下一组API了。
你完成了工作有钱拿，离开产品和服务的技术，再nb又如何呢？
其实有螺丝钉可以拧，还能养活自己，挺好的。","最近几年我也一直在寻找人生的意义：当我们不再被基本的物质生活所困扰的时候，人活着到底是为了什么，可能这个问题一直没有答案，谈谈自己的想法。
小的时候，我也崇拜过Linus, 后来更喜欢Xavier Leory因为感觉后者更全面一点。再后来因为工作的原因，近距离接触过，发现这种人生并不是我想要的人生，他们只是在一个很小的圈子里面是神一样的存在。
后来自己经营一个程序语言的社区，经常被一些人气的半夜睡不着。午夜梦回，经常问自己为甚么要为一个不相干的人发脾气，他可能是一个你一辈子永远也见不到的人，甚至说完全不同的语言，生活在不同的半球。
现在我的想法是人活着是要让自己爱的人开心，让爱自己的人幸福。我爱这个国家，爱它的文化，所以不管是不是内卷也要回国生活，我要把自己学到有用的东西传递给更多我爱的人，我希望我的下一代不用再远赴重洋，异国飘零；我爱自己的家庭，所以每天需要花更多的时间陪伴老婆，我爱自己，所以无论如何再忙，也要抽出时间多锻炼身体。
这是我现在的认识，让自己爱的人开心，编程或者其他技术都是达到它的一种工具吧。","大概1994年时候，那年，我16岁。
电脑，当时还很神秘。平常人家，难睹其芳颜。我从没见过电脑，普通麻瓜一名。
有一天，发现我哥整天在看一本书，他说，这本书讲的就是电脑。你只要看懂了，就掌握了电脑。
我十分好奇，一看书名《BASIC程序设计》。
我问我哥：
B-A-S-I-C
是什么（要一个字母一个字母的念）？是电脑吗？电脑为什么叫B-A-S-I-C？
显然，我哥给不了我答案。我只好自己去看这本书。
第一章，讲了一种奇怪的计数方式，将一个数字不断除以2，记录余数和结果，最后变成一个1101001。。。样式的数，
好奇怪，它是什么？它似乎是进入魔法世界的钥匙。书上把它叫二进制。
我看了两周，我还是搞不懂啥是二进制？为什么要二进制？电脑，和二进制有什么关系？为什么学会了二进制，才能学这个神秘的B-A-S-I-C？
我放弃了，16岁的时候，那个时候的世界，存在太多末知，有太多东西可以吸引我，当一名普通麻瓜也不错。
1995年，我们开电脑课了。终于，要在老师的带领下，进入IT世界。
一上来，老师就带我们背内功心法口诀，据说很厉害。口诀是：他强由他强，清风拂山岗；他横由他横，明月照大江 …………。哦，不好意思，看武侠太多，串词了。真正的电脑口诀是：
王旁青头兼五一、土士二干十寸雨、……。对，它是“五笔字型”。我现在就在用它，来写这篇文章。
学了五笔字型，我们终于上机了，我也终于摸着了电脑。
我们排着队进入微机室，每个人都要穿鞋套。为什么要穿，不知道。如果有人可以不穿，那绝对是权威的存在。有一个高年级的同学，就可以不穿鞋套进入，这在我们同学心目中，简直就是“剑履上殿,入朝不趋,
赞拜不名
”。
当然，除了五笔字型，我们还学了一个东西，启动的时候屏幕上用字符显示一个大大的：dBASE。
create table\list\append……。期末考试，我们就考这些命令。
1996年，刚过18岁，我毕业了。职高生吗，就是18岁毕业。我学的是会计，我应聘到当地一家做财务软件的公司。终于可以每天摸到电脑。
我的职务是培训讲师，主要讲授公司财务软件的使用方式，还有电脑的基础知识，五笔字型什么的。我的讲师也生涯由此开始。1996年，我也接触到了另一个东西：C语言。
我是看
谭浩强
的《C语言编程》入的门。一个月间，我白天在公司学习，晚上回家没电脑可用，就看《C语言编程》做笔记。一个月我就学会了C语言，后来我常常以此炫耀。
其实也就是只学会了条件、分枝、循环、变量、数组什么的。内存、指针还似懂非懂。以境界而论，这个时候最多就是炼气初级，入门级的程序员。
我对底层十分感兴趣，到书店买了几乎每一本讲计算机的书，《电脑报》上的小技巧，更是看了一遍又一遍。1997年初，还尝试向《电脑报》投稿，我用C语言写了个DOS下隐藏文件的程序，我总结成一篇文章，寄给了《电脑报》。但最终没没有回复。
不过，这不会影响我研究技术的热情。我还记得，有一天晚上，我在研究DOS的内存驻留技术，这是一种古老的在单进程系统中，模拟多进程的方式。
在一遍又一遍的失败后，终于在午夜时分，成功了。我让一个程序驻留在高位内存中，它运行后，并没有结束，而是一直运行。每隔1秒，它让PC机的喇叭“B”的响一声。同时，还不影响你运行其他命令和程序。二十多年后，似乎还能感受到当时的兴奋。那种快乐，足以抵消领到好人卡时候的惆怅。
是的，这一年我领到了人生中第一张好人卡。起因是，我帮一个朋友补习课程，她们学校在讲：BASIC，她听不懂。
当然了，一上来先讲一个星期除以2记录余数……，谁听了都没兴趣，不懂很正常。
我说：包在我身上。
她说：可你不会BASIC。
我说：放心，几天之内，我就可以学会。
然后，我用了两天时间吧。翻看完了那本《BASIC语言设计》。学习一门语言，so easy。
其实，学了多少种编程语言、某个编程语言的掌握程度，都是浮沙之上的高楼。还有一层在语言之下的东西，但我当年当然没有悟到。很长时间，我都以为，编程语言，就是全部。
后面的故事，有我亲授，那有挂科的道理。她成功通过了BASIC的考试，然后就给了我一张好人卡。
我还花了几个月，研究《8086汇编语言程序设计》。书中的东西，我一开始全不懂，每一个字都认得，但组合在一起，我就傻逼了。
看示例程序，mov来，mov去，功能就完成了。mov相当于赋值，为什么赋个值，功能就实现了？
后来有一天，我坐在一棵树下，发誓搞不懂绝不起身。终于有一天，豁然开郎，我顿悟了，大地震动，雷声阵阵，霞光普照，香气四溢。。。当然以上都是我在扯蛋。
我的确把《8086汇编语言程序设计》看了好几遍，还抄，抄了有半本的时候，真的突然就明白了。内存，是程序的舞台。mov修改内存中的值，就是修改各种状态，……。
就好像，有一块内存，对应显卡，只要将这块内存中某个字节改为1、0，就显示出一个白点、黑点（像素）。
键盘，也对应一块内存，向这块内存写入一个值，就好像敲击了某个键。所以，我看别人的程序，都是mov来mov去的，功能就实现了。读、写不同内存区的值，就能完成某些操作。
这是我第一次顿悟。
1999年，21岁。顿悟之后已经有几年。越来越失去方向。DOS，那个文本的时代，过去了。我引以为傲的内存驻留，等等，这些高深的DOS技术，都过去了。多少年后，只剩下我曾经使用的网名：文本时代，还记录着，它曾来过这个世界。
这一年，有个重要的事情，我又领了一张“好人卡”。
“你是一个好人”，这是人生中第二张好人卡了。我给自己起了个新的网名：VAGE。把A和E两个元音颠倒一下，就是一个单词。我是想提醒给我发好人卡的女孩子们（对，要加们，是复数），颠倒一下，有时能更清楚的理解这个世界。
百无聊赖时，我翻了翻已经买了好久的书，《Windows95程序设计》。
好像也没什么。后来又看了
候捷
的《MFC程序设计》，还有点意思。懂了“框架”这个高大上的词。别人把常用的、不怎么变的代码总结出来，帮你自动生成，就是框架了。
比如，你新建一个p1.c文件，打开，马上就有下面几行：
int main(int argc, char *argv[])
{
    // you code
    return 0;
}
这就算是框架的雏形了。
通过《MFC程序设计》，还理解了一点，函数指针的应用。把数据、函数指针，放入一个struct中，就好像c++的Class一样。……
此后又过数年，（这些年，）我一直在老家省会做外包，也就是临时工了。使用五花八门的语言，满足客户开发五花八门的需求。其实就是打怪升级。
我的技能点也不断增加，C/C++、Java/JSP/J2EE、HTML、网页三剑客、……，
我们的项目部接到需求，客户想培训两天Auto CAD。已经是资深讲师的我，责无旁贷啊。于是，我的技能点，就又增加了一项。
但我越来越迷茫了。
开始进入IT世界，已有五、六载时间，我学了好多东西，我是骨干，我几乎无所不会，但是，这些真的就是“电脑”吗？
我又好像回到了1994年，初遇B-A-S-I-C的时刻。一种迷茫的无力感，时刻裹挟着我。只觉得空有一身力气，却看不到，要干什么。
以上，就是我当年参悟到“引以为豪的编程，期实只是一种工具”是的心情。
本来以为不会有人看，只写了一部分。没想到，还是有人爱看的，我后面尽快写完。
还有一个视频：
IT世界修仙记―从开发小白到专家
对职业生涯迷茫的同学，也可以参考下","除了
，这世界都是你的工具。连
、感觉、情绪都是，更不必提你的手臂、大腿和老二了，统统都是你的工具。","这种悲哀感的本质，其实就是马克思在《
1844年经济学哲学手稿
》中提出的“四个异化”（的前三个）：
1，工人同自己的劳动产品相异化。
2，工人同自己的劳动相异化。
3，人同自己的类本质相异化。
马克思认为人区别于动物的最大特点，就是人本质上就需要“工作”，既“创造性地改造环境”。马克思所说的工作，其实就是后来“
马斯洛需求层次理论
”中的“自我实现”需求。
这也是马克思的牛逼之处，理论精髓之一――人的本质就是需要工作、热爱工作的，工作是人之所以为“人”的重要组成部分。
但是
资本主义世界的雇佣关系，将工作这个部分严重扭曲了，以至于将“工作”与“人性”剥离开来。在资本主义世界中，无论是宏观角度还是微观角度，工作都与人性割裂开来，甚至让“工作”与“人性”变成了对立的存在。
所以人们普遍认为，下班才是人生的开始。
所以人们才需要丰富的夜生活，才需要各种宣泄和放纵。
而这，也助长了消费主义。
但是消费带来的快乐，终究只是隔靴搔痒，甚至是饮鸩止渴。消费并不能真正填补人性被剥离的空虚。
特别是，被剥离的部分（工作，或者说是自我实现）还是人性最重要、最核心、最高级的那一部分……
这种人性被剥离的悲哀
就正是你体会到的悲哀
你引以为豪的时候，是你以自我实现（工作）角度去看待编程，这是人性最高级的展现，当然值得自豪。
而你悲哀的，是发现编程如此高级的东西，它并不属于你……不仅编程的成果不属于你，编程的动机也不属于你，编程过程附带的精神回报也不属于你，甚至你的自我实现（工作）需求也不属于你了……编程沦落为一种生产商品的工具，甚至其本身也是一种商品。
你的自我实现，变成了一种交换生存资料的手段。放到
马斯洛三角
里，这种悲哀体现的更加直观：
这个过程相当于把最高级的需求（自我实现），直接压低到最低级的生理需求（交换生存资料）层次！甚至，资本主义倾向于让你只能交换到“刚好能活着”的生存资料，多余的价值都会被剥削！甚至的甚至，再观察一下其他那些层次的需求，呵，这些东西在职场中都是要一一被打破的东西（职场pua请大伙卷起来！）。资本就是要把你压到只能获得生理需求的水平！
这实在是太tm悲哀了啊！
所以马克思也是深感悲哀，才搞出了共产主义。
而共产主义最本质、最核心的创新，就是要把资本主义剥离出来的人性还给人类，把工作和人性相统一，把每一个人都变成完整的人。
两百年前的哲学家，就已经从现象看到本质，抽离出一套理论体系，做出了一堆神准的推演和预言，定位了核心问题，并想出了一套解决方案。
牛逼不～
附一段关于马克思四个异化的论述：
1、工人同自己的劳动产品相异化。
马克思认为，在资本主义社会中，存在着这样一个基本事实，即工人生产的财富越多，他就越穷。工人创造的商品越多，他自身就变为越廉价的商品。“物的世界的增值同人的世界的贬值成正比。”这跟人的本质要求是大相径庭的。“劳动所生产的对象，即劳动产品，作为一种异己的存在物，作为不依赖于生产者的力量，同劳动相对立”。所以，马克思得出结论：“工人对自己的劳动的产品的关系就是对一个异己的对象的关系”。
2、工人同自己的劳动相异化。
这种异化关系决定了工人同自己的劳动过程之间的关系也必然是异化的。工人在自己的劳动中无法肯定自己的生存意义，相反，只能否定自己。在劳动中，工人不能自由地发挥自己的体力和智慧，只能使自己的肉体和精神遭受摧残。防纱的工人一年到头只能围着机器打转，与机器人没有差别，煤矿工人在矿井下工作，连安全都没有保证。在马克思看来，真正的劳动应当是一种自由自愿的活动，这是人成其为人的一个基本条件，每一个劳动者都应该能够体会到生命的价值和意义。可在资本主义社会中，这样的劳动是不存在的。工人为了生活，没有选择的资格，工人的意愿，在资本主义制度下显得微不足道。而且这种异化的本质还是工人同劳动产品之间的异化的根源。劳动产品的异化是物的异化，劳动活动的异化是劳动者的自我异化。物的异化是劳动者自我异化的总结而已。
3、人同自己的类本质相异化。
在马克思看来，人的本质就是要劳动，要自由自觉的劳动。不允许人进行自由自觉的劳动，是违反人的类本质的。而在资本主义社会中，这种情况恰恰就发生了。自然界给人提供劳动加工的对象和人类生活资料，使人的肉体能生存。但是“工人越是通过自己的劳动占有外部世界、感性世界，他就越是在两个方面失去生活资料。”
4、人同人相异化。
马克思认为，当一个人分别同自己的劳动产品、劳动活动和类本质处于异化、对立状态的时候，这些东西必然属于另外一个“他人”。即就工人而言，这个“他人”就是有产阶级、资本家阶级。正是这部分人以及作为其政治依托的私有制才导致了工人与自己的上述三个规定处于异化状态。也就是说，私有制度下的所有人都跟真正的“人”相异化，其本源就是私有制度。所以私有制度必须被批判和推翻。在《手稿》中，马克思经常在同一意义上使用异化和外化两个概念。在此，马克思区分了对象化和异化。劳动对象化，劳动者在劳动过程中把劳动凝结于劳动对象中，产品包含了劳动者的劳动和生命。那么劳动产品本来应该属于劳动者。然而，马克思看到事实并非如此，实然与应然之间存在巨大鸿沟。劳动对象化不一定导致劳动异化，但在资本主义私有制的条件下，劳动产品异于工人而存在，不属于工人。不是工人支配劳动产品，而是劳动产品支配工人，这就是
劳动异化
。简单的说，物支配了人。所以，马克思非常现实地写道：“在国民经济假定的状况中，劳动的现实化表现为劳动工人的非现实化，对象化表现为对象的丧失和被对象奴役，占有表现为异化、外化??????对象的占有竟如此表现为异化，以致工人生产的对象越多，他能够占有的对象就越少，而且越受自己的产品即资本的统治。”","没啥可悲哀的，这世界绝大部分东西都是工具。
作家引以为豪的纸笔键盘，是工具。
书法家引以为豪的笔墨纸砚
文房四宝
，是工具。
播音员引以为豪的铿锵有力的嗓音，是工具。
工人引以为豪的操作手艺，是工具。
到最后，你会发现之所有还有人愿意给你工资，也是因为你自己就是工具（人）。
真的，没啥可悲哀的，工具的作用就是适得其所，不要为工具而悲哀，要悲哀就悲哀自己，想象是不是自己作为工具（人）只是付出却没有获得对应回报，如果是，那才是应该悲哀的。","恭喜你，终于认清了编程的本质。
前两天我在对女朋友说：
“感觉现在没有多少时间学技术，技术都没有进步多少，大多都是不断熟悉业务”
女朋友：
“傻瓜，技术不是最重要的，技术如果不能带来商业价值，那就没人维护，做技术的人，千万不要抱着
。。。”
“你看Apache那些顶尖项目，比如Dubbo，不一样只能靠捐赠维持。。。。”
“但是你看有些大厂内部烂成屎山一样的代码却每天创造大量的利润。。。”
我恍然大悟，放下手上的 paxos made simple 去睡觉了。。。
----后记----
技术说到底还是为了提高生产效率，为了解决业务的问题而产生的，没有了业务，技术就没有了存在的前提，没了业务，搞技术的也只能失业。。
很多人可能说那些造轮子，搞底层技术的人就不容易失业，实际上他们不容易失业真的是因为技术吗？
部分是，但我觉得更多的是因为他们技术更加通用，比如云、分布式存储、操作系统等，不管哪个上层业务都能用到，这才是搞底层技术更加长青的原因。
就算你是搞底层的，大多数都是可替代的搬砖。。。当然，不排除一部分真正的技术大牛有着无可替代的作用，但是这样的人毕竟是少数。
真正热爱技术的人是认清了技术是工具的本质，依然热爱技术！
为热爱的技术的程序员点个赞！！！
欢迎关注我
 
@编程指北
 编程指北，分享硬核技术，依然热爱技术！
附
程序员必读
经典书单：
书单推荐，少即是多（含下载方式）","收藏了多年的文章，分享出来。
许多年前，中国社会有一句流传甚广，但是错误深重的话：学好数理化，走遍天下都不怕。这句话没有流行十年，就被另外一句话取代了：造原子弹的，不如卖茶叶蛋的。对比前后两句话，前者的谬误就变得非常明显---
依仗单一技能，是不足以应付一个复杂而快速变化的世界的
。尤其是在一个现代社会里，技能可能是生活的基础保障，但是对于生活质量的贡献却极为有限，基本算不上是决定性因素。
技术男对生活有一种天真的看法，认为存在以下不言自明的真理：我只要专心搞好技术就可以了，其它的东西自然都会有的。没有那么自然的事，如果沃兹尼亚克没有遇见乔布斯，他现在还是一个电脑工程师，不可能连续两次前后亏损接近3000万美金，举办音乐节。也不会全世界飞来飞去，作为传奇人物被大众所认知。
在这种误解之下，还有一种更为深刻的心理偏差：我不喜欢和人打交道，所以做技术工作最适合我。于是，就出现了那个著名的观察结果---
技术平庸之辈总是能成为领导
。这或许是真的，管理技术男的人通常都不会是技术最强的那一个，但是，他往往是极少数同时可以同技术员和普通人打交道，让双方能够理解彼此的人。虽然这个能力在技术男那里可能会被鄙视，可是在麻瓜的世界里，这是了不起的能力。没有这种能力，麻瓜的世界和巫师的世界之间就没有了中间人，也就不存在沟通理解的可能。
认为技术可以包打天下，认为技术世界可以避开复杂的人际关系，这是技术男的第一种毛病。
当一个人如此倚重技术的时候，很自然地会把技术的地位提升到前所未有的高度。我不否认职业荣誉感的可贵，不过这里需要强调一个基本常识：这个世界的本质是人和人关系的总和，驱动这个世界运转的力量是利益和利益的分配。技术在这个世界里，过去、现在、将来都是配角。
沃兹尼亚克
的电脑再强悍，技术再精湛，也需要乔布斯把投资弄进来，把电脑卖出去，用大众听得懂的语言给他们一个购买的理由。把Think Different这种感性的认知，绑定在购买一台苹果电脑的消费行为上，这是沃兹尼亚克和所有他的技术小伙伴都做不到的事情。
在技术男看来，乔布斯所做的事情“不实在”。这当然不实在，世界上有许多事情都不实在，比如说爱上一个人，或者被一个人爱上，这件事情并不是拿出技术等级证书和银行收入证明就能够完成的。因为它需要走出去参加聚会，需要一对一聊天，需要烛光晚餐和电影，需要做一堆没有逻辑也不能预期结果的事情。如果要一万人，十万人，一百万人，一亿人爱上你的产品，可能需要更多“不实在”的事情。因为程序和技能不能直接变成产品，产品也不会自动跑到用户家里，钱就会自动划到公司账户上。它需要不实在的产品设计，不实在的市场推广，不实在的商务谈判，需要一堆人拍胸脯、吹牛皮、说服另一堆人相信。技术在这个复杂的故事里，只是一个环节而已。
认为技术至上，其他职业技能都无法和技术相提并论，这是技术男的第二种毛病。
如果一个人的手里只有一把改锥，那么，无论他在这个世界上遇见了任何东西，他都会第一时间想用改锥来两下子。这种行为有一道护身符，叫做：技术中立。在技术中立之下，似乎一切都理所当然。因为缺电，因为航运能力不足，所以纯技术手段的解决方案是修建大坝。至于因此造成的地震、生物灭绝、历史古迹消亡，那是无关紧要的小细节。因为技术需要，所以用克隆技术直接克隆人类，因此产生的伦理学、道德困境就不算是个问题。五十岁的儿子面对母亲的三岁克隆体，真的不会带来任何困扰么？从自己的克隆体身上取下心脏，进行自我移植真的不算是谋杀么？
从技术中立的角度看，制造出一颗足以毁灭地球十次的炸弹，它的意义何在呢？
专注技术这个概念，在一定程度上变成了封闭。只有技术世界里的事情才构成值得思考的对象，除此而外的一切事情都不值得学习和思考。许多技术男对于人文知识的认知几近于零，在网上成为狂热的“工业党”，原因就在于此。除了技术中立之外，价值观一塌糊涂，甚至以此为荣，认为自己超越了善恶的两端，达到了某种超然的境界。在他们看来，
奥本海默
因为制造出核武器而忏悔，完全不是不明所以和毫无必要的矫情。钢铁侠统治的世界才是一个美好的世界，在那个世界里，技术可以决定一切。
认为一切问题都可以用技术手段解决，用极为狭隘的视角看待世界，这是技术男的第三种毛病。
这张列表我可以继续开列下去，不过我觉得写到这里已经足够了。每次看到技术男在这个世界上撞得头破血流的新闻，我在同情和惋惜之余不免去想一件事情：如果技术男是洁白无辜的羔羊，在无法捕杀所有饿狼的情况下，还有什么办法能够帮助到这些羔羊？这篇文章就是我的答案，我认为羔羊应该长出犄角，能够高速奔跑，能够在群体中获取力量和保护。为了做到这一点，技术男也应该反思一下自己的想法，反思一下自己对世界和人类的认知。技术只是羊圈的栅栏，它不应该成为某种自我设限的牢狱，也不应该成为狭隘心态和狭窄视野的温床。
在这都市每生活一天，都意味着要面对同事、上级、保姆、快递员、律师、中介、招待、保洁、门房、司机、导购、邻居、亲人、朋友，都要面对合同、邮件、文件、新闻、计划、财报、统计、日程表、商业策划案，它们都不是技术所能解决的人和事，也不是专注于技术就能自动消失的问题。
它们后面是形形色色的人，各种各样的欲望，千奇百怪的人际关系，和在之上的关于利益和利益分配的角力。每个人都要考虑，如何在这样的现代生活中安置自己，寻求自己的利益最大化。如何找寻盟友，如何分辨人物，如何找到可以信任与合作的对象，谋求更高的胜率。
而所有这一切，仅仅靠技术是远远不够的。单凭一把改锥，撬不开全世界的锁。","没事儿，悲哀的还在后头。
等你意识到引以为豪的自己也是个一个工具的时候，你就麻了。","我从报这个专业的时候起，就已经知道这一点了。
那年我去看望三爷爷，聊到选专业的问题，他说 “计算机只是工具，不能只学这个”，然后我告诉他说，我要学的是怎么创造工具，而不仅仅是使用它，于是三爷爷点点头。
所以哪里存在什么 “突然意识到” 呢，是一开始就知道呀！
如果这个问题想问的是，工具究竟有多大价值，那么我想说，经济基础决定了上层建筑，科技水平决定了经济基础，而每一次科技革命都是由工具的变革引发的，从钻木取火，到石器时代，到青铜器，铁器，火器，到蒸汽机，内燃机，到电力，计算机，互联网，人工智能，哪一步不是用一种工具定义了一个时代？
如果这个问题想问的是，人在社会上的地位，那么我想说，不仅程序员是工具人，每个人都需要在社会上找到自己的位置，成为别人的工具，而另一方面每个人又都并非是无可取代的，时代的洪流滚滚，不会因为少了谁就停止向前。 强如奥运冠军，你也可以硬说人家只是给资本家拍广告的带货工具，富如王健林，你也可以硬说他只是执政者的缴税工具，智如诺奖得主，你也可以硬说他们只是扩展人类知识边界的科研工具。 所以 “不想当工具” 这种想法究竟是哪儿来的，难不成你想要统治世界不成？
如果这个问题想问的是，社会资源的分配机制，那么我想说，这可能是问题，但绝不是程序员最应该关心的问题，在这个问题上，程序员暂时只能算既得利益者，不信你去看看别的行业？","编程是一种工具吗？我更愿意称之为一门手艺。
所有能用来讨生活的技能，都可以称之为手艺，而程序员本身就是手艺人。
和其他可以用来讨生活的手艺一样，没有什么可悲哀的。
大到千古传唱的唐诗宋词，小到随处可见的街头巷尾，作诗填词是一门手艺，摆摊吆喝也是一门手艺。
不同的是，有人借此流芳百世，有人淹没于滚滚红尘，有人靠此名利双收，有人用此生活无忧。
伟人曾经说过，枪杆子里出政权，而枪杆子本身，也是一种工具，但正是因为这种工具，才有了今天的蒸蒸日上！
所以，悲哀是悲哀者的悲哀，热爱是热爱者的热爱！
无它，唯人而已！","不悲哀，先说问题本质
编程对于普通人而言，就是一个技术，所有的技术都是工具
公司企业也是工具，其目的是最大化股东利益，通俗点说，就是帮股东老板赚钱的工具
所以在企业公司里的员工，无一例外，都是工具人
程序员，工人，会计，前台，甚至包括职业经理人，都是为股东赚钱的工具人，明白了吗？
为什么我不觉得悲哀呢，因为打从一开始，我就没有打算为了技术而技术
技术是工具才符合我的初心，我学编程，是为了实现我想要实现的软件
而不是为了那些简陋的英语单词和符号的拼凑
能从简陋的英语单词和符号中看出美感来的人，我不知道它是怎么想的
也就是我从学编程的那一天起，就不是为了编程而编程，而是带着某个目的去编程
就我想要实现一个软件，我该如何用手中的技术，也就是编程去实现它
怀揣着这个目的之后，因为目的明确，所以我学得很快，很多细节可以直接跳过不看了，用的时候再说，但是很多人因为没搞懂这个目的，所以经常在细节上绕来绕去，其实一点意义都没有
就跟
北洋
一开始学java，还去背classpath，path的设置一样，现在解压缩后直接用了，这些设置都不需要搞，北洋之前背的是不是就白背了？
还有像
jvm
的参数，cms一大堆参数，现在zgc了，会开zgc就行了，就一个参数，cms那一大堆参数就算你记住了，又有什么意义？没用了
但是我不一样，因为我知道这些东西是工具，所以细节可以不用太过于在乎，你知道这是做什么用的，就行了，细节用的时候，其实辅助编程工具会提示你，你都不需要去记，所以我学起来就特别快
这也是在国外读书时候的秘诀，就是一大本书，你别把每个字都看过去，你应该速读，看每一段的第一句话，看懂，看不懂才看该段下一句，如果还看不懂，再看下一句……但是如果你看懂了，这一段就不看了，看下一段，其实出国时候的外语阅读训练，就是做这种训练，考过托福雅思gre的应该很清楚我在说什么，其实技术也是一样的，你知道这个工具是做什么用的，然后大概怎么用，行了
其他的细节，在你干活时候，工具会帮你，比如java的ide，自动提示是非常常用的功能，如果ide还帮忙不了，那就Google咯，做到这两步，其实编程就轻而易举了
然后我就赶紧用手中的工具去实现我想要实现的软件去了，然后进一步创业去了，谁神经病一天到晚对着技术在那边啃细节，那是书呆子
就跟我们读书时候，我们经常可以遇到一些同学，这些同学不是说他不努力，他很努力，但是成绩就是上不去，为什么？他只是无脑的背诵记忆而已，都没有总结规律，这个规律在语文中就是中心思想，数学中就是各种公式定理，英语中就是语法规则，化学中就是方程式，但是几乎所有学科，都在帮你总结规律，你要做的就是找到这个规律，然后加以训练，熟练掌握规律之后，去考场上答题
所以死记硬背的话，遇到同样的题型，改一点细节，他就不会了，那这样做成绩能好么？
再努力也没用啊
技术也是如此，你需要做的，就是找到工具使用的规律，然后剩下的，交给工具去完成","很长时间里我都很喜欢写程序，编程是自我认知的一部分，直到现在也是这样，只是不再那么强烈而已。我也有过题主这样的感受，这其实是某种轻度 existential crisis，也就是找不到存在的意义――当自我认知的一部分失去了重要性，当然会觉得失落。
不知道题主之前把编程当作什么，技艺？特长？信仰？生活态度？遁世奇术？总之想必是放在某种超越工具的地位，而这并没有什么问题，对其他人来说处于这个地位的可能是琴棋书画，烹饪滑雪，翻修摩托，或者开挖掘机。我们会以超过平均值的热爱来对待某项活动，有些人可能会一辈子都保持着这样的热爱，他们无疑是幸运的。但忽然有一天你下头了，你开始像缺乏催产素和多巴胺的晚期情侣一样对你与热爱之间的关系产生怀疑。这也没什么问题，甚至应该祝贺你，因为与其说这是一种悲哀，不如说这是一种成长。
每一次 existential crisis 都让人成长。那些以往被热爱支配的脑细胞空闲下来，甚至有点闲的发慌的时候，很适合思考人生的意义。如果你觉得编程只是工具，本质上与螺丝刀或者微积分无异，那你可以找找别的什么来成为你的下一个热爱，比如琴棋书画，烹饪滑雪，翻修摩托，或者开挖掘机。世界上好玩的事情很多，编程只是其中一个，每一次下头都是下一次上头的开始，上头过的东西越多，你的自我认知就越稳固，由于一个单点而失去自我认同的风险就越低。为什么很多人喜欢用「不做X的Y不是好Z」这种胡话做签名？因为它看起来显得这个人自我认知很多样性。
不管你觉得编程是什么，客观上作为一种人类活动的编程其实并没有改变，所有的意义都是被赋予的，你说它是工具也好，是人类命运终极答案也好，它都不会有什么反应。也许有一天你又会觉得编程开始上头了，那你完全可以再把它供起来，社会不会因此给你一点点道德压力，甚至会有人为你觉得开心，比如我。","孱弱的知识分子们就不要在小布尔乔亚聚集地知乎做小布尔乔亚式的无病呻吟然后勾引一批小布尔乔亚式的回答了，不如来点
齐泽克
笑话。
一位年薪百万的高级程序员说：“天啊，我引以为豪的编程，其实是一种工具，这不是一种悲哀吗？”
在他之后，一个年薪二百万的投资经理说：“天啊，我引以为豪的投资技巧，其实是一种工具，这不是一种悲哀吗？”
接着，一个农民上前说：“天啊，我靠锄头养活全家，但锄头其实是一种工具，这不是一种悲哀吗？”
高级程序员悄悄地对投行经理说：“这个可悲的农民，他以为他拿的是什么东西，锄头也配是工具?”
联动一下
如何看待武汉大学邓红兵教授为生化环材专业正名「没有差的专业，只有差的人」?
5708 关注 ・ 1844 回答
问题
一位年薪百万的高级程序员说：“天啊，我引以为豪的编程，其实是一种工具，这不是一种悲哀吗？”
在他之后，一个年薪二百万的投资经理说：“天啊，我引以为豪的投资技巧，其实是一种工具，这不是一种悲哀吗？”
接着，一个月薪五千的生化环材的工作者上前说：“天啊，我苦心学习数十载的生化环材知识，其实是一种工具，这不是一种悲哀吗？”
高级程序员悄悄地对投行经理说：“这个可悲的生化环材人，他以为他自己学的是什么垃圾东西，生化环材知识也配是工具?”","你以为的编程是这样的，在电脑前慷慨激扬，指点江山。
实际上，大多程序员是这样的。
也有客户不改需求后的欣喜若狂。
认识到了编程是工具这一点应该感到庆幸。
那些科研人员，不会以熟悉编程为自豪。编程只是他们实现算法的工具。其核心是科研能力，而不是所谓的编程技巧。
有了编程工具，我们能让计算机为我们做很多事情。
因此，我们追求的不应该只是编程这个工具。而应该是我们可以用这个工具做点什么事，解决什么问题。
将编程这个工具与自己的专长、爱好结合起来，一定能发挥意想不到的作用。
比如，平常工作忙咋整？写个代码花式陪女友。
再比如，实现数据可视化。
如果你喜欢三国，可以分析三国人物出场次数，形成词云。
扩展阅读，怎样自学Python："
,,,,,,,,,,,,,,,,,,,,,
我编程写代码被我妈一直说成玩电脑打游戏，我该咋办？,None,"因为你没有买书。
若你编程时电脑边上摆一本近千页的，密密麻麻有中有英的编程书。又若你时而敲键拍得噼噼啪啪，时而捧书念得呢呢喃喃，时而起身暴走来回踱步动若脱兔，时而托腮发呆陷入沉思静如处子……
我写了30年的代码了，也经常在家里写，老母从40多看到70多，也就说我从10多岁的
APPLE II
 到286，386，486，586……我的码农在家耕田状态一直是这个样，除了抽烟和咖啡我没提以外，没有哪位老人会认为我在玩游戏。像现在这样的三伏天，一碗绿豆汤悄然放到桌面倒是真的。
后来我父母有了自己的一台台式机。我在上面写了一个程序，在母亲节那天会于桌面展现一朵盛开的玫瑰 ，（
异形窗口
），祝福母亲节快乐。这事在我出的
《白话C++》
下部（练武篇，已出版面市）有提到 。
几次我立于阳台，眺望远方，嘴上叨着烟。老人家怀疑我情绪不佳，还会过来搭一句：又在编译啦？
因为这本书，我干脆做了个网站 
d2school.com
 。大家再有等编译而无聊，或写程序时一时或阵发性思路堵塞时，欢迎前往围观，或可疏压。","我妈出去的时候我在玩，我妈回来的时候我在玩。
我妈：你是不是一整天都在玩？
我妈出去的时候我在学习，我妈回来的时候我在玩。
我妈：是不是我一走了你就开始玩？
我妈出去的时候我在玩，我妈回来的时候我在学习。
我妈：是不是我回来之前你都在玩？
我妈出去的时候我在学习，回来的时候我在学习。
我妈：你白天是不是在偷偷玩？
上面是个老段子了。
你父母在意的不是事实，而是他们的认知。
你觉得你在学习？在工作？但我觉得你在玩。我不要你觉得，我要我觉得。
既然你写代码被说成玩电脑，那你以前肯定也有类似上面说的情况。归根结底，你父母不相信你，他们不觉得你是懂道理的孩子。
对于这种情况你需要讲道理吗？不，你需要闭嘴。
跟讲事实的人讲事实，跟自以为是的人说对对对。只要他们不会物理层面上阻拦你，那你就没有改正他们认知的必要。
不是所有人都需要真相。
记住这句话。它可以为你减少无数毫无意义的争论。
以上。
其他同类答案
原创段子
博物馆长吴力：为什么父母不采纳孩子的合理建议?
3384 赞同 ・ 185 评论
回答
关于“大部分人不需要真实”
博物馆长吴力：为什么有些人总是不愿意相信主流的科学理论是正确的？
2379 赞同 ・ 417 评论
回答
苏联，阿不，火星段子
博物馆长吴力：如何看待字节跳动对于哔哩哔哩及相关创作者「散布谣言」的行为，将保留追究法律责任的权利?
74 赞同 ・ 3 评论
回答
本题同款老段子
博物馆长吴力：如何看待科学网发布文章称「我国数学家证明 NP=P」，是真的吗？如果是，会带来怎样的影响?
1372 赞同 ・ 86 评论
回答
每天一个发财小技巧（雾）
博物馆长吴力：学生会让写两万字检查，只有我一个人反抗，其他人都没有，那么我还继续吗？
329 赞同 ・ 13 评论
回答","老爹告诉我们
用魔法才能打败魔法
所以在家人群里推送如下文章
小伙月入过万，只因每天坚持做这事
别再说这样学习是浪费时间了，看看大师是如何说的
掌握了这种小技巧，和子女之间融洽相处
21世纪大变革，游戏编程或将成为最热门职业","你误会了你妈，以及绝大多数长辈，领导的意思了。
我妈原来也经常说我要努力跟她同学的孩子学习，我就很纳闷，她同学的孩子有在贷款公司拿着我三分之一工资成天打骚扰电话，有0.8的绩点要被大学劝退，到处找医生给他开抑郁症证明休学的。有的在二流公司当一个外包团队的员工。还有做传销，劝了我三个月做他的代理的。我也不知道我妈让我学啥。
我常常想，为什么我妈连电视剧里面的奸臣的水平都学不到，你看人家严阁老至少知道说话对事不对人。后来我才发现，其实对于大多数人来说，在一个没有领导监督的环境下，他是不愿意说那种对事不对人的话的。
换一句话说，无论我妈，领导，长辈，对我干啥事不满，其实他们很可能不是对我做这件事不满，而是对我不满。
情绪大于事实。女朋友嫌你长的丑，你请来造型师，女朋友都会说你不会打扮。领导觉得你技术不行，你写个gayhub上几百星的工程，他都会因为你if判断后面直接跟动作而不是打个回车再跟动作喷你一顿。你妈烦你，你就是在家里看书看到双眼充血昏天黑地，你妈都会找到什么死读书，不懂人情世故，不会帮家里做点事之类的理由嫌弃你。
所以不要纠结咋办，两耳一塞，情绪屏蔽。反正开学后就见不到了。","背景：某小厂游戏服务器开发，老婆山东人，结婚时去她家。
早就有了解过她们家那边亲戚对IT不太了解，特别还是给游戏服务器敲代码的。一听就很不务正业很没面子。所以一直在想她们亲戚要是问起来我是干什么的应该怎么说。突然想起我们公司租用的云服务器是华为云。
不如用魔法打败魔法？
对！
我是华为的电脑工程师！","这么说吧，是不是写代码一眼就看出来了。
我妈小学没毕业。
当她看到我的电脑屏幕满是密密麻麻她不认识的英文字母时，她不会和我聊天，害怕打扰我。
当她看到我的电脑屏幕上红红绿绿，有个小人跑来跑去，我妈就会凑过来，“怎么是个女的？”
保持妈妈看到你屏幕时，屏幕上全部是密密麻麻的英文字母，她就不会说什么了。","我大学社团的同学还是计算机专业，家长不给买电脑的，说买电脑就是玩一用电脑就毁了，一辈子就废了，然后他大二编程考试要用，他们c++那些考试都是上机考试，(这哥们大一在纸上写了一年代码，学校向学生公开的机房都是那种古老的winxp2003，卡的一批，能不能开机都是问题，打字都能死机，更别说练习代码了)
问家长要钱买，说他在学c#是计算机语言需要搞，他家长不给，说c++既然是一门语言就应该和学英语一样，买个单词书，语法书，作文书，背就行，要电脑没有用的，电脑只能打游戏，学不了语言，学语言只能好记性不如烂笔头什么的多抄写几遍就会了，笑死了，最后这哥们自己攒生活费加食堂打工一万多多买了个
拯救者
，放假还不敢带回家，怕被骂。
我感觉他父母确实有问题，他说他家长大一开学前甚至打算让他带诺基亚去学校，说手机就是毒品 大学生一瓶手机前途就毁了。就是那种不能上网只能打电话游戏只能贪吃蛇
推箱子
那种诺基亚，后来软磨硬泡好歹买了个1000以下的智能手机，好像是什么360
计算机不让用电脑，为什么要选计算机呢，他还说这专业是他爸给他挑的，服了","我在学java
：玩
我在学c
玩
我在学linux
玩
我在学神经网络
玩
我在学算法
玩
我在学网络编程
玩
我在搭一个网站
嗯。
我刚搭完一个网站
嗯
我加点班把这个交付了能拿一笔钱
好的，不打扰了
总结，他们眼里：
有可见产出=正经事，无产出=玩。
意识以物质为转移。
方法：
1，薅点东西做你的产出
2，吹b画饼
3，摆烂","想到了那个看心电图被病人投诉上班炒股的医生。
我觉得你们可以交流一下心得体会。","我奶奶不识字，但是只要她发现我在长时间的看满屏字符她就会劝我：“休息一会吧，学习也要劳逸结合。”
但我要是一直在操作小人蹦来蹦去，她就会变成：“休息会吧，一直玩游戏对眼睛不好。”","嗨，别提了。在相当大的比例内，老一代人，尤其是欠发达地区的老一代们，对计算机的理解几乎等同于游戏机。他们的逻辑是：电脑＝游戏机＝洪水猛兽
至于计算机技术，数理化那么难都能学会，计算机能有什么难的？用到了再说。
所以，一般而言解释是没什么用的……因为思维定式已经形成了。
你说你在编程？他们不信；你说你在学习？他们更不信；你说你在打游戏？他们估计马上就信了……
前几天我还遇到了一个语音输入写论文的神人，当然写的是结课小论文。
为啥？
我问他为啥，他说因为从小家里不让碰电脑，打字数度慢……按他的速度，一次作业要写特别久，所以才用语音输入法……
噗……
我问他学业水平测试怎么过得，他说当时练了好久，然后家里就不让碰电脑了……
家长们可能自己也不知道……现代社会“打游戏”也是必备技能……",你这算啥，我去给经济学研究生上课，被我妈一直说成去学校上学…,我妈一直无法理解为什么我还没把自己饿死，在她看来只要我离开她的视野范围，一定是打游戏去了。,"害呀，你别说写代码了。我今年大四毕业，不正赶上这疫情吗，从去年12月一直到6月都在家，论文都只能在家写。重点来了，只要我打开word写论文，我妈就开始喊，XXX你早上八点就起来玩电脑，一玩玩到半夜十点多，有没有你这样整天浑浑噩噩的？我给她解释这是毕业论文，她就会两眼一瞪：别欺负我没见识，人家写论文都是用笔写，
陈景润
写个论文都用了几屋子的纸，你天天就抱着电脑在那玩，你当我什么都不知道？（我之前把在学校买的书带回来过，其中有一本《
哥德巴赫猜想
》，讲陈景润的故事，估计她没事看把书里写的东西当成写论文的常态了）
后来整的没办法，只能每天把笔记本充满电，节电模式什么都打开，亮度调最低，连手机热点，到楼下公园里的亭子里写。中午回去一趟，充满电了下午继续。只能这样。整个毕业论文就是在这种情况下完成的。导师还嫌弃这不好那不好，我都羞于启齿这论文是在什么情况下完成的，我真的努力了，我真的尽力了......","感谢评论区各位的关心和建议，吐槽父母的回答我写了好几篇，但是这篇获得这么大的关注我也的确没想到。
我现在真的过得很好，我已经6年不怎么搭理我父母了，我在北京，他们在俄罗斯对面，相隔2000公里，联系方式一律断绝。我留了我爸的微信，以防有突发事件（不过已经发生完了，去年我爷爷过世了）。
我也尽可能把他们的影响降到最低，我任何一个亲戚来找我，我都会提前说：不要和我说我父母的事儿。不过失策的一点是，我是在工作一段时间之后才和他们决裂的，所以他们知道我公司的地址，所以在前年的某一天，我妈出现在了我公司楼下蹲我……让我心态不好了很久。
这些事儿大多数发生在我中小学时期，那会儿父母即强权，稍不对劲就是打骂，小时候打，大一点骂，经济独立了道德绑架，如评论所说，完全的寄人篱下。反抗？当然有过，直接和他们讲理、离家出走之类的，都做过。讲理讲不过我，那就是高八度的吼叫，离家出走，总也得回去，然后又是更大的风暴，我对我爸的恐惧早已形成了思维惯性。唯一一次还算和平的离家出走，还是我中考的时候，躲到了某个亲戚家，中考过后没发生什么事情。
做flash动画，是小学的时候参加网页制作大赛，我们队flash动画部分是我来负责。原回答里面的事情则是我初中的时候要给班主任做一个动画，作为一个活动的背景。
我用电脑用得多，有玩游戏的时候（当年玩传奇私服、红警2、魔兽争霸、
热血江湖
），有聊天的时候，可能这两项的确占比高些，有时候家里不让玩游戏，我甚至每天到同学家看同学玩游戏；也有学习的时候，也有搞那些兴趣爱好的时候。当年的Windows XP，安装那些软件（Frontpage、Photoshop、
Fireworks
、Flash、Dreamweaver、网页特效秀，加上各种各样注册机，当年Flash还不是
Adobe
的，还有著名的名字叫网页三剑客，列举这么多是因为想起来，小时候搞这些东西的时候真的是开心的），的确有可能把电脑变卡，甚至中毒，或者多弄出来一些东西，加之当年对传奇这款游戏，媒体各种各样的妖魔化，自然我也就变成了电脑变坏的背锅侠。
毕竟，我爸自己在电脑上，基本上只是玩那几个自带游戏，以及聊天。我妈比较离谱，当年很喜欢用QQ加一些不知道是哪的人视频聊天，哥哥妹妹叫得很亲，咱也不知道算不算精神出轨。
我父母对我的不信任还有一例，我高中毕业的时候请我朋友帮忙拉了个配置单，给我家里配了一台新的机箱，花了2100，送回家去，在我大学某一次寒假回家的时候，在一个人不少的饭桌上，他们就疯狂想要证明我被人坑了，什么谁谁谁的朋友1700就能弄一台配置比那个好的电脑。我随口问了两句，电脑配置在他们眼里大概就只有内存的容量和硬盘的容量，其他的一概不管，然后我就被按头说是被坑了。
核心原因我想的也很清楚，评论区有一位朋友说的也很清楚，就是这些东西他们真的不懂，但是他们还想要掌控我，还想要显得自己讲理，那自然就要想方设法证明我是错的。所以我也不明白为什么有人觉得我可以跟他们解释。
回答这个问题的初衷也不是卖惨，虽然现在也变成了卖惨，单纯是我对父母控制这一话题有很严重的
PTSD
，碰上这类问题就很想槽一下二老，所以就形成了这篇回答的初版。
我一路走到现在，要感谢的人很多，比如坚定支持我高中去省城的两位表姐，我的几位老师，和一些无限包容我的朋友、同事们。我性格里曾经有很重的我爸妈的影子：极强的控制欲，极低的安全感，死要面子，不敢承认自己错了之类的，给我身边人造成了很大的困扰，而当我意识到这点的时候，我是极度恐惧的，到现在我也担心，一旦我进入了亲密关系，或者为人父母，这种本性会暴露出来，由我再去害其他人。毕竟，多年媳妇熬成婆。
我也不知道我是否摆脱了那些，但这确实也成了我一辈子的事儿。
至于受害者有罪论的几位朋友，我不知道该羡慕你们的清澈，还是羡慕你们生活比较幸福，但是我性格里面非常讨厌被误解，我记恨我爸的最大原因之一就是他几次严重的冤枉。
觉得我通篇都是编的的朋友们，你们爱怎么觉得就怎么觉得吧，我也不明白我编这个是为了啥。
原回答：
我在家做flash动画，我爸觉得我碰电脑就是玩游戏，所以就在我后面背后灵看着我。
我调了大概半个多小时，调出来了大概几秒钟的动画，我爸就跑我后面，让我播放，我一放，我爸直接暴怒：你折腾这么长时间就折腾出来这点儿？还说你不是玩游戏呢？
还有，还是我在家做ppt，顺便听了个歌，打开了音乐播放器，我爸进门的瞬间看到了我的音乐播放器，然后说我在网上聊天。
还有，我爸妈喜欢乱点电脑上的东西，导致电脑经常中毒，动不动桌面上就多出来点儿东西，然后他们就会说是我在家乱装游戏，实则我几个月已经没碰家里电脑了。
还有，我更新系统，导致右下角出现了一个五角星（实际上是激活问题），我爸相信了网上的阴谋论，觉得电脑上出现了那个五角星，就是被美国监控了，随时可以偷你资料关你电脑。
还有，我爸不知道信了谁的邪，说我在网上看视频，会损伤光驱。
还有，我找工作准备面试（以及准备接电话）的时候，在家刷
topcoder
，我爸觉得我在打游戏，以应聘为借口不去我爷爷家，然后直接骂我满嘴借口，是的，这种对我来讲头等大事的事情……
还有很多很多……
最终就是，我一个一本学计算机的，现任程序员，曾经也在电脑店搞过维修的人，家里电脑坏了，甭管我多长时间没碰，那都是我玩游戏弄坏的。然后他们去找一个八竿子打不着的人来修……
这么多评论了来回复一下：
首先，这些都是多年以前的故事了，绝大多数是小学初中的事儿，最多到我上大学期间（Window未激活右下角出蓝色五角星都多少年前的事儿了）。我早就和我原生家庭决裂了，关于电脑能搞出来这么多事儿，其他方面的更加离谱的事情也不是没有，比如觉得我喝了一杯我都没见过的酸奶就打了我一下午，事后还觉得自己有理。还有，我小的时候让我每天晚上洗全家的袜子，有天我没洗我爸的，也被打了。以及我在学校和同学玩的时候坐在了地上，就罚我在家蹲了两三天，什么也不干，就蹲着。
有关上一本这个事情，我可以补充一下，我人生道路上如果听了我爸半点，可能都完全不一样了。比如我选择去省城上高中，我爸疯狂阻止我（最后因为我免学费也就没拧过我，我们学校虽然是个民办吧，但肯定比县里强的。我们县的状元分是比我低的，报志愿还估低了20多分，估分报志愿又是多少年前的事儿了）；我大学泡实验室打比赛，不冲着什么保研考研使劲儿，也被我家里人槽了多少次了，觉得我毕业就完蛋，然而我找工作那年是最后一年窗口期，之后一年比一年难，晚个两三年我都不能找到现在的岗位。
某些说我自身性格有问题的朋友，我承认我自身是有性格缺陷的，但是我的性格缺陷也来自于原生家庭，包括我现在也觉得我某些毛病来自于我爸的影子，也让我很恐惧。
有关家庭地位，我从小到大挨打无数，我爸妈也特别喜欢PUA我，我爸80%的时间是以审问、说教的口吻和我讲话，20%的时间是把我当宠物玩儿，在我彻底崩溃之前，是根本没有反抗意识的，崩溃之后自然就决裂了。
另外，个人比较反对身边统计学，不是没见过就是假的，父母的确是存在多样性的。
论网友的阅读理解能力是多么强。
以及我现在做flash怎么了？我只是想要借助它完成一个效果，刚好flash能实现，而且我认为比ppt的表现力强一些，那我用一下有啥问题？难不成就为了一个ppt上的效果，我需要两三天内学习一个新的东西并且完成一个效果？我之前在公司的发布会上发布一个产品，就用了flash做了点儿效果，嵌到ppt里面做了下表现，怎么了？
原来知乎现在写一个答案的要求已经这么高了","没什么办法，之前小住在亲戚家，当时正好刚入门编程在学c＃，刚入门热情很大，每天都窝在电脑面前钻研。然而我忽略了一个事，这也是我后来才推测出来的，亲戚家有一台被雪藏的电脑，有一个贪玩的男人。懂我意思吧？这导致我一开始就被偏见了，那个男人每次过来，就看我有没有打游戏，没有就无趣的走开。亲戚每次看到我都是坐在电脑面前敲敲敲，又看不懂我屏幕上写的啥，只看见一个一个窗口弹来弹去。一口咬定我在玩，我当时没在意，玩味的说了句，确实在玩，玩的蛮开心的，以后我还可以边玩边赚钱。之后我就凉透了。我妈哭着和我说啊，你别玩电脑了，这十里八乡的全都说你是个fw，天天就知道打电脑，以后还要玩游戏赚钱，都传到我耳朵里了！我直接？？？。有些人的嘴远比你想的要尖酸刻薄且多舌。我也不好生气，跑去和亲戚解释，然后结果是，他先说，你学习，你学习天天笑声那么大，鬼信啊？我当时就傻了，学习为什么不能是快乐的事情？我解释一番以后，亲戚依然不接受，说，我孙子啊，天天一大堆作业在写，书都叠的那么高。我说我也这么过来的，考上大学了不一样嘛。再说了，我拿出我的c＃从入门到精通，我也要看书啊，但是实践代码就是要电脑嘛。这东西写纸上又看不出效果。结果呢？结果他又拿读大学读幼教专业的孙女说事，孙女都不用电脑，你天天用？我说我就是计算机专业嘛，我也没办法的。他眼看说不过我，好，直接一句反正你接触电脑我就是看不爽，你就是有玩游戏，游戏就是恶魔，你就是人品不行。泥人也有三分土气，我当时就火气上来了，好，我就是人品不行，我不仅要玩游戏，我的目标还是做游戏，我以后就是你口中的恶魔的创作人！
后来？后来就是我妈道歉，我憋屈的标准结局。人情世故，对我这个标准直男来说还是太难了。有的时候这就是一种固执的偏见。现在回想起来，只觉得当时的情况根本无法破解，我的退让只换来他人的误解，一度解释全变成了
诡辩
，甚至一度怀疑自己当初是不是该听从父亲的劝告去学会计。人事总有地方让人无奈。现在嘛只希望自己能坚持本心，在这条路上走下去。其实我也不是很在乎他人的看法，当初执意要学编程的是我，也不会真的后悔。只是有的时候，真的很讨厌，人说我就说我吧，你当面骂我，其实我也不会说什么，寄人篱下，稍微委屈求全我也是懂的。结果搞得我妈一快50的人了在电话里和我哭。完了还要反咬一口说是我不对。搞得我现在一谈到家里亲戚就是一阵恶心。虽然说知道这都是偏见的结果，谁让他们家有个“好儿子”，但果然，还是恶心。","你这才哪到哪啊，我小时候写珠算作业，我姥姥看到了立即把算盘没收，找我妈告状说我边写作业边玩。
我妈向她解释半天，她才相信小孩也可以学会“高深”的珠算。
我姥姥是旧社会长大的，不太识字，在她的固有印象里，算盘是村里最有文化的人才会用的玩意。
其实我妈那一代人也在学校里学过珠算，但是我姥姥当时忙于农活，连孩子的早饭都来不及做，根本顾不上我妈的学业。","如果您的母亲对电脑的认知程度已经低到把写代码都认为是打游戏的程度。
但是你却没有办法把您的母亲""忽悠瘸了""。
我很有理由相信，您应该用无数个理由忽悠您母亲，让她以为您用电脑在学习，其实是在打游戏。
导致您母亲根本不相信您的说法。
您现在需要做的，就是去接个私活，赚个千八，然后给您母亲。
这样您母亲就会认为您用电脑打游戏还在游戏里骗钱了","咱俩的情况恰恰相反。我坐在电脑前打游戏，我妈却说我编程太刻苦了，该玩会游戏休息一会。
我非常生气，这游戏就是我做的，我正在测试bug，怎么说我是在放松和娱乐呢？
  这是对我极大的误解。
所以说，想消除误解，就先做个游戏出来。
当初打游戏被抓分了两个阶段：
  1 最初的时候，确实就在玩三国游戏，各种裂土封侯，走马圈地。好几次被抓个正着，网线被拔，室内放了一个摄像头对着电脑屏幕。基本上赤果果的玩，肯定是行不通了。于是我就在思考，如何既能够玩游戏，又能够学习。 先用时间来换空间了，最终是要玩自己喜欢玩的游戏，可是毕竟如何能玩会游戏，也总比一直玩不到喜欢的游戏好呀。
 于是，上知乎问了一下，结果得到的回答就是，可以找一个带有源代码的游戏。那么编程语言那么多，有源码比较好学的，就两种语言，一个是python，一个是c。c则有很多商业化的游戏开源代码，python则更多是小品集的游戏，这些游戏简短，但如麻雀一样五脏俱全，非常适合边学习编程，同时又可以给父母信心让其能够觉得你通过学习是可以做出来的，你才可以放心让你去学。
  2 于是，我就想到，如果我用，python的数据抓取，分析和可视化为借口，先仿造游戏做一个全国工作岗位数据图，就可以明目张胆地玩了，毕竟都是用的地图嘛。然后边玩，还边抄写数据和心得，掌握玩法。等万事俱备，就用python做游戏。
 于是，我就找了一款c版本的《仙剑奇侠传》的源码sdlpal，这个游戏在当年火遍大江南北。下载后，直接就运行可以玩了。最开始的几天，我沉迷游戏之中，没有办法向父母汇报进展，只能拖借口说刚开始不太熟悉，正在熟悉环境。总这样下去是不行的。
于是，又来知乎提问，得到了答复是，最好找一个python教程，针对那种0基础的，最好是图示化比例很大的那种教程，这样跟父母讲起来的时候。也方便让他们看懂。于是，看了几款知乎比较知名的几大python平台，有的是主打acm世界冠军的可能，有的是刷题的，最后在几个python大v回答里，看到一个叫夜曲编程的平台，说是有20多天的免费教程，是图形+app交互的方式，于是我在夜曲编程里回复了“免费教程”，果然收到了教程，我一直担心学不会，于是，就快速地点下去，怕浪费时间，结果，不是图形就是选择题，一节课下来居然没有任何阻拦。
 拿着手机看着知识点，然后通过选择合适的代码组件就把知识点抓取，然后记录到了卡片里面，再通过思维导图替代书本的目录，用于关联记忆。
 这下真的好，一边手机看教程，一边用电脑用python来练习学到的知识点，同时再把自己学到的知识点，插入到游戏之中。
 伴随着，学习进度的推进，和在游戏中的步步深入，已经略有小成了。同时也把课程里学到的内容，通过用游戏里面的素材，使用python知识点复刻出来。毕竟图形转图形很是方便
下一步已经在设想一个，能够自动识别脚步声和开门声，同时把游戏测试画面切换到编程模式的软件。",直接打游戏
,,,,,,,,,,,,,,,,,,,,,
网传华为研发出属于我国的编程语言「仓颉」，这是真的吗？这意味着什么？,None,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,
如果有两颗药丸，一颗吃了让你写代码100%不出错，另一颗吃了能让你100%发现并修改bug，选哪颗？,速度等同你原来的速度，其他各方面不变。第二个除了能发现自己的，还能发现别人的。,"魏文侯
问扁鹊：“你兄弟三人，哪个软件开发水平最高？”
扁鹊说：“大哥最好，二哥其次，我最差。” 
文侯甚为不解。扁鹊解释道：“我大哥不等Bug出现就提前预防了，所以名声传不出开发组。二哥在Bug出现时就顺手解决了，所以名声传不出技术部。我呢，每天像打地鼠一般到处救火，所以在公司没人不知道我。”
这选择，一目了然吧。","以前是给我 10 亿美元，但会有一只蜗牛永远追杀你，问我干不干？
还有要我吃一小勺太阳会如何？
更有甚者，直接让我强化一亿倍，问我是什么概念？
我只想问这次的药丸是谁发？麻烦给我快递一下，谢谢","小孩子才做选择，我当然是全都要...吃！
只要吃不死，就往死里吃！
写代码 100% 不出错简直是我捏脚，呃，做梦的时候都想要的技能，bug 怎么能是自己的呢？bug 必须是别人才对！
这颗必须吃，谁拦着也不行！谁拦着我咬谁！
100% 发现并修改 bug，我要有这本事还至于现在单身？我早就化身超级英雄，以一只救世猪的身份出现在我亲爱的学妹面前：
“咋滴？有 bug 了？乖，不慌，有我在呢，你让开，放着我来！”
“呔，何方 bug！快快给俺小李现出原形！”
我想要的甜甜的恋爱这不就来了！这晚上睡觉都得流一枕头哈喇子！！
谁也别挡着，给我，我要吃！我是学妹的奥特曼！
---
好了，沙雕完了，该清醒一点了。
可惜，这个世界上没有如果，照照镜子看看自己，还是个头发没掉光的普通程序员。
现实一点，意淫这种超能力真是嘛用都没有，暗搓搓的爽一下就行了。
还是得脚踏实地的选择好安身立命的语言，然后就是精进！精进！！精进！！！
作为一名数据分析师，选 SQL 和 Python 虽然不是 100% 不出错，但是也能很大程度上帮助满足我们的需要。
说到这了，我赶紧把自己祖传的 Python 和 SQL 学习路线丢出来！
一、Python 学习路线
其实我们说学习路线，其实就是对于一些 Python 视频啊，书籍的推荐以及一些比较好的做题网站。
因为怎么说呢，编程语言这个东西的学习，都是“理论 + 实战”。
理论是什么，就是与 Python 相关的方方面面的知识，这些知识来源于书籍和教学视频，再说实战，实战就是将你学到的理论知识转化为解决实际需求，在这个过程中，你提高了你的逻辑思维能力，提高了所谓的 debug 的能力。
我之前在知乎上看到过一个问题，问的是“学习Python有什么推荐的网课，书籍资料，以及该装哪个版本的Python?”
认真回答了一下：
为了方便大家阅读，我把主要的内容拿出来供大家阅读。
先说视频。
《
Python
 
核心基础
》
这门课一共 131 集，大多数都是 Python 的核心基础知识，像 Python 环境搭建、基础语法、类型和对象、函数、面向对象等等等等，适合 Python 新手从入门开始学习。
除此以外还包括了一些操作系统的内容，说实话操作系统啦这些课程也是对于我们很重要的知识，不管是在大学还是工作中都很重要，所以我希望大家在学完 Python 的时候可以看看操作系统的内容。
《Python 入门教程完整版》
黑马程序员出品，一共 547 集，我看了一下，可以说是很全面了。不只是涉及 Python，还包括 Linux 操作系统等的学习，每一集的时间也不是很长。如果你对别的不感兴趣，可以直接看 Python 那一趴的，从第 110 集开始。
对于书籍的话，我在之前回答过类似的问题，感兴趣的可以看一下：
我也说过，我最喜欢的是下面这本书：
我感觉这本书的内容给我了一种很舒适的感觉，我很少有觉得读起来很舒服的技术书...
整个的结构很清晰，内容简单但是不肤浅，整个基础知识的讲解简洁明了，一点也不嗦，很容易就看懂了。
当然萝卜青菜各有所爱，这也仅仅是我自己的看法而已。
编程语言的学习其实是边学边练，刚开始的时候是一边看视频看书，就把视频上的小例子，书上的小例子自己动手敲出来。
等能力到了一定的地步，可以尝试一下实战。
对于实战来说，可以有两种：
刷题
项目
下面我将分别来讲一下这两种。
刷题
刷题大家应该都知道，就是在刷题网站上解决
数据结构
与算法题。
如果你从事计算机行业，在你找工作的时候，数据结构与算法都是你跨不过去的坎儿。
这里我推荐一个 Python 的数据结构与算法的视频。
数据结构与算法的重要性不言而喻，作为一个前 ACMer 更是深有感触。
北京大学这门课主要由
陈斌
教授主讲，介绍常见的数据结构和相关的经典算法，包括线性结构、递归与dp、排序与查找、树及其算法等。
这门课我觉得最好的一个点是，比较关注数据结构与算法的时间空间效率，这个是很多课程忽略的地方。我也有一篇旧文，详细的介绍了时间复杂度和空间复杂度，感兴趣的可以看下：
时间和空间效率是数据结构和算法yyds，学会了这个你就学会了分析优劣，成长是不可同日而语。
同时这门课也比较注重数据结构和算法的实践应用，毕竟只有真正用起来你才知道你是不是真的学会了，课程里的案例和变成习题建议好好做一下。
刷题是一个很好练习和检验学习成果的方式，刷题直接在 LeetCode 上刷就好了。
至于刷题顺序，我可以分享下自己总结的【
LeetCode 刷题顺序
】，希望能帮助大家少走一些弯路。
这份清单我会一直更新，同样也会一步步的把
每个知识点的入门讲解
和
每道题的题解
用“图解”的方式分享给大家。
站在初学者的角度，
用最直白的方式和最易懂的代码，最大可能摒除不同编程语言的带来的干扰
，理论 + 实战，带你彻底搞定数据结构与算法。
下面就是我为大家精心挑选的 LeetCode 题目清单，
按照知识点进行分类
，大家可以根据知识点，有针对性地刷题。
项目的话就先做些小项目练手。还是那句话，对于编程语言的学习来说，
“理论 + 实战”才是王道
。
我在这给大家推荐几个我觉得比较好的开源项目吧，好的开源项目会对学习会有很大帮助，我这里推荐的都不是很大，结构比较清晰的开源项目。
tomato-clock（star 240+）
Python 写的命令行番茄工作法定时器。代码仅有 100 多行，不依赖其它第三方库。
tomato 25 minutes. Ctrl+C to exit
   ---------------------------------------------- [8%] 23:4 ?
传送门
：
coolcode/tomato-clock
magic-wormhole（star 12.8k+）
一条命令就能将文件安全地传送到另外一台电脑上的工具。基于 PAKE（Password-Authenticated Key Exchange）协议实现文件在公网的加密传输，发送和接收均仅需一条命令。
传送门：
https://github.com/magic-wormho
blind_watermark（star 800+）
给图片加盲水印的 Python 库。
盲水印
就是图片有水印但人眼看不出来，需要通过程序才能提取水印，相当于隐形“盖章”，可以用在数据泄露溯源、版权保护等场景。该库出自阿里巴巴安全团队，强大之处：
解析水印图时无需原图
水印图剪裁、旋转都不会破坏图中的盲水印
支持密码加密
from blind_watermark import WaterMark

bwm_obj = WaterMark(password_wm=1, password_img=1)
# 原图
bwm_obj.read_img('pic/原图.jpg')
# 水印图
bwm_obj.read_wm('pic/水印.png')
# 打水印后的图
bwm_obj.embed('output/结果.png')
# 注意需要设定水印的长宽 wm_shape
bwm_objextract(filename='output/结果.png', wm_shape=(120, 120), out_wm_name='output/解出的水印.png', )
传送门：
guofei9987/blind_watermark
alive-progress（star 2.5k+）
新！Python 炫酷进度条项目。支持 Python2.7-3.8 示例代码：
# 安装：pip install alive-progress
from alive_progress import alive_bar

with alive_bar(total) as bar:  # declare your expected total
    for item in items:         # iterate as usual over your items
        ...                    # process each item
        bar()                  # call after consuming one item
传送门：
rsalmei/alive-progress
二、SQL 学习路线
SQL 的学习就很简单了，只需要买本书，然后看一下。
但是只看书是不行的，还得再找个在线的练习平台练习一下。
很多大佬都在推荐 《
SQL 必知必会
》、《MySQL 必知必会》啥的。
而我却有不同的意见，这些虽然经典，但是
对于新手学 SQL，我推荐大家用这本《
SQL 基础教程
》！
这本书介绍的节奏的更加平缓，并且用图示和关键字加粗更加生动地介绍知识，适合零基础的学生。
对于零基础的朋友来说 Mick 的《SQL 基础教程》更容易看懂学会，非常适合入门者学习。
如果只推荐一本书的话，我只推荐这本。
当然我觉得非常好入门，可能对于初学者来说有些地方还是有些晦涩难懂。
针对看不懂的内容，我在这给大家推荐一门 
MySQL 入门教程，知乎上可以直接看
。
虽然是 MySQL，但是里面也有数据库的分类、SQL 介绍、数据库基本操作等内容。知识点很大程度上是相通的，你可以直接找到对应的知识点去看。
Python 进阶之 MySQL 入门教程
?
www.zhihu.com/education/video-course/1483114387146166272?section_id=1483130134320852992
SQL 基础的语法还是很好学的，但学习还是要落在实处，具体应用，光看书是么的用的。
但是说实话，像什么 MySQL 等的练习环境，对于新手来说，安装配置还是有点劝退的，而且交互性也不是很舒服。
初期练习的时候还是用在线的 SQL 练习平台好了
。我给大家找了 5 个在线的平台，优劣也做了描述，可以直接取：
当然了，你也可能不喜欢 Python，你以为我只有这些嘛！
这才是你最想要的 C 语言学习路线：
这也是你最想要的 C++ 学习路线：
别夸我，我是做好事不留名的 
@Rocky0429
 ，点个赞就行了！","但凡过了试用期，也不至于问出这样的问题。
第一个最大出路无非是自己能单干搞点私活。
至于第二个，那就是大多数公司能把你捧起来的神。","编程爱好者程序员：选第一颗，因为代码一次写对好酷！
想要影响力更大的程序员：选第二颗，一个人写的代码是有限的，能看出很多其他人写的代码中的漏洞并发现问题，更有前途。
鸡贼程序员：选第二颗，这样只要被人随便写，我都可以改好，等同于拥有了第一颗的超能力。
精通超能力漫画的程序员：慢着，这两颗药丸带来的超能力buff时间多少？
真正的程序员：现实一点，不要yy这种超能力了。
老谋深算的程序员：若真有这种药丸，不管谁造出来的，虽远必诛！","一般人：第一个
有工作经验的程序员：肯定选第二个，写代码不出bug，但该不会写的功能还是不会写；会修各种bug，在公司里等同于神
习惯卡超能力bug的我：第一个，然后脸滚键盘打出解决
哥德巴赫猜想
的代码","问这种问题的一看就不是老程序员，老程序员一般都会毫不犹疑的选第二个。
几乎只有非程序员（比如在校计算机专业学生、其它领域的研究员）才会经常不断的写新程序，作业也好、课设也罢、或者研究过程需要临时编程演算什么的。这些不用形成正式产品，不用太考虑质量，也没有广泛的用户群体给予“测试”反馈，更不用考虑后期长期的面向甲方爸爸的维护。所以他们可以有恃无恐的写新程序。而真正的公司程序员，长远来算差不多三天写bug三十天修bug（自己或其他人的），这还算是不错的，有些人大部分时间都写不了什么新程序，一直在测bug修bug。
而且几乎没有程序员会追求程序一写出来就没有bug，因为有bug也没关系，只要再改就行（第二个技能正好）。而且任何程序都有它的运行场景和范围，范围内工作正常，没有客户抱怨，那基本就可以看做没有（紧急）bug，都可以从长计议。但是几乎所有程序员都会经常面临被紧急bug弄到焦头烂额的时候，当程序员被bug逼到茶不思饭不想疯狂掉头发的时候，你跟他说“兄弟，我这有颗药吃了就能立马发现bug，以后都不用愁修bug。” 那甭说免费了，折寿十年他也要（反正他这么熬下去也得折寿十几二十年，还没有什么前途，996.ICU可不是说着玩的）。
写程序会出错才有编程的乐趣，如果一写就对，写出来就不用改，那将失去编程甚至合作编程的大部分乐趣（况且刚写完就没问题心理不慌么～）。但是这并不会减少你的工作量，只会导致你需要写更多的代码，而代码，是永远写不完的！这个技能只适合一种人，那就是给自己打工的人。给自己打工的人的最大乐趣是用最少的人月，完成最多的有效产出，获得最大的收益。而代码一写就对，无疑是能让收益最大化的技能。但是这个技能并不能保证你成为一流程序员，因为它有两个大的漏洞，一个就是程序员不光自己写程序，程序员大部分时间需要审核或修改别人的程序，这时候第一个技能没用，除非你把别人的程序都重写一遍。另一个大漏洞就是你不一定有那个知识水平写出程序来。你都没能力写出程序来，谈会不会出错则完全没有意义。
反观100%发现并能定位bug，这个技能简直是打工人的利器。而且这个技能不完全受上面“漏洞”的限制，因为定位bug并不需要你对整段程序都有全面的理解和认识。比如有一个空指针访问的bug，你只需要定位是哪里产生了这个空指针就可以了，但是对于一个复杂程序来说，这有时是很难定位的。而你100%定位bug的技能就可以让你省去很多时间，你还可以自己选择什么时候说出来，先慎一段时间，然后经常在别人之前指出问题还可以让其它人对你肃然起敬，这技能简直收放自如，想装苦时可以装苦，想装B时可以装B。
写程序有bug是极其正常的事情，只要不是经常出特别严重的bug，则完全不用放在心上。而且你和别人产生的bug，还会成为后面程序员的performance来源，甚至营造更多的就业岗位！哈哈哈～而100%发现并定位bug的技能可以在自己给自己review代码时能马上定位自己代码的bug，更重要的是自己给别人review代码时也能马上精确的指出别人代码的bug，还能告诉他怎么改。这是高级程序员（上不封顶）最需要的技能了，各大项目的maintainer都会争先恐后的招揽你，而你则可以游刃有余的游走在各大项目中，享受各个公司给你开出的技术顾问的礼遇。
ps: 问题本身就有不少bug，大家不用过于纠结，这就是个娱乐性问题，一看一乐就好。毕竟程序员除了工作以外，调侃娱乐一下也是需要的嘛。如果对专业方面的内容感兴趣的朋友，可以翻看下面的README，看看有没有中意的。","小明认为开发的乐趣就在于解决问题，于是选择了第二颗药丸。
接下来的一年，小明乐此不疲地修复了Linux的一些重要问题，成为小有名气的Linux内核专家。
但Linux太大，太复杂，光内核就有几百万行代码，小明一年下来只修复了个位数的重大缺陷，这还不足以让小明成为首屈一指的专家，他决定继续努力。
墨先生选择了第一颗药丸。
墨先生高峰时一周曾肝了6000行代码，其中debug至少占一半的时间，无他，只因为TensorFlow1.x调shape实在太麻烦了。
“速度还是原来的速度”就相当于墨先生一天至少可以写2000行代码，还不用写
unit test
。已知Fuchsia内核代码量约70W，也就是说，墨先生不到一年就可以完成
之后的第二款国产开源操作系统，很可能也是第一款真正开源了的国产操作系统。
吃完药后，墨先生悄悄成立了一家公司，开始开发。
第二年，墨先生开源了日后成为破解技术封锁最重要武器的“药丸OS”，拿到风投，买了游艇和别墅，同时，他还招聘吃了第二颗药丸、擅长解决bug、在业界小有名气的小明负责组织开发内核之外那1900万行代码。","第一颗
红色药丸
可以成全到自己，属于小乘佛教，吃完你就是万古永真罗汉。
第二颗
蓝色药丸
可以造福全人类，属于解救全人类的大乘佛教，吃完你就是救苦救难改Bug菩萨。
正义如俺，反正都是药丸，For whole mankind，选择第二颗
小蓝药
当菩萨。
以下内容纯属虚构，狗头保命。
一、火车抢票解难题，测试工匠首建功
话说某国12305在抢票的关键时刻总是卡壳，民间抱怨连连。作为特邀专家的我，早上开开心心吃了药，溜溜哒哒过去到铁道部开发部门控制中心。
问题十有八九在消息队列处理模块。背着手装腔作势翻看了30秒（29秒用于装深沉）代码，突然心头一悸。
立即要求小弟用文本编辑器打开某个文件，定位到某一页，当当当，敲三下屏幕后，我一言不发地，在他身边慢慢走了十步后离开。
小弟愚钝不解。他苦苦看了一天代码，忽然灵光一闪：
大师的每个动作必有深意！
他仔细研究了第三行代码十次，终于发现队列机制貌似有大问题！
小弟感叹道：大海哥，真不愧大名鼎鼎是测试工匠阿！
咦？他人呢？
大海哥，他被一辆军绿色悍马接走了。
二、导弹系统解BUG，技术专家再逞威
某个导弹研究所设计中心里，一堆科学家正急得象热锅上的蚂蚁。他们设计的超远程巡航导弹在百发百中一百次后，在一次重大汇报演习里失误，大庭广众和众目睽睽之下，一发打飞 。
领导要求归零，可是导弹又变得百发百中，错误不能再现。
我赶紧吃了一颗药，溜溜哒哒走进指挥中心大门。指挥中心所有人都紧张地不由自主站了起来：测试工匠终于登场！
我坐到屏幕前 ，装腔作势看了一下几个模块，感觉4号模块不大对，要求他们调出4.5模块。
4.5里的4.5.7感觉不好，调出来。
我心头一悸，嗯，4.5.7.9不对劲，调出来。
这个
正则表达式
谁写的？有特定情况下不对的意外。
专家们一小时后才醒悟理解看懂，他们感叹道：
大海哥
，真不愧大名鼎鼎是测试匠人阿！
咦？他人呢？
大海哥被一辆黑色牌照防弹车接走了。
三、火星返回克危难，大国工匠归平凡
航天口，载人火星登陆任务中心。火星上的三个勇士48小时内必须起飞返回地球，可是起飞测试指令火箭就是不响应，即便宇航员手动启动也没用，整个指挥中心都毛了。
中心几百号人，看见我走进来，全体不由自主地起立，等我走到主控计算机屏幕面前，四块大屏幕上全部是密密麻麻的代码。
刚吃了药的我大手一挥：换一批，这批无异常。
大屏幕开始翻页，屏幕花花绿绿闪闪烁烁，我站在大屏幕前不断挥手，眼镜片明明暗暗。
中心工作人员窃窃私语道：“谁说量子波动阅读骗人的，大海大师这套绝对真的，否则出门会被活活打SHI""。
十分钟后，我忽然心头一悸，大喊道：
停，STOOOOP ！
屏幕停止了滚动，量子停止了波动。全场鸦雀无声，麦克风递送到我面前。
IT'S SHOW TIME。
我清了清嗓子朗声道：
达瓦西里
们，这行汇编代码执行时取的数据段数据，它的存储区可能被宇宙射线打坏两位，纠错系统刚好不能发现。
技术人员立即进行模拟并证实了这个BUG，纠正指令发向遥远的火星 。
航天中心负责人感叹道：大海哥，真不愧大名鼎鼎是测试的匠人阿！
咦？他人呢？
大海哥被一辆白色专车接走了。
航天专家们感叹道：工匠就是这么忙。辛苦他了。
尾声
我从迷混中慢慢醒来，熟悉的白色的墙壁，白色床单，白色桌椅，一身白长得很像迪丽热巴的美女小护士微笑俯视着我：
”9527，您吃药了吗？”
我看了看病号服，激动地说：
“护士，这个药绝非凡品阿，药效SSSS级，可以变身工匠改变世界，比如我在载人航天中心。。。”
护士小姐姐温柔地打断我：“啥都甭说了，我都知道。上次几乎要灭世的外星飞船BUG也是你在打野的时候一抬头看窗外的时候无意中发现，由地球卫队瞄准命门一记激光炮过去打爆的。 可你反复说是药好， 这么谦虚谨慎找理由配合吃药的病人本院少见。 谢谢你，你对我真好。”
你刚要争辩，却见她她微笑着坐到床边，一手拿水，一手拿药，说到：
“大郎，不不不，大海，该吃药了”。
我努力想伸手去接，可是憋气不能动，仔细一看被约束带紧紧捆绑着我。我拼命挣扎想接过小姐姐的药，拼命用力想碰到她接近她。。。。
于是我醒了 。
完。","当然是第二颗啊，这还用问？
第一颗有毛线用？说个比方吧，张三写1+1=2永远不会错，但张三傻，永远只认识1和2，其他的数字都写不出来，这样好吗？
第二颗的话，这可不得了，这个能力的强大可不是你能想象的。我们知道
停机问题
不可解吧？程序永远运行不能终结也是bug之一吧，如果我随便写一个程序都能发现bug，至少解决了停机问题吧？也就是说，我已经超越了
图灵机
的计算能力，至少达到了
图灵度
0'的水平。
来一个具体例子吧。比如x=1当π中含数字串a=""782......3""(随便写)，x=0当π中不含这个数字串。首先π是可计算数，所以程序一定能被我编出来，比如穷举每一位小数。然后这个问题和停机问题差不多。
①如果π中含a，程序在有限步后找到a就停机，输出""x=1""，
②如果π中不含a，程序永不停机，无法输出""x=0""。
现在②情况下，程序陷入无限循环，就是一个bug，如果我吃了题主说的药后能修复这个bug，输出x值，就完成了一个普通图灵机不可计算的任务，达到了图灵度0'的水平。
事实上我可以走得更远。对每个正整数n，我们把之前例子中的π换成π^n，都可以提一个类似的问题。把之前例子里求x的程序加一个参数n封装起来，得到M(n)，之前那个就是M(1)。再定义一个十进制小数c=0.xxx......，其中小数点后第k位是M(9k)～M(9k+8)运行输出的x(n)之和。然后我们又可以问，c中是否含有数字串v=""782......3""？假设有一个带有计算能力为0'的谕示机的图灵机X，对每个n，都能在有限时间内判定M(n)并输出x(n)。如果c中含数字串v，就存在某个有限的n，使得x(1)～x(n)的结果能判定v存在，但如果c中不含数字串v，那么X的运行也陷入无限循环，永不终止。现在我发现并解决了这个bug，就解决了关于X的停机问题，也就达到了图灵度0""的水平。
以此类推，吃了题主的第二颗药后，对任意n∈N，我都能编程解决图灵度为0(n)的判定问题。也就是说我的能力达到了整个arithmetic hierarchy(
算术层谱
)，能解决复杂度低于0(ω)的所有问题。判定
皮亚诺自然数公理
的一致性，也就是0(ω)这个水平了。
PS.比如哥德巴赫猜想和
黎曼猜想
，都是∏(0,1)语句(对应图灵度0')，所以如果0'的判定问题是无边的沧海，这些猜想都只不过是沧海里面的一粒沙子而已。除了数理逻辑之外，人们关心的所有需要无限次枚举的数学猜想，基本上都是∏(0,1)的语句。你继续想象一下0(100)的复杂度？0(10^1000)？0(10↑↑↑10)？0(10→10→10→10→10)？这些可都只是算术层谱里的沧海一粟。","必须是第二个！
写代码100%不出错依然只是一个码农，顶多算一个不错的码农，在公司只不过是一个无情的编码机器，业务代码一大堆堆你身上，撑死了老板觉得你靠谱给你涨薪30%，让你做个骨干程序员。
能100%发现并修改bug这可是大杀器，神一般的存在，任何公司的任何产品都会面临各种复杂的线上bug，非必现bug，要知道有时候团队为了解决这些bug花费的人力物力简直是不可估量的。
嘿嘿，这个时候你一上去bug就立马解决了？还能帮其他人发现bug，这可是要快速晋升的。
举一个栗子，
李一男
毕业后加入华为，3个月晋升主任工程师，半年晋升总经理助理，两年后就是最年轻的华为副总裁，靠的就是能解决其他人系统的bug。
另外，有了这神技能，还不一定需要打工了，积累点口碑和人脉后做个自由职业者，专门帮一些小公司解决各种稀奇古改的问题。
这个来钱那可真不是码农可比拟的，IT行业的一个知名大V左耳朵耗子曾经就干过这个，就饿了么一单一个月就是10多万，当时饿了么在快速扩张期很多服务器的高并发/高可用的bug团队解决不了，就请了左耳朵耗子做兼职技术顾问，一周只用去1天，解决问题就好。
很多人认为优秀的程序员就是coding厉害，其实这都是误解，真正牛逼的程序员不光coding要厉害，更重要的是debug的能力。
现实中没有这种神奇药丸，但有如何成为debug高手的方法论，曾经在360带几十人技术团队，同时研发几条业务线。参与过的产品，日活过千万的有一款，过百万的有三款。
这个过程中各种稀奇古怪的bug见过不少，也一一解决了（不然估计就要滚蛋）。
分享下我的debug经验，希望对大家有用：
1.日志Log尽可能详尽
编程领域流传着一句话：必现的bug，都不是bug。
因为好复现，就容易解决，代码一直跟下去，或者看看
堆栈信息
，很快能定位问题。
真正困难的是偶现bug，甚至那种概率千分之几，但后果严重的bug。解决他们就需要详细的日志Log，尤其是关键点上的信息，非常重要。
顺便推荐一个经典的github项目，这个项目收录了程序员需要学习的方方面面，包括计算机经典书籍、经典大厂面试题、各种图解tcp/ip、操作系统、在360积累的soa、网络相关核心文档、程序员成长超全攻略等等:
https://github.com/pinefor1983/CS-Growing-book?github.com/pinefor1983/CS-Growing-book?github.com/pinefor1983/CS-Growing-book
?
github.com/pinefor1983/CS-Growing-book
2.google要用好
程序员+google=好的程序员，这句话真的没错，很多技术bug，当你毫无头绪之际不妨google下，可能不少人遇见过。
当然，最关键的是搜索的关键字，这取决于你对bug现象的描述，越言简意赅搜索到的信息反而越多。
3.二分注释法
这个方法在实在束手无策之际不妨用用，用法也很简单，当你不确定哪一块新增代码引入问题，就尝试注释一半代码看看程序是否OK。
不行再换另一半代码注释掉，很快你就可以缩小bug的查找范围，进而定位问题。
4.熟练掌握算法
算法很多程序员朋友并不重视，认为这东西并没有什么用，实战中遇不到呀？
其实在很多性能bug中，引发的原因就是代码实现的时间复杂度和空间复杂度导致的，这个时候不清楚基本的算法压根寸步难行，无法做任何调整。
反之熟练掌握算法就能很快进行调优，有的时候优化后甚至都不需要加服务器。
更别提算法是大厂面试和笔试的必考题，原因也在于大厂需要有筛选方法来判断你是否有成长空间。
顺便送大家一份经典算法资料，是一个阿里P8撰写的，如果你能吃透，那我相信80%的技术面试都会不在话下：
5.模拟用户环境
可以采用一些工具来模拟前端或者后端，制造假数据、假操作。有了这些工具之后，把你怀疑可能出问题的情况模拟一遍，观察是否会出问题。
其次，遇见一些极端情况，比如怀疑是
多线程
/多进程死锁，那不妨在某个进程/线程写个死循环看看bug是不是就出现了，当然做这种操作千万千万别给忘记了，提交了，那就完犊子了。
6.记录曾经解决过的bug，并建立索引
其实很多bug会变着花样反复出现，俗话说好记性不如烂笔头，把解决过的问题记录下来，并且做好索引，下次遇见可能相同的问题，先检索一遍，搞不好就找到答案了。
7.多看
官方文档
特别是引用了第三方代码或者是开源代码导致的问题，官方文档对应的部分反复看看，可能问题就解决了。
8.引入工具，放大问题
比如很多线程注入的工具，你开启后，但凡是一点点依赖线程顺序的bug都会从偶现变为必现。
这个相当于主动把代码运行环境变成地狱模式，比如你的一个线程的结果依赖于另一个线程的输出，但你忘记加
同步代码
了，不过大部分情况另一个线程运行都飞快，但有些机器就不好使了。
这个时候加入这种工具，它直接让某些情况下另一个线程运行速度变慢（我猜大概率是加了个sleep(1000)），结果你的程序就崩溃了，崩溃堆栈直接打开，迅速定位，问题解决！
9. 制作工具，针对某些bug编写一些调试辅助工具。
比如，某些系统没有完善的崩溃报告，虽然也有dump，但是分析出来的callstack经常不准。完全可以为解决崩溃问题编写了个工具，自动扫描代码，在每个函数入口和出口插入log，以此来定位崩溃点。
以上9点，都是在实战血淋淋的过程中总结出来的，希望对大家有帮助。
另外，对于想在计算机行业卷的朋友来说，夯实
计算机体系
基础知识非常重要。顺便推荐一个经典的github项目，这个项目收录了程序员需要学习的方方面面，包括计算机经典书籍、经典大厂面试题、各种图解tcp/ip、操作系统、在360积累的soa、网络相关核心文档、程序员成长超全攻略等等:
祝大家前程似锦，在程序员这条道路上一马平川。
如果觉得写的还不错，请别吝啬你的点赞，请给：
@findyi
一个点赞鼓励，笔芯～",当然选,"曲突徙薪
有一个造访主人的客人，看到主人的炉灶的烟囱是直的，旁边还堆积着柴草，便对主人说：‘重新造一个弯曲的烟囱，将柴草远远地迁移。不然的话，会有发生火灾的忧患。’
主人沉默不答应。不久，家里果然失火，邻居们一同来救火，幸好把火扑灭了。
于是，主人杀牛摆酒来感谢他的邻人。被火烧伤的人在上位，其他的各自以功劳的大小依次坐，但是没有请说改“曲突”的那个人。","我选蓝色的那颗，吃了能隔着屏幕给题主一大嘴巴子的那种
题主但凡写过一个月程序，就问不出这种挑衅的问题来。","Update:果然牵扯到因果律的不能随手作答。
毕竟所有的因果律，从来都是副作用更好利用。
（出题人不会给出效用太强的因果律，毕竟那么做就没意思了）
第一颗暂时看不出什么可以利用的副作用，因为很有可能“写代码100%不出错”的意思是“写不出不出错的代码”，当你试图写出错误代码时候，或者停电，或者台风，这些都在因果律的正常射程之中。
但第二颗就不一样了……第二颗不存在前置发动条件，也就是说，因果律不能阻断你发动第二颗效果。
让我们看一下第二颗的效果：
吃了能让你100%发现并修改bug
速度等同你原来的速度，其他各方面不变
我们可以随手写一个带bug的程序，比如“输出
千禧问题
的解”
让程序从/dev/urandom随便输出点什么
显然这个程序不能正常工作,a.k.a.,存在BUG
于是我们可以愉快地改BUG了
不要试图把这个BUG改出来，因为“速度等同你原来的速度”，你原来十辈子解不开六个问题，现在肯定还是解不出
但因果律会要求你解出这六个问题……
所以你只能乖乖活到这六个问题都出现证明（虽然显然不是你写的），之后依次把这六个问题的证明输入到程序里。
觉得六个问题一定会解决？到第五个问题解决的时候找几个新问题制造BUG即可
吃下第二颗药丸的，可能这辈子都解决不了任何一个问题
但吃下第二颗药丸的，这一辈子会过得很长很长。
剩下的是原来的废答案……仅供参考，毕竟是没想到“
利用debuff
”这一招的答案，质量并不算上乘。
就算真实宇宙都有人
拿debuff当buff用
，在因果律宇宙，不这么搞，实在太对不起那个题目了
第一个可能是废能力：当因果律有生效前提的时候，你一定要权衡生效条件和生效后果哪个更难改变。
第一个能力，写代码100%不出错，速度等同于你原来的速度……
你原来就写不出不出错的快排，也就是写“不出错的快排”的速度是0，于是吃了药之后你就写不出快排了
第二个能力，100%发现并修改BUG，发现BUG的速度等同于你原来的速度
也就是原来debug一周才能解决的BUG现在还是需要一周时间……
总觉得这两个都不是什么好东西。
但讲道理，必须选一个的话，第一个或许更好些。
毕竟第一个可以迅速让你明白“你能做什么”，可以节省你许多时间（做不能做的事情&&debug的时间都可以省去，基本上相当于程序员寿命翻倍）
第二个……我猜是普通糖丸。
毕竟第二个没改掉“发现BUG所需的时间”","当然选找bug.
你自己写代码没bug用处不大。最多解决10%的问题。
大部分bug都出现在系统整合上（
integration
），最常见的是数据不匹配合约。
大白话讲就是你没bug, 别人写的代码有bug。以及你和别人的都没bug但合一起就有bug。","顶尖技术大牛选第一个，底层苦逼搬砖选第二个。
第一颗药丸看似鸡肋，实则鸡肋。普通人或者是编程能力很一般的人吃完之后，几乎没什么效果。
But，它更像是特攻宝具，对于编程
天赋树
快点满的大牛们，可谓是宝藏神器。
有着这个库那个库我都会，这个算法那个算法我能熟练掌握的前提，现在还有写代码100%不出错的顶尖BUFF加成，这意味着什么？
意味着只要你的指尖在键盘上起舞，就能写出来高水准且毫无错误的代码。
你可以一边听歌一边写，一边看剧一边写，通勤在路上写，排队买奶茶时写，只要醒着你都可以一直写。
工作轻轻松松，私单接到手软，财富自由指日可待。
当然如果你足够地积极进取，你也可以持续地学习知识，毕竟对于你来说，之后最有挑战的事情可能就是学习了。学得越多你就越牛逼，越牛逼能做更多的事情，在输出这块你已经是前无古人后无来者，你要做的就是不断地进行输入。
综上如果你知识量不够，只能编写一些简单地排序代码，你吃了第一颗药丸，效果几乎也是微乎其微的。所以普通人请出门右转，
第二颗药丸才能是帮助普通人逆袭的宝物。
吃完之后，方圆几十里的IT公司的测试岗位员工瞬间失业，因为他们已经失去了价值。
几十万行的代码放在你面前，你也不会面露愁色。鼠标滚轮能拖多块就拖多块，最好是七八个屏幕一起摆在你脸上，同时翻滚。你用最快的速度审完之后，心里已有定数。你也懒得跟周围人解释bb，直接上手就干，当然你也可以一边看热映电视剧一边修改，轻松写意地就之前十几个人要干几天的活干完了。
从此之后，你就成为了神话，找你的基本都是大公司，中小型公司你都懒得搭理，当然他们也请不起你~
钱吗自然是不必愁了，名声地位你也基本都有了，到时候你还要雇几个美女经纪人，像CEO明星那般细细地安排行程。
市场永远有需求，所以你要做的就是吃吃玩玩，等到银行卡里余额不足时，再出去干个几票。
简直不要太爽！
等下，这样来看技术大牛也该选第二颗药丸了......","不不不，第二颗药丸药效太厉害了。
弱化一下：不用解决bug，只要100%定位bug，就已经保证一辈子不动代码还能吃香喝辣并且名正言顺当上业内知名的技术专家了。就像那个故事一样：9999美刀告诉你在哪画线，至于最后画线的1美刀，让别人挣去吧。
至于第一颗药丸？说破天了也就是个高级工程师。","你们有没有想到深度学习的功能？我猫狗分类能做到100%分类正确，那你觉得我是神还是不是？
这个问题里面第1个选项没有包含工作量和程序的技术深度。怎么叫做100%不出错？一般的代码在没有并发的时候不报错，这个代码在高并发底下报错，那这就要出错吗？
如如果我随手写的代码，哪怕只是一行，他不管多大并发量都死活不会出错，不管多少线程竞争，他的同步状态都一定是正确的，还得包含性能指标，比如说我这个代码能保证一连串的微服务调用最终出来的结果绝对不超时（我说单次调用总体时间不超过0.01秒就0.01秒，不超过0.005秒就0.005秒），那我觉得这个100%不出错的能力很强啊。
如果做个100%识别率的CNN，把VGG , ResNet这些的正确识别率爆成渣，不香吗？做个100%识别率的RNN，把BERT爆成渣也很香。
补充一个，有人说选项二是包含选项一的能力的，可以呀但是他必须是看到我的代码之后才能改对。论文我已经先发了，你后面看到我的再优化，我没意见，反正你的论文上面也得加上引用我的
citation
对吧。
但我觉得你们还想着拿选项二去修改别人的代码？我都巴不得自己做不到这一点，反正死活做不到，要么重构，要么大家双手一摊。因为这种东西急着现场一定要把bug改掉的，你通常是在加班的情况下，说不定还是在甲方的人看着的情况下。
我根本就不想变成超人，不想上班。按照选项一随手写几行hello world改变一下世界，出出教程做做直播不爽吗？
就算有选项2这个能力，都不想再去伺候他们了。","功能上第一种只能在自己身上起作用
第二种你就有发现bug的能力了，能发现其他所有人的bug，简直就是
世界之神"
,,,,,,,,,,,,,,,,,,,,,
自学简单编程可行吗？,如果可以，具体去哪里自学好呢？就是把电脑的一些知识都了解一下。,"自学不难，难的是避免走弯路。
一、首先，不同语言的入手难度是不同的。
C/C++、JAVA。殿堂级，规范好，资源好，需求多，长期投资好。就是自学门槛高点，易犯错，见效慢，要整出一个像样的作品，单撸废劲。
比较适合有时间、有耐心的选手。
Python、PHP、Javascript、小程序。热门级，上手快，新人友好，容错率高，见效快，中小企需求大。多个第三方库东拼西凑，加以复制大法，就能组成一个自己的网站/WebApp。
比较适合着急入门的选手。
自学的话，最好根据个人过往的学习毅力，理性做选择，这样真能学成的概率大点。
个人比较推荐从「上手快」的语言开始。
二、具体怎么学好？
先说下我自己的情况。
我专业是后端的，但因为兴趣使然，业余搞过IOS、Android、SPA、每种都整过大半年以上的项目，也莫名带过几个新人入行。
我的经验建议是，一开始必须以做「成品」为目标。
有目标才不会学偏学泛，导致学而无用，浪费时间。
其次是「勤动手」。
可以选择自己平时喜欢的网站/WebApp作为练手模板。
现在不是2000年，就别再被各种三流的老师忽悠去学做枯燥的「学生课程系统」了。
人就这样，当你对一个主题压根没兴趣时，学习的兴趣就坏了50%。
2019年的我们有更好的选择，诸如浅copy微博，B站等等，关键是你喜欢。
新人入门，浅copy练手模板就行，主要目标是学会「增」「删」「查」「改」内容。麻雀虽小，但五脏俱全，在实际的工作开发中，60%代码都是写这些东西。所以，学会并熟悉跟其相关的技术知识点是最必须的。
三、入门学习方向和目标确定好后，就是分配阶段性的学习任务。
这里以后端为例简单说一下。
首先，我们要准备一个辅助学习工具：
菜鸟教程
。
主流语言的基础知识都汇集在此，而且有案例哦，非常方便新人快速了解知识点。
编程工具的话，新手整个简洁的vscode、sublime就好。
先别去搞那些要复杂的配置，很影响的学习激情，先看到「hello world」才是关键。
然后，在学习的过程中要多搜索、多借力于能「完成任务」的文章和视频
。记住，是跟「完成任务」有关的。
（都 1w 收藏了）
（点赞，评论，给师兄点正反馈^-^）
接下来，我们就逐一介绍6个主要的学习任务。
它们彼此互有关联，由易而难，循环渐进。
第 1 个任务是，copy一个静态页面。
具体来讲，就是做一个展示内容的页面，目标是搞懂html、css的基本语法，明白一个简单的页面由哪些东西组成。最重要的是，这个任务门槛低，完成时间短，能让你快速看到小成果，学起来也更有动力。
第 2 个任务是，copy一个动态列表页。
在搞定展示内容的基础上，尝试动态填充内容。这时，你需要初步接触Linux、部署服务软件、数据库Mysql、语言框架，开始有一定难度了。
可以分两步走。
第一步是，先不管数据库，把数据写死在编程语言中，然后学会把数据显示到模板中。
目的是学会使用数据和遍历数据。
第二步是，在完成第一步的上，学习使用数据库。
目的是明白SQL的语法。
第 3 个任务是，copy一个登陆模块。
这个很关键，登录功能是多数应用软件绕不开的核心模块。
目的是了解session、cookie这些经典知识，以及初步接触完整闭环的功能逻辑。
第 4 个任务是，浅copy一个发布功能。
在有用户登录，和动态列表页的基础上，我们加个发布功能。
目的是学会新增数据，并把前面的所有任务内容串起来，进一步明白业务从前端到后端的大体运转过程。巩固加深对业务的开发流程的认识。
第 5 个任务稍微务虚一点，养成分析项目业务的小习惯
（不考虑各种复杂情况）
分析业务是程序员的必备能力。平时使用web和app时，多留个心眼，想想看这个功能的数据结构是由哪些元素组成。
目的是养成系统化的业务思维，这对更好地学习编程非常有帮助。
第 6 个任务，选一个较小的生产级别的Web/APP，做有一定深度的Copy。
有两个好处。
其一，可以帮助巩固原有的知识，起到温顾而知新的作用。
其二，有深度的copy，意味着业务逻辑复杂了，技术逻辑要求更缜密，这能促使你或多或少接触一些中高阶的技术知识点，实战能让你更深刻地理解它们。
其三，自学找工作，
一个有模有样的项目，其说服力，胜过千言万语的言语自荐。
当你完成以上所有任务时，你就已经达到入门程序员的水准。
四、再来是一些帮助小贴士：
1、如果条件允许的话，请把你学习过程的每一个大知识点，都梳理归纳成文章集，放在
csdn
，自己的博客，github都行。
一来，是让自己看到努力的硕果，增强信心。
二来，是它们能丰满你往后求职的简历，增加谈资。
总之好处多多。
2、如果你是学后端的，git、redis、nginx、
zookeeper
、kafak、docker的入门使用，要了解一下，真实工作是会用到的。
3、有人打趣说：“感觉不懂英语学编程，跟瞎子抹黑一样，得慢慢摸，才知道是什么。英语好，起码是睁着眼睛能直接看到东西的。”
所以碰到不会的英语单词，一定要「勤查」「勤记」「勤背」。
4、预备一本技术的枕边书。我之前带人入门java，都会让他买本《java语言程序设计-基础篇》，把碎片时间利用起来，打稳根基。
既然要学，想学好，自然不能放过任何学习的机会。
剩下的就是去实战了，去积累经验。有经验，才能配合进一步的学习，真正理解中高阶技术知识的作用。
那去哪实战呢？必须是去工作，这个法子最实际。闭门空想着造车，实战性和锻炼性不够。找工作的这里不详细叙述。具体就是找合适的题型，刷起来，然后认真做好一份简历。有疑惑，可以关注私聊
师兄
。
另外，可能网上有人告诉新人要学透「
设计模式
」，学好「算法」，其实说得对。
但如果「新人A」一听，就不假思索，二话不说，买来一本500页的模式圣经、一本800页的算法宝典，开始从头啃到尾。
那么，能不能学好不好说，但是学到崩溃是必然的。多少业内人都没学透的东西，部分也就嘴上说说而已，而他当真一口闷，兴致不被磨光才怪，直接从入门到放弃。
即便「新人A」真能生吞20多种设计、几十种算法、也用处不大。因为他的业务经验缺乏，不足以支撑他对理论实际用处的理解。一个月后他就忘得差不多了，很浪费时间和头发。
最佳的方式是：例如设计模式，他可以先学单例、工厂、装饰这3种常见的模式。吃透了，够他在前期用了。其他的模式，等实际使用接触到，再慢慢学。一开始上路，就背着块大石头，只会压得自己喘不过气。
学习陌生的事物要「有主次，有先后」，一开始，量要小，目标也要小。要在1周内能看到终点，有盼头才有动力，能短时间就有所收获，才有学习的乐趣。
自学编程是可行的，只要少走弯路，其实比培训班学习周期短不少。
毕竟人家是上万元的学费，必须拉长足够的课时，才能让学生觉得物有所值。
但是单靠零基础的自己，加网上的碎片文章和视频，其实想少走弯路有点难，时间充裕倒无所谓，算磨练自学能力。
如果时间有限，比较靠谱的方法还是：借力。
有条件的情况下，找个有经验的业内人士，帮你规划学习路线，阶段性地验收你的学习成果，查缺补漏，防止跑偏，这样会比较高效，又省心。
最后，我想跟大家分享一个朴素的心得：
自学编程的成败，不在难易，贵在坚持。
希望对你有帮助，祝顺利。
现在的朋友点起赞来，都这么含蓄的吗？
来，左下角，大胆一点！
卫星ktshixiong，深度职业规划＋
/*
----------------------------
*/
     有用点个赞，世界你最棒
/*
----------------------------
*/
知乎就是师兄的心得记事本，喜欢的可以
关注
哦~
相关 IT 求职干货
自学有哪些优秀书籍
→ 
在你自学计算机的路上，哪些书籍对你的帮助最大?
自我介绍讲不好，谈薪容易谈不高。 
→ 
面试的时候，如何自我介绍？
公司想白嫖你？教你如何优雅地回击
→ 
面试的时候面试官问如何看待加班，该怎么回答？
详细到你害怕的应届生简历教程 
（4000+字，推荐收藏备用）
→ 
应届生没有工作经历，简历应该怎么写？
最后，再次感谢大家的支持。","正确的学习方法、学习路径，不要说简单的编程，转型都是可以的，
但是自学编程有几个非常大的坑，很多人因此走了不少弯路
：
1、如果你不是计算机、工科专业，不是以编程为生的大学毕业生，不要去用国内的大学教材来入；
不要去学考验人性的C/C++、Java、汇编等，
这些东西已经不适合你，推荐你去学Web前端（HTML、CSS、JavaScript）、去用PHP搭建网站、或者学Python（取代VBA来提升办公效率，替代Excel、PowerBI来做数据分析、可视化）、小程序等，一周可入门，好玩又好学，对工作有帮助，深入可提升工资，也不排除可转行；
大学教程讲理论比较多，所学的内容只有你在月薪2万以上才开始发挥作用。即使月薪2万以后，也不建议你使用国内的人写的计算机教程，国内越是名校，学历越高，就越会用国外写的教材。而美国学计算机理论之前在高中就有AP课程，而国内绝大多是计算机零基础。
C/C++、Java不学习半年以上，你是很难开发出一个实用的东西的。用C++写贪食蛇小游戏？别搞笑了，你觉得你这游戏实用吗？用Java开发安卓？你零基础学半年，能开发一个App上线吗？用Java做网站？稍微简单的JSP已经淘汰了（当然国内有些外包公司还在用JSP）。
如果你花半年时间学前端、Python、PHP，不仅可以开发出实用项目，你都可以来接外包、来找工作了，甚至可以转行了。
很多人居然推荐已经工作了的人或者不想从事编程行业的人从
汇编
、网络、C等等这些学起来，你可能大学是这么读过来的，但是这只适合计算机相关专业的人，不适合其他人，你的这些推荐太误人子弟了。
（计算机、工科相关专业还是要把C/C++或Java给学好的。)
2、不建议你学
易语言
，不推荐你学VB、VBA，因为这些没有前途，不建议你去学Julia，Dart，你没有基础就不要追逐过新的东西；
有些方向不实用，也就是实际开发已经不作为一个通用的解决方案了，比如JSP、Flash这些；
有些方向在国内用的人会越来越少，比如VB、比如
http://ASP.NET
；
有些方向没有前途还会阻碍你的进步，花大量时间折腾没有意义，比如易语言；
有些方向不适合新手去学，新手学了没用，哪怕再怎么流批，比如汇编；
有些技术听起来很有前途，但是不适合新手去跟风学，比如Dart，Go，你啥基础没有你也学不通。
3、不要去买书来啃好几周，不要不动手光看视频光看书，学技术一定要先从安装开发环境开始，
编程只有动手实战起来才会变得简单
。很多人一上来就问，编程难么？我零基础能学会么？这个知识是用来干啥的？你问这么多干嘛？有些人收藏了几百篇好文章，花的时间不可谓不多，但是就是没有开始实战起来，这能学会么？
有些人买了一些经典计算机教材（通常比较厚），一啃就是几个星期，甚至个把月。更可怕的是直接去啃
编译原理
、算法导论、计算机系统、网络编程这些书，不说你啃不啃得下来，你即使学完了你也不知道可以干嘛啊！！！
JS直接啃
犀牛书
，这本书可有1000页。很多人啃了半天学不下来就说编程好难。你学习方式方法有问题，编程能不难么？
PHP、Python、前端这些如果你学习两天到一周都不能上手实际开发一个东西出来（非写几行代码），你就走了很多弯路。
4、
大学生千万不要用考证的方式来学编程
；如果学校对二级计算机等级考试有要求，就考Office或Python吧，混过去就行了，不要去参加什么软考之类的，浪费你的时间。
很多学生视野比较狭窄，他只能接受到学校和身边的人灌输给你的知识和观念，只能了解到有限的评价体系，觉得考了这些
计算机等级考试
和软考才算得上是优秀，学编程也往往以这些知识为目标。这些完全可以理解，因为我大学时也考过。
事实上评价一个学生在计算机方面是否真的优秀，一个是你对技术知识的深刻理解，这一点你可以像写论文一样多写写技术文章，培养自己的研究探索精神；二是你对项目产出能力，你能够证明给自己、给他人看的，项目是非常重要的一个依据。对于一个初学者，该如何输出自己的东西这里面有非常多的学问，以后我再整理一下。
学校对于优秀学生的评价体系与企业对于优秀员工的评价体系差异是非常大的，而你个人对于学技能的追求，你自己心里也有一套标准，这三者之间有很大的不同。
但是很多零基础想学技能的人却被要求按照学校的标准与方式来学，怎么可能学得好？
（当然有些技术方向的证书是可以考的，比如网络工程师CCNP、
运维工程师
RHCE、RHCA，PMP这些行业还是比较认可的，软考什么的就算了）
5、
学编程应该以项目开发为主
，不要东学学西学学，到时候啥也没有掌握。不要看人家说Python好就去学Python，一会学C，一会学Java，招聘时就说自己掌握这些语言。要知道不没有开发出一个网站、一个网页、一个App，一个实际的东西、项目出来，你学再多，都等于半成品，都不算学会。
以项目为导向的方式来学习，即是符合程序员学技术的方式，又能让你对学技术欲罢不能。
学习技术本来是一件可以让你很有成就感的事情，如果你学编程一个星期都受挫茫然没有效果，只能说明你学习方式不对。
国内编程教育思路很有问题，
编程本来就是一项技能
，所谓技能就跟做菜、骑自行车一样，你学了就可以实操。但是国内编程教育却要求你成为一个有品味的厨师，给你灌输菜系的知识，告诉你色、香、味、形、器、意、养等做菜的道理，就是不让你动手做菜。很多资深厨师会告诉你这道理太重要了，厨师不懂这些算个p的厨师，但是你明明想学的是做菜，有些人就说了，你只学做菜，跟进技校有什么区别？太low了。但是你明明就没有资格以及不想成为厨师啊....
6、
很多编程零基础的人一上来就想学人工智能、大数据等这些看起来很有前途的方向，妄想通过培训半年就能找到好工作，这些都已经不切实际了。
（特别刻苦肯学，有理工科背景，热爱数学、喜欢编程，能坚持学习一年以上的例外，国外这样的例子太多）。很多培训班不加限制不设前提就鼓吹这些领域的求职神话就是欺诈，严重误人子弟。这些方向甚至都不建议一般学校乃至一些985计算机专业的学生来学习。（有毅力、决心、恒心者即使是30多岁劝退的年纪零基础也可以，但是你这是在挑战人性，没有几个人可以做到）。
如果你想转型IT，成为互联网方向的职场达人，其实方向是有很多很多的，比如如果你对设计有追求，哪怕你没有绘画天赋，你仍然可以学UI、UX；如果你对互联网产品感兴趣，沟通能力比较强，产品经理就比较适合你；如果你自认为你喜欢研究数据，数据分析就有大量岗位等着你；前端、后端、移动端、测试、运维等等都有大量高薪有前途的岗位。
互联网（含EE、CS）相关岗位是非常丰富的，编程不只是会让你成为程序员，机会多的是，没有必要硬着头皮不切实际去成为算法工程师、
人工智能工程师
、大数据工程师这些你已经不具备进入资格的方向。
如果你想快速入门，建议找个人指导你，比你买书、自己去翻视频、自己摸索要强得多。
有不少计算机专业的学生出去找工作前会去培训班或者他们学习时都是到网上看视频看文章，很多知识也是自学的，这是因为一般的学校会教你知识，而培训班和网上的资源会教你技能。
如果你是计算机相关专业，系统而底层的知识是十分有必要的，它会决定你职场上的高度。如果你学专业课感到艰难，你也可以花点时间从我说的Python、PHP和JavaScript入手学起，然后再来结合专业知识。
如果你是想系统学习计算机科学的专业知识，推荐花两三年的时间按照“科班式”的方式来学习国外名校的计算机课程：","本回答首先分享了如何选定学习方向，自学编程主要有几个阶段，学习过程中有哪些注意事项和学习方法，最后分享了目前权威的学习资源，如果对你有用的话，点个赞吧。
首先要选定编程学习的方向，例如 Python、C、C++、Java、JavaScript 等等编程语言，你最好先去查一查都有哪些编程语言，每种编程语言都侧重于哪些方向，例如 JavaScript 主要用于 Web 前端开发，Java 主要用于后端开发，Python 在数据分析和机器学习等方面有较好的应用。不同的方向有着不同的吸引力和特点，你多了解一下，选一个自己感兴趣的。
接下来就是学习编程，那么在看书学习的过程中，有一点要记住：
不要无脑照着别人的代码敲
，重要的是思考，是学习编程的思想！照着别人代码敲一遍除了让你看得仔细点，练了打字外其它并没有任何帮助 ― 和自己盯着代码仔细看是一样的，这样的学习效率是不高的。
重要的是学习编程思想，这个功能是怎么实现的，为什么这么实现，作者是怎么想到的，其次才是敲代码，学习好了思想以后，你可以自己敲，模仿敲，再对照着检查自己代码中存在的问题。
自学编程主要有以下几个阶段：
看书、看博客、学课程或者看视频等
模仿着书上或者博客的代码，进行复现，复现不重要，思考才是关键 ??
思考学习别人思路后，脱离书本和博客，完全自己实现功能
自己实现一些 DEMO，看别人项目代码，与别人讨论，提升代码能力
在别人的框架和要求下，写代码实现业务
自己负责别人设计的模块的实现
独立设计业务模块并开发实现
负责大项目框架设计和拆分，带领别人进行开发
其他高阶的架构和管理工作，已经不仅仅是代码能力了
那么在自学编程的前期和中期，能够完成前五项就是取得了很不错的效果了。
学习过程中的建议：
初级程序员，涉猎广泛，但都是浅尝辄止。这是很多人面临的问题，而在编程学习则是需要实际操练，加深体会，不断深入的一个过程。在这个回答里，我想说一下初级程序员应该如何提高。
1. 让编程成为一个习惯
想要培养一项技能的最好的办法，就是将他融入到我们的生活并成为我们的爱好。其实说白了，就是让这个爱好成为一个习惯，一天不去做这件事情，都会觉得少了什么。在不知不觉中，这个习惯会像滚雪球一样积累起来。
对我来说，养成这种习惯首先就是要对“拖延症”说不。比如，你想锻炼下自己的写作能力时，但是没有好看的本子，没有好的灵感，没有安静的环境....总之就是找各种理由一拖再拖，最后就不了了之了。
为自己设定一下，每周拿出几天，每天拿出几个小时，编程学习就这样慢慢步入正轨。
2. 将每天的学习过程拆分成小块
对待编程学习，我们没必要像健身狂人那样一口气做到筋疲力尽。与其直接编程2小时，我们完全可以先做40分钟、然后休息5分钟，整个过程重复4次。很明显，40分钟这样的短周期更容易坚持也不会带来多少压力。
不过这样的方式应该配合更为灵活的执行思路。如果你感觉状态很好，而40分钟才刚刚完成热身，那就继续做下去并努力让自己抓住这种状态。向大家推荐蕃茄工作法，这是种学习新型技能的良好机制，推荐各位认真了解。
3. 学好基础知识
在确定好学习方向和
技术栈
之前，你可以多做尝试，学不同的语言。但是当你学到一定程度，知道自己对哪个方向更感兴趣的时候，就不要广撒网了，一定要专注于你所选择的领域，做深做精。认真系统化地学习相关语言知识。当然，这不是让你就知道看书，你要看书的同时结合项目实践，进而对自己的掌握程度得到反馈，知道自己哪里不足，再继续学习，如此反复，详见第四点。
4. 学练结合，从做项目中找知识漏洞
当你选好方向，认真学习基础知识后，学习一部分的知识，就结合项目做一些实践，已明确自己哪里不足。并且做项目能增加学习乐趣，给自己提供一些正反馈，让学习变得有趣，让自己有足够的动力继续学习。
5. 阅读别人的代码
学习编程不能闭门造车，经过这几年的编程学习，我认为想要提升编码水平的最佳途径就是多看、多写。看别人的代码，看一些程序员大佬写的代码，看一些标准库的源码，仔细思考他们的编程思维和编程方式，以提升自己的编程思维和编程方式。阅读别人的代码也确实是快速提升代码水平的一个技巧。
当然，也有一些提升阅读别人代码速度的技巧。很多时候读代码靠的不是阅读文字速度，而是理解的速度。我把自己理解的影响速度的原因列举出来。
1. 对整体的思路没有概念
2. 对类库不熟悉，包括方法调用不熟悉
3. 不理解里面的一些算法
4. 中途停顿时间太长，接过来后没有形成一个系统的思路。
阅读的方法是先整体再局部。目前我们知道了那些因素影响到了速度也知道了阅读的方法。那下面就开始一个个击破难度。
1. 把握整体有个大体的框架在脑海中，此时根据里面的文件名和文件夹，从入口文件大段大段看就可以，知道这段或者这个文件的作用就可以。很多写得好的类库都是思路很清楚，非常有助于从整体理解， 此时只需要知道这个文件和这个方法是什么作用就可以，还不到细细研究的阶段。
2. 对
类库
不熟悉那么会引起阅读时候左右查资料，影响速度。此时应该先把不熟悉的类库全部整理出来，一次性过一遍，然后到对应的官网查用法就可以，注意，此时不用全部看，只需要查调用到的地方什么意思，弄明白调用的意思即可。
3. 遇到不熟悉的算法此时就要静下心来，如果有注释可以根据注释来理解，如果没有那么也是一样的思路，想整体了解这个算法再细分进去了解，这一步只需要静下心里是可以理解的。
4. 中途不能说看一个小时，停了4个小时再接着看，或者是今天看一点点，隔了非常长的时间再看第二部分。最好是趁热打铁。
里面核心的地方还是从整体到细节的方法，掌握到了整体阅读细节才有意义，有时候知道了整体一些细节的地方清楚了，总之没有不努力就能理解的代码，上面的方法只是帮助你可以轻松些阅读，只是努力是必须的。
6. 寻找良师益友
学习编程的一个很好的方法就是和其他的程序员交谈。这不仅能够帮助我们多获得一种思维方式，同时也能够以更为愉悦的感受完成学习任务。至于内容没有特定的要求，可以是你正在学习的东西，也可以是你认为很酷的东西，更可以是你正在工作的东西。这样做可能会让你学到很多关于库，服务，编程语言和模式方面的知识。但是，最重要的是，你能了解到其他人是如何看待编程的。
7. 写技术文章
如果大家学习了一种新的编程概念，但不能确定自己是否已经真正掌握，可以写技术博文加以检验。或者是在
技术博客
网站上搜索，找找是否有人提出了类似的问题，然后给出您自己的答案。如果答案不对，那么讨论的过程能够有效加深理解。这样的过程，能给我们带来宝贵的经验，同时也能帮助他人。
值得提醒的一点，别因为自己刚刚涉及编程而有所顾虑。罗马不是一天建成的，出色的程序员也是一样。只要您对问题有所了解，就不妨给出自己的答案――无论对错，这都将成为一次宝贵的经历。
8. 保持耐心
对于人生来说，其中任何目标的实现都离不开耐心。编程学习就如其它任何学习任务一样，都需要反复努力并投入大量时间。
在这个过程中，您一定会经历高潮与低谷――别被这些曲线影响了心情。接受已经发生的一切，并尽可能避免其中不好的部分。就像打高尔夫球一样，我们的手感总在不断浮动，但只要坚持到底，您最终总能成为一个大神呢~
推荐一些程序员学习网站：
0. GitHub ― 开发者最最最重要的网站：
https://github.com
这个不用多说了吧，代码托管网站，上面有很多资源，想要什么轮子，上去搜就好了。并且呢，上面有很多优秀的程序员，你可以在这里交到很多好朋友喔。
1. Stack Overflow ― 解决 bug 的社区：
https://
stackoverflow.com/
开发过程中遇到什么 bug，上去搜一下，只要搜索的方式对，百分之 99 的问题都能搜到答案。在这里能够与很多有经验的开发者交流，如果你是有经验的开发者，还可以来这儿帮助别人解决问题，提升个人影响力。
2. 
程序员客栈
：
https://www.
proginn.com/
程序员客栈是领先的程序员自由工作平台，如果你是有经验有资质的开发者，都可以来上面注册成为开发者，业余的时候做点项目，赚点零花钱。当然，如果你想成为一名自由工作者，程序员客栈也是可以满足的。只要你有技术，不怕赚不到钱。很多程序员日常在这里逛一下，接一点项目做。很多公司也在这发布项目需求。
3. 掘金 ― 帮助开发者成长的技术社区：
https://juejin.im
现在国内优质的开发者交流学习社区，可以去看大佬们写的文章，也可以自己分享学习心的，与更多开发者交流。认识更多的小伙伴儿，提升个人影响力。
4. v2ex：
https://www.
v2ex.com/
V2EX 是一个关于分享和探索的地方，上面有很多各大公司的员工，程序员。你想要的应有尽有。
5. 
博客园
：
https://www.
cnblogs.com/
博客园创立于2004年1月，是一个面向开发者的知识分享社区。自创建以来，博客园一直致力并专注于为开发者打造一个纯净的技术交流社区，推动并帮助开发者通过互联网分享知识，从而让更多开发者从中受益。博客园的使命是帮助开发者用代码改变世界。很多早期的高质量内容都在博客园。
6. Medium：
https://
medium.com/
国外优质文章网站，Medium 的整体结构非常简单，容易让用户沉下心来专注于阅读。上面有很多高质量的技术文章，有很多厉害的人在上面发布内容。
7. Hacker News：
https://
news.ycombinator.com/ne
ws
国外优质文章网站，上面有很多高质量的技术文章，有很多厉害的人在上面分享内容。
8. GeeksforGeeks：
https://www.
geeksforgeeks.org/
GeeksforGeeks is a computer science portal for geeks。（感谢@三三白白的补充）
除了这些论坛，程序员还有一些必备网站：
0. Google：
https://google.com
这个不用多说了吧，查资料，有问题，Google 一下。当然，能访问的人自然会用，访问不了的人，可以用
必应
或者百度吧。
1. 算法学习 LintCode：
https://www.
lintcode.com/
算法学习网站，上去每天刷两道算法题，走遍天下都不怕。
2. 算法学习 LeetCode：
https://
leetcode.com/
也是算法题网站，同上。
3. 算法学习 LeetCode 中文站：
https://
leetcode-cn.com/
这个是上面算法题网站的中文站点，英文不好的可以刷这个，英文好的推荐去刷英文网站的题目，还能提升英语能力。
4. 
牛客网
 ― 面经和刷面试题：
https://www.nowcoder.com
各个公司的面试题和面经分享，找工作前认真刷一刷，一定会有很大收获！拿到心仪的 offer！
5. Web 开发练习题：
https://www.
freecodecamp.org/
这是国外发起的一个 Web 开发学习的网站，从简单到深入，一步一步带你学习 Web 开发。就像一本练习册，并且当你完成相应的内容后，会得到相应的资格认证。
6. 
百度前端技术学院
 ― 前端开发项目库：
http://ife.baidu.com
学前端的看这里，百度官方推出的前端开发学习技术学院，题目从简单到困难，如果你把里面的题都做会了，找个 BAT 的前端工作不成问题的。
其他学习网站：
0. 各种编程语言，编程工具，各种轮子的官方网站
要记得，学习一门语言或者一个工具，最优质的学习网站就是他的官方网站，官方文档。
1. 菜鸟教程：
http://www.
runoob.com/
菜鸟教程的 Slogan 为：学的不仅是技术，更是梦想！ 记住：再牛逼的梦想也抵不住傻逼似的坚持！网站包括了HTML、CSS、Javascript、PHP、C、Python等各种基础编程教程。
2. 中国大学MOOC网：
https://www.
icourse163.org/
中国大学MOOC是由
网易
与高教社携手推出的在线教育平台，承接教育部
国家精品开放课程
任务，向大众提供中国知名高校的MOOC课程。在这里，每一个有意愿提升自己的人都可以免费获得更优质的高等教育。
欢迎将本回答分享给你的朋友，他/她可能正需要。
我的其他相关回答：
怎么学好数据结构？
零基础如何系统地学习前端
初级程序员，该如何提高？
如何才能做一名自由职业者？
程序员上班有什么提高效率技巧？
如何学习编程？顺便介绍些好的网站","完全可行！！
我在17年花了大半年时间自学前端，然后进入了准一线互联网厂子，所以
自学是完全可行的！！
这篇文章我主要分4个部分来说下我的看法
编程是什么？
如何知道自己有没有兴趣学编程？
编程怎么自学？
如果是为了兴趣和了解知识，怎么自学？
如果是为了找工作，怎么自学？
1.编程是什么
首先看题主的提问，我感觉到可能你对计算机和编程没有相关的理解，所以我先解释一下吧～
电脑的知识简单分两种，一种是软件相关（编程），一种是硬件相关
你可以这样理解，把计算机理解成一个机器人，可以不停歇的工作，你可以给他说一些
“指令”，
比如  ""给我做个饭，给我泡杯茶""，你说出
指令
的这个过程就是编程，学习指令怎么说的过程就是学习软件相关的知识，而硬件相关的知识就是了解机器人是怎么造的
那么学习这两种知识有什么用呢？
硬件的话主要是了解电脑的构造，说白了就是了解了这个你至少可以明白怎么买到一台好电脑，怎么组装一台好电脑（这方面我就先不多谈了～）
软件的话就是广义上的编程了，也是我主要回答的部分，了解这个的人不一定了解电脑的构造，
如果你让了解软件的人帮你选电脑他有可能一脸无奈……转而告诉你一句“
我不是卖电脑的…
”
软件相关的知识主要是用来解决问题
的，比如有一些重复的劳动，你做的很厌烦，那么你完全可以交给计算机来完成，然后用“指令”告诉它，你来帮我做这些事情，那么计算机这个“机器人”就会帮你解决这些问题
而这个所谓的
“指令”，
就是你听大家说的什么什么语言，
学习怎么说这个指令，就是学习编程
2.怎么知道自己有没有编程的兴趣呢？
分两个方面来说吧
你有没有深入思考的习惯？
一般来说，喜欢编程的人都是有深入思考的习惯的，那么什么叫深入思考的习惯呢？
举个例子就是，你做数学物理题的时候，有没有做着做着就变得特别专注了，以至于忘了时间，如果你有这个习惯的话，那么你很大概率是有编程的天赋的
那如果你是你是文科生，或者不爱看书所以也没咋体验过怎么办？那么看第二个方面吧
2.接触下编程的基础知识，看看会不会厌烦
这里的基础知识肯定不是说让你去学算法，
计算机原理
这些东西
我指的是
了解下：变量，常量，循环，条件判断，之类的基础概念
然后随便找一种语言
先看看它的普通for循环，在看看它的双重for循环，看看能不能静下心来理解，如果可以的话，初学的兴趣应该是没有问题的
如果1和2都不满足怎么办呢？那可能编程的兴趣是不是很大…这时候要是还想着入门就必须有人带了，自学就不太建议了
3.怎么自学编程呢？
1.如果是为了兴趣和了解知识，怎么自学？
提前说一句吧，
让你用c入门的，都是在搞事情
，这玩意太劝退了，会打消你编程的兴趣
毕竟自学靠的是
兴趣驱动
呀，
没兴趣了还自己一个人瞎搞终究是从入门到放弃
那么，怎么在有兴趣的同时自学编程呢？
解决问题
上面也过说了，编程的本质是解决问题，脱离这个本质为了编程而编程，本身就没什么意思
而且
通过解决问题你可以获得巨大的成就感
，
成就感就是你兴趣的动力
就像很多人为什么喜欢打游戏呢，因为干掉对手会有成就感，赢了一局也会有成就感，这种短时间内获得的成就感是很有促进作用的，
如果你没赢过，你看你还喜不喜欢玩游戏……
那么我推荐什么语言呢？
我推荐python
，因为python这种胶水一样的语言，天生就适合解决问题，语法简单而且什么都能干
学习python的时候要记住我说的话
了解基础知识就够了，不停的找一些小问题去解决
很多人学语言的误区就是，一天看一点语法，一天看一点语法，感觉自己很努力了，但是到最后问学到了啥的时候，发现还是什么都不会，关键是
没有实践，没有解决问题
所以
你应该过一遍基础知识，然后找小项目，小问题去解决
但是这个时候你会发现你基础没学好，写不出来，怎么办呢？去查就好了，
在查和解决问题的过程中学是最快的
学python的资料我就不写了，这方面大家已经整理的很详细了，贴一些高赞链接吧
2.如果是为了找工作，怎么自学？
找工作的话我就不建议学python了
为什么呢？python适合解决小问题，但是不适合找工作，
因为它相关的职位相比其他岗位实在是太少了
但是不要担心学了python白学了，因为语言都是相通的，转学其他语言也很快
如果你一开始就是为了找工作而学编程，我建议你自学什么呢？
前端，后端
先说下这两个概念是什么吧，你可以这么简单理解，如果做一个网站，你看的的页面，动画等等都是前端，你看不到的部分就是后端，一般是一些数据的储存和处理，是和数据打交道的
前端代表语言：JavaScript
后端代表语言：php，go，java（入门最最好还是别用java）
后端的话我就不多说了，只是告诉你go在目前这个年代可是大红人，找工作比较好找
我着重说下前端吧，为什么呢？
因为前端是做页面的，所见即所得，做起来容易产生兴趣，而且入门的初期，及其简单，随便学学就能作出一些感觉很酷炫的东西
还是上面讲的那些话，要
为了解决问题而编程，而不是为了编程而编程
前端自学入门的话我已经写过一篇很详细，而且很简单粗暴的回答了，但是框架相关的部分近期还会补充，贴上链接吧
====================
如果有什么问题就来问我吧，我会尽力帮你的，我又不收费=。=
最近在知乎上已经在帮一个朋友入门前端了，教的过程中感觉这些东西市面上并没有特别好的免费教程，都不太适合纯新人，自己也想整理一套免费的教程出来帮助大家～
码字不易，求赞求关注呀，如果你对前端感兴趣就来找我吧～我会作为朋友帮助你的呀～","许多人想入门编程的同学，在其准备开始上手学编程时，都会面临一个问题：
如何找到优质的计算机课程？
一般情况下，我们可以利用搜索引擎，来定位到我们所需要学习的资料。或到一些当下比较流行的视频网站上，搜一搜看看有没有值得学习的课程。
比方说此前我就在公众号（GitHubDaily）上面分享过一篇文章，向大家介绍了 B 站上一个比较优质的计算机课程：
我在 B 站学编程之《计算机科学速成课》
但是，最简单快捷的方法，还是莫过于直接看前人做过的资料汇总。之前看到有一位国外小哥整理了一份超级全面的计算机学习资源，下面跟大家分享一下。
这个小哥名叫 Deepak Kumar，印度人，同时也是一名全栈开发者。此外他还担任了微软的学生大使（Microsoft Student Partner，简称 MSP）。
这里很多人可能对 MSP 比较陌生，这里简单介绍下。
MSP 是由微软所创立的全球性学生组织，致力于挖掘校园中优秀的技术人才，以帮助他们更好的提升专业水平，推动技术的发展。成为 MSP 后，便能拥有来自微软的专业培训及资源。
每年微软都会固定透过各种校园活动招募更多志同道合、喜爱科技的伙伴，后面再透过这 - 些 - 活动将他们所学到的东西再回馈于学界，这种做法非常值得称赞。
上面跟大家聊到的印度小哥便是 MSP 其中一员。不知道小哥是否是受到了微软 MSP 圈子的影响，才用心整理了这份学习资料。但不管怎么说，还是感谢小哥如此费心整理了这么一份优质的学习资料，让开发者们大大减少了查找资料的时间成本，下面我们就来聊下这份资料吧。
从零到一学编程
这份资料叫 
A-to-Z-Resources-for-Students
，从名字可以看出，它的主要面向人群是学生，但其实里面的内容也可以适用于普通程序员。
https://
github.com/dipakkr/A-to
-Z-Resources-for-Students
这份资料作者将其托管到了 GitHub 上，一些非计算机专业的同学可能对 GitHub 不太了解，这里简单科普下：GitHub 是目前全球最大的程序员社区，每天有来自世界各地的程序员在上面开源自己写的项目代码、交流技术、分享编程相关的学习资源。
具体如何玩转 GitHub，这个话题比较大，就不细说了，感兴趣的同学可以去看下我们往期分享过的文章，或者关注下我们的公众号 GitHubDaily，每天都会在上面更新与 GitHub 相关的文章，分享比较实用的开发工具与
开源项目
，偶尔也会聊聊技术圈内最近发生的新鲜事。
介绍完 GitHub，我们再来看下这份资料都包含哪些内容：
编程学习资源
黑客马拉松
与其它活动
学生福利计划
开源项目
创业项目与孵化器
实习生资源
开发者线下聚会
技术大会
值得关注的技术人
值得关注的网站
附加链接
编码训练营
其它资源
我大致看了下，整理得还是蛮全面的。
如果你要学编程，可以看看上面整理的 Python、机器学习、前后端开发、
移动端开发
等课程内容：
如果你是学生，可以看下上面那些针对学生党所提供的福利：
如果你学完编程后，成功做出了一款解决某个特定需求的产品，也可以到上面寻求与创业公司合作，将产品进行商业化：
平日无聊的时候，也可以逛逛作者推荐的这些网站：
整个项目完全是一条龙服务，从编程到创业，相信你都能从这个项目里面学到不少东西。
总而言之，这是一份覆盖面非常之广的编程学习资料，深挖下去，你会发现里面藏着不少宝贝，由于篇幅较大，这里就不一一列举了。","本人就是通过自学成功的找到了一份
计算机视觉
的岗位，但是实际上是否可行还是因人而异
一、分析原因
但是我个人觉得这个因人而异，有些人报班或者是花了很多钱不努力去学，也学不好，但是如果你愿意去学的话，其实参加不参加培训班都是没关系的。
本人就是通过自学成功的找到了一份计算机视觉的岗位
，培训机构的课程很多，而且课程的质量也不好评价，总是拿着很
高新待遇、诱人的课程目录以及偶尔几个求职成功者的聊天记录
来吸引我们，千万不能一时上头就被诱惑进去了，而且现在很多企业对教育机构出来的学生有一定的抵触，因为教育机构不能保证你学到东西的同时，还会教你如何做
假的简历
，而一旦有这种情况出现直接导致了企业对培训机构出身的求职者有一定的怀疑。
培训机构的承诺就像放屁，当时惊天动地，过后苍白无力，或许就是这个样子吧
如果你决定自学，我希望你可以参考我的思路来准备，或许能对你有所帮助
二、学习资料收集
这里我分享一下自己准备计算机视觉岗位时候所用到的一些相关资料
数字图像相关
方面内容的准备，
冈萨雷斯
的《数字图像处理》和opencv，以及一份经典的计算机视觉的书籍清单――包括西瓜书，花书等等（可下载）：
代码能力
的提升，我在B站看的
黑马程序员
的python视频，内容非常多，包括linux的一些基本操作和python的编程，不过老师讲的非常好，学完之后我感觉收获满满：
https://www.
bilibili.com/video/av24
724071?from=search&seid=15217644103362054676
当然除了看视频以外，还是需要去学习数据结构和算法的内容，这里的话，我自己当时没有作为重点，目前也正在不断的补这块的内容，这里分享一份自己
刷题
的优质内容和指南：
这里才开始学习机器学习相关的内容，这里推荐经典的一些视频，真的质量非常高，我建议先从这里开始看，
吴恩达的《机器学习》
《斯坦福大学的CS231N》
这里是英文字幕版本的播放量最高，大家可以自行去b站搜索中文字母的版本
李宏毅
系列的《机器学习》《深度学习》
风格非常幽默，让人非常的舒服
这些视频就应该够你看了，如果不够，可以添加我微信，我有一份教育机构的视频教程，私信我发你。
深度学习实战，
前面的都是理论，如果你想要找到工作，理论肯定是远远不够的，所以你还需要实战方面能力的提升，这里推荐了黄海广博士分享的一个各种框架的样例，学完我觉得你可以算是入门了
当然对初学者来说，
tensorflow
太不友好了，当然现在已经发布了
tensorflow2.0
会相对简单易上手一些，不过我还是建议先可以试一下keras框架，非常容易实现你想要的目标，对于深度学习的概念理解益处良多，这里是我自己整理的一份keras学习资料，附带书籍
准备笔试和面试，
如果把找工作比喻做一场考试我觉得刷书是不够的，你还需要一份优质的题目来帮助你知道面试官会问到的问题，这里是我觉得非常不够的一份资料，内容包括python和深度学习等等
三、感悟和分享
最后分享一下自己的
双非考研985和跨行找计算机视觉岗的感悟
，希望能帮助你，在痛苦复习准备的日子里一定要给自己一个积极的心理暗示，相信未来的你一定会是非常优秀的。
最后的最后打个小小的广告吧，我自己在这大半年期间经营了一个公众号：
AI算法与图像处理
，用于分享和记录自己的学习成长和感悟，目前约有6000的关注，虽然对于大佬来说这只是一个小数字，但对于我来说这是一个非常的鼓励，在这里我认识了很多优秀的小伙伴，和他们交流技术和心得，让我受益匪浅，所以欢迎您也来到这个
成长中的社区
，共同追求进步。
年轻人一定要坚强，你转行自学的过程会有很多人嘲讽或质疑，请你保持良好的心态，真的，大多数时候都是精神上的溃败让你寸步难行。请你一定切记，关注不关注公众号啥的无所谓，毕竟本来也没啥人关注，但是希望真的能帮助到你，熬过最绝望的时刻，你才会感到自己有多么的优秀，对未来做任何事情也是非常有益！
我们共勉～～～>_<，当然还是期待有“赞”的","首先亮出观点：
当然可行！
因为我就是
从 0 开始自学，并成功转行到 IT
 ！所以，我最有发言权！
自我介绍一下。
我是良许，本科及硕士所学专业都是机械，毕业后从零开始自学转行 IT，1 年后被世界 500 强外企所录用，目前是 Linux 工程师。
我把我的自学经历写了下来，没想到这篇文章成了爆款，全网有大几万的阅读量。同时我的故事也影响了很多人，他们纷纷以我为榜样，给自己坚持下去的信心！
当然，限于篇幅，还有很多细节那篇没有讲明白。本文将进一步描写当年的状态及一些心路历程，看看能不能与读者引起一些共鸣，能不能有一些启迪。
1. 心路历程
前面已经提到，我本科及硕士所学专业均为机械。毕业后，阴差阳错进入到一家生成液晶屏幕的公司做电子工程师。也正是那时候，我开始接触到了编程，并产生了深厚的兴趣。
我所在的公司虽然对外号称是国企，但外界人都认为是私企，而我们内部人员又普遍视它为台企。在这样多重性质的背景下，它继承了这几种类型公司的所有缺点：官僚，小气，加班重！
所以，我在里面的状态是，拿着不高的工资，做着无尽的琐事，看着他们官僚争斗。
工资低，加班多，我心里积累了一肚子的怨气。而且我们这个岗位行业性太强，如果跳出来的话，只能继续跳到面板行业，其它行业很难。而
面板行业
国内并不多，我所在的公司在业界还算是比较好的了。
所以，我开始迷茫了，因为想跳槽，但很难跳到其它行业，就业面太窄了。如果重新回到机械行业，离开两年的我竞争力太弱了，而且我也不想回到机械行业。
于是，我每天都在思考着这个问题，前途真的是一片迷茫，看不到未来，也看不清现在。每天晚上我都会倚着阳台的栏杆，看着楼下行色匆匆的人们，在迷茫中彷徨……
在这样的情况下，我不得不转行，否则我在当前的环境下只会慢慢失去竞争力，可能不到35岁就已经被淘汰了。那段时间，焦虑、迷茫一直笼罩着我，我也在一直思索着转行方向。
由于我在公司里做了大量的编程工作，而且写了一个功能很强大的测试工具（至今电子部门及其它兄弟部门都在用），还有带领团队开发了一个自动参数调优工具（耗时减少，精度提高，获得公司级奖项）。于是，我在想，我要不要转行做 IT 呢？
2. 转行过程
还在第一家公司的时候，我后面又接触到了嵌入式，对其产生了深厚的兴趣，于是我决定转行到嵌入式方向。
明确了目标之后，我开始下载资料，准备材料，开始进入转行进程。那时候真的是非常疯狂，晚上加班到 8、9 点回来，回来也不休息，直接开始自学，一直学到凌晨 1 点再睡觉，几乎每天如此。
当我有了一定基础之后，在同学的推荐下，我进入到了第二家公司，成了一名真正的
嵌入式工程师
。当然入职只是第一步，为了节约路上通勤时间，我搬到公司附近住，走路 5 分钟就能到公司。每天我依然 12 点睡，6 点起，学习 2 个小时后再去公司。周末也不休息，依然去公司自学。所以，对于我的转行过程，我经常说的一句话是：
没有晚上，没有周末，没有节假日，没有一切娱乐，也没有应酬，只有学习！
每天上班，我都在写 bug （真的是 bug ，写了很多现在看起来很不可思议的 bug），下班就回来狂看书看视频，而且周末也不休息，几乎一整年都是。有时看书看累了，趴在桌上休息一会儿，醒来继续看。
入职半年多的时候，领导见我进步很快，就把一个刚毕业的小姑娘安排给我做徒弟。你能想象，一个 0 基础的机械工程师，通过7、8 个月的自学，居然能够做师傅带徒弟？！输出是最好的输入，靠着我给小徒弟讲解，我自己也巩固了不少知识点。
同时，我也非常感谢一个 QQ 裙，我有问题的时候，群友都很积极为我解答。在组织里，我从他们身上学到很多知识，同时也与很多人成了好朋友，至今保持联系！
就这样，在我没日没夜的学习下，我学会了 
C语言，
51单片机
，STM32，Git，FreeRTOS，Marvell芯片，RealTech芯片，软件设计
，等等内容，并且有了实战经验。这些内容，在正常情况下，学校需要上 2~3 年的课程，而我在一年多的时间里就自学完成了。此时的我已经是一名合格的
嵌入式软件工程师
，正式转行成功！
但是后来，决定跟老婆一起去广州，离开了第二家公司。那时我觉得单纯做单片机发展前景受限，一定要结合 Linux 才更有前途。于是在面试第三家公司的时候，我一定要选择做 Linux 的岗位。凭借我之前优秀的背景，我也顺利被广州的一家世界 500 强外企所录用。
单片机与 Linux 相比，就像手枪与大炮的差别。所以在第三家公司，我依然开启疯狂模式，继续没日没夜学习。现在我依然在这家公司，独立负责公司项目的几个模块，也是一名合格的嵌入式 Linux 应用开发工程师！
3. 如何自学编程
很多读者看到我的文章，辗转联系上我之后，只为跟我说一句谢谢！我觉得非常欣慰，至少我给转行的人做了一些贡献，哈哈！
现在回到主题，如何自学编程。
3.1 一定要有激情！！！
我觉得这个最重要，所以把它放在第一点。你一定要对你要转的那个方向有兴趣，否则怎么继续下去？而且你一定要有激情，否则你能像我做到每天 12 点睡 6 点起？能做到没日没夜学习？能做到没有晚上，没有周末，没有节假日，没有一切娱乐，没有应酬？
如果你没那个兴趣的话，我劝你尽早放弃吧。如果你有兴趣但没激情，那么你可能就要花更多时间去学习了。这里放一张我当时自学到深夜的照片，也激励一下大家。
你要有激情，你才能坚持，这是前提条件。你们应该能感受到，我是一个特别能坚持的人。关于我特别能坚持，以及非常自律这件事，我也分享了两篇文章，欢迎围观。
3.2 一定要找到组织
学习是一件很枯燥的事，如果没有一些志同道合的朋友，很容易就坚持不下来。但是现实中，有时候我们可能找不到有共同目标的人，那我们可以去网络上找啊，现在网络这么发达，找个人还不容易。
当时我加入了一个 QQ 裙，有疑问的时候就把问题丢到群里，很快群友就帮我解答。同时，有时候学习累了，就在裙里跟大家聊聊天，吹吹水，顿时心情愉快了不少。
圈子对于我们来讲实在是太重要了，特别是我转行时以及做公众号时，真的是深有体会！在圈子里，即使你不说话，就看群友聊天，你也能知道一些行业动态，以及大家所关心的话题。有时候裙友丢出的问题可能正是你所想知道的，互相讨论能激发出很多灵感。
正因为深知圈子的重要性，我建立了很多技术交流裙，欢迎在我的公众号「
良许Linux
」后台找到入口。
3.3 一定要有合适的资料
自学编程，资料的重要性不言而喻。但是，资料有的是文本，有的是视频，那要看文本还是视频？这个话题其实有一定的争议性，
但是我更倾向于看视频
。为什么呢？因为一个优秀的视频凝结了讲师大量的心血，他已经帮你将重点知识归纳总结了，你只需跟着他的进度走就行。
而书籍其实一般大而全，方方面面都讲到了。但是有很多知识点其实并不高频，工作中用到的概率不大。而对于新手而言，经验比较缺乏，不能有效筛选，容易钻牛角尖。时间宝贵，一定要花在刀刃上。
但是，
如果你想成为
大牛
的话，那最终一定一定要回归到书籍
。经典书籍承载了前人智慧的结晶，仔细品读一定能挖掘出更多你所不知道的技术。
3.4 一定要有输出！！！
输出也非常重要的，但很多人却忽略了输出这件事！等你去做输出的时候，你就会发现，学会是一件事，说出来是另一件事，而写出来又是一件事！
输出会让你把学到的知识重新整理一遍然后再表达出来，而在整理的过程中，你就会对知识有更深入的了解，或者对知识形成一个体系，可以使知识建立关联，更有逻辑性。
我之所以建立公众号，一是想把我的转行经历分享给更多人，激励大家坚持下来；另一个就是整理自己的学习笔记，分享给更多人，同时也
以输出倒逼输入
，让自己的技能不断提高。
Linux环境搭建 | 手把手教你安装Linux虚拟机
 
Linux环境搭建 | VMware下共享文件夹的实现
 
Linux常用工具 | 使用notepad++远程编辑虚拟机文档
 
Linux常用工具 | 全能终端神器――MobaXterm
 
Linux常用命令 | 10个非常有趣的Linux命令
 
Linux常用命令 | Linux下find与exec的联手干大事
 
Linux性能优化 | Linux性能检测常用的10个基本命令
Linux命令高级用法 | Linux下 ls 命令的高级用法8例
 
Linux命令高级用法 | 5分钟 more 命令从入门到精通
 
Linux命令行工具 | 程序员轻松绘图神器
 
Linux命令行工具 | Linux里隐藏的计算器，你知道它的奥秘吗？
 
Linux常用技巧 | 让你提高效率的Linux技巧
 
Linux常用技巧 | Linux下日志文件过大解决方案
同时我也在知乎开辟了专栏，将我的原创干货也收录到专栏里，欢迎关注！
最近的一篇暴款回答：
到什么程度才叫精通 Linux？
3089 赞同 ・ 217 评论
回答
4. 小结
花了 3 个多小时，把自己转行过程及转行方法分享给大家，希望对大家有帮助。非常感谢看到这边，还望帮我点个赞，让更多人看到，希望能够帮助到更多多人，先谢过了！","最近有不少朋友私信，值乎来问类似的问题，正好看到这个题目，所以我来说几句。
我想很多行外的朋友对计算机认知不是很深入，我给你们简单讲一下编程和电脑知识的关系。
第一，有很多生活当中，行外的人看起来的电脑高手，他们并不会编程，同样的，也有计算机系大四的学生不会重装windows。电脑溜不简单的等于编程。
第二，科班出身，学习好的计算机系，会懂更多电脑理论基础。计算机系有很多课程和编程无直接关系，比如
计算机组成原理
，操作系统原理，但是学好了，你会对计算机系统了解更多。
第三，编程本身是一种上下限都很高的活动，上到火箭，空间站控制，下到一段win批处理脚本，都算编程，所谓简单编程，在不同层次，“简单”都是不一样的。
根据以上这三条，再看问题本身，可以看到，其实一个问题，问了两件事情，一个是对计算机知识的熟悉，这点上，无需编程技术，同时，也没有很多培训班会教这个，学习的主要途径是混论坛和自己实际手操。一般非土豪，非发烧友建议你装个虚拟机玩。
回到自学简单编程这件事上，对于计算机行外的朋友来说，简单编程主要有两个方向，一是在同样的朋友当中炫技或者自己消遣，一是辅助日常工作学习。
炫技和消遣的话呢，没有人会教的，所以你只能去各种公众号，论坛，抄点技术来，一折不扣地按着做，比如什么屏幕截图再把图标隐藏。这种主要是学会快捷键，一般人对电脑的认知就是越用键盘越牛逼。编程语言本身可以有很多不同，比如我是JAVA系的，java可以做出几千万行的阿里巴巴，也可以做出一个几十行的简单的小程序。比如前几天我在一边开无聊的会议，一边自己写了一个J2SE的程序，自动生成毫无意义但闪瞎眼的gif，纯粹是在开会也没别的事情可以做。核心代码就这么点，10分钟的事情
出来是个这种玩意，放在gmail里发出去能直接在预览里闪瞎眼。
辅助日常工作生活是我认为计算机对行外人士的最大帮助，这里面包含主要三块：
1，是office人士熟悉使用MS-excel宏命令。这是一种真正的所谓简单编程，宏使用的脚本语言在计算机编程当中属于任何语言系统的人都需要掌握的基础。而熟练使用excel宏命令能给相关人士带来极大的帮助。
2，是windows系统的批处理指令。这是日常生活当中很容易使用到的技术，比如批量改几千张照片的名字，当然有很多软件可以做到，但是毕竟技多不压身。这个以上，我还会建议普通人学习下视频压制和后期处理，就是你们看的各种字幕组的作品，这其实包含了非常简单的计算机编程，在日益趋向视频化的年代，学会视频处理，将会很有帮助。
3，是很多行外想转行内的人士的一个过程。很多人来问我，我合适转行吗？我的建议很简单，你先在不放弃目前工作的情况下尝试简单编程，乃至于编程游戏，看看你能顺利地完成吗？比如screeps，比如human resource machine，比如乐高机器人大赛，如果你能轻松完成，那么恭喜你，你有入行的潜力，可以考虑开始学习真正的编程。
综合来说，自学
简单编程
当然可行，但是你要考虑清楚自己的目标，不要一味听信网上很多一刀切的回答。","我初中毕业时，在没有电脑、没有互联网查资料的情况下，自学编程并做了大量小游戏自娱自乐。所以我可以非常肯定地说自学编程是可行的。
可能有人好奇，我没有电脑怎么编程，用手机吗？当然不是，我学编程的时候，手机长这样：
当时中考结果出来，考得不错。爸妈就给我买了这么个东西作为奖励：
这个叫“
文曲星
”，是一种打着学英语的幌子，实际上用来养
电子宠物
和玩白金英雄坛的掌上词典。
白金英雄坛
这玩意儿有一个逆天的功能，你应该猜到了。它可以用来编程，用的是一种叫BASIC的语言。那个时候编程的概念不像现在这么，火满大街的人都知道程序员秃头。那时我根本没听说过编程，也不知道是干嘛的，但冥冥中就觉得这个有搞头（天生程序员的料）。
研究了内置手册里几个简单的示例后，也不是特别明白。于是我就去了专卖店，让店员帮我下载了几个别人做的小游戏。什么样的小游戏呢？就这种：
纯文字游戏。
玩了一会儿，了解了游戏流程后，我就开始看这些游戏的代码了。文曲星屏幕很小，总共显示不了10行代码吧，所以我就把代码抄在纸上，大概1000多行的样子。
就这样，一边研究代码，一边在手册里面查这些关键字是什么意思。刚开始也不是很理解，那些循环、条件是怎么运行的，会有什么样的结果？那怎么办呢？我就直接改代码，看看代码修改后程序在执行的时候会有什么区别。
有时候改错了，会有一个错误提示，也不是太理解，又没有网络可以查，那就强行改，把我能想到的所有情况都尝试一遍，看看是不是碰巧能搞正确。
我就这样的条件，靠蛮力学会了编程。做了各种各样的游戏。比较有印象的，打砖块、赛马（其实是一整套赌博小游戏：P）、黑白棋、类似疯狂坦克的射击游戏、
RPG，等等吧。
现在信息技术这么发达，你想学什么，网上全都有教程，文字的视频的都有，比我条件好多了。自学编程一点问题都没有。
我觉得自己在自学编程的过程中，做对了这么几件事，是非常值得借鉴的：
1. 一开始没有拿一本语法教材去啃，而是直接研究别人的代码。
学习编程很重要的一点是尽快开始实践，实践大于学习。编程语言的知识点超多，但初期你能用上的只有不到20%，所以不要把厚厚的教材啃完了才动手写代码，尽早开始实践。
2. 碰巧我研究的代码非常简单，又完整地包含了编程的核心语法。
选择合适的研究案例，可以从一些小游戏，小工具开始，比如贪吃蛇、计算器。这些网上都能找到各种各样的代码，你可以先自己写，然后再看看别人怎么写的。我的专栏里有一些小游戏教程，需要的同学可以看看：
老徐编程：你们要的贪吃蛇C++手把手教学来啦
3. 碰巧我初中毕业闲着没事，没电脑玩、又没手机玩，只能学编程玩，让我可以长时间专注这件事。
编程需要花很长的时间钻研和练习，遇到一个问题研究几个小时是很正常的。有的同学遇到问题第一反应是“我不会做”，然后就放弃了，或者去找答案，这样就放弃了一次思考提升的机会。
就像做数学题，如果想都不想直接看答案，你获得的就只是一个答案而已，思维能力和解决问题的能力都没有任何提升。
如果你从零开始学编程，可以从C语言或者python入手，这两个入门相对来说比较简单，长期来看也有足够的深度。
C语言入门可以看《啊哈c语言》，号称是可以坐在马桶上学的编程书，看这本书要注意痔疮。
Python则推荐《
》，这是一本在线电子书，同样适合新手入门学习。
文明看帖，点赞+关注一波走起~
-----------------------------------
回答完这个问题后我决定写个C++自学专栏：","必须完全可行！
因为我就是在八个月的时间内自学C++，并且通过互联网求职找工作，顺利进入字节跳动写代码的。
因为我的本科四年都浪费了，每天浑浑噩噩，并没有都在大学四年好好学习。
直到去年，也就是我研二的时候，我才忽然醒悟过来要好好学习，因为我不想毕业就失业，也不想再回到祖祖辈辈那种面朝黄土背朝天的生活或者像父母一样去做体力活。
以前我也割过稻子
至少能够坐在办公椅上，吹着空调写代码要比顶着太阳割稻子好太多了，因为我小时候真的面朝黄土背朝天似的割过稻子。
以前我回答过一个问题：
“你的编程能力是什么时候突飞猛进的？”
刚去看了下已经获得超过1600+知乎小伙伴的赞同和2500+的收藏了！
你的编程能力从什么时候开始突飞猛进？
我觉得
我的编程能力就是在这八个月的自学时间里突飞猛进的。
需要说明的是
，在这八个月的自学时间里，对于自学编程我只能在周一到周五的八点之后再去学，还有就是充分利用周六周日两天时间刷题看书写代码。
周一到周五的白天，我还要做实验、看论文以及做老师的横向，感觉那段时间自己的时间利用率高到爆表！
那些说学习累的的人，如果
体验过夏天拔花生拔到腿抽筋，后背被晒得红通通的就不会觉得累了；
体验过春天弯腰插秧，秋天弯腰割稻子到晚上直不起腰来就不会觉得累了；
体验过抗 120 斤重的电缆上 20 楼就不会觉得学习累了；
体验过装灯管一天都得抬着头，到了晚上睡觉都不能躺着睡，也不会觉得累了；
体验过因为电线走线走错了，需要砸墙重来，抡大锤轮一天到晚上吃饭的时候筷子都拿不起来的时候，可能也不会觉得累了；
真的，学习真的已经很轻松了
。
以下回答源自于个人在你
的编程能力什么时候开始突飞猛进
中的回答
作者：拓跋阿秀
链接：
你的编程能力从什么时候开始突飞猛进？
来源：知乎
你如果问我有什么学习计划的话，说实话我是没有的，我干脆就按照自己前年的学习时间线来回忆一下吧。
有几个已经毕业了的师兄师姐在得知我的情况后说我是""
逆天改命
""的典型，因为能去字节跳动这种一线互联网大厂就很难能可贵，还是个 
SP
，这更不得了。
但我觉得真的有点夸张了，我只是比别人多花了点时间而已。
很多人说我是逆袭？
其实不是，我只是多一点坚持而已。
以下回答摘抄自我在知乎专栏上的一篇文章
2019 年 8 月
说来可笑，我自己都不相信，因为在 
2019
 年 
8
 年之前我对C++的认识只停留在 “
Hello world
” 水平上，还有三大特性：封装、继承、多态，我当时就只记得多态，其余两个都不记得了。
因为校招主要语言就是C++和Java，主要是想要掌握一门企业级开发语言的初衷，研二刚开始的时候，这个时候我开始了
C++
 的学习之路。
有人问我为什么选择 
C++
 而不是 
Java
 ，除了因为自己喜好是一个方面，最主要的原因是
Java
比
C++
卷的多，学习
Java
的人实在是太多了，相比之下还是
C++
好上岸一点。
我自己的学习习惯就是先从视频入手，然后再去看书，所以我当时下定决心学C++后，我的第一反应就是去B站上看看有没有相关视频，看了看评论和播放量后，我最终确定了 黑马机构出版的教学视频。
搞笑的是，我记得当时自己看完后还留了个言，现在好多人在在我走过的路，看那个视频的时候给我留言。
无线套娃
我记得我当时开着 
1.5
 倍速看的，挺快的，很快就看完了，还跟着视频里敲了不少代码，我喜欢或者说是习惯了一边看视频一边跟着敲，因为这样学得更牢一些。
个人笔记
黑马的视频很快就看完了，又开始看经典的 
C++
 书籍，我选择了《
C++Primer 5th
》，除了看书之外，课后习题我也基本都做了一下，并且从网上找了正确的习题答案，进行查漏补缺。
我个人比较喜欢做笔记，如果看的是纸质书就在书上写写画画，如果是 PDF 就做标记之类的，我记得大概花了 
3
 个月左右的时间过了一遍这本 
C++
 圣经。
C++Primer上的笔记
月末的时候，我去 LeetCode 写下了自己的第一道题，也就是“两数之和”的题解，从此自己就走上了一边看书 看视频，一边刷题复盘的不归路。
2019 年 9 月
转眼就到了九月，这个时候也开学了，研究生老师也开始慢慢安排事情了。
由于白天需要帮老师做横向项目和看论文，所以我一般都在周一到周五的白天去干活写代码做项目，傍晚去跑步溜达溜达的，而在每天晚上八点之后看 C++ 书籍和刷力扣题，周六周日两天则是自己的全部学习和复盘时间。
在九月自己在看完《C++ Primer》的前八章后就开始疯狂得在力扣刷题了。因为刚上手的缘故，自己刷题速度也比较慢，对于一些不会的题往往需要两三个小时之久。
2019年力扣提交记录
在刷题过程中真的是感觉到人和人之间是有差距的，实在不明白有些人的脑子在呢么那么好使。
我现在还记得力扣第一题的评论区有一句名言“
有人相爱，有人夜里开车看海，有人 Leetcode 第一题都做不出来。
”
有时候对象邀我一起回宿舍，我也会说你先回吧。就觉得这道题没做出来回去了也睡不着，一定要把它做出来为止，为此搞到半夜一两点也是常有的事。
整个九月我都沉浸在 C++ 的世界里，也没去学别的科目。
2019 年 10 月
进入十月了，在七天假期里除了第一天跟对象出去吃了顿饭，剩下的时间都用来看书学习了。嗯，是的，七天假期我也没出去玩，也没打游戏，都用来看书学习啦。
在经过九月一整月的学习我对于 C++ 有大致的了解后，就没那么把心思和时间都花在 C++ 上了。
我开始着手学习操作系统和计算机网络了，比如哈工大的操作系统、清华大学的操作系统、南京大学
袁春风
老师的计算机基础课程都是在这期间刷完的。还有
韩立刚
老师的计算机网络视频，韩老师讲课确实有意思，整个课程欢声笑语不断。
除此之外我也看了一些比较经典的书籍，像《图解HTTP》、《
图解TCP/IP
》、《网络是怎样连接的》都是在这个月看完的。前期有了视频的铺垫，看起来很快的。
老师依旧还是那样，我们每周五还有组会要开，要汇报自己一周的进度，包括项目上的，学习上的。
说实话挺烦的，有时候自己一周明明啥也没干，也没啥进展还要在组会上吹牛逼，读研读了三年别的没咋学会，写 PPT 、美化包装自己工作的本事倒是精进不少....
2019 年 11 月
时间在指缝中不断流逝，自从开始有计划地学习后，感觉时间过的更快了，有时候一周在不知不觉中就过完了。与之相对的就是视频越看越快、PDF 越滑越快、桌子上的书也越堆越多，吃饭速度也越来越快，每晚回宿舍的时间也基本都在十二点之后了。
那段时间，我是我们宿舍回去最晚的一个，还好自己的室友们都给我留着门哈哈。
走在回宿舍的路上，我都会想哪一个知识点还没搞懂，明天要再重点看一遍；还有视频中讲到的某一个题，为什么自己没有解题思路；还有哪些书自己还没有看到，规划一下自己的未来一段时间的进度.....
十一月的时候我慢慢的开始去看操作系统的书籍资料了，像《现代操作系统》、《
深入理解计算机系统
》都是这段时间看的。我本科时间干的为数不多的正确的事就是硬着头皮把 《深入理解计算机系统》啃完了，真的是为数不多的有价值的事了，二刷的时候就很舒服~
2019 年 12 月
转眼就进入十二月了，《C++ Primer》也快啃完了。看书过程中，除了记录自己的所思所想，在看这本书的过程中有些课后题我也没放过，很多人说没必要做课后习题，对此我持否定意见，每章课后习题数量不等，前三道我基本都是必做的。
这样一本经典的书籍，它的课后题都是经过精挑细选的，你看完一章学没学会检验一下就知道了，
不是你觉得你自己学会了你就学会了的。
喜欢写写画画
到圣诞节前后，《现代操作系统》和《深入理解计算机系统》也看了一大半了。力扣刷题也一直没落下，在刷题过程中，自己也知道了 C++ 中还有 STL 这种神奇的东西，也知道了另外四本经典的 C++ 书籍《Effective C++》、《
More Effective C++
》、《
STL源码剖析》、《深度探索 C++ 对象模型》。
我一口气全部买回来了，兴冲冲的直接去看源码剖析，差点把当场我劝退。。。。
我又去搜索大家在看这本书的时候是怎么看的，有没有什么值得借鉴的方法。由此知道了侯捷大师，也知道了侯捷老师的几门经典课程。
侯捷老师几门经典课程：C++面向对象高级开发（上下两部曲）、STL标准库和泛型编程、 C++设计模式、 C++新标准C++11&14、 C++内存管理机制、 C++程序的生前死后
我都看过了，其中有些视频甚至二刷三刷，就比如STL源码解析的视频。
侯捷老师有句话讲的非常好：
源码之下，了无秘密
！
这些视频以前我就保存过来着，后来听说B站将这些视频全都下架了，现在想想还好我保存了，有需要的可以下载一波。
下载 | 侯捷C++系列视频
就跟我开始学习C++时会选择从黑马C++教学视频入手一样，在学习STL的时候，我也选择了从侯捷老师的 STL 讲解视频入手，依旧是 1.5 或者 2.0 倍速看的。
十二月的时候我除了看操作系统的书籍之外也另外看了“STL标准库”和“C++内管管理”这两个视频。
对了，如果你跟我一样是C++
技术栈
，那下面这个项目还是不错的。
感觉时间真的不够用啊，想看的书和视频也越来越多，可是自己一天只有 24 个小时，还要帮老板做项目和看论文。
2020 年 1 月
元旦那天，我和对象去吃了四川串串晚上去看了电影，然后继续看书、刷题。
在放寒假前我特意把两本 《Effective C++》 带回家了，现在想想还好自己带回去了，没白白浪费那个寒假。
因为
疫情
的存在，2020 年的寒假注定是不同寻常的一个寒假，很多学生跟我一样都到了四五月份才开学。
一月份回家的时候，把侯捷老师的 STL 源码剖析视频下载下来了，存在 Ipad 里，因为以前就看过一遍，在火车卧铺上迅速过了一遍，也没花多长花间。
回家的时候家里有人生病了，一直在医院接受治疗，外出打工的爹妈也还没回来我就去陪护了。就类似下图这种病房，但我们那是十八线小县城，没有这么干净整洁。
图片来源于网络
一个病房四个床位，每天来探病的人络绎不绝，在那种嘈杂的环境下不可能看得下去书，我又掏出自己的 Ipad 接着看视频，比如尚硅谷的 MySQL 视频、Linux视频都是那个时候看的。
一月下旬的时候，家里人出院了，我也能顺利回家不再继续陪护了。也终于能有一个相对安静一点的环境看书学习了，我捡起闲置了大半个月之久的 《Effective C++ 》和《More Effective C++》开始囫囵吞枣起来。
也许是《C++ Primer》 打的基础比较好，看着两本书的时候并没有花很多时间，很快就看完了。
在家的时候，每天早上八点起床，吃过早饭修整一下就开始看书了，一直到中午十一点左右，中间也没什么人来打扰我；
下午吃过饭就午休一会，醒了就径直去医院拿中药回来，然后就开始下午的学习了，下午我一般不怎么喜欢看书，我比较喜欢写代码，我会选择做一些课后题或者复盘一下以前做错的力扣题；
到了晚上则是看教学视频，十点多了就玩玩B站，看一些比较有意思的吃播，比如华农与竹鼠的爱恨情仇、硬核厨师阿远、还有大姨绵羊的视频。
睡前会跟自己的对象视频一会，然后就不知不觉的睡着了。。。
多说一句， B 站真的很多优秀视频，总是有人问我该看什么资料看什么视频，其实你自己去 B 站输入一些关键字，直接找播放量比较高的视频来看就可以的，播放量比较高的视频，质量一般都过得去。
2020 年 2 月
后来到了二月，这时候国内疫情已经进入了比较严重的时期了。武汉全城封锁也已经好多天了，每天起来第一件事就是看看疫情发展情况。
在学习的时候不断的有新名词冒出来，就好像在学习 C++ 的过程中，网络编程这个词也慢慢出现，我也是知道了 C++ 后台开发跟
网络编程
有关。
第一反应就是直接去知乎看有没有推荐的资料，在看过差不多二十多个高亮回答后，我发现有三本书出现频率最高：《
TCP/IP 网络编程
》、《Linux 高性能服务端编程》、《Linux 多线程服务端编程：使用 muduo C++ 网络库》。
我最先看的是游双老师的那本《Linux 高性能服务端编程》。讲真，确实有点云里雾里的，因为以前也没怎么接触过这个。后来转头去看了《
TCP/IP
 网络编程》，你别说，真的越看越有意思，就有时候可能不是自己脑子有问题，是因为没在恰当的时候看合适的书。
在看这本书的过程中，我知道了一个简易版的 
Web
 服务器是由服务器和客户端两方组成的，也知道了回声服务器是什么意思。
这是本很不错的书，我一边看一边记笔记
这本书上例子很多，我很快就看完了，然后就开始看《Linux 高性能服务端编程》和《Linux 多线程服务端编程：使用 muduo C++ 网络库》了。前者我好好看完了，收获很多，但后者我没怎么看完，随便翻了翻就没看了，我也不是很推荐这本书。
后来疫情逐渐严重起来，接到学校通知说要延迟开学，我有点不爽，可也有点高兴。不爽是因为在家呆久了，老妈整天唠叨我，干啥都有错，高兴是因为自己有更多的时间来学习看书了，一回学校就要开始做老师的项目课题了，就没有这么多空闲的时间了。
现在想想应该多在那个时候刷一些算法题的，因为现在的互联网招聘过程中很看重算法题，在自己去年顺利上岸后也总结了一些不错的算法题，有需要的可以看看。
2020 年 3 月
进入三月后，因为一直没能回学校也复习不了C++，我的笔记都在书上，看不了就很难受，只好转头去看操作系统和计算机网络的知识。同时力扣上的题也开始二刷了，当时我重点刷HOT 100 的那 100 道题，来来回回的刷，一道题最多的时候来回刷了七八遍。我并不是什么算法大佬，自己脑子也很榆，一遍记不住我就刷两遍，两遍做不出来我就去做三遍，总有能做出来的一天。
老是有人说什么算法太难，你先看看自己下够功夫了没？对于每道题，你是真的会做了没？是不是你自己做出来的？对于你不会做的题目，你有没有及时复盘和总结？
如果你的回答全部都是 
Yes
，那你不可能做不好算法题；
如果有 
No
，你可以看看自己缺的是哪一步。然后对照着补充不就完事了吗？
最多在刷题的过程中你可以选择性的看一些别人总结好的资料，比如这种前人准备好的一些刷题笔记之类的，支持三种语言就很不错。如果算法题有障碍可以多看看。
2020 年 4 月
在复习完操作系统和计算机网络后，我除了开始继续刷力扣
HOT 100
，也在慢慢刷《
剑指offer
》，这本书上的题目都比较经典，经常出现在一些笔试面试中，可谓是经久不衰。
再者，虽然我已经有一个实验室的项目可以写在简历上，但一个项目还是不太够看，思考再三，我决定走前人走过的路，我也选择做一个 
WebServer
 服务器。
emm，真香！
我是根据 TinyHTTP 和 游双老师的《Linux 高性能服务端编程》的课后大作业为基础，这两者结合后做的自己的 
HTTP
 服务器，后来我把它作为我简历上的第二个项目了。简历上的第一个项目是实验室的项目，跟了快两年了，终于能发挥点用处了。
可项目还没做完，学校已经给消息了让尽快回去，本来想在家把这个项目做完的，没办法匆匆买票，赶紧滚回去了。
2020 年 5 月
可能谁也想不到，一个寒假居然能放 150+ 天的。回去学校第二天，我就立马把《
C++ Primer
》捡起来看，因为第一遍看的时候比较用心看，所以第二遍过的时候即非常轻松加愉悦了，很快就看完了。
在此期间也是把自己的服务器项目完成并且开源到 
Github
 上了。
2020 年 6 月
因为我是在一个普通二本学校读的研，历届的师兄师姐没有去大厂的先例，师兄师姐们貌似对于秋招找工作也不上心
。
按理来说金九银十，他们一般在九月份就应该开始找工作的，但以前的师兄师姐都是在十一月份才开始写简历找工作，去的也都是一些愿意来我们学校进行校园招聘的企业，
所以找到的工作质量可想而知
。
我也私底下问过他们，得到的解释和答案就是学校比较差，然后 balabalabala 之类的。
emm，我信了，因为师兄师姐比我多上一年学，见识也多一些，但还是想努力一把，想着万一能有一点机会呢
。
万幸，自己努力了一把。还好，自己坚持了一下。
在六月份校招提前批的时候，我就兴冲冲的投了简历，结果全部石沉大海，后来才知道提前批是选拔优秀人才的，提前批能上岸的也都是一些好学校的学生，比如各种
本硕985、211本985硕
的。
投完简历没有后文，我也在找自己的原因，除了学校不行是一个因素之外，在思考有没有其他可以改进的地方。后来看了一些比较优秀人才的简历，我觉得问题有可能出在自己的简历上，因为自己的第一版简历写的着实垃圾。
所以后面又迭代完善了自己的简历，足足写了 26 个版本的简历，也正是自己精心打磨的简历使得自己在接下来的秋招正式批中能够收获到不少胜利果实。光是修改这 26 个版本的简历，就足足花了我十来天的时间。
2020 年 7 月
去年的秋招正式批是在 7 .15 号开始的，在经过提前批投递简历的全盘皆输后，我开始有些畏手畏脚不敢投递简历，因为每个校招学生可以投递一个公司的机会是有限的，比如京东，每个学生都只有一次投递的机会，每次可以投递两个岗位。所以投递简历的机会，不能随便浪费。
在别的小伙伴开始大势投递简历的时候，我总觉得自己还没复习好，一直在不断复盘以前学过的知识点。我自己的经历告诉我，永远不可能有复习完的那一天的。
因为你每次面试都有可能遇到你不会的题目，所以最好的方法就是在实战中成长，多去投递简历。当然投递顺利是有技巧的，前期去投递一些小公司，积攒积攒经验，后期再投递一些互联网大厂！
所以小伙伴们不要抱着把全部的知识点复习完事后，再去开始投递简历，等你复习完了，黄花菜凉完了，校招早就结束了。
整个七月我都是在复盘知识点 + 刷题中度过的，7.15 号正式批一开始我就立马开始投递简历了。
如果是往届的师兄师姐们，他们投递第一份简历很可能要到十月份去了。还好自己没听他们的话....
2020 年 8 月
不知道你们是否体验过笔试全部会做的感觉？就是我所投递的互联网公司发来的笔试，我居然都会做...这不是装逼或者凡尔赛，就是我当时的真实情况，来一道过一道，来两道过一双。
在牛客网看到他们发帖讨论今天 XX 的笔试题好难，求交流求解答之类的时候，我下意识地以为他们是不是在夸大难度，因为我觉得貌似没他们说的那么难；
傍晚在操场跑步，听到旁边的人在讨论今天的 XX 公司的笔试题怎么这么难，我停下来随口说道：今天这笔试第一题是力扣
No.200
，岛屿数量那题，很经典的;第二题是回文子串，在力扣上也有，你们也可以去查查，具体题号我记不清了，都是原题的。
然后我就在他们惊愕的眼神中扬长而去，接着跑我的步去了。。。。
在我过五关斩六将一般通过一场场笔试后，随之而来的就是一场场面试邀约，为了避免漏掉笔试或者面试，还专门用备忘录记录了一下。
最多的时候一天我面过五场面试，上午两场，下午两场，晚上一场。那天面试完后，感觉身体好像瞬间被抽空一般。
然后就是笔试、面试、复盘的交替进行、循环往复。那是真难熬啊，也真难受啊，在面试过程中遇到很多自己不怎么会的知识点，有时候也会被问到崩溃或者被面试 PUA ，可来不及伤心和怀疑自己，因为可能一会就要进行下一场面试了。
心态真的会崩，当我心态崩了的时候，我一般都是去操场上跑两圈，然后回宿舍洗个澡，再来到实验室看个电影或者看看吃播，然后第二天接着干！
还好，最后终于有所收获。
意料之外的果实
写在最后
如果你能看到这里，确实很了不起。我罗里吧嗦说了一大堆，每个人的成功都是不可复制的，
我也不敢说自己的经历或者学习过程一定就是正确的，但我确实是这样走过来的
。
我写下这篇回答的时候是2021年的五一期间了，距离那段时光已经快过去一年了，确实挺快的，还有一个多月自己就要毕业了，时间真的很快。
有时候我就在想，“
玩也一天，学也一天，为什么不试着学一下呢？万一你就成功了呢
”
现在你要再问我，我的编程能力是什么时候提高的？
那我觉得是在
B 站的教学类视频收藏多了、也看多了的时候；
周日别人跑出去玩，我却在实验室里看各种技术书的时候；
力扣上的刷题数量从 0 开始逐渐变为 400+，通过从 40% 逐渐提升到 70% 的时候；
《剑指offer》中的每道题过了一遍又一遍，以至于都可以出一个刷题笔记专栏的时候；
大冬天的早上别人还在被窝里睡大觉，我早早来到实验室复盘昨晚没做出来的算法题的时候；
导师有时候疯狂 push 项目、催进度，只管提需求不管如何实现，搞得我崩溃得受不了的时候；
纳闷钱包越来越薄、支付宝余额越变越少、实验室书桌上的技术书越来越多以至于放不下，一看当当网消费金额被吓一跳的时候；
在食堂吃饭排队打菜，忽然想起来刚才那道题/那个 bug 怎么解决，大叫一声“卧槽，我知道了”被女朋友嫌弃，被别人当作傻子的时候；
就是在这些时候，我的编程能力提高的，也是在@些时候学会编程的。","我不建议你从“基础”开始，尤其是什么：C语言，数据结构，离散数学……之类的，那是把你逼疯的节奏（感觉这是知乎
学院派
的风格）。如果你自觉是神人级别的，当我没说。
其实软件工程发展到今天，编程已经是一个很“职业化”的技能。业内自嘲“IT民工”，每天“搬砖”之类的，就是这种现象的反应。不扯远了，总之一句话，基本上都是些是个人都能学会的技术，没有什么神秘的。某些培训机构招一些高考失利的考生，培训两年就把他们往公司里送，他们也一样能胜任工作。所以自学也不是件难事。但前提是，你走对了路。
如果你从二进制、
编译原理
、数据结构……这些开始，我估计你陷在里面就出不来了――除非有名师指点或者天赋异禀，再或者有大机缘？
不要急着做这些“学究”式的学习研究，就像学开车一样，不需要你从发动机原理学起是一样的。程序/语言是让你用的，就像车是让你开的，明白了这一点，你就可以立马轻松100倍。
所以，先选一辆“好开“的车，迅速的跑起来，享受这种微风拂面的快感和刺激，才是最重要的。
由于你的问题过于简单，我不知道你成为程序员是想干什么，所以无法给你具体的建议。大致的：
如果你是想做网站，可以向从静态页面（Html、CSS、javascript）入手，做一个漂漂亮亮的页面出来，先；然后加上一些功能，比如可以发布一篇文章，自然就需要构建动态页面的语言，我推荐
http://
ASP.NET
，原因无它：好上手。当然，你还需要数据库，我推荐MSSQL，原因无它：好上手……这样一步步下来，你很快就能看到自己的成果，可以不断的产生自激励，你才能走得更远。
其他方面，我不是很了解。但大致思路查不多，你想学游戏，就尽快弄出一个坦克大战出来；你想学Android，就马上整一个小APP出来；你想做
嵌入式
，就尽快弄个小机器人出来，呵呵。总之，要尽快做出东西来，丑也好俊也好，都要有个东西放在那里。看着自己的作品一点点成型的快感是难以言喻的！
这就是我反对从数据结构，离散数学开始的原因，一是这些东西很难学，更重要的是，费了九牛二虎之力，学了你也就学了，你能用它干什么？学这些应该是你有了一定的基础，需要进一步提高钻研的时候，才应该考虑的东西。
+++++++++++++++++++++++++++++++
安利一个自己早年的经历：
从包工头到程序猿・一起帮
?
17bang.ren/Article/Category-3
++++++++++++++++++++
最后很煞风景的加个推广：
飞哥办了一个IT培训班，
http://
ASP.NET
全栈开发，线上全程直播，可以免费收看；线下拎包入住。如果你有兴趣了解一下，可以加QQ群：729600626（一起帮・源栈・有意向）","问：自学
简单
编程可行吗？
当然可行。
建议语言：python，因为语法简单，接近人类语言（不过是英语），不用多久就可以照着写几行代码实现一个完整的功能。
推荐书籍《
》，这本书是我见过最适合完全没有编程甚至电脑基础的人来学编程，里面坑比较少。不像另一本经常被人推荐的《
》里面有很多命令行甚至linux的预设知识，在windows上根本做不到（比如有一课用到zip命令），我都怀疑推荐它的人自己有没有真的从头到尾看过。
当然，你也可以看我写的教程，我的定位也是完全零基础。
https://
wechat.python666.cn/cls
/lesson/list/
如果觉得看书看教程太枯燥，也可以网上找个入门级的视频来看，应该能搜到很多。
我自作主张把问题再扩展一下，那么：自学
高级
编程可行吗？
前面说的，简单编程，你只要在网上找本好教程，加上搜索和提问，基本就可以搞定，达到写一写小脚本，自动处理文件，批量下载数据，写个简单小游戏等程度。
但，如果是要求比较高的，比如是以就业为目标的
编程能力
，自学还是否可行？
理论上还是可以，但你会面临几个坎：
遇到某些概念很难理解
代码出错了之后不知道问题在哪
不知道学习的方向在哪里，要学哪些东西，学到什么程度
这几个问题，尤其最后一个，虽然你也可以尝试通过互联网解决，但肯定会绕很多弯路。如果身边有能点拨指导一下的人，会好很多。
然后就是，要自学到能找工作，是需要较长时间的学习和练习（一年以上）。对于自学的人来说，非常考验持续力，一般人未必能坚持。
如果能有人指导，再能长时间的坚持，那自学出师也不是问题。那些培训机构，其实也就是给你提供了这样一个环境，有答疑的人（是否负责另说）、共同学习交流的人，本身的课程内容，网上免费的都足够多了，没多大差别。","答案是肯定的，而且自学是学习软件编程极其重要的一个途径。不过最好的方式是 自学的同时，有一个可以帮助解决问题的同事或者老师，这样可以避免卡在一个问题上太长时间。 
现在有很多途径可以自学，例如IT图书，或者在线视频教程，比如我们九章的基础算法班（
Python
、
Java
的都有）就是针对初初学者的在线互动课程，可以边学习边实践， 你也可以尝试一下。
对于编程入门小白来说，你需要一个计算机系统学习框架。
首先，你要设定编程的大方向：
编程涉及的方向范围很广泛，所以还是要选定一个大致的方向。比如前端，后端，移动，等等。 
然后，确定一门想学习的编程语言：
选择什么样的编程方向，直接决定你编程语言的选择，选择一门最主要的开足马力去学习。
3.制定学习计划开足马力去学习
（1）基础比较薄弱情况下，可以通过相关入门视频开始跟着学习
（2）刷完视频的基础部分后，就可以开始买一本基础的入门书籍开始从基础语法开始入手学
视频教程更多程度上是别人总结好的知识点，有了一些基础之后，还是要回归书本，系统地学习。在看书的过程中大脑会有一个不停息的思考过程，有些疑问点也就随即产生，这对培养自己的知识体系很有帮助
（3）跟随书本把书上一些基本的代码在电脑上根据自己的理解输入一遍
这是非常重要的一步，毕竟我们最终的目的是让自己能够动手写出代码 
（4）遇到很难的技术点，可以再找相关的视频讲解，找老师解答。
推荐一些适合编程网站学习的靠谱网站
首先，学习算法和数据结构是非常重要的一部分，可以多了解一下九章相关的算法课程。同时配合
LintCode
进行刷题使用。
九章算法
由FLAG工程师，前算法竞赛中国国家集训队员
令狐冲
担任主讲，破解面试算法，洞察硅谷大厂最新算法面试动向，教你有重点地刷题。课程涉及的算法面试套路国内外通用，是一门算法求职的必修课，适合有任意一门
编程语言基础
、算法基础薄弱、面试经验少的求职者。
然后
精英大学
的
在线编程
课程，都是入门的不错选择。
美国最著名的提供线上学位的编程课程:
MIT
Stanford
Yale
Harvard
Carnegie Mellon
免费在线编程课程，博客和课程平台
Coursera
edX
Codecademy
Codewars
FreeCodeCamp
JavaScript Is Sexy
GA Dash
Khan Academy
MIT OpenCourseware
The Odin Project
Udacity
SoloLearn
The Code Player
Bento.io
Udemy
Code.org
Scotch.io
W3Schools
Coderbyte
Microsoft Virtual Academy
免费编程书籍/网站
Github
Tutorialzine
MakeUseOf
WebPageFX
Open Library
Free Computer Books
Internet Archive
Libgen.io
XooBooks
学习实践过程中，注意以下这些操作：
在学习概念的时候去思考在它在现实应用中的意义。一旦你充分理解了这个概念，在构建一个真正的项目的时候使用它，它的意义就会浮现出来。你会马上明白它在实际应用程序中的相关性。
多去“造轮子”
。通过同一个轮子的不同的制造方法，你学到的可能已经不再只是相关的函数本身，同时还有可能涉及更多的背景知识、基础原理、算法知识等等。基本上所有编程语言涉及到的问题都可以通过这种方式来练习来实现多角度的观察和实践。
多去阅读
开源项目
的源代码。
比起看很多编程书籍，课程视频等，阅读其它编程人员的代码，你能更有效地学会如何编写高效，简练，可维护而且不重复的可扩展代码。
如果你只是想简单了解一下编程知识，在对变量类型、循环、条件判断等编程有了基本概念的了解后。就可以开始做一些项目实践，能解决基本的语法问题就差不多了。 
如果您还想进一步学习编写代码并且可以成为一名以此恰饭的程序员，那么最好每周能花超过20个小时来学习代码。这样在三个星期之后，你就可以开始着手构建项目，来磨练编程和UI / UX开发技能。实践期间你可能就要花费至少2-3个月来解决编码问题。你花在这上面的时间越多，解决这些问题就越溜，你就越有可能在面试编程工作的技术部分中成功。
总之，编程语言就像英语一样，终究只是一个学习工具。如果你想在码农的道路上走得远，一定要实践，实践，再实践
九章算法，硅谷一线工程师在线直播授课，已经帮助30000+人成功拿到心仪offer。
九章基础算法班（Java）
，零基础转专业找工作必备现，针对知乎用户推出限时免费，原价US$101.68（￥666）现在邀请一名好友共同报名，即可免费学习。添加微信jiuzhang6，回复“知乎Java”领取全额课程抵价券。
更多课程信息请访问：
九章算法","自学编程之前，首先明确学习目的，学习目的不同，其难以程度也就不同！
01、是否具有计算机基础
如果没有计算机基础，首先需要学习计算机基础知识，为学习编程打下基础。如计算机组成、计算机的工作原理、计算机操作系统的类型、计算机网络等基础知识。
02、选择入门计算机语言
目前计算机语言众多，首先结合学习目的，选择一门入门计算机语言。汇智妹建议，尽量选择一门主流语言，应用范围广，简单易学。选择之前，可先了解清楚每门语言的特点，应用领域。
03、学习计算机语言，辅助练习
1.准备参考教材，查看视频课，加入
技术论坛
；
首先需要学习计算机语言的语法，掌握语法逻辑。
2、寻找练习题，辅助练习；
3、在网上找他人的代码，模仿练习；
4、在网上找简单的项目，尝试自己敲代码实现。
附上一些自学编程的推荐网站：
1.菜鸟教程
网址：
http://www.
runoob.com/
菜鸟教程主要是教你基础语法的，对于入门来说很不错，内容讲的都不是很深很好懂。也会教你如何搭建开发环境之类的。
2.
慕课网
网址：
https://www.imooc.com
3.
腾讯课堂
网址：
https://
ke.qq.com/?
tuin=7876e67c
实践操作
这没什么好说的，学编程必须要亲自敲代码。多看别人的代码（最好是一个可以运行的完整的工程源码），自己学着写一个一样的，从搭建工程开始自己弄，不要在原工程的基础上改，那样你是记不住的。这里小编就推荐几个可以下载到源码的网站。
1、Github
网址：
Build software better, together
2.
开源中国社区
网址：
https://www.
oschina.net/
3.Code4App
理论和提升
如果你想从码农晋升为工程师的话，理论就比不可少。到了这个阶段就要多看一下进阶的书籍了，买之前要多看看评论是不是适合自己的，毕竟知识太多了一辈子也学不完的，还是先学一些对自己有用的。这方面小编就做具体的介绍了，只是推荐一些遇到问题时查找解决方法和理论知识的网站给大家认识一下。
1.Google
网址：
www.google.com
2.Stack Overflow
网址：
Stack Overflow - Where Developers Learn, Share, & Build Careers
3.CSDN
网址：
https://www.
csdn.net/
5.ImportNew
网址：
http://www.
importnew.com/
网站推荐借鉴了，现场喷口水 的博客《如何自学编程》，
原文：
https://
blog.csdn.net/wrathli/a
rticle/details/81813990
 
自学编程是一件比较辛苦的事，需要较强的自律性和自学能力，加油！","当然可行，你以为科班出身的真就都是老师教出来的？？？
到了大三，除了背会了些基本概念，学校什么都没教会。教点java、C++也都是基本语法。
选修的网页设计课，报的人趋之若鹜，守着时间点抢名额。到最后，也就是做一个简单的html页面，连jquery都没教会。
这样的科班出身，真的有优势？？？
真正学的好的，绝大部分同学都是靠的自学！！！
自学一定要跟着视频学！一定要跟着视频学！！！！
我当年很傻，自己买书看，琢磨的毛都快没了，连个环境都搭不起来
后来，我跟着视频学，真香
现在工作近十年，这里把我的经验告诉你
收藏是点赞的五倍啊，原创不易，辛苦大家动动小手双击屏幕赞一下吧，手动叩谢了
学好计算机只需要两步：
第一：选一门语言学习
其次：学好四大基础课
一、语言的选择
目前而言，linux C++服务端开发、Java后端开发、web前端开发，就业岗位都很多，都是不错的方向。
我把我学C++的路线和资料分享给大家。
初学，一定要跟着视频学，可以减轻很大的负担，也可以走很多的弯路。
视频强推侯捷老师的C++面向对象程序设计，我当前入门C++就是跟着侯老师学的，讲的非常仔细，现在候老师在B站上开源他的讲课视频，大家可以去看：
但候老师的课，一如即往的每节都非常长，短的也要三十分钟……着实很难坚持。
对于定不住的同学，可以看小甲鱼的《C++快速入门》，每个视频十分钟左右，共49集，看完以后，再看候老师的课会轻松很多。
配置书籍首推
《C++ Primer》
本书是久负盛名的C++经典教程，其内容是C++大师Stanley B. Lippman丰富的实践经验和C++标准委员会原负责人Josée Lajoie对C++标准深入理解的完美结合，已经帮助全球无数程序员学会了C++。
《Effective C++：改善程序与设计的55个具体做法》(中文版)
一共组织55个准则，每一条准则描述一个编写出更好的C++的方式。每一个条款的背后都有具体范例支撑，教你怎样才能写出优雅的C++代码。这里也是很多关于C++方面面试问题的出处。
这些内容看完，C++已经入门了，接下来就进阶的内容了。
C++进阶
有关STL标准库的使用是比较难的，同样推荐大家以视频入手。
再次感谢侯捷老师，他录制了46集的系列视频讲解了《C++ STL标准库和 C++ 泛型编程》
配置书籍推荐《
C++ 标准程序库
》
这本书给我感觉就是既适合初期入门，又适合当字典用，因为里面的内容比较多，好多第一次记不住。
所以也可以大致看一遍，以后用时再具体记，这样根据实际去学习我个人觉得效果会更好。
《STL源码剖析》
学习编程的人都知道，阅读、剖析名家代码乃是提高水平的捷径。源码之前，了无秘密。大师们的缜密思维、经验结晶、技术思路、独到风格，都原原本本体现在源码之中。在你仔细推敲之中，迷惑不解之时，恍然大悟之际，你的经验、思维、视野、知识乃至技术品位都会获得快速的成长。
这些内容学完以后，基本上具有了工作两年的水平，别说校招，就是社招找工作都是非常简单的。
为了方便大家，我把以上推荐的所有书籍、工程文件、开源工程地址，都已经整理好了，需要的同学可以去下载。
接下来是计算机四大基础课的学习。
数据结构与算法，
计算机操作系统，
计算机网络，
计算机组成原理。
这几门科目，是考研408科目，也是校招必考内容。无论是新入校园的萌新，还是工作多年的老鸟。都离不开这几门知识点。
有些同学上学时候不好好学，到进阶的时候，就出现问题了
出来混总是需要还的！
无论学习什么，最关键是要找一个风评还不错的课程，就从头到尾学一遍，千万别东学一点，西来一些的。这样的效果肯定不会太好。
这里给大家推荐一些我看过的，比较认可的课程，跟着学即可。
数据结构与算法
关于数据结构，我想说的是，它是这四大件中最简单、最基础的一个。离开了数据结构，几乎任何的程序都会失效，所以在讨论数据结构的时候，常常要把算法也连带着说一说。
要单纯地掌握常见的数据结构，就如同拆解一个个精妙的仪器件一样有趣和简单。正因为数据结构这个东西在程序中的作用，和仪器部件特别相像，不同的数据结构有着不同的特性，因此要想学好数据结构，图解是必备武器！
这里强推中国大学上，浙江大学的开设的《数据结构》课程，涵盖了常用的数据结构和算法。
辅以教材参考书，强推《
大话数据结构
》，光看封面你就知道这本书的风格了
没错，这就是大名鼎鼎的《
大话设计模式
》的作者出的，绝对顶。
算法课常常和数据结构课放在一起，在有些高校中，会存在“数据结构与算法”和“
算法设计与分析
”这样的两门课。
但很多同学搞不明白，数据结构与算法有什么区别，甚至有些同学以为数据结构中就包含了算法。
其实，是字面意思就能知道个大概，
数据结构主要讲解数据的组织形式，换句话说，我就是我们要怎样把这些数据存储起来，所以有列表、堆、栈、树、图，这是数据结构的重点。
而
算法，则注重的是思想，比如列表里的元素怎么排序、怎么在当前的存储结构中找到最大的数和最小的数？等等，说白了就是解决现实中问题的思想。所以才会有分治思想、贪心思想、动态规划这三大算法。
学习算法的套路很简单，多看、多写、多上机，既然是思想的集合，看得多了，自然无师自通。
至于刷题，很多同学都知道要刷LeetCode。
LeetCode题库：（2123题）
总共两千多道题，而且有些题，非常难，就算每天10题，也至少刷半年。这显然不适合绝大部分同学。
所以，我们要找到最核心、最重要的题集，即可
比如，如果时间紧张，可以先刷《程序员面试宝典》里的题目，总共109题。
刷完以后，有时间，可以再刷《剑指offfer》的题目，共75题。
因为这两本书，都是面向面试的高频题汇总，自然有很多题目是重合的。这也正能说明这两本书的重要性。 
当然，我也有一本谷歌师兄总结的高频面试算法习题集，包含了常见的数据结构和算法汇总，无论是排版还是内容，都是非常棒。  
具体地，我也专门写过一篇如何学习算法的文章，五天破千赞，有兴趣的同学可以去仔细研究。
计算机操作系统  
无论你学习什么语言，都避免不了和操作系统打交道。所有语言的最后执行，都是靠操作系统。
比如，你用C++可以使用new创建一个变量来存储数据，也可以通过malloc创建一块空间。
但你真的知道他们的区别吗？无论用什么操作符来操控程序，最终真正分配内存空间的其实还是操作系统，所以，想真正了解他们的区别，就必须深入操作系统内部原理。
这就是为什么，我们学习语言时比较简单，而真正深入起来，却很多地方不懂的原因。
操作系统是程序员进阶必会的基础知识。
刚开始学操作系统，不建议闷头看书。相信我，用不了几分钟，你就会打瞌睡。学不了一星期，你就想打退堂鼓。
这里推荐B站清华大学的操作系统课程。这是我见过最简单易懂的操作系统课程了。
在看视频的同时，如果你还想要教材，在看上部分时，可以搭配《操作系统导论》辅助入门，在看到具体的
操作系统理论
时，可以搭配业界经典《现代操作系统》深入学习。这样相比直接啃书会容易很多。
计算机网络：
计算机网络，提供的是管道服务，像自来水管一样单纯，发送方Bob向管道里注入一吨液体，接收方Alice就接收到整整一吨液体，不多一滴也不少一滴。当然这是完美的理想，而现实往往并不是这样的。
真实的情况是这样的：Bob与Alice之间自来水管，每隔几公里都有一个蓄水池（增压泵），这个蓄水池有若干个进水管，也有若干个出水管，如果进入管的整体流速 > 出水管的整体流速，那么这两者的流量差就会被临时缓存在蓄水池里。稍后如果进入管的整体流速 < 出水管的整体流速，那么蓄水池里的水就可以乘机流走。
但是如果进入管的整体流速 > 出水管的整体流速一直持续，多出来的水蓄水池容不下了，多出来的水就溢出了。这溢出的水是永远都无法到达目的地的，对吗？
这个蓄水池有一个专业的名字：路由器，由于蓄水池无法补偿溢出的水，自然就需要有一个流量补偿机制，来补偿流量丢失，那么谁来补偿呢？
肯定不能网络来补偿，网络一直以无状态（Stateless）为首要目标，如果让网络来补偿流量，自然就需要网络来记忆状态，这点是难以接受的！
最终流量补偿机制的重担就落在了流量发送方Bob的身上，实现这个流量补偿机制的代码赫赫有名，它的名字就是TCP！
TCP大佬实现流量补偿机制，其实很简单，就一句话：确认机制！
一旦流量到达接收方，需要接收方Alice明确确认到达，否则TCP大佬会周期性使用流量补偿（重传）机制。
所以TCP是一个需要记忆状态（State）的代码，它本质是Stateful的！
从上面的例子也可以看出，计算机网络相比操作系统好学非常多，因为计算机网络不抽象，在现实生活中，都能找得到例子。而且，如果我们想知道网络中的细节，完全可以通过抓包来分析。
课程推荐哈工大的计算机网络系列课程：
这里需要说明的是，计算机网络中的细节非常多，李老师讲的也很全面。但这些细节是无需关注的，比如Http协议的错误码分类，我们记不住，而且记住也没任何意义，知道有这个玩意即可，需要的时候，百度一下，它不香吗？
（如果考研用，当我没说，考研考……）
 
关于计算机网络，我们真正需要了解的是osi 7层协议和Tcp四层协议的产生原因和具体使用场景，就足够了。
关于图书，绝大部分高校都用的
谢希仁
的《计算机网络》，这本书讲的很好，很浅显易懂，它也是考研408的常用教材
计算机组成原理
组成原理应该是所有课程里最难的课了，它是一门衔接数电和汇编的一门课。整个课程的核心就是使用数字逻辑电路和触发器搭建一个可以运行汇编指令的机器.
单纯看书、看视频的学习，会极其枯燥，必须搭配实验性小游戏，才更容易理解并坚持下去。
如果你需要提前感受一下可以去玩一个叫人力资源机器的游戏.代码区就是ROM,中间箱子是寄存器,两边输入和输出的会和并到一起装到RAM,小人就是运算器.
这篇文章里有这个游戏的简介和玩法：
你可以从这个游戏做为一个开始。
再回来问题上来，我们先推荐学习资料，最后再推荐一些实验性游戏。
视频首推
卡内基梅隆大学
的《深入理解计算机系统》系列课程，英语不好？没关系，有中英文字幕，看完这套视频，不仅能学到知识，指不定六级顺带也给过了。
配套教材建议选用《深入理解计算机系统》，这个视频应该也是用的这个教材。
组成原理游戏推荐：
Oxygen Not Included
 里面的逻辑电路相关的内容可以提供具体案例,提高对逻辑门的感性认知.同时可以衍生出很多机制相关的思考,比如 具体的问题转化为数理逻辑,小人作业并发冲突,随机地图生成,权限管理,复杂功能分区规划等等.
Human Resource Machine
 这个可以最直观的展示指令和运算的关系,上文也说过了和组原大作业有千丝万缕的联系.另外通过关卡提供了较为平稳的曲线,可以提前规避因为理解力不足带来的挫败感. 这个游戏还有一个多线程版本:
7 Billion Humans
=
Opus Magnum
 前置知识要求低,极为艺术的逻辑呈现,完成之后真的会有炼金一般的快感.
Silicon Zeroes
 一次性解决触发器!!!
TIS-100
 汇编王中王
把这些内容学会，通过校招笔试，完全不是问题。
但校招不光有笔试，还有面试环节，面试考的就是项目实战能力了。
有关校招的内容非常多，这里我就不一一列举了。我把我这些年的所知所得，整理成了一本书，开源到github上了。相信会对大家很有帮助，大家可以去看.
目前还在持续更新，欢迎大家star。
地址：
https://
github.com/harvic/Fight
ingCoder
好了，这篇就到这了，希望大家毕业都能找到好工作。
我是 
@启舰
 ，原创不易，帮我点个赞吧。
本人所有文章皆为原创，著作权归@启舰 所有，未经授权，转载必究","当然可行
事实上，除了CS系可能会在大学“系统”地学习编程，其余的某种程度上都是自学的！
学什么语言？
自学编程，推荐号称胎教语言的Python。
Python语法简单，方便上手，并且兼容Windows，Mac，Linux多种操作系统，相关代码库完善，可以迅速实现相关功能。比如web框架Django，可以写个小网页，再比如Pygame，写个小游戏，简单易学，成就感高。目前大热的人工智能相关技术，Python也是首选语言，Github上有着极为丰富的项目库，方便一键调用！比如下面就是利用Python库matplotlib可视化的一张图和利用
Pygame库
做的一款小游戏。
可谓下可胎教，上可智能。
Python怎么学？
学习的道理大抵是相通的：逐步走出舒适区，学习曲线逐步上升。
输入必有输出，最好能有“老师”反馈。
此外编程作为一门实践性学习，需要启动最小学习成本（也就是基本语法和概念），然后迅速上手小项目，进行实践输出。
学以致用，快速看到学了编程能够做啥，这样才能越学越快。
Python资料推荐
首先推荐一本书，
《
父与子的编程之旅
，与小卡特一起学Python》
。
这本书或许是最适合初学者入门的书了，以一个父亲的角度教孩子学习Python。书的实践内容首先是每章后面的习题，让人惊喜的是，基础语法之后的章节，全部都是以小游戏展开的。书籍的示例程序全都在
www.helloworldbook2.com
可以找到。此外，《
笨办法学Python
》这本书入门者也可以选择，主要以练习题为主。
书籍之外，再来推荐一些开源的教程。比如
莫烦
的个人网站，有Python基础，还有数据处理和机器学习，强烈推荐。此外， 
https://
github.com/jackzhenguo/
python-small-examples
，这个github中有相当一部分的小例子，也能帮助理解Python，使用Python。
再进一步，Python最强大的就是各种库了，图像处理的OpenCV，数据处理的Numpy，Pandas，Web开发的Django，人工智能的pytorch、
tensorflow
等等。不管做什么应用，大抵都有相应的
Python库
可以去学习使用。直接搜索打开官方文档，照着文档学习就行。
更多海量的原创教程，大抵是通过谷歌、知乎、CSDN等查询学习了。
例如在网上搜索Pandas教程，可以检索到 
@运筹OR帷幄
 技术社区原创的Pandas
数据分析教程
https://
github.com/zhouyanasd/o
r-pandas
运筹学相关职业薪资大叔据可视化与分析
Python入门课程推荐
最后，再推荐一款利用Flash卡片学习编程的课程――
夜曲编程
。
它的课程特点和前面推荐的书籍很相似，都是先介绍基础的Python概念和语法，再通过小练习和实践去进行巩固的。
先看一下入门课：课程目录先是数据与运算，后面还有入门的条件判断，循环，函数，类与对象等，最后还有编程实践。
点击课程名可以看到一系列可交互的卡片式学习方案，用提问的方式进行：
点开编程基础的知识点可以看到知识脑图，有概念有代码，代码还有相应拆分和解释，小白可以了解代码是如何一步一步写出来的：
点开
百题斩
可以看到对应的练习题，可以直接在网页端进行输入输出：
此外还有概念卡，代码卡进行复习
夜曲整个课程十分适合小白入门，并且页面清新，交互式体验良好，卡片式学习让人印象深刻。此外，学习过程中也有老师及时反馈，完成正式课程结束后，按期完成学习还有大奖：
这种交互式的课程，或许比起视频和书籍，更加适合想要入坑Python的初学者。
感兴趣的初学者可以试试他们推出的免费课，20天可以学完Python基础概念，直接在App就能领取体验了！","可以以目标为导向来学，不要去系统性的学习。
比如你想做个什么东西，就去尝试开始做，一边做一边学。
比如说想做个网站，那么就配置服务器开始，随便找个
编程语言
，再随便找个流行的框架，按照教程慢慢来。过程中遇到不懂的可以暂时先忽略，一边做一边学习。","您好，您想自学编程的话，是可以的。不过编程的话，您是想要学web前端、java还是大数据呢？因不知您想要学什么，我简单跟您说一下自学编程您需要确认的几件事。
第一、自学编程是为了什么
您得弄明白，您自学编程是为了什么，是纯属的个人爱好，还是为了学好之后出来找份高薪工作。如果是个人爱好，那您学编程里面任何一个都可以。如果是为了找份好工作，您得先看根据您自己的实际情况适不适合学。
第二、能否坚持学习
编程这东西，也是时时刻刻跟随着社会走，如果没有坚持学习的心态，那不建议您学编程了。因为编程技术更新迭代比较快，如果您不学，那您终究会看不懂，那不是浪费时间吗？""时间""虽然不收费,但“时间”这东西也无价啊。
第三、搜集教程的能力
决定自学，就要有搜集教程的能力。无论是视频还是教材，都得是最近几年的，技术比较前瞻一点的。不然您自学也没什么用。
――――――――――――――――――――――――――――――――――――――――
以上信息确定好了。那您得根据您实际情况看一下，自己是否能自学，并确定一下自己要学的科目：比如web前端、java、大数据等。
自学编程需要注意以下几点：
1. 自己的自律性怎么样
好的自律性可以让您保持较好学习状态。
2. 持之以恒的耐心
持之以恒的耐心可以让你坚持学习完整个课程，没有这样的坚持力很可能会导致半途而废费时费力。
3. 自学能力如何
自学能力的强弱会直接导致你学习的成果的好坏。
4. 逻辑能力怎么样
因为大部分编程语言，都需要良好的逻辑能力，像大数据学习的话需要一些数学方面的逻辑知识，如果这方面能力比较强的话那么学起来也就比较容易。
您如果有自学能力编程那就更好了。。因不知您想学哪个科目，因此，几个科目的教程送给您。为您解决搜集素材的烦恼。（不懂的地方，可随时问我哦）
1.JAVA学科全套教程
链接：
https://
pan.baidu.com/s/1-F4kxA
aW2S2xx28yARNbhw
 
提取码：7cb9 
2.大数据学科全套教程
链接：
https://
pan.baidu.com/s/1LpG5wh
TKyNlJcbW6pbzGuQ
 
提取码：
3.前端学科全套教程
链接：
https://
pan.baidu.com/s/1R6mnPI
erT_-haFoW7t0jfA
 
提取码：6i9u 
4.C语言全套教程
链接：
https://
pan.baidu.com/s/1Mir5nT
yVs_-GkdxQmddryQ
 
提取码：3dcj
5.区块链全套教程
链接：
https://
pan.baidu.com/s/15eTDMq
Qi4YJlc95LJ-SXaA
 
提取码：du65
6.职场全套教程
链接：
https://
pan.baidu.com/s/18TQHqv
lqgG7yokkTYZ870g
 
提取码：or6u
7.面试技巧及就业攻略全套教程
链接：
https://
pan.baidu.com/s/1x0E0Nt
r6GXnlqS-k4NyIEQ
 
提取码：jir1
8.Python全套教程
链接：
https://
pan.baidu.com/s/1EzzjL4
_jyDpI6f9z7vV6Ag
 
提取码：e68o 
9.Android全套教程
链接：
https://
pan.baidu.com/s/1vm4sjO
Ig0s4yxb6THNcSRg
 
提取码：9d3h 
10.Go语言核心编程课程全套教程
链接：
https://
pan.baidu.com/s/122MmxH
IkvggRhgf5pv5Nbg
 
提取码：rblg 
11.公开课全套教程
链接：
https://
pan.baidu.com/s/1ApPFb0
hzjuupEyrCxp99Mg
 
提取码：4ib9 ","题主口中的“把电脑的一些知识都了解一下”，不是编程。
程序员是不会修电脑的，也不比普通人了解太多的电脑知识。
他们只是在编程语言、代码领域、软件开发，比别人了解的多一些。
会修电脑的程序员，肯定是自学的各种电脑知识。
题主想学习电脑知识，应该在知乎搜“
【学习电脑知识】
”。
如上图的搜索，我就找到了如下这篇回答，这篇回答较为详细的讲解了，如何系统自学简单的电脑知识。
题主的问题解决了，接下来说一下
【自学简单编程可行吗】
自学简单编程可行吗？
学编程，以【兴趣】为目标，或以【提升学校教的编程，这个档次的编程知识】为目标。
这样档次的简单编程，是可以自学的。
反之，
想以【零基础，或接近零基础】的水平，去学习【入行程序员岗位】目标的编程能力。
这样档次的复杂编程，是不建议自学的。
先说一下
【
简单编程
】
怎么自学。
1、学编程要选一个方向，编程有哪些方向呢？
你可以搜“【学编程有哪些方向】”
一般是前端、后端开发、测试等。
2、学编程有哪些语言？
一般是Java、Python、C++等。
3、怎么学【简单编程】？
只要通过网上的免费教程，就可以学习。同样你可以搜一下“【java基础教程/前端基础教程】”、“【XX学习路线图】”等。
动力节点11年专注培训“java开发”，
这里推荐一份动力节点的“【java开发】”基础学习资源：
这套零基础入门教程，
在B站上有400多万播放量
，可以见得是一份质量优秀的java教程。
这个是2020年之前版本的159集教程（400多万播放量的那套）
在2020年，动力节点
杜老师
，给大家带来了最新的零基础入门教程：
录制使用JDK13最新版，
核心基础篇：316集
核心内容： 代码+工具+视频+文档+资源（样样齐全）
教程内容为：
本套视频适合绝对零基础的小白学习，课程内容细度前无古人，每个知识点以“掰开了揉碎了”的方式讲解，本视频基于JDK最新版本13进行讲解，主要包括Java核心语法、Java程序运行内存分析、Java面向对象等内容。
虽然本视频是专门为小白量身打造，但是课程在每一个知识点上进行了很大的延伸，深度完全完胜三年工作经验的程序员。为您以后的发展奠定坚实的基础。
当然不光是有基础入门的视频教程，还有Java零基础SE进阶的视频教程。
教程内容为
本Java视频教程适合有一定编程语言基础的学员观看，在本Java视频教程中讲解了Java面向对象、异常、数组、常用类、集合、
IO流
、线程、反射机制。
该视频教程基于Java13进行讲解，Java13是目前Java最新版本。视频中讲师语言表达流利，思路清晰。如果您是有一门编程语言基础的，或者您现在是一名Java程序员且想巩固一下JavaSE的，请下载该Java视频教程观看吧！
当然两套视频教程都有相对应的资料以及源码。
再说一下【复杂编程】为什么不建议自学。
几年前的计算机专业科班生，在毕业前，很多学校就会组织学生，去培训机构参加培训，以此提高学生的就业率和就业档次。
想自学编程，到能工作的水平，要学的内容很多！！！
网上的教材，就算是把最好的都找出来，并自学学完。也要用上一年左右的时间（至少多半年），学完也是个半吊子（且能不能学完也是个问题），这个水平去找工作，也只能找一家要求不高的公司，低薪打杂。（费这么大劲去低薪打杂？）
而找个【好的培训机构】学完，能快速高效的学到比自学更好的技术/项目，学完后能掌握培训机构整理的系统全面技术、和研发的大厂真实项目，这样的能力就能去到大公司，就能独立完成项目工作！
而上面去要求不高的公司，很可能遇到奇葩公司。在奇葩小公司发展，和在正规大平台发展，几年后的差距是很大的！
前者可能止步不前，顶多涨1-2K薪水。
后者能接触到更优秀的人、和工作中最前沿的技术、项目，带来的成长和经验，可以顺利进阶下一个档次的岗位，薪资涨10K以上。
一般，越奇葩、越不正规的公司，给的薪资也少，很多正规大公司都不招半吊子，只高薪招能直接完成工作的“成手”。
在
【好的培训机构培训】
的薪资水平，口说无凭，
拿动力节点2020年三四月份的就业统计为例：
2020年3月面授同学整体就业情况，平均月薪11611元，最高月薪15K，最高年薪19.6K（14k*14薪）。
3月就业1名
硕士
学历学员
，
月薪
15000元。本科生
平均月薪
11507元，专科生
平均月薪
11679元，高中生
平均月薪
10050元。男生
平均月薪
11561元
，
女生
平均月薪
12167元。
本月学员入职名企有
网易严选
、京东、中国**银行、某国企等。
动力节点三月份的就业统计平均薪资11611元！
?
www.zhihu.com/pin/1231254410346172416
2020年4月面授同学整体就业情况，
平均月薪12104元，最高月薪17K，最高年薪20.4万。
4月就业1名
硕士
学历学员
，
月薪
12000元。本科生
平均月薪
12135元，专科生
平均月薪
12062元，
1名
高中生
就业
，
月薪
12000元。男生
平均月薪
12038元
，
女生
平均月薪
12109元。
本月学员入职名企有
中国邮政、邮政物流、南天集团、**银行、外资企业、某国企等。
4月随“薪”所欲，平均月薪12104元！！！…
?
www.zhihu.com/pin/1243908700198748160
可以见得，在
【好的培训机构培训】
出来，是能找到不错工作的。而自学基本是学不到这个水平的。
这篇回答对你有帮助，帮忙点个赞吧~感谢！
如果觉得有用，收藏的同时可以关注一下我 
@动力节点
，以后有什么问题可以直接私信请教我~（评论区的回复容易被漏掉）","一定要动手。
一定要动手
一定要动手
剩下的就是如何动手的问题了。最好就是解决一个实际的问题，或者想象中的一个实际问题。
从循序渐进与实用的角度考虑，建议你用php+js+mysql 写一个类似留言板的东西
只要这个一直专研下去，可以有很多搞头的。
此外，js是目前使用最多的语言，真会js，什么C++、java、python都差不多是一个意思。
当然，前提是自学一门编程语言而已。
真正的编程其实就是一个数学问题。而计算机表达数学符号，你学一下Latex编辑。
会这种编辑，再去学算法，学C 之类的会觉得容易好多。
会让你懒得去重复造轮子。"
,,,,,,,,,,,,,,,,,,,,,
有没有一段代码，让你为人类的智慧击节叫好？,不一定要是完整算法，就是那种看着看着就觉得嗨爆了，惊为天人的结构或语句。,"当然是这个啦！
用三段 140 字符以内的代码生成一张 1024×1024 的图片
原文 by Matrix67
Kyle McCormick
 在 StackExchange 上发起了一个叫做 
Tweetable Mathematical Art
 的比赛，参赛者需要用三条推这么长的代码来生成一张图片。具体地说，参赛者需要用 C++ 语言编写 RD 、 GR 、 BL 三个函数，每个函数都不能超过 140 个字符。每个函数都会接到 i 和 j 两个整型参数（0 ≤ i, j ≤ 1023），然后需要返回一个 0 到 255 之间的整数，表示位于 (i, j) 的像素点的颜色值。举个例子，如果 RD(0, 0) 和 GR(0, 0) 返回的都是 0 ，但 BL(0, 0) 返回的是 255 ，那么图像的最左上角那个像素就是蓝色。参赛者编写的代码会被插进下面这段程序当中（我做了一些细微的改动），最终会生成一个大小为 1024×1024 的图片。
// NOTE: compile with g++ filename.cpp -std=c++11



#include
 
<iostream>


#include
 
<cmath>


#include
 
<cstdlib>


#define DIM 1024

#define DM1 (DIM-1)

#define _sq(x) ((x)*(x)) 
// square

#define _cb(x) abs((x)*(x)*(x)) 
// absolute value of cube

#define _cr(x) (unsigned char)(pow((x),1.0/3.0)) 
// cube root



unsigned
 
char
 
GR
(
int
,
int
);


unsigned
 
char
 
BL
(
int
,
int
);



unsigned
 
char
 
RD
(
int
 
i
,
int
 
j
){


// YOUR CODE HERE

}


unsigned
 
char
 
GR
(
int
 
i
,
int
 
j
){


// YOUR CODE HERE

}


unsigned
 
char
 
BL
(
int
 
i
,
int
 
j
){


// YOUR CODE HERE

}



void
 
pixel_write
(
int
,
int
);


FILE
 
*
fp
;


int
 
main
(){


fp
 
=
 
fopen
(
""MathPic.ppm""
,
""wb""
);


fprintf
(
fp
,
 
""P6
\n
%d %d
\n
255
\n
""
,
 
DIM
,
 
DIM
);


for
(
int
 
j
=
0
;
j
<
DIM
;
j
++
)


for
(
int
 
i
=
0
;
i
<
DIM
;
i
++
)


pixel_write
(
i
,
j
);


fclose
(
fp
);


return
 
0
;


}


void
 
pixel_write
(
int
 
i
,
 
int
 
j
){


static
 
unsigned
 
char
 
color
[
3
];


color
[
0
]
 
=
 
RD
(
i
,
j
)
&
255
;


color
[
1
]
 
=
 
GR
(
i
,
j
)
&
255
;


color
[
2
]
 
=
 
BL
(
i
,
j
)
&
255
;


fwrite
(
color
,
 
1
,
 
3
,
 
fp
);


}


我选了一些自己比较喜欢的作品，放在下面和大家分享。
首先是一个来自 
Martin Büttner
 的作品：
它的代码如下：
unsigned
 
char
 
RD
(
int
 
i
,
int
 
j
){


return
 
(
char
)(
_sq
(
cos
(
atan2
(
j
-
512
,
i
-
512
)
/
2
))
*
255
);


}



unsigned
 
char
 
GR
(
int
 
i
,
int
 
j
){


return
 
(
char
)(
_sq
(
cos
(
atan2
(
j
-
512
,
i
-
512
)
/
2
-
2
*
acos
(
-
1
)
/
3
))
*
255
);


}



unsigned
 
char
 
BL
(
int
 
i
,
int
 
j
){


return
 
(
char
)(
_sq
(
cos
(
atan2
(
j
-
512
,
i
-
512
)
/
2
+
2
*
acos
(
-
1
)
/
3
))
*
255
);


}


同样是来自 Martin Büttner 的作品：
这是目前暂时排名第一的作品。它的代码如下：
unsigned
 
char
 
RD
(
int
 
i
,
int
 
j
){


#define r(n)(rand()%n)

static
 
char
 
c
[
1024
][
1024
];
return
!
c
[
i
][
j
]
?
c
[
i
][
j
]
=!
r
(
999
)
?
r
(
256
)
:
RD
((
i
+
r
(
2
))
%
1024
,(
j
+
r
(
2
))
%
1024
)
:
c
[
i
][
j
];


}



unsigned
 
char
 
GR
(
int
 
i
,
int
 
j
){


static
 
char
 
c
[
1024
][
1024
];
return
!
c
[
i
][
j
]
?
c
[
i
][
j
]
=!
r
(
999
)
?
r
(
256
)
:
GR
((
i
+
r
(
2
))
%
1024
,(
j
+
r
(
2
))
%
1024
)
:
c
[
i
][
j
];


}



unsigned
 
char
 
BL
(
int
 
i
,
int
 
j
){


static
 
char
 
c
[
1024
][
1024
];
return
!
c
[
i
][
j
]
?
c
[
i
][
j
]
=!
r
(
999
)
?
r
(
256
)
:
BL
((
i
+
r
(
2
))
%
1024
,(
j
+
r
(
2
))
%
1024
)
:
c
[
i
][
j
];


}


下面这张图片仍然出自 Martin Büttner 之手：
难以想象， Mandelbrot 分形图形居然可以只用这么一点代码画出：
unsigned
 
char
 
RD
(
int
 
i
,
int
 
j
){


float
 
x
=
0
,
y
=
0
;
int
 
k
;
for
(
k
=
0
;
k
++<
256
;){
float
 
a
=
x
*
x
-
y
*
y
+
(
i
-
768.0
)
/
512
;
y
=
2
*
x
*
y
+
(
j
-
512.0
)
/
512
;
x
=
a
;
if
(
x
*
x
+
y
*
y
>
4
)
break
;}
return
 
log
(
k
)
*
47
;


}



unsigned
 
char
 
GR
(
int
 
i
,
int
 
j
){


float
 
x
=
0
,
y
=
0
;
int
 
k
;
for
(
k
=
0
;
k
++<
256
;){
float
 
a
=
x
*
x
-
y
*
y
+
(
i
-
768.0
)
/
512
;
y
=
2
*
x
*
y
+
(
j
-
512.0
)
/
512
;
x
=
a
;
if
(
x
*
x
+
y
*
y
>
4
)
break
;}
return
 
log
(
k
)
*
47
;


}



unsigned
 
char
 
BL
(
int
 
i
,
int
 
j
){


float
 
x
=
0
,
y
=
0
;
int
 
k
;
for
(
k
=
0
;
k
++<
256
;){
float
 
a
=
x
*
x
-
y
*
y
+
(
i
-
768.0
)
/
512
;
y
=
2
*
x
*
y
+
(
j
-
512.0
)
/
512
;
x
=
a
;
if
(
x
*
x
+
y
*
y
>
4
)
break
;}
return
 
128
-
log
(
k
)
*
23
;


}


Manuel Kasten
 也制作了一个 Mandelbrot 集的图片，与刚才不同的是，该图描绘的是 Mandelbrot 集在某处局部放大后的结果：
它的代码如下：
unsigned
 
char
 
RD
(
int
 
i
,
int
 
j
){


double
 
a
=
0
,
b
=
0
,
c
,
d
,
n
=
0
;


while
((
c
=
a
*
a
)
+
(
d
=
b
*
b
)
<
4
&&
n
++<
880
)


{
b
=
2
*
a
*
b
+
j
*
8e-9
-
.645411
;
a
=
c
-
d
+
i
*
8e-9
+
.356888
;}


return
 
255
*
pow
((
n
-
80
)
/
800
,
3.
);


}



unsigned
 
char
 
GR
(
int
 
i
,
int
 
j
){


double
 
a
=
0
,
b
=
0
,
c
,
d
,
n
=
0
;


while
((
c
=
a
*
a
)
+
(
d
=
b
*
b
)
<
4
&&
n
++<
880
)


{
b
=
2
*
a
*
b
+
j
*
8e-9
-
.645411
;
a
=
c
-
d
+
i
*
8e-9
+
.356888
;}


return
 
255
*
pow
((
n
-
80
)
/
800
,
.7
);


}



unsigned
 
char
 
BL
(
int
 
i
,
int
 
j
){


double
 
a
=
0
,
b
=
0
,
c
,
d
,
n
=
0
;


while
((
c
=
a
*
a
)
+
(
d
=
b
*
b
)
<
4
&&
n
++<
880
)


{
b
=
2
*
a
*
b
+
j
*
8e-9
-
.645411
;
a
=
c
-
d
+
i
*
8e-9
+
.356888
;}


return
 
255
*
pow
((
n
-
80
)
/
800
,
.5
);


}


这是 Manuel Kasten 的另一作品：
生成这张图片的代码很有意思：函数依靠 static 变量来控制绘画的进程，完全没有用到 i 和 j 这两个参数！
unsigned
 
char
 
RD
(
int
 
i
,
int
 
j
){


static
 
double
 
k
;
k
+=
rand
()
/
1.
/
RAND_MAX
;
int
 
l
=
k
;
l
%=
512
;
return
 
l
>
255
?
511
-
l
:
l
;


}



unsigned
 
char
 
GR
(
int
 
i
,
int
 
j
){


static
 
double
 
k
;
k
+=
rand
()
/
1.
/
RAND_MAX
;
int
 
l
=
k
;
l
%=
512
;
return
 
l
>
255
?
511
-
l
:
l
;


}



unsigned
 
char
 
BL
(
int
 
i
,
int
 
j
){


static
 
double
 
k
;
k
+=
rand
()
/
1.
/
RAND_MAX
;
int
 
l
=
k
;
l
%=
512
;
return
 
l
>
255
?
511
-
l
:
l
;


}


这是来自 githubphagocyte 的作品：
它的代码如下：
unsigned
 
char
 
RD
(
int
 
i
,
int
 
j
){


float
 
s
=
3.
/
(
j
+
99
);


float
 
y
=
(
j
+
sin
((
i
*
i
+
_sq
(
j
-
700
)
*
5
)
/
100.
/
DIM
)
*
35
)
*
s
;


return
 
(
int
((
i
+
DIM
)
*
s
+
y
)
%
2
+
int
((
DIM
*
2
-
i
)
*
s
+
y
)
%
2
)
*
127
;


}



unsigned
 
char
 
GR
(
int
 
i
,
int
 
j
){


float
 
s
=
3.
/
(
j
+
99
);


float
 
y
=
(
j
+
sin
((
i
*
i
+
_sq
(
j
-
700
)
*
5
)
/
100.
/
DIM
)
*
35
)
*
s
;


return
 
(
int
(
5
*
((
i
+
DIM
)
*
s
+
y
))
%
2
+
int
(
5
*
((
DIM
*
2
-
i
)
*
s
+
y
))
%
2
)
*
127
;


}



unsigned
 
char
 
BL
(
int
 
i
,
int
 
j
){


float
 
s
=
3.
/
(
j
+
99
);


float
 
y
=
(
j
+
sin
((
i
*
i
+
_sq
(
j
-
700
)
*
5
)
/
100.
/
DIM
)
*
35
)
*
s
;


return
 
(
int
(
29
*
((
i
+
DIM
)
*
s
+
y
))
%
2
+
int
(
29
*
((
DIM
*
2
-
i
)
*
s
+
y
))
%
2
)
*
127
;


}


这是来自 githubphagocyte 的另一个作品：
这是一张使用 diffusion-limited aggregation 模型得到的图片，程序运行起来要耗费不少时间。代码很有意思：巧妙地利用宏定义，打破了函数与函数之间的界限，三段代码的字数限制便能合在一起使用了。
unsigned
 
char
 
RD
(
int
 
i
,
int
 
j
){


#define D DIM

#define M m[(x+D+(d==0)-(d==2))%D][(y+D+(d==1)-(d==3))%D]

#define R rand()%D

#define B m[x][y]

return
(
i
+
j
)
?
256
-
(
BL
(
i
,
j
))
/
2
:
0
;


}



unsigned
 
char
 
GR
(
int
 
i
,
int
 
j
){


#define A static int m[D][D],e,x,y,d,c[4],f,n;if(i+j<1){for(d=D*D;d;d--){m[d%D][d/D]=d%6?0:rand()%2000?1:255;}for(n=1

return
 
RD
(
i
,
j
);


}



unsigned
 
char
 
BL
(
int
 
i
,
int
 
j
){


A
;
n
;
n
++
){
x
=
R
;
y
=
R
;
if
(
B
==
1
){
f
=
1
;
for
(
d
=
0
;
d
<
4
;
d
++
){
c
[
d
]
=
M
;
f
=
f
<
c
[
d
]
?
c
[
d
]
:
f
;}
if
(
f
>
2
){
B
=
f
-
1
;}
else
{
++
e
%=
4
;
d
=
e
;
if
(
!
c
[
e
]){
B
=
0
;
M
=
1
;}}}}}
return
 
m
[
i
][
j
];


}


最后这张图来自 
Eric Tressler
：
这是由 logistic 映射得到的 Feigenbaum 分岔图。和刚才一样，对应的代码也巧妙地利用了宏定义来节省字符：
unsigned
 
char
 
RD
(
int
 
i
,
int
 
j
){


#define A float a=0,b,k,r,x

#define B int e,o

#define C(x) x>255?255:x

#define R return

#define D DIM

R
 
BL
(
i
,
j
)
*
(
D
-
i
)
/
D
;


}



unsigned
 
char
 
GR
(
int
 
i
,
int
 
j
){


#define E DM1

#define F static float

#define G for(

#define H r=a*1.6/D+2.4;x=1.0001*b/D

R
 
BL
(
i
,
j
)
*
(
D
-
j
/
2
)
/
D
;


}



unsigned
 
char
 
BL
(
int
 
i
,
int
 
j
){


F
 
c
[
D
][
D
];
if
(
i
+
j
<
1
){
A
;
B
;
G
;
a
<
D
;
a
+=
0.1
){
G
 
b
=
0
;
b
<
D
;
b
++
){
H
;
G
 
k
=
0
;
k
<
D
;
k
++
){
x
=
r
*
x
*
(
1
-
x
);
if
(
k
>
D
/
2
){
e
=
a
;
o
=
(
E
*
x
);
c
[
e
][
o
]
+=
0.01
;}}}}}
R
 
C
(
c
[
j
][
i
])
*
i
/
D
;


}

","分享几个第一次看到就被它的优美深深震撼到的代码：
1、
线性求逆元
：
for
 
(
int
 
i
 
=
 
2
;
 
i
 
<
 
MAXN
;
 
i
++
)

	
inv
[
i
]
 
=
 
mul
(
inv
[
mod
%
i
],
 
mod
 
-
 
mod
 
/
 
i
,
 
mod
);


仅仅两行代码，就实现了在$O(n)$的时间内求出1到n对模m的逆元有木有！？
2、求最大公因数：
int
 
gcd
(
int
 
x
,
 
int
 
y
){
return
 
y
 
?
 
gcd
(
y
,
 
x
%
y
)
 
:
 
x
;}


第一次接触到这样的代码时，我的内心是这样的：
wtf???黑人问号.jpg
3、树状数组
对于单点修改区间求和，
树状数组
可谓达到了时空复杂度的极限，甚至不多用额外一字节存储空间。来看看它的实现：
修改：
void
 
add
(
int
 
i
,
 
int
 
x
){

	
for
 
(;
i
 
<=
 
n
;
 
i
 
+=
 
i
 
&
 
-
i
)
tree
[
i
]
 
+=
 
x
;


}


查询：
int
 
sum
(
int
 
i
){

	
int
 
ret
 
=
 
0
;

	
for
(;
 
i
;
 
i
 
-=
 
i
 
&
 
-
i
)
ret
 
+=
tree
[
i
];

	
return
 
ret
;


}


表示记性不好的我看完一遍也记住了呢。
4、
zkw线段树
对于单点修改区间查询的线段树，zkw大神实力教你如何1分钟内码出代码：
修改：
void
 
set
(
int
 
x
,
 
int
 
value
){

	
val
[
x
 
+=
 
treeLen
]
 
=
 
value
;

	
while
 
(
x
 
>>=
 
1
)
pushUp
(
x
);


}


查询：
int
 
query
(
int
 
l
,
int
 
r
){

	
int
 
ret
 
=
 
0
;

	
for
 
(
l
 
+=
 
treeLen
 
-
 
1
,
 
r
 
+=
 
treeLen
 
+
1
;
 
l
 
^
 
r
 
^
 
1
;
 
l
 
>>=
 
1
,
 
r
 
>>=
 
1
){

		
if
 
(
~
l
 
&
 
1
)
ret
 
=
 
min
(
ret
,
 
val
[
l
^
1
]);

		
if
 
(
r
 
&
 
1
)
ret
 
=
 
min
(
ret
,
 
val
[
r
 
^
 
1
]);

	
}

	
return
 
ret
;


}


以上都是一些十分基础但真的让你赞不绝口的算法和数据结构。还有一些稍微复杂一些的栗子，由于手机码代码太不方便了，就以后再更吧。（如果有笔误打错的地方欢迎指正哈）
5、后缀数组的DC3算法，反正学完它的一瞬间我是明白了，天才和普通人的智商差距简直比人和狗还大啊。。。
6、
快速傅里叶变换
的数论版本（即NTT）：学完后有种想去数学系的冲动（还好后来冷静下来了）。费马素数群的性质居然和复数完美吻合，不得不说是一种奇迹啊。
7、主席树：这是fotile巨佬考场上发明这种数据结构，用于在$O(log n)$的
时间复杂度
内解决序列区间第k大问题，以及区间内元素的排名。个人感觉他比划分树的设计巧妙多了，有一种自然的美感。
8、
Pollard因数分解算法
：如果你真的把关于时间复杂度的证明一步步看完后，相信你会有一种豁然开朗的感觉。这个算法真正高的地方在于把
生日悖论
和递推式循环节巧妙的结合在一起，最后运用递推方程
主定理
的理论，使得时间复杂度达到了看似不可能的期望$n^0.25$的数量级。
其实现在感觉一切和数据结构或数学有关的算法都是非常优美的，前者在于设计的精巧性，后者在于证明的环环相扣，达到引人入胜的效果。","Tomohiko Sakamoto
 算法，来确定当前日期是星期几：
int
 
dow
(
int
 
y
,
 
int
 
m
,
 
int
 
d
)
 
{
 
    
static
 
int
 
t
[]
 
=
 
{
0
,
 
3
,
 
2
,
 
5
,
 
0
,
 
3
,
 
5
,
 
1
,
 
4
,
 
6
,
 
2
,
 
4
};
 
    
y
 
-=
 
m
 
<
 
3
;
 
    
return
 
(
y
 
+
 
y
/
4
 
-
 
y
/
100
 
+
 
y
/
400
 
+
 
t
[
m
-
1
]
 
+
 
d
)
 
%
 
7
;
 

}
 

同时，Tomohiko Sakamoto 还发布了另外一个更简洁的版本：
dow
(
m
,
d
,
y
)
 
{
 
y
-=
m
<
3
;
 
return
(
y
+
y
/
4
-
y
/
100
+
y
/
400
+
""-bed=pen+mad.""
[
m
]
+
d
)
%
7
;
 
}


代码看着就很漂亮，分析一下会发现确实很漂亮。","如何单独使用正则表达式验证所有email地址？
坐稳了！答案是：
(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)*\<(?:(?:\r\n)?[ \t])*(?:@(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*)|(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)*\<(?:(?:\r\n)?[ \t])*(?:@(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*)(?:,\s*(?:(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)*\<(?:(?:\r\n)?[ \t])*(?:@(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|""(?:[^\""\r\\]|\\.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:\\"".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*))*)?;\s*)
上述正则表达式有 6.2kb，由于太过复杂，并不适宜人类阅读，建议直接调用。
我用 Python 3.8.12 做一个测试：（请不断拖拽代码块下方的滑块）
# 导入正则表达式模块


import
 
re



# 设定验证规则


regex
 
=
 
r
'(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)*\<(?:(?:\r\n)?[ \t])*(?:@(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*)|(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)*\<(?:(?:\r\n)?[ \t])*(?:@(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*)(?:,\s*(?:(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)*\<(?:(?:\r\n)?[ \t])*(?:@(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|""(?:[^\""\r
\\
]|
\\
.|(?:(?:\r\n)?[ \t]))*""(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:
\\
"".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[""()<>@,;:
\\
"".\[\]]))|\[([^\[\]\r
\\
]|
\\
.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*))*)?;\s*)'



# 定义验证函数


def
 
mailvalidate
(
mailaddress
):

    
if
 
(
re
.
fullmatch
(
regex
,
 
mailaddress
)):

        
print
(
""Valid Email""
)

    
else
:

        
print
(
""Invalid Email""
)



# 对地址“contact@wired.me.uk”进行验证


mailvalidate
(
""contact@wired.me.uk""
)
验证结果有效：Valid Email
据说，该正则表达式能验证所有 RFC822 格式的email地址！
如果服气请点赞，如果不服请留言。","客户的机器有在国内的有在国外的，aws 的机器本机看不到公网 ip，需要判断机器到底在国内还是国外，再来判断后面脚本的执行路径。想了很多办法，包括往我们的服务器发一个请求我们通过ip判断地理位置之类的等等，最后的解决方案：
# Guess your 
location
, you know it.
location='oversea'
curl --connect-timeout 1 https://google.com 2>&1 >/dev/null
ret=$?
if [ $ret -ne 0 ]; then
    location='cn'
else
    .......
机智如中国人","天才程序员
约翰・卡马克
（John Carmack）在《雷神之锤 III 竞技场》源代码中的
平方根倒数速算法
（Fast Inverse Square Root，Fast InvSqrt()）。该算法的意义在于减少了求平方根倒数时
浮点运算
操作带来的巨大的运算消耗，毫无疑问，这对游戏图形运算具有非凡意义。
自从卡马克写下这段代码，引起诸多能人异士的兴趣和探讨。其中的
魔术数字
――0x5f3759df――到底是什么鬼――迄今为止仍未能明确这个神秘的特殊常数起源何处......
一段代码，就像天外一剑，惊若天人造，成就如大师卡马克，此生就不枉做一名程序员了。","我在这里提供我见识到的三个精彩算法的解析，强烈地推荐给初学的算法爱好者，它们可能会令你眼界大开，同时坚定你在算法大道上勇往直前的信念。
#3. 二进制是人类的好朋友，在线的树的
最近公共祖先
（LCA）算法：
利用数的二进制表示可以产生很多加速算法，online-LCA是其中之一。许多算法的加速是对数率的，就是利用了数的二进制表示。
首先定义二维数组：prede[N+1][B+1], N表示树的结点的数量，结点以数字1到N代指，B满足条件：2^(B)>=N
令fa[i]表示结点i的父结点，那么prede[i][b]的含义是：
prede[i][0] = fa[i];
prede[i][b] = prede[prede[i][b-1]][b-1]; // b >= 1
也就是说，prede[i][b]指的是从结点i往上走2^(b)步，所到达的结点。如果走到了尽头，就令prede[i][b]为0。
我们只需要O(NlogN)的复杂度，就可以完成prede的初始化。此外，我们还需要预处理出所有结点的高度，也就是depth[i]，定义为：
depth[root] = 0;
depth[i] = depth[fa[i]] + 1;
当遇到询问LCA(x, y)，我们只需要采取如下行动，就可以O(logN)的代价获得答案：
int
 
lca
(
int
 
x
,
 
int
 
y
)
 
{

     
if
 
(
depth
[
x
]
 
>
 
depth
[
y
])
 
swap
(
x
,
 
y
);

     
for
(
int
 
i
 
=
 
B
;
 
i
 
>=
 
0
;
 
i
 
--
){

         
//令x和y高度一致

         
if
 
(
depth
[
prede
[
y
][
i
]]
 
>=
 
depth
[
x
])
 
y
 
=
 
prede
[
y
][
i
];

     
}

     
//注意此时有可能出现x == y，那么LCA(x,y) == x，下方的for

     
//就不起作用了。

     
for
(
int
 
i
 
=
 
B
;
 
i
 
>=
 
0
;
 
i
 
--
){

        
//如果prede[x][i]和prede[y][i]不相同，说明这两者的高度

        
//都大于所求的LCA(x,y)，也就是在LCA(x,y)的下方，此时令

        
//x和y一同往根部以2^(i)的步数爬升

        
if
 
(
prede
[
x
][
i
]
 
!=
 
prede
[
y
][
i
])
 
x
 
=
 
prede
[
x
][
i
],
 
y
 
=
 
prede
[
y
][
i
];

     
}

     
if
 
(
x
 
==
 
y
)
 
return
 
x
;
   
//此时LCA（x,y) = x

     
return
 
prede
[
x
][
0
];
     
//此时x和y有共同的父结点

}


上述代码的精髓在于两个for(int i = B; i >= 0; i --)，这里利用了数的二进制表示。可以证明，对于任何严格小于2^(B+1)的非负整数t，下面的代码运行之后可以令a == t，
int
 
a
 
=
 
0
;
   

for
(
int
 
i
 
=
 
B
;
 
i
 
>=
 
0
;
 
i
 
--
){

     
if
(
a
 
+
 
(
1
<<
i
)
 
<=
 
t
)
 
a
 
+=
 
(
1
<<
i
);


}


#2. 集合之交，
树状数组
，动态更改、查询数组前缀和算法
。
实现树状数组所需的代码极为简易，实际上它是一棵残缺的
线段树
，它可以实现一部分线段树的功能（但凡可以化为区间求和的问题基本上都能解决），但是毕竟不如线段树功能完整，有兴趣的读者应该学习一下线段树的知识。
问题描述：利用预处理的前缀和数组pre[N + 1]，我们可以O(1)的代价对静态的数组A[N + 1]求取区间和：
pre[i] = A[0] + A[1] + A[2] + ... + A[i];
A[a] + A[a+1] + A[a+2] + ... + A[b] = pre[b] - pre[a-1];
但是当需要对数组A进行动态的更改时，上述代码就失效了。我们需要一种算法，可以动态地更改以及查询前缀和数组pre[N+1]。下面首先展示树状数组的代码，然后解释其数学原理，它的插入和查询的代价都是O(logN)：
int
 
Count
[
BiggestN
+
1
],
 
N
;
 
//使用前令Count所有元素为0，规定A[0]没有数

                          
//据，也就是说数据从A[1]开始存，pre[0]总为零



//实现功能A[i] += add

void
 
insert
(
int
 
i
,
 
int
 
add
)


{

    
while
(
 
i
 
<=
 
N
 
)

    
{

        
Count
[
i
]
 
+=
 
add
;

        
i
 
+=
 
i
&
(
-
i
);

    
}


}


//返回pre[i]的值

int
 
query
(
int
 
i
)


{

    
int
 
num
 
=
 
0
;

    
while
(
 
i
 
>
 
0
 
)

    
{

        
num
 
+=
 
Count
[
i
];

        
i
 
-=
 
i
&
(
-
i
);

    
}

    
return
 
num
;


}


算法中最关键的语句是位操作i&(-i)，读者在稿纸上算一算就可以知道：
i -= i&(-i)的功能是令i的最低的非0位变为0；
i += i&(-i)的功能是令i的最低的非0位变为0，并往更高一位进一。
理解树状数组的行为，需要构造两个集合：
Define lowbit(i) = i&(-i);
up(a) = {a, a1, a2, ...}, ai = a(i-1) + lowbit(a(i-1));
down(a) = {a, a1, a2, ..., 0}, ai = a(i-1) - lowbit(a(i-1));
可以证明，对于任何a <= b的正整数对(a,b)，up(a)和down(b)的交集都有且仅有一个元素。对这个定理进行含糊的说明是很容易的，a == b的情况不必考虑，a < b时，总有一个最大的i，使得b的第i位大于a的第i位（也就是b的第i位是1，而a的第i位是0）,那么对b产生down(b)，对a产生up(a)，它们的唯一交集就是(1<<i)。注意这里讨论的第i位的i是从0开始索引的。读者可以在稿纸上找若干数对进行实验来加深印象。
有了上述定理，我们就不难意会insert函数和query函数的作用了。
#1. 机器浮点数的秘密，""巧夺天工""的完美实例，基于标准浮点数的快速开平方倒数算法
这是一个公开的秘密，这是一个所有程序员得以欣赏的智慧之美。她在许多程序员的心目中高居“最美代码”的第一位，所有溢美之词都无法表达他们所感受到的震撼。
一定会有许多人想在这里贴这段代码，少年，来我这里，我帮你揭开她神秘的面纱。
公式太多，贴图讲解。
Vote Me Up If You Like My Answer ^_^","0 引言
这个题我已经留坑很久很久了，但是最近忙于赶一篇论文，5月31日是投稿截止日期。今天终于是把论文写完了，于是准备把留的坑都填一填。
前辈们已经把很多经典的、让人眼前一亮的代码展示出来了。我虽然不是码农，但也经常会看一些奇怪的代码。这里我列举五个我觉得最有趣、最好玩的代码给大家。这些代码一部分已经在之间的回答给出了，但为了Self-Contained，我也把这些已经给出的代码再次展示出来，并给出原始答案的链接、作者以及出处。
前方多图预警，超长答案预警，建议在WiFi环境下观看。
=============================
1. 真正改变世界的算法：向杰出的数学和计算机科学家们致敬
真正改变世界的是那些依托于数学的，真正高大上的代码。知乎er 
@张狗狗
提到的“支配世界的10个算法”（The real 10 algorithms that dominate our world，
The real 10 algorithms that dominate our world
）就是10个这类典型的算法。让我惊喜的是，这10个算法中竟然有4个与密码学相关（RSA算法，安全Hash算法，整数分解算法，随机数生成算法）。难道说真正掌控世界的是密码学嘛（笑）。作为一个密码学研究者，我感觉很激动啊！具体的内容 知乎er
@张狗狗
已经回答的非常详细了，请大家参考他的答案（
有没有一段代码，让你觉得人类的智慧也可以璀璨无比？ - 张狗狗的回答
）。作为致敬，我仅列出这10个算法，并请大家一起像这些杰出的科学家们致敬。
三种排序算法。
归并排序
（Mergesort），提出者：约翰・冯・诺尼曼（John von Neumann），现代计算机创始人；
快速排序
（Quicksort），提出者：托尼・霍尔（Tony Hoare），1980年图灵奖获得者；
堆排序
（Heapsort），基于计算机基本数据结构堆（Heap）的排序方法。
傅里叶变换
（Fourier Transform），提出者：约瑟夫・傅立叶（Joseph Fourier），温室效应的发现者，名字被刻在
埃菲尔铁塔
的72位法国科学家与工程师的其中一位。小行星10101号以傅里叶命名；
快速傅里叶变换
（Fast Fourier Transform），原始提出者：
约翰・卡尔・弗里德里希・高斯
（Carolus Fridericus Gauss），历史上最重要的数学家之一，被誉为“数学王子”。
Dijkstra
最短路径算法
（Dijkstra Shortest Path Algorithm）。提出者：
艾兹赫尔・戴克斯特拉
（Edsger Wybe Dijkstra），1972年
图灵奖
获得者。
RSA公钥密码体制
（RSA Public Key Cryptosystem）。提出者：罗纳德・李维斯特（Ron Rivest）、
阿迪・萨莫尔
（Adi Shamir）和伦纳德・阿德曼（Leonard Adleman）。他们为2002年图灵奖获得者。
安全Hash算法
（Secure Hash Algorithm）。一些经典的安全Hash算法及其提出者们。MD5算法，提出者：
罗纳德・李维斯特
（Ron Rivest），2002年图灵奖获得者。SHA家族（SHA-1，SHA-224，SHA-256，SHA-384，SHA-512），提出者：美国国家安全局（National Security Agency）。值得注意的是，MD5以及SHA-1算法在2005年由中国密码学家王小云、殷益群、于红波从理论上破解。
王小云
因“国际通用Hash函数的破解”获颁陈嘉庚科学奖信息技术科学奖。
整数分解
（Integer Factorization）。该问题已可以在量子计算机上以多项式复杂度解决，被称为秀尔算法（Shor Algorithm），提出者：彼得・威廉・秀尔（Peter Williston Shor），1998年奈望林纳奖（Nevanlinna Prize，计算机科学的数学方面重要贡献奖，每4年一届，得奖者在获奖当年不得大于40岁）获得者。
链接分析
（Link Analysis）。提出者：Gabriel Pinski、Francis Narin。
比例积分微分算法
（Proportional Integral Derivative Algorithm）。提出者：尼古拉斯・米诺尔斯基（Nicolas Minorsky）。
数据压缩算法
（Data Compression Algorithms）。包括数据压缩、图像压缩等等。
随机数生成器
（Random Number Generation）。
=============================
2. 数学拯救计算机科学算法：Quake III源代码中的玄机
很多知乎er们都提到了一个神奇的数0x5f3759df（ 
@高城
 ， 
@陆天培
 等）。追溯这个数的来源，我们就要谈到一个经典游戏Quick III了。Quick III从现在的眼光看来实在不是一个很精细的游戏。但是在当时，Quick III的画质简直是狂暴酷炫掉渣天。在Quick系列，Doom系列，及其3D引擎出现之前，有谁能想到计算机也可以显示如此神奇的3D效果呢？ 
这个3D引擎的开发者是约翰・卡马克（John Carmack）。他是美国电子游戏程序员，ID Software（一个著名游戏开发公司）的创始人之一。他在1999年，被时代杂志评选为科技领域50大影响力人物榜单，并列名列第10位。为表彰他的在电子游戏和电视游戏领域所作出的杰出贡献，卡马克称为第四位进入互动艺术和科学学院（The Academy of Interactive Arts and Science）名人堂的人物。我们来看看其余人物的名字吧（
美国互动艺术与科学学院（AIAS）名人堂_smile_新浪博客
）：
宫本茂
：任天堂公司，《
超级马里奥兄弟
》的创始人。
丹妮・邦顿・贝瑞：名人堂游戏《M・U・L・E》的制作人。
席德・梅尔：FiraxisGames公司，《文明》系列的制作人。
铃木裕
：世嘉公司，众多街机游戏的制作人。
威尔・赖特：Maxis公司，《模拟城市》系列的制作人。
坂口博信
：Square Enix公司，《最终幻想》系列的制作人。
理查德・加略特：NCsoft / DestinationGames公司，《创世纪》系列的制作人。
彼得・莫利纽克斯：牛蛙公司，《上帝也疯狂》，《主题公园》，《主题医院》，《
地牢守护者
》制作人。
特里普・霍金斯：3DO公司，《
魔法门
》系列，《英雄无敌》系列，《玩具兵》系列制作人。
麦克：暴雪公司，《魔兽世界》制作人。
卡马克在计算机领域最重要的贡献是，极大限度地压榨计算机计算性能，实现了一系列令人惊叹的数学函数。其中最知名的就是很多知乎er们提到的开平方取倒数算法，这个算法的基本原理是牛顿迭代法。原文出处来自
一个Sqrt函数引发的血案
。
float
 
Q_rsqrt
(
 
float
 
number
 
)


{

    
long
 
i
;

    
float
 
x2
,
 
y
;

    
const
 
float
 
threehalfs
 
=
 
1.5F
;


    
x2
 
=
 
number
 
*
 
0.5F
;

    
y
  
=
 
number
;

    
i
  
=
 
*
 
(
 
long
 
*
 
)
 
&
y
;

    
i
  
=
 
0x5f3759df
 
-
 
(
 
i
 
>>
 
1
 
);
 
// what the fuck?

    
y
  
=
 
*
 
(
 
float
 
*
 
)
 
&
i
;

    
y
  
=
 
y
 
*
 
(
 
threehalfs
 
-
 
(
 
x2
 
*
 
y
 
*
 
y
 
)
 
);
 
// 1st iteration

    
// y   = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed


    
#ifndef Q3_VM

    
#ifdef __linux__

        
assert
(
 
!
isnan
(
y
)
 
);
 
// bk010122 - FPE?

    
#endif

    
#endif

    
return
 
y
;


}
  

看看这段代码吧，只用了2次叠代，而且其实根本上就没用叠代，因为算一次直接就得到结果了。这个函数的效率比C库函数中执行sqrt()函数再取倒数要快4倍。
为什么能得到如此令人惊叹的效果呢？这段代码最让人费解的就是下面这行代码：
i  = 0x5f3759df - ( i >> 1 ); // what the fuck?

这个0x5f3759df是个什么鬼？
牛顿迭代法
的原理是先猜测一个值，然后从这个值开始进行叠代。因此，猜测的值越准，叠代的次数越少。卡马克选了0x5f3759df这个值作为猜测的结果，再加上后面的移位算法，得到的y非常接近1/sqrt(n)。这样，我们只需要2次牛顿迭代法就可以达到我们所需要的精度。
普渡大学的数学家Chris Lomont看了以后觉得有趣，决定要研究一下卡马克弄出来的这个猜测值有什么奥秘。在精心研究之后，Lomont从理论上也推导出一个最佳猜测值，和卡马克的数字非常接近, 0x5f37642f。Lomont计算出结果以后非常满意，于是拿自己计算出的起始值和卡马克的神秘数字做比赛，看看谁的数字能够更快更精确的求得平方根。结果是卡马克赢了... 
Lomont怒了，采用暴力方法一个数字一个数字试过来，终于找到一个比卡马克数字要好上那么一丁点的数字，虽然实际上这两个数字所产生的结果非常近似，这个暴力得出的数字是0x5f375a86。
Lomont为此写下一篇论文，""Fast Inverse Square Root""（这里原文给出的地址有误，论文的地址为
http://www.
files.sauliaus.info/Inv
Sqrt.pdf
）。
感谢开源GPL协议，Quick III的源代码已经公开，我们可以目睹一下Quick III的风采了。源代码下载地址为：
ftp://ftp.idsoftware.com/idstuff/source/quake3-1.32b-source.zip
。这个地址需要翻墙才能下载。而那个传说中的代码，位于game/code/q_math.c中。
=============================
3. 二进制的神奇应用：基于位运算的代码系列
看到了Quick III中神奇的代码，想必知乎er们也对二进制和位运算的神奇有了一些感觉了。我最开始觉得二进制运算很有趣，是因为Leetcode中的一道题：Single Number（
Single Number
）。题目如下：
Given an array of integers, every element appears 
twice
 except for one. Find that single one.
问题在于，如何在线性复杂度下实现呢？这里就要用到与或运算了。
二进制运算还有哪些神奇的应用呢？Stanford的一个Ph.D学生Sean Eron Anderson（
Sean Anderson
）自己维护了一个网站，里面列举了一大堆二进制运算的神奇应用，链接为：
Bit Twiddling Hacks
。
我们来简单看几个运算：
1. 计算一个整数的符号：
int v;      // we want to find the sign of v
int sign;   // the result goes here 

// CHAR_BIT is the number of bits per byte (normally 8).
sign = -(v < 0);  // if v < 0 then -1, else 0. 
// or, to avoid branching on CPUs with flag registers (IA32):
sign = -(int)((unsigned int)((int)v) >> (sizeof(int) * CHAR_BIT - 1));
// or, for one less instruction (but not portable):
sign = v >> (sizeof(int) * CHAR_BIT - 1); 
2. 检测两个整数的符号是否一致：
int x, y;               // input values to compare signs
bool f = ((x ^ y) < 0); // true iff x and y have opposite signs

3. 计算一个整数的绝对值：
int v;           // we want to find the absolute value of v
unsigned int r;  // the result goes here 
int const mask = v >> sizeof(int) * CHAR_BIT - 1;

r = (v + mask) ^ mask;

@高城
还提到了Google Code上面的一个基于浮点数标准的快速算法库，里面也用到了各种二进制运算，链接为：
fastapprox -
 
 
 Fast approximate functions
。
=============================
4. 能不能把代码写的够混乱：世界混乱C代码大赛
后面的几个就是比较好玩的东西了。首先我们来看看计算机学科的怪胎们是怎么玩坏C语言的。 
@毛草
提到了一个神奇的代码，通过计算代码本身的面积，来计算圆周率的近似值。这个代码来自世界混乱C代码大赛（International Obfuscated C Code Contest，IOCCC）。这个大赛的宗旨是，在C语言本身可以执行的条件下，看谁能写出最有创意的最让人难以理解的C语言代码。代码的长度要求限制在4kb以内。大赛的官方链接为：
The International Obfuscated C Code Contest
。
第23届IOCCC竞赛已经在2014年10月27日结束，但是我似乎找不到源代码。我们来看看第22届IOCCC竞赛中的代码中又没有什么好玩的东西吧。因为有些代码知乎上显示的不太好，我用截图的形式给出。
Best Painting Tool
（
http://www.
ioccc.org/2013/birken/h
int.html
）
Most Lazy SKLer
 （
Most lazy SKIer
）
Best Use of 1 Infinite Loop
 （
Best use of 1 Infinite Loop
）
下面是以前一些比较有趣的代码：
2012，
Most Elementray Use of C
（
Most elementary use of C
）
2012，
Most Functional 
（
Most functional
）
1998，
Best of Show 
（
Carl Banks' Blog: IOCCC Flight Simulator
）
=============================
5. 数学也可以画图：用公式绘制任意图形
还记得一直在电视上播放的
百岁山
广告吗？很多人都说看不懂那个广告。其实那个广告参考了1650年著名数学家笛卡尔与瑞典公主克莉丝汀相恋的故事。具体的故事我就不再赘述了。最后，笛卡尔写给克莉丝汀的情书中出现了这样的公式：
r = a(1 - \sin \theta)
r = a(1 - \sin \theta)
这个公式对应的几何图形为心形，是著名的“心形线”。笛卡尔用这样一种方式，通过数学表达了对克莉丝汀的深深爱意。这封情书最后也被收录到欧洲笛卡尔博物馆中。
浪漫的故事到此为止，这引发了一个有趣的问题：我们能不能用数学公式，来构造任意几何图形呢？这个问题实际上是有解的。有人真的研究了这个问题，并给出了肯定的答案。链接如下：
http://
blog.wolfram.com/2013/0
5/17/making-formulas-for-everything-from-pi-to-the-pink-panther-to-sir-isaac-newton/
。我们来看一看一些有趣的图形吧~具体的生成算法课参考上面给出的链接。
美国队长曲线
（Captain America-like curve）
台灯曲线
（Luxo Jr.like curve）
a^2 + b^2 = c^2
牛顿曲线
=============================
以上。","大一第一学期，第一节C语言课，老师问如何进行四舍五入？
答曰：加0.5取整数部分。
当时，我觉得算法是这么神奇的东西。","int
 
find
(
int
 
x
){

        
return
 
x
==
Fa
[
x
]
?
x
:
Fa
[
x
]
=
find
(
Fa
[
x
]);


}


一行
并查集
不管从算法内涵到代码表示都简直精致优雅到炸","花费一天一夜写了一个巨复杂的代码，测试我同时发微信的三个女生跟我交往的可能性。
里面涵盖了我苦心计算的各种友好度估分，回复微信长度，回复等待时间，有没有图片，语音，女孩主动程度，
每个都有分值。
以及我发送微信过去，预计收到的微信长度，等待时间。
我还导出微信，整理了一个我的经典套话100句。
供我没话题说的时候随机选择。
经过我一礼拜的实验修正，使得女生回复我的时间，内容长度误差在10%以内。
还可以导出一堆EXCEL图表供我分析。
我每天晚上乐此不疲的和她们三个聊天做实验修改我的参数。
里面一个女孩的对我友好度逐渐远超其他女孩。
超过我设计的100分上限。果断约出来强行牵手
（虽然是程序员也知道表白死，坚决不表白，直接拉手）
最后追到这个小姑娘，完全符合我的预算。
哥那段代码绝对壮绝古今。
我认为我那段代码的最终版已经把追女孩上升到一个模式化。
完全可预计结果。我简直无敌了。
后面因追到女生后一高兴删除了，后面分手懒得再写了。
分手原因是我加班太多。她家人喜欢公务员。。。","Linux 的 
container_of
 宏。在最新的 Linux 6.12 中（甚至可能在这之前），它被尊贵地单开了一个文件 include/linux/container_of.h：
#define container_of(ptr, type, member) ({				\

	void *__mptr = (void *)(ptr);					\

	static_assert(__same_type(*(ptr), ((type *)0)->member) ||	\

		      __same_type(*(ptr), void),			\

		      ""pointer type mismatch in container_of()"");	\

	((type *)(__mptr - offsetof(type, member))); })
而 
offsetof
 目前已经被编译器内置的 
__builtin_offsetof
 替换，这里只能在旧版中一睹其风采了：
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE*)0)->MEMBER)
这玩意怎么用呢？先给一个使用范例：
struct
 
a
 
{

    
int
 
b
;

    
short
 
c
;

    
char
 
d
;


};



a
.
d
 
=
 
15
;



char
 
*
ptr
 
=
 
&
a
.
d
;


struct
 
a
 
*
container
 
=
 
container_of
(
ptr
,
 
struct
 
a
,
 
d
);


printf
(
""%d""
,
 
container
->
d
);
 
//
 
15
凭借一个指向结构体成员的指针就反推出这个结构体本身的地址，这个是怎么做到的呢？
首先看第一个宏 
offsetof
，它的实现就一行：
((size_t)&((TYPE*)0)->MEMBER)
。
现在重新描述一下问题：知道 
&type.member
，要求 
&type
。 由于一个结构体在内存中的排布必然连续，所以计算出 
&type.member
 相对于 
&type
 的偏移 
n
 ，然后就可以通过 
&type.member - n
 的方式得到 
&type
 了。
只要让 
&type
 为 0， 
&type.member
 就是那个 
n
 
。原理很简单，既然 
n
 是 
&type
 相对 
&type.member
 的偏移，我自然可以随意移动这个 
&type
，让它等于 0 就是最简单易行的方式。
不过，由于代码中把 0 指针强转为结构体，甚至还访问了成员，所以它虽然优雅，但是否属于 UB 目前仍有争议。或许也是因为这个原因，C++ 标准提供了 
std::offsetof
 以代替这种写法（事实上 C++ 明令规定不准这么做了），
GCC 编译器
也提供了 
__builtin_offsetof
。 
下面进入 
container_of
，这里面用了一些 GCC 扩展，比如 
({...})
，这个东西叫做
复合语句表达式
，里面可以是任何东西，除了正常的变量赋值、计算以外，甚至还能用 
if-elif-else
、
for
 之类的条件循环语句，更能定义新函数，函数内定义函数不是梦。这个复合语句表达式的值，就要看整个复合语句中最后一个语句，如果它是一个表达式，那整个块的值就是这个表达式的值，否则是 
void
，没有任何返回值。
第一行换类型没有什么可说的，换成 
void *
 和 
char *
 其实没有什么区别。
第二行做了一个 
static_assert
，
__same_type
 最终化为 GCC 编译器扩展，总之内容就是判断两个东西的类型是否一致；这里是把它解除引用，然后去和 
((type *) 0)->member
 的类型比较。这又是在干什么呢？事实上，这只是因为我们不知道 
member
 的类型，所以需要在一个结构体中引用它，所以又跟上面一样，设置了 
&type
 为 0 的缘故。这下是不是 UB 真绕不过去了。后面还或了一个解引用以后是否为 
void
，这是因为这个 
ptr
 本身可能就是一个 
void *
 的缘故（
__same_type
 不会求值只会看类型，因此可以不经转换对 
void *
 解引用）。 
最后第三行有了上面的分析就很平凡了，已经知道了 
&type.member
，接下来用 
offsetof
 求得 
n
，即可用 
&type.member - n
 求得 
&type
。
或许已经见过很多次，见怪不怪了，但我相信初见总能予人以震撼。 ","24行内实现 BASIC语言（老外写的）：
#define O(b,f,u,s,c,a)b(){int o=f();switch(*p++){X u:_ o s b();X c:_ o a b();default:p--;_ o;}}

#define t(e,d,_,C)X e:f=fopen(B+d,_);C;fclose(f)

#define U(y,z)while(p=Q(s,y))*p++=z,*p=' '

#define N for(i=0;i<11*R;i++)m[i]&&

#define I ""%d %s\n"",i,m[i]

#define X ;break;case

#define _ return

#define R 999

typedef
 
char
*
A
;
int
*
C
,
E
[
R
],
L
[
R
],
M
[
R
],
P
[
R
],
l
,
i
,
j
;
char
 
B
[
R
],
F
[
2
];
A
 
m
[
12
*
R
],
malloc


(),
p
,
q
,
x
,
y
,
z
,
s
,
d
,
f
,
fopen
();
A
 
Q
(
s
,
o
)
A
 
s
,
o
;{
for
(
x
=
s
;
*
x
;
x
++
){
for
(
y
=
x
,
z
=
o
;
*
z
&&*
y
==


*
z
;
y
++
)
z
++
;
if
(
z
>
o
&&!*
z
)
_
 
x
;}
_
	
0
;}
main
(){
m
[
11
*
R
]
=
""E""
;
while
(
puts
(
""Ok""
),
gets
(
B
)


)
switch
(
*
B
){
X
'R'
:
C
=
E
;
l
=
1
;
for
(
i
=
0
;
i
<
R
;
P
[
i
++
]
=
0
);
while
(
l
){
while
(
!
(
s
=
m
[
l
]))
l
++
;
if


(
!
Q
(
s
,
""
\""
""
)){
U
(
""<>""
,
'#'
);
U
(
""<=""
,
'$'
);
U
(
"">=""
,
'!'
);}
d
=
B
;
while
(
*
F
=*
s
){
*
s
==
'""'
&&
j


++
;
if
(
j
&
1
||!
Q
(
"" 
\t
""
,
F
))
*
d
++=*
s
;
s
++
;}
*
d
--=
j
=
0
;
if
(
B
[
1
]
!=
'='
)
switch
(
*
B
){
X
'E'
:
l
=-
1


X
'R'
:
B
[
2
]
!=
'M'
&&
(
l
=*--
C
)
X
'I'
:
B
[
1
]
==
'N'
?
gets
(
p
=
B
),
P
[
*
d
]
=
S
()
:
(
*
(
q
=
Q
(
B
,
""TH""
))
=
0
,
p


=
B
+
2
,
S
()
&&
(
p
=
q
+
4
,
l
=
S
()
-
1
))
X
'P'
:
B
[
5
]
==
'""'
?*
d
=
0
,
puts
(
B
+
6
)
:
(
p
=
B
+
5
,
printf
(
""%d
\n
""
,
S


()))
X
'G'
:
p
=
B
+
4
,
B
[
2
]
==
'S'
&&
(
*
C
++=
l
,
p
++
),
l
=
S
()
-
1
 
X
'F'
:*
(
q
=
Q
(
B
,
""TO""
))
=
0
;
p
=
B
+
5
;
P
[
i


=
B
[
3
]]
=
S
();
p
=
q
+
2
;
M
[
i
]
=
S
();
L
[
i
]
=
l
 
X
'N'
:++
P
[
*
d
]
<=
M
[
*
d
]
&&
(
l
=
L
[
*
d
]);}
else
 
p
=
B
+
2
,
P
[


*
B
]
=
S
();
l
++
;}
X
'L'
:
N
 
printf
(
I
)
X
'N'
:
N
 
free
(
m
[
i
]),
m
[
i
]
=
0
	
X
'B'
:
_
 
0
 
t
(
'S'
,
5
,
""w""
,
N


fprintf
(
f
,
I
))
t
(
'O'
,
4
,
""r""
,
while
(
fgets
(
B
,
R
,
f
))(
*
Q
(
B
,
""
\n
""
)
=
0
,
G
()))
X
 
0
:
default
:
G
()


;}
_
 
0
;}
G
(){
l
=
atoi
(
B
);
m
[
l
]
&&
free
(
m
[
l
]);(
p
=
Q
(
B
,
"" ""
))
?
strcpy
(
m
[
l
]
=
malloc
(
strlen
(
p


)),
p
+
1
)
:
(
m
[
l
]
=
0
,
0
);}
O
(
S
,
J
,
'='
,
==
,
'#'
,
!=
)
O
(
J
,
K
,
'<'
,
<
,
'>'
,
>
)
O
(
K
,
V
,
'$'
,
<=
,
'!'
,
>=
)


O
(
V
,
W
,
'+'
,
+
,
'-'
,
-
)
O
(
W
,
Y
,
'*'
,
*
,
'/'
,
/
)
Y
(){
int
 
o
;
_
*
p
==
'-'
?
p
++
,
-
Y
()
:*
p
>=
'0'
&&*
p
<=


'9'
?
strtol
(
p
,
&
p
,
0
)
:*
p
==
'('
?
p
++
,
o
=
S
(),
p
++
,
o
:
P
[
*
p
++
];}
运行后输入程序（记住字母大写）：
10
 
A
=
1


20
 
B
=
1


30
 
FOR
 
I
=
1
 
TO
 
10
 
DO


40
 
C
=
A
+
B


50
 
PRINT
 
A


60
 
A
=
B


70
 
B
=
C


80
 
NEXT
 
I


90
 
END
然后输入命令：
RUN
即可求解斐波拉契数列。
再来一段我写的
空战游戏
：
WINXP下（或者DOSBOX: 
D-Fend Reloaded
 ）在DOS窗口中运行DEBUG，然后把横线下的内容复制、粘贴到DEBUG窗口中，回车就可以见到了。  
--------------------------------------------------------------------
e100 e8 5f 0 e8 4c 1 e8 ed 0 b8 0 4c cd 20 f f 0 8 7 1 7 1 6 7 7 1 0 f 1 0 0
e11f 0 fe c2 cb c4 c1 8a d3 c5 df 8a cc c5 d8 8a da c6 cb d3 c3 c4 cd 86 8a
e137 c8 d3 8a d9 c1 d3 dd c3 c4 ce 99 9a 9a 9a ea c2 c5 de c7 cb c3 c6 84 c9
e14f c5 c7 a7 a0 0 87 97 8a ef f2 ec e5 f8 e9 ef 8a 97 87 0 66 60 b8 0 11 a3
e168 e 1 5 80 bb a3 16 1 5 0 1 a3 10 1 5 80 0 a3 12 1 5 10 2 a3 14 1 8b 3e 10
e185 1 fc b9 80 2 33 c0 f3 aa 1e 33 c0 8e d8 8e c0 be 24 0 66 ad 1f 66 a3 18
e19e 1 8c c8 66 c1 e0 10 b8 1d 2 bf 24 0 fa 66 ab b0 34 e6 43 b8 87 0 e6 40
e1b7 8a c4 e6 40 fb 66 33 c0 1e 7 b8 13 0 cd 10 be 7e 3 bb 0 0 8b 3e 16 1 ac
e1d1 3c c0 73 4 aa 43 eb 9 24 3f 50 ac 59 f3 aa 43 43 80 fb 9b 72 e9 33 c0 cd
e1ea 1a 81 e2 ff 7f 89 16 1c 1 66 61 c3 33 c0 8e c0 66 a1 18 1 bf 24 0 fa 66
e203 ab b0 34 e6 43 33 c0 e6 40 e6 40 fb 66 33 c0 b8 3 0 cd 10 1e 7 e8 4d 0
e21c c3 60 1e 6 8c c8 8e d8 8e c0 33 c0 e4 60 8b c8 83 e1 7f 8b 1e 10 1 3 d9
e235 24 80 f6 d0 c1 e8 7 88 7 e4 61 c 80 e6 61 24 7f e6 61 b0 20 e6 20 7 1f
e24e 61 cf c3 c3 60 b4 2 b7 0 ba d 0 cd 10 b3 3 be 54 1 e8 9 1 61 e8 b1 1 c3
e269 be 20 1 e8 fe 0 33 c0 cd 16 c3 60 8b 36 e 1 bf 40 1f b9 c0 5d fc b8 0 a0
e283 8e c0 f3 a5 e 7 61 c3 60 8b 3e e 1 b9 c0 5d e 7 33 c0 fc f3 ab 61 c3 c8
e29d 0 0 0 60 8b 4e 4 8b 56 6 8a 46 8 81 f9 40 1 73 1a 81 fa 96 0 73 14 8b 3e
e2b8 e 1 8b da c1 e2 8 c1 e3 6 3 da 3 d9 3 fb 88 5 61 c9 c3 c8 2 0 0 60 8b 1e
e2d4 16 1 ba 0 0 83 6e 4 8 83 6e 6 8 c7 46 fe f 0 b9 0 0 33 c0 8a 7 43 3c 0
e2f0 74 1e 50 8b 46 6 83 7e 8 0 74 4 3 c2 eb 3 3 46 fe 50 8b 46 4 3 c1 50 e8
e30b 8f ff 83 c4 6 41 83 f9 10 72 d3 ff 4e fe 42 83 fa 10 72 c7 8b 4e 4 8b 56
e324 6 61 c9 c3 c8 0 0 0 52 66 a1 1c 1 66 69 c0 35 4e 5a 1 66 40 66 a3 1c 1
e33e 66 c1 e8 10 66 25 ff 7f 0 0 99 f7 7e 4 8b c2 5a c9 c3 c8 0 0 0 8b 1e 12
e358 1 b9 20 0 b8 0 0 83 3f 0 74 7 83 c3 10 40 49 75 f4 c9 c3 fc ac 3c 0 74 a
e373 b4 e 34 aa 60 cd 10 61 eb f1 c3 c3 0 1d 19 c4 0 19 1d c1 c4 c7 0 c2 19
e38c c4 0 19 0 c1 c4 c4 0 c2 70 0 19 c1 c4 c2 28 1d c2 70 28 70 0 c3 70 c2 28
e3a6 c2 70 c2 28 c2 19 70 c2 28 c6 70 28 70 19 c2 28 c3 70 c2 28 19 28 c2 70
e3be c2 0 c2 70 19 c3 28 70 c3 28 19 28 70 c4 0 70 19 28 70 28 c3 70 28 19 70
e3d7 c6 0 1d 70 0 28 0 70 0 70 1d c7 0 1d 70 0 28 36 70 0 70 1d c7 0 1d c2 0
e3f2 28 36 70 c2 0 1d c9 0 28 70 19 c2 70 cb 0 28 70 19 c2 70 cb 0 28 c4 70
e40b cc 0 28 c2 70 cd 0 28 19 cf 0 70 c8 0 c8 32 0 0 56 57 c7 46 fe 9c 2 c7
e425 46 fc cd 2 c7 46 fa 28 3 c7 46 f8 51 3 c6 46 f1 1 c6 46 f0 0 c6 46 ef 0
e43f 66 c7 46 e8 0 0 0 0 c7 46 e2 a0 0 c7 46 e0 78 0 c7 46 d2 0 0 c7 46 ce 0
e45a 0 a1 10 1 89 46 ec a1 14 1 89 46 f6 a1 12 1 89 46 f4 c7 46 de 0 0 8b 76
e474 f6 eb 38 68 40 1 ff 56 fa 59 89 4 68 c8 0 ff 56 fa 59 5 ce ff 89 44 2 83
e48e 7e de 35 7d c c7 44 4 1 0 c7 44 6 17 0 eb a c7 44 4 2 0 c7 44 6 1c 0 ff
e4aa 46 de 83 c6 8 83 7e de 50 7c c2 e9 94 3 66 8b 46 e8 66 89 46 e4 eb 14 66
e4c3 60 33 c0 cd 1a 8b c1 66 c1 e0 10 8b c2 66 89 46 e4 66 61 66 8b 46 e4 66
e4db 2b 46 e8 66 83 f8 c 72 de 66 8b 46 e4 66 89 46 e8 b8 8b 2 ff d0 c7 46 de
e4f4 50 0 8b 76 f6 eb 36 8a 44 6 50 ff 74 2 ff 34 ff 56 fe 83 c4 6 8b 44 4 1
e50e 44 2 81 7c 2 96 0 7e 14 68 40 1 ff 56 fa 59 89 4 6a 3c ff 56 fa 59 f7 d8
e528 89 44 2 ff 4e de 83 c6 8 83 7e de 0 75 c4 8b 5e ec 80 7f 4b 0 74 f 83 6e
e542 e2 2 83 7e e2 0 7d 5 c7 46 e2 0 0 8b 5e ec 80 7f 4d 0 74 10 83 46 e2 2
e55c 81 7e e2 40 1 7e 5 c7 46 e2 40 1 8b 5e ec 80 7f 48 0 74 f 83 6e e0 3 83
e576 7e e0 0 7d 5 c7 46 e0 0 0 8b 5e ec 80 7f 50 0 74 10 83 46 e0 2 81 7e e0
e590 96 0 7e 5 c7 46 e0 96 0 8b 5e ec 80 7f 1 0 74 3 e9 b0 2 8b 5e ec 80 7f
e5aa 1d 0 74 33 80 7e f0 0 75 31 c6 46 f0 1 ff 56 f8 c1 e0 4 8b 7e f4 3 f8 80
e5c4 7e ef 2 7d 1c fe 46 ef c7 5 2 0 8b 46 e2 89 45 8 8b 46 e0 5 f7 ff 89 45
e5de a eb 4 c6 46 f0 0 c7 46 de 0 0 8b 7e f4 e9 a3 1 8b 45 8 89 46 d6 8b 45 a
e5f9 89 46 d4 8b 5 89 46 d0 3d 1 0 74 b 3d 2 0 75 3 e9 a7 0 e9 6b 1 83 7d 2 0
e615 74 6d 8b 46 d6 2b 46 e2 89 46 da 83 7e da 0 7d 5 f7 d8 89 46 da 8b 46 d4
e62e 2b 46 e0 89 46 d8 83 7e d8 0 7d 5 f7 d8 89 46 d8 83 7e da d 7d a 83 7e
e647 d8 d 7d 4 c6 46 f1 0 6a 2 ff 56 fa 59 40 1 46 d4 81 7e d4 a0 0 7e 5 c7
e661 46 d0 0 0 6a 8 ff 56 fa 59 b c0 75 25 8b 46 d6 3b 46 e2 7e 5 b8 ff ff eb
e67b 3 b8 1 0 1 46 d6 eb 10 ff 45 4 8b 45 4 3d 28 0 7e 5 c7 46 d0 0 0 8b 45 2
e697 8b 55 4 83 e2 1 b c2 75 3 e9 d8 0 6a 1 ff 76 d4 ff 76 d6 ff 56 fc 83 c4
e6b1 6 e9 c7 0 8b 46 d4 5 fb ff 89 46 dc eb 27 6a 9 ff 76 dc 8b 46 d6 5 fb ff
e6cb 50 ff 56 fe 83 c4 6 6a 9 ff 76 dc 8b 46 d6 5 3 0 50 ff 56 fe 83 c4 6 ff
e6e5 46 dc 8b 46 d4 5 5 0 3b 46 dc 7f ce 83 6e d4 4 83 7e d4 ec 7d 8 c7 46 d0
e6ff 0 0 fe 4e ef c7 46 dc 0 0 8b 46 f4 89 46 f2 eb 65 8b 5e f2 83 3f 1 75 56
e719 83 7f 2 1 75 50 83 7e d0 0 74 4a 8b 46 d6 2b 47 8 89 46 da 83 7e da 0 7d
e733 5 f7 d8 89 46 da 8b 5e f2 8b 46 d4 2b 47 a 89 46 d8 83 7e d8 0 7d 5 f7
e74c d8 89 46 d8 83 7e da f 7d 19 83 7e d8 f 7d 13 8b 5e f2 c7 47 2 0 0 c7 46
e766 d0 0 0 fe 4e ef ff 46 ce ff 46 dc 83 46 f2 10 83 7e dc 20 7c 95 8b 46 d6
e77f 89 45 8 8b 46 d4 89 45 a 8b 46 d0 89 5 ff 46 de 83 c7 10 83 7e de 20 7d
e798 3 e9 54 fe 6a 14 ff 56 fa 59 b c0 75 3b ff 56 f8 c1 e0 4 8b 56 f4 3 d0
e7b1 89 56 f2 8b 5e f2 c7 7 1 0 c7 47 2 1 0 c7 47 4 0 0 68 40 1 ff 56 fa 59
e7cc 8b 5e f2 89 47 8 6a a ff 56 fa 59 5 ec ff 8b 5e f2 89 47 a b8 96 0 2b 46
e7e6 ce 89 46 d4 83 7e d4 0 7d 5 c7 46 d4 0 0 8b 46 d4 89 46 de eb 11 6a 4 ff
e800 76 de 68 3f 1 ff 56 fe 83 c4 6 ff 46 de 81 7e de 96 0 7c e8 81 7e d2 8c
e819 0 7d f c6 46 f1 1 8b 46 d2 25 1 0 89 46 da eb 5 c7 46 da 1 0 83 7e da 0
e834 74 e 6a 0 ff 76 e0 ff 76 e2 ff 56 fc 83 c4 6 b8 74 2 ff d0 ff 46 d2 80
e84d 7e f1 0 74 3 e9 63 fc 80 7e f1 0 75 2e 66 8b 46 e8 66 89 46 e4 eb 14 66
e866 60 33 c0 cd 1a 8b c1 66 c1 e0 10 8b c2 66 89 46 e4 66 61 66 8b 46 e4 66
e87e 2b 46 e8 66 3d d0 2 0 0 72 dc 5f 5e c9 c3 ff 53 4b 59 57 49 4e 44 30 35
g
--------------------------------------------------------------------
游戏运行于DOS环境，所以不必当心它是个病毒 ：－），用方向键控制运行，CTRL发射激光，
如果运行在WINXP下面，粘贴操作只需要点击DEBUG窗口的图标，选“编辑”即可。
游戏效果：
我 2004年实现的竖版空战射击游戏，整个代码 1K以内。
------------
Win7下 DosBox的用法（没有 WinXP和 VmWare时）：
下载安装 
D-Fend Reloaded
 最新版（带GUI和 FreeDOS 的DosBox） 并运行
复制游戏代码（横线中内容）保存到 C:\Users\用户名\D-Fend Reloaded\VirtualHD\game.txt 
双击 D-Fend Reloaded窗口中的 DosBox，启动DosBox窗口
按CTRL_F12将CPU Speed调到10000以上
输入命令：debug < C:\game.txt，按回车启动游戏","不用临时变量交换两个数的值
    a = a ^ b;
    b = b ^ a;
    a = a ^ b;
再补一个蓄水池抽样(reservoir sampling):
在超大数据流的情况下，如何随机抽取其中一行。
因为数据量很大，并不想先读取一次数据，获得数据量n, 然后第二次再根据概率选择数据。
而这个算法的核心思路就是：
1
1
×
1
2
×
2
3
×
3
4
×
4
5
×
5
6
×
.
.
.
.
.
.
.
×
n
?
1
n
=
1
n
\frac{1}{1} \times  \frac{1}{2} \times  \frac{2}{3} \times  \frac{3}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} =  \frac{1}{n}
\frac{1}{1} \times  \frac{1}{2} \times  \frac{2}{3} \times  \frac{3}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} =  \frac{1}{n}
所以：
读第一行文件时，保留第一行在内存里，这个概率是 1/1.
读第二行，用1/2的概率来确定这一行要不要替换内存里存着的那一行，
读第三行，用1/3的概率来确定这一行要不要替换内存，
读第四行，用1/4的概率来确定这一行要不要替换内存，
。。。。。
一直读到n行，用1/n的概率来确定这一行要不要替换内存里的那一行。
这个时候，内存里留下的那一行就是随机选取出来的那一行。
不信？你看！
p
(
k
=
1
)
=
1
1
×
1
2
×
2
3
×
3
4
×
4
5
×
5
6
×
.
.
.
.
.
.
.
×
n
?
1
n
p(k=1) = \frac{1}{1} \times  \frac{1}{2} \times  \frac{2}{3} \times  \frac{3}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} 
p(k=1) = \frac{1}{1} \times  \frac{1}{2} \times  \frac{2}{3} \times  \frac{3}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} 
p
(
k
=
2
)
=
1
×
1
2
×
2
3
×
3
4
×
4
5
×
5
6
×
.
.
.
.
.
.
.
×
n
?
1
n
p(k=2) = 1 \times  \frac{1}{2} \times  \frac{2}{3} \times  \frac{3}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} 
p(k=2) = 1 \times  \frac{1}{2} \times  \frac{2}{3} \times  \frac{3}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} 
p
(
k
=
3
)
=
1
×
1
×
1
3
×
3
4
×
4
5
×
5
6
×
.
.
.
.
.
.
.
×
n
?
1
n
p(k=3) = 1 \times 1 \times  \frac{1}{3} \times  \frac{3}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} 
p(k=3) = 1 \times 1 \times  \frac{1}{3} \times  \frac{3}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} 
p
(
k
=
4
)
=
1
×
1
×
1
×
1
4
×
4
5
×
5
6
×
.
.
.
.
.
.
.
×
n
?
1
n
p(k=4) = 1 \times 1 \times  1 \times  \frac{1}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} 
p(k=4) = 1 \times 1 \times  1 \times  \frac{1}{4} \times  \frac{4}{5} \times  \frac{5}{6} \times ....... \times \frac{n-1}{n} 
.....
p
(
k
=
n
)
=
1
×
1
×
1
×
1
×
1
×
1
×
.
.
.
.
.
.
.
×
1
n
p(k=n) = 1 \times 1 \times  1 \times  1 \times 1 \times  1 \times ....... \times \frac{1}{n} 
p(k=n) = 1 \times 1 \times  1 \times  1 \times 1 \times  1 \times ....... \times \frac{1}{n} 
p.s. 这两个算法都是
编程珠玑
(Programming pearls)里的例子。
另外还有logn 时间复杂度求
斐波那契数列
.","mame/quine-relay ・ GitHub
突然发现已经100种语言了，想看50种语言的进50分支。
璀璨无比谈不上，反正让我震惊了会儿，原来可以这样玩","真心佩服PID！！！暂时绝对是我觉得最惊艳的东西了。
经典的东西往往是简单的！而PID控制算法恰好就符合了这一点，短短一个公式，十多航。
在工业应用中，PID及其衍生算法几乎是应用最广泛的算法。而它问世的六十、七十年以来，一直在使用，仍未淘汰。至于在我们学生当中，假如对PID
足够熟悉
，对PID的参数整定
熟练
的话，我觉得参加电子设计（控制类），
飞思卡尔智能车
，机器人比赛等这类的比赛，获奖的压力肯定会小很多很多。其他类型的创新项目只要涉及到控制类的，问题也应该不大了吧。至于其他领域，我就不太清楚了，毕竟也没太多接触。
下面来大概介绍下这个算法。
首先，这些介绍都是之前做比赛或是电子设计时，从网上搜集到的各种资料（仔细看完应该可以大概入门了吧）。 所以假如有侵犯个人版权之类的，请联系我。我会立刻改正，并补上作者。毕竟是第一次完整答题，有什么问题，请大家提出，谢谢~
不废话，进入正题，开启搬运工模式
****************************************************************************************** 
第一，就是这张图了
PID 对应的就是 比例（Proportion）、积分（Integration）、微分（Differentiation），对应着上面的图，意思就是。通过一个输入量（偏差值），经过比例、积分、微分、的运算后（应用时不一定需要三个步骤都有）得到一个输出量（结果）。再把这个输出量直接给执行部件，执行操作。此后通过，传感器得到实际值时，再于目标值作差，传给输入量。接着，一直循环下去。直到你所需要控制的那个量慢慢逼近，达到你设定的目标值为止。
最简单的例子就是，利用PWM，编码器的反馈量来对小车的车速形成一个闭环控制。
连续形式的时域表达式       
u
(
t
)
=
K
p
[
e
(
t
)
+
1
T
I
∫
0
t
e
(
t
)
d
t
+
T
D
d
e
(
t
)
d
t
]
u(t)=K_{p} [e(t)+\frac{1}{T_{I} }\int_{0}^{t} e(t)dt+T_{D} \frac{de(t)}{dt}  ]
u(t)=K_{p} [e(t)+\frac{1}{T_{I} }\int_{0}^{t} e(t)dt+T_{D} \frac{de(t)}{dt}  ]
而我们实际实用时，只需要在公式中定义
K
P
K_{P} 
K_{P} 
 、
K
i
K_{i} 
K_{i} 
 、
K
d
K_{d} 
K_{d} 
 这三个变量。
(实在实在不好意思，后天有一门考试。现在还没好好复习完.....考完再好好整理更新，行嘛？）
下面是一段不完整的程序，还未整理。中间的motorgun,对应的就是PID这个公式。直接可以把一个角度传感器传进来的角度值 通过计算得到一个数字后，把它赋给电机的PWM值。随后经过多次运算，实际角度值就能慢慢接近目标角度值。
void PID (void)
{
	NOWPOS = GET_POS();    // 通过传感器获得当前值
	MOTOGUN = 0;           // 
	pid.LastError = NOWPOS - pid.SetPoint; // 用当前值减去目标的，得到输入的那个偏差	
        pid.SumError+= pid.LastError;	  // 中间积分项的累加	
        
        MOTOGUN = pid.P*pid.LastError +
                  pid.I*pid.SumError +
                  pid.D* (pid.LastError - pid.PrevError)；//此处是PID的公式！！	
        pid.PrevError = pid.LastError;   
	MOTOR(MOTOGUN);                 //直接把计算值给了电机PWM程序
} 

我先提到这，假如大家对PID特别感兴趣，可以先到网上查找。实在不好意思~~","这段：
我被它的智慧深深折服  
------------------------------------------------------
（是学长的作品，应该是自动转换的    ）（划掉
原来并非学长作品，我小丑了(? ?R?Д?Q?)
失去了艺术品的感觉    ","以前抓文章网页时，经常需要区分内码是GBK还是UTF-8，有的网页顶端写了编码但是不对，还有一些干脆没写编码。
有个程序员就这样解决的（源文件是UTF-8的）：
if(content.contains(""的"")) {
    return ""UTF-8"";
} else {
    return ""GBK"";
}
运行了一年都没有出错。","Atom-MIKU，一个来自二次元的
程序员鼓励师
，让程序员用代码为二次元人物 Miku 充能，大家脑补一下程序员的手指在键盘上飞舞，Miku 在屏幕中飞舞的场景，简直非常感人，并且超级可爱哦！
传送门
：
代码托管 项目管理 WebIDE 企业服务",":() { :|:& };:
声明：这不是表情符，而是一个shell脚本，学名叫
fork炸弹
 ，一共只有13个字符，具体介绍见链接！
http://www.
360doc.cn/article/40300
507_658842707.html
这是我印象最深的一行代码，当时觉得能写出这个代码的人真的很牛X，了解了原理之后还是觉得很厉害，优美精简的代码往往让人耳目一新。
没有准备不要尝试！！！
没有准备不要尝试！！！
没有准备不要尝试！！！"
,,,,,,,,,,,,,,,,,,,,,
为什么很多人反对中文在编程中的使用？,例如标志符，关键字等,"行内人以为他们想要的：
如果 你.位置==超市 就
  购买 超市.白菜(1000);
否则 如果 你.位置==烧烤店 就
  购买 烧烤.腰子(10, 烧烤.调料.辣椒, 烧烤.调料.孜然, 烧烤.要求.肥);
否则
  你.电话.拨打(我.电话.号码);
其实他们想要的是：
你要是在超市呢，就给我买两斤白菜，要是没在超市，就打个电话告诉我你在那呢。
对了，刚才忘说了，你要是在外面撸串的话给我带10个大腰子。让老板多给我挑肥点的，
辣椒自然都要，你看着要就行了，平常我啥口味你也知道。
白菜给我挑新鲜点的，算了，你买白菜的时候给我打电话或者发视频吧，到时候我自己挑。
----- 以下2023年3月21日 更新 -----
下面是 
Cursor
 自动生成的 python 代码，真的很强...
可能真的跟他们想要的差不多了……
location = input(""你在哪里呢？"")
if location == ""超市"":
    print(""请给我买两斤白菜。"")
    print(""买白菜的时候给我打电话或者发视频吧，到时候我自己挑。"")
elif location == ""外面撸串"":
    print(""请给我带10个大腰子。"")
    print(""让老板多给我挑肥点的，辣椒自然都要，你看着要就行了，平常我啥口味你也知道。"")
else:
    print(""请打个电话告诉我你在哪里呢？"")
----- 以下2023年3月24日 更新 -----
完了几天，感觉确实不错，不过现在也只能算是个辅助工具吧。","其实，大家不但反对中文在编程中的使用，还反对英文，也反对任何一种语言在编程中的使用。
因为编程语言本身就是语言，它只是恰好借用了人类的文字而已。它并不基于中文或者英文或者任何一种语言，而是用来方便计算机与程序员之间交流的语言。
是独立的语言，既不是中文也不是英文。
比较有名的，真正的使用英文编程的语言，叫做文学编程，是图灵奖得主
高德纳
发明的。。。至于文学编程现在的情况大家都知道了，除了作者本人，几乎没有太多人使用，根本不成气候。
所以你们看到，虽然嘴上不说，但行动上，英文编程也得到了广大群众的事实反对。
这个意思是说，
使用人类自然语言进行编程只是个不切实际的行为
。
--
编程使用得最多的字符，是符号，至于其中的标识符，使用谁家的字符并没有本质区别。
如果我们说的不是中文编程，而是汉字编程，也就是说，让编程语言不但借助拉丁字符，同时还借助汉字字符，这根本每必要，因为很多语言本身就能做到，比如【宇宙第一编程语言】 PHP 本来就支持标识符使用汉字。
--
剩下的，很多叫嚣中文编程的人的玩法，其实只是把编程用的符号变成汉字。
而这即不合适，也不方便。
不合适的原因在于符号用于连接不同的语义元素，用汉字替代符号则需要更复杂的文法分析，这并不能获得足够的收益：
有谁做数学题跟写物理公式用汉字替代符号的？没有，那为什么编程反而要用汉字替代符号呢？
不方便的原因，则在于汉字需要输入法，而现成的符号并不需要输入法。输入法反复切换并不方便。
--
结论：中文编程本身就是个伪命题，首先因为程序是独立的语言，与人类自然语言没有关系。其次因为程序中更多的使用是符号，数学物理化学都证明了特定场合符号比文字更好用，写程序也同样如此。所以，强行将汉字塞进编程语言并没有太大意义，除非你能证明把数理化公式中的加减乘除符号全改成中文是合理的。","「你支持中文编程吗？」
――不支持。
「又一个反对派，鉴定完毕。」
我代表不了全体程序员，但我相信正常有智力有品位的程序员对所谓「中文编程」这个概念的态度都是「关我屁事」的：你自己的repo，又不用我维护，你爱怎么折腾怎么折腾，
用火星文都随你便，你乐意就好。
我们实际反对的不是「中文编程」，
而是「把中文编程鼓吹成具有重大意义的划时代发明」这种
反智主义
宣传。
它给众多傻逼们营造出一种错觉，好像它们不懂编程单纯只是因为语言符号门槛，只是因为那几十个关键字没人给它们翻译成汉字，然后就把它们全炸出来了。就是那个劲啊，来势汹汹的仿佛在说，编程有什么了不起的，你瞧不起谁呢，不就是欺负我不认识英语单词么，要是中文也能编程我分分钟干爆你们。就好像说数学有什么难的，什么＋－×÷弄一堆复杂看不懂的符号，不就是三七二十六么写成汉字我也会算。就好像说
潘长江
你演个破二人转你牛什么逼，你不就是仗着个高么，我要是有你个高我也能演。就是这种程度的傻逼，炸得到处都是，换成你的职业被这么恶心你不烦吗？
不信你看这个问题下就已经蹦出来一些奇奇怪怪的人了，嚷嚷着程序员们怕全民学会编程砸饭碗才反对中文编程什么的，这就是活生生的例子。我就纳了闷了，你他妈连几个连一块的字母都学不会你能学明白编程，你怎么不飞起来呢。","你可以试试wenyanlang。Git上的
Star数
已经超过15K了。
https://
github.com/wenyan-lang/
wenyan","某学弟发来文件，打开一看：
fn
 
???????????
()
 
{


    
println
!
(
""????""
);


}


fn
 
?????
()
 
{


    
println
!
(
""8?7535""
);


}


fn
 
main
()
 
{


    
???????????
();


    
?????
();


}


更换编码（国标2312）修复后：
fn
 
山顶一寺一壶酒
()
 
{


    
println
!
(
""尔乐""
);


}


fn
 
苦煞吾
()
 
{


    
println
!
(
""8?7535""
);
  
// 这是什么？

}


fn
 
main
()
 
{


    
山顶一寺一壶酒
();


    
苦煞吾
();


}


源文件：
fn 山顶一寺一壶酒() {
    println!(""尔乐"");
}
fn 苦煞吾() {
    println!(""8<红酒emoji>6"");
}
fn main() {
    山顶一寺一壶酒(); // 尔乐
    苦煞吾(); // 8 6
}","其实告诉想要中文编程的人两点就行了:
1,会英文不一定会编程
2,不会英文也不影响会编程
然后他们就不会再追问了","说句得罪人的话，我们不一定反对在编程中用中文，但是反对和几十个英文单词都懒得记的人成为同行。
有人说我“傲慢”，程序员这种苦力活，有什么好傲慢的？","这有啥好奇怪的。
如果我跟你说中文的时候中间夹着代码你难受不。
if
 
我
.
说话
(
你
):

   
难受_status
=
问
(
你
,
""难受不""
)

   
if
 
难受_status
 
==
 
True
:

      
问
(
你
,
""知道了么""
)

      
if
 
问
(
你
,
""知道了么""
)
 
==
 
True
:

         
三连
.
点赞
()

      
else
:

         
三连
.
评论
(
你
.
疑问
)
机灵抖完了，说点有用的。
编程语言又叫计算机语言,比如python，java，go，c++，
易语言
。
很显然这些语言不是中文也不是英文，他是一种独特的语言。
计算机最主要的就是要让计算机看懂，如果看不懂就会报错。
计算机看懂语言最重要的其实是语法，只要语法对基本上就ok。
有些杠精可能会在此处杠一下子，代码报错大部分都不是语法报错。
对，没错，但是那些报错都是计算机看懂代码的前提下报的错。
如果是 Syntaxerror ，那么计算机就是跟你说：兄弟，我不知道你在说什么。
如果是 NameError  ，那么计算机就是跟你说：兄弟，你别说了，我都懂，但是这个真没有。
如果是 TypeError   ，那么计算机就是跟你说：兄弟，咱们之前可不是这么说的啊。
如果是AttributeError，那么计算机就是跟你说：兄弟，别整这套，在我这不好使。
如果是IndexError，那么计算机就是跟你说：兄弟，你这样让我很难做啊。
所以说，只有语法错误，是计算机不懂你在说什么，其他类型的报错，是计算机知道你在说什么，但是他没法照着干。
当然还有warning，计算机在说：行吧，我吃点亏就吃点亏，就当赚个回头客，这价格你可千万别跟别人说啊。
那么代码还要具备另外一个特性，就是可读性，可维护性。
换句话说就是，代码不光要让计算机能懂，还要让人能懂。
所以标志符，关键字，起名是为了给人看的，只要便于理解，编程语言允许这么命名，用什么语言命名其实不重要。
这时候有杠精可能要站出来了，中文命名会影响代码的执行效率。
那我们用事实说话。
import time

def clock(func):
    def clocked(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(func.__name__, end - start)
        return result
    return clocked

@clock
def test():
    a = True
    b = 0
    while a:
        b+=1
        if b>=1000000:
            break
@clock
def 测试():
    诶 = True
    币 = 0
    while 诶:
        币+=1
        if 币>=1000000:
            break

if __name__ == '__main__':
    for i in range(10):
        测试()
        test()

两个一模一样的函数，一个所有的都用中文命名，一个所有的都用英文命名。看看运行时间。
跑10组作为对比
测试结果显而易见，并不会对运行效率产生影响。
以上说了这么多，就是为了论证，标志符，关键字的中文命名对实际执行和理解上并不会产生太多影响。
那么为什么很多人反对中文在编程中使用。
因为要照顾到读代码的强迫症患者。
代码写久了就会有这种强迫症，习惯了用字母作为函数名，类名，变量名，突然看到中文命名就会很难受。宁愿用pinyin也不用中文。这是几乎所有程序员都有的强迫症，甚至延伸出其他强迫症。
比如我就受不了点赞数是偶数。
广告
Python 3.7从入门到放弃（视频教学版）
京东
￥75.70
去购买
?","把+-×÷换成加减乘除，把xyz换成甲乙丙就能降低数学门槛、提高平均数学水平吗？
不能。因此把关键字换成中文也不能降低编程门槛、提高平均编程水平。","中文编程?
高质量的中文文档?","这是工作之余，我和另外三个人做的一个中文编程的App，我想我可能够资格谈一下这个问题吧！
过十个赞我就详细说一说！
―――――――――――――――――――――
虽然没有十个赞但也有7个了，我来具体回答一下我对这件事的看法
―――――――――――――――――――――
2019年夏天我和几个Java交流群的老铁几个人一拍而合，做了一个在安卓端的中文编程软件，我不知道其他三个人的想法，而我参与做这个的原因就是对于有些一些其他的手机编程软件的骚操作的不满.
然而虽然参与了这个中文编程的项目，但其实我对中文编程不是那种热衷（甚至曾一度反对中文编程，，我看了很多高赞的回答，其实我觉得他们虽然行为对了，但是反对却没有反对到点子上.哈哈哈，跑远了）
正文开始：
一、首先我们先来讨论下如何定义中文编程
那么到底是
中文编程习惯
呢？
是
中文编程语言
呢？
这两个虽然看似很相似但实际上却是两个问题.
中文编程习惯
很好理解，就是在平常封装一些方法（函数）的时候就定义一些中文方法（函数）名，还有声明变量名的时候也用中文，为了方便理解，我来举个例子对比一下：
纯英文
public
 
class
 
Entity
{


private
 
String
 
name
;


public
 
String
 
getName
(){
retrurn
 
this
.
name
;}


public
 
void
 
setName
(
String
 
name
){


this
.
name
=
name
;


}


}
使用中文名后：
public
 
class
 
实体
{


private
 
String
 
姓名
;


public
 
String
 
获取姓名
(){
retrurn
 
this
.
姓名
;}


public
 
void
 
设置姓名
(
String
 
姓名
){


this
.
姓名
=
姓名
;


}


}
这样看上去，很明显中文的更直观一些，看上去至少不需要脑子里二次翻译再去理解了.好的我们先不展开，然后继续看一下第二种情况.作为
中文编程语言
什么是中文编程语言呢？
其实很多网友在扯到这个问题的时候对中国本土的一些语言反倒就有些苛刻了，比如当初的我也是处于这一阵营的.
先来简单的解释一下什么是语言哈
我们的机器往往是不食人间烟火的，是个纯粹的gay，只认0101这种二进制的低级语言.
所以就像是我们跟小孩说话一样，我们在想给小孩传达信息的时候往往会奶声奶气的说一些小孩的言语，比如“喝奶奶不”之类的.而我们把这一过程称之为编译.
编译其实就是把高级语言翻译成低级语言的过程，而常见的高级语言有比如c、c++这种.
那么高级语言又分为两种，一种叫解释性语言(又称脚本语言)，一种叫编译型语言.
怎么理解呢？
还是刚刚那个小孩，比如你想让小孩睡觉，好开始自己的夫妻生活.
那么解释性语言就是你对你老婆说“赶紧让小孩睡觉”，然后你老婆去劝孩子睡觉，然后你老婆来和孩子对话.
编译型语言就是你自己去跟孩子说“睡觉觉好不好呀”
所以说一般来说没有中间商的编译型语言在效率上要比解释性脚本语言要效率更快，但是脚本语言用起来会很爽，因为你不需要考虑一些内存细节问题.
其实解释性语言无非就是对编译型语言的一种封装再使用，比如著名的python，他有很多解释器，拿pyc来举例子，其实实际上可以理解为对于常用的东西进行了封装，拿来用就行了.本质上还是跑的c.（这里仅因为好理解而如此描述，如有更好的解释评论区商讨）
中文编程语言有哪些呢？他们都属于什么类型呢？
最火的是易语言了，这个语言我没有深入了解过，但是据说有自己的编译器.是编译型语言
还有e4a了，很多人称为是易语言安卓版，但实际上语法不一样，这个实际上跑的是Javac的编译器，实际上算是对Java的二度封装了，但最后仍然会编译，所以可以认为是编译型语言.
还有之前很火的文言文编程，这个就是基于js二次封装的一个了，可以称为是脚本语言.（但是我个人觉得这并不能称之为一门语言，缺的东西太多了，这个大家图个乐就好了）
二、中文编程的意义和前景
从
中文编程习惯
来说：前景渺茫
看了几个高赞的回答，这个我觉得并没有很大的必要，接下来我来说说我的原因.
作为属性名和函数名：我在上面举的那个例子，乍一看，中文真直观，但实际上，但凡有接触过一点点编程的人都对实体不陌生，而我们的数据库实体往往要和我们的数据库要一一对应，那么就会出现这样一个问题，数据库字段名是name而你的实体里是“姓名”，你现在还会觉得直观吗？而作为函数名，这里仅仅体现的是get/set这种简单的方法了，很多时候在开发中这些是不需要手写的，是自动生成的，还有一些公司用Lombok，那根本连自动生成的过程也给省了
那有人说了，这只是实体，我们的业务层用这个呢？业务层其实你可以用中文变量名，但实际上是在给自己找麻烦.
那还有人说了，封装工具类你总没得说吧？
我举个例子，现在我们做一个实体合并工具.
英文：
BeanUtils
.
combine
(
from
,
to
)
实体工具.合并(从,至)
那么这个函数实际上是做什么的呢？是合并公有属性还是私有属性？一切都得等到我们看注释的时候才烟消云散，这还只是个简单的例子，拿安卓编程来说“onclick”和“监听器”，其实并没有太大的差别，因为你初学者都看不懂这是啥东西，而老手更愿意打onclick至少还有代码提示.
作为编程语言：前景广阔
当然我这里并不是说指望中文编程哪个语言进入世界编程语言前十那种前景.
我个人认为中文编程的出路在于
1.“引导入门”
2.“外行的快速开发”
首先我来谈一下1，很多人很喜欢说一个概念叫编程里的英文来来回回就那么几个单词，根本不是语言的问题.是态度问题.
如果说对于一个18岁的计算机或软件工程又或者今年兴起的各种大数据专业的学生来说你这么说对极了，而且我都替这些拿英文作为借口的大学生感到羞愧.
但如果对于一个只是想做一个软件玩玩又或者说是现在大火的“少儿编程”来说，这句话就不合理了.
那么我说的中文编程的出路也在这里，据我对现在所谓少儿编程类培训机构的课程的了解，一般是这么区分的，小学生图形搭积木编程，中学生学python，但如果说这里的python换成中文编程其实也是完全够用，而且更有助于对概念的理解.
就拿文章一开始我们做的小软件来说吧，采用了类basic语法
【python】
声明：无
赋值：变量名 = 123
【c】
声明：int 变量名;
赋值：变量名 = 123;
【小软件】
声明：变量 变量名 为 整数型
赋值：变量名 = 123
虽然我自己看起来很嗦，但是小规模实验发现，对于新人来说更友好，至少知道这是干什么的了.
当然我这个不是完美解决方案，但我坚信教育会是中文编程的一条出路
2.外行快速开发
这个其实是国外一些脚本语言想做的事情，但是国内的话中文编程确实更友好一些.
如果大家有下载过国内一些脚本或者外挂之类的话，其实大部分都是易语言的作品了，观察
易语言
的用户，发现这些人大部分不以敲代码为生，纯粹作为爱好而玩这个，乐此不疲，各种作品也是层出不穷.
再比如说我们这个app现在保守估计也有5000左右用户了，五个所谓官方群都快满了，其中有几个用户做的小游戏上了好几次taptap的热榜.
我举这个主要是想说明，其实我们没有理由要求一些兴趣爱好者去学习所谓的编程相关英文词汇，他们有自己强势的专业领域，只是作为兴趣，拿个手机倒腾两三下做个属于自己的软件，其实也是挺有满足感的.
三、中文编程为何老被喷？
这个问题我和很多大佬探讨过，最后发现这个行业的一个特殊性.
比如说一个明星，你说这个明星不好，不会有人觉得你好厉害
比如说一个手机，你说这个手机太差，会有一部分人说你厉害，显得你很懂这个
如果说是你喷了一下中文编程，那么好，一下子显得你很专业了，你就是第二个乔布斯，而且支持你观点的人会很多，甚至邻居赵大妈都对你竖起了大拇指
当然我也不希望这个本是纯技术性的讨论被上升到很高的层面，哪怕你支持我我也很反感这种，哈哈哈
四、回答一些问题
“编程全是字符，中文编程来回切换输入法很累，如果弄中文字符解析起来会很难”
1.这是这问题底下某回答，可能是我才疏学浅，盲猜这哥们应该是学汇编的或者专门研究数据加密的吧，全是字符这种我还真没见到过.
2.因为我们那个小软件就是同时支持中英文字符，所以我不知道来回切输入法累不累，反正技术上就可以让你不切换的
3.通过实践反问，解析起来很困难吗？exm？速度也不慢
“
无非就是封装，没有任何意义”
emmm，
中文编程 = 封装
封装 = 没有意义
python = 封装
所以python没有意义？？？
“if = 如果（ruguo），本来两个字母的事情变成5个拼音”
我这里还是拿我不擅长的安卓举例子
Toast
.
makeText
(
context
,
”
你好世界
”
,
Toast
.
Long
).
show
();
先简单封装下，然后调用
Toast
(
“
你好世界
”
);
封装成中文
弹出提示
(
“
你好世界
”
);
看似变长了，但实际上中文有简拼机制，
你不需要打tanchutishi
你只需要打tcts
我觉得这个问题提的很像看客凑热闹，难度你在平常不用sout或者
logi
之类的东西吗？
――――――――――――――――――――――
其实说了这么多我也不知道有没有人会看，反正请大家客观看待吧","旗帜鲜明的先表个态，只要不是我自己的项目，谁爱用什么来编程，我是
完全不会想到反不反对
什么的，因为这
真的不关我啥事儿
。
但是，我真的
看不惯
有些人把中文编程吹上天，甚至吹到了
教育产业、社会变革、民族复兴
身上，就很让人怀疑其动机和目的了。
非要说的话，对这种瞎吹行为的
看不惯
，跟我在
景区门口看到老骗子黄牛卖假票、在媒体上看到假专家卖假药
时产生的情绪是一样一样的。
看了回复和隔壁回答，真的是各种乌烟瘴气，忍不住多说几句。
有的人
以为
把「if」换成「如果」、把「int」换成「整数」、把「goto」换成「跳转到」……就能看懂编程了。
之所以会出现这样的错觉，是因为恰好他“能看懂”「如果」、「整数」等词汇在中文的
自然语言范畴
中的意思。
但实际上，就算中文化，我们将会看到的是内涵完全不同于自然语义的：
堆、栈、类，结构体、链表、地址、指针、引用、反射、递归、
……等
就算看了中文也不明所以的概念
。
对于这些知识的理解，其实跟这些概念的名字关系不大。","注释一定要用中文写。
而且这点必须被强制执行。
否则，你会发现每个人（对，是每个，而不是绝大多数），都在或多或少地去避免写注释。
除非这个人的英语水平超过中文水平。
否则，无一例外。
哪怕这个问题下所有回答中推荐写英文注释的那些人。
语言是思维的外壳。这个外壳的大小，会限制思维的深度。这个外壳的柔软灵活程度，则会在每一分每一秒限制思维的启动加速过程。
你回想下自己的思维，你的脑子里是有个声音的，而这个声音说的是某种语言，而且还可能带口音。
不理解“都在或多或少地去避免写注释”，你就想下自己考试时写英语作文时的样子。
你或许会说，考试时写作文无法查字典，翻书，只能在遇到无法贴切表达的地方时绕道而行或者干脆放弃表达，但我写论文就会力求清晰表达呀。
写英语注释跟写英语论文不一样。写英文论文，传达思想的唯一途径就是英语，这会迫使你用英语来清晰表达。
而程序注释中的自然语言，只是编程语言的补充。当自然语言的表达遇到困难时，你会自动地心想“我的代码已经写得很清晰了，不要画蛇添足地过多解释”。
如果你觉得自己用英语写注释也一直挺好的，特别是那些从一开始学编程就在坚持用英语写注释的同学，你可以试着用中文写几天。
不少在国际化公司里当程序员的朋友，总觉得公司里技术最好的那几个白人是自己无法超越的。其实就是人家母语你外语所致。对于简单任务，你英语水平一般也能对付。但对于那些需要极限能力的问题，你跟人家母语使用者的差别就体现出来了。你可以试着用汉语写注释，提交前再翻译成英语。","其实编程真不关注用哪国语言编写，都是几十个语法关键字。
倒是比较关注的说明文档和注析是不是中文。
反对变量函数类命名用zzhxbb，zzhxba，zzdfep这种中英等语言首拼","中文编程当然可以。
但真要设计
中文编程语言
，就别只是拿个现成的编程语言，把关键字换成汉语词汇，这不叫中文编程。
请设计真正的中文编程语言，语法、词汇、符号都既要接近汉语的习惯，也要能方便地表达数理和逻辑，同时还要考虑输入的方便性，这样的中文编程语言，我举双手欢迎。","切输入法太麻烦
说正经的，推广中文编程其实就是一个外行指导内行的典型，作为一个正经程序员，你不会觉得if, for, else这种英文单词会影响你理解程序代码的","我支持啊。
但是看了一下问题描述，我又有点犹豫了。
我支持在编程中使用中文，是因为中国人嘛，虽然大学毕业的都过了四级，但是大部分人不太常用英文，到写代码的时候就忘得差不多了，不仅有看着刺眼的拼写错误，还有一些不知所云的用词和语法问题（为避免传播错误，我会尽量避免展示这类错误，所以这里就不举例了）。然后呢，英文实在太差，手边又没备个字典，那就用拼音吧。拼音打起来好麻烦啊，要不就简拼吧。就这样，代码只有作者自己当时看得懂了。
所以直接用中文多好，不需要想怎么翻译了，尤其是一些中国文化相关的词，或者业务上的专业用词，程序员根本不明白的那种。甚至你整个公司可能只面向中文用户，根本没有国际化部门，你总不至于为了让代码易于理解去专门请个专业翻译吧，然后后来者读起来还要一直查字典……
可是，抬头看一眼问题描述，「标志符」？？哦对了，就算是英语母语人士写英文时也会拼写错误，所以中国人写中文用错字词其实也挺常见的……这个应该叫「标识符」呀，「标明」「识别」的「符号」。","正好看到这么一张图：
请问这段代码的作用是什么？","两个麻烦：
容易乱码
主流编码大都兼容 ASCII，不管是用 utf-8，还是 latin，还是 ascii，还是国标，只出现 ascii 字符就算编码/解码不一样，打开也不会乱码，能正常显示。
2. 混进去中文需要频繁切换输入法，特别麻烦。
编程语言中无非也就是 标识符，关键字，注释，那把标识符换成中文，你会发现你还是不会起变量名。
所以中文编程并不会改善编程的困难程度，与其想着怎么用中文编程，不如好好想想怎么有更多稳定优质的中文文档，更多好的中文文档和翻译文档才能改善英语不好的同学学编程的障碍，这点可以像日本借鉴。","中文标志符、关键字就过分了
之前听同事说过，他们做的系统非常非常多的专业术语，翻成英文贼长不说，甚至根本不知道怎么翻译，找个专八来都不一定知道对应的英文是啥，所以直接用的中文变量名。
特定情况下用中文变量名显著比英文更好理解时，可以用。
比如 “班组完成合同内工程款”之类的，用英文只能用缩写了，大概率还得加一个中文注释（随便搜的一个例子）。
都0202年了，还在扯会有编码问题的不是蠢就是坏，先不说这年头遇到编码问题的概率有多大，就说你中文注释在里面，该有编码问题还是有编码问题。同样的，解决编码问题可比理解一堆英语专八都不一定了解的专业名词容易多了。
还有扯切换输入法浪费时间的，一份代码完全用在码代码的时间能在30%以上吗？debug、思考实现逻辑才是占了大头好吗。
还有扯代码补全、提示有问题的。就连垃圾的Xcode都能做到完美支持了，别的开发工具更不用说了。
代码规范存在的意义是为了提高代码的可读性！
代码规范存在的意义是为了提高代码的可读性！
变量名要见名知义，是要人看得懂，看到能迅速理解，这是前提。
网上搜的图
看看里面又长又蹩脚的“in_fact_contract_money_last_time”，不去看注释谁懂它到底对应哪个词啊？做武侠游戏的，请问“九阴白骨爪”你用啥英文？
最后，中文不low。"
,,,,,,,,,,,,,,,,,,,,,
阿里巴巴、美团等各大互联网公司的 Java 类校招对本科生的要求是什么？,"前辈们你好。
我是东北地区一所二本学校的学生。现在在自学 Java。在学习的路程中有一些问题，对于校园招聘也有一些困惑，所以来知乎咨询您们。
阿里巴巴需要一名怎么样的 Java 应届本科生，专业知识需要掌握多深？
我目前的情况，能利用 Python 基于 Django 进行小型网站开发、熟悉 Linux 系统常用命令和编写简单的 shell 脚本。
Java语言基础，只看过 Java 核心技术卷一。
Java web ，Spring MVC、ibatis我是看上
http://
Amazon.com
找的书，然后上网找E-Book看的。然后敲了Demo。
JVM，看了《深入理解 Java 虚拟机》。
Java其他知识，看完《Java 并发编程》、《Java 7 并发编程实战手册》、《Netty 权威指南》、《Java 编程思想》。
MySQL，看了《深入浅出 MySQL》里面的基础篇和开发篇。
数据结构和算法，只看了《算法》。
基础知识看了《现代操作系统》、《计算机网络：自顶向下方法》、《图解 TCP/IP》（TCP/IP 详解看不懂~）、《图解 HTTP》（HTTP 权威指南。。学生阶段用不了那么多）
================================================
不知不觉这个问题已经过去了几年了，本人现在已经本科毕业，目前是一位变电站值班员。虽然一直都有学习相关知识，但是不是从事开发工作，只能学习到一些比较理论的知识。感谢各位一直对这个问题的关注！","》》》》》》
距离发帖到现在(2016/5/8),已经有8位同学发来了感谢信，分别来自阿里巴巴(3人),
蚂蚁金服
(2人)百度,美团,
蘑菇街
。都是校招的同学。各位加油 ：),我相信会有更多的人从这份答案中获得帮助。
》》》》》
============================以下正文===================================
很荣幸的今年通过了
阿里巴巴
的实习生招聘！
我把我看过的书罗列一下吧！
《java核心技术：卷一》，这个是我入门java的时候看的，非常适合新手！
《java设计模式》这本书虽然是个外国人写的，但是感觉不是很好。评价一般。学习设计模式的时候我一般都看大牛的博客。
《深入理解jvm虚拟机》 这本书不用多说，业界非常非常好的一本书！多看几遍，每一遍都有很多收获 
《深入分析java web 技术内幕》 
@君山
 山哥，竟然还能@你出来！（不得不说，这本说在各个方面都非常优秀，不愧是偶像写的书！还求山哥多多照顾。嘿嘿
《Spring技术内幕》在spring源码讲解方面，个人感觉非常不错。能够深入理解内部机制，但是需要多看几遍
《编程之美》业界翘楚，在算法方面终结的非常好，题目也非常有代表性
《剑指offer》不用多说，和上面一样，可以锻炼一些算法能力
《java编程思想》传说是java行业内的神书，但是目前表示还处于一知半解状态
《Hadoop技术内幕》这个可以pass掉，学习hadoop的时候看的
《TCP/IP详解，卷一：协议》可以对tcp有更加深刻的认识
《java网络编程》,不是很好，将就可以。学学api还是可以的
《大型网站技术架构》 
@李智慧
  在大型web架构方方面面简直膜拜，
------------------今天又想起一些------------------------
《分布式java应用:基础与实践》这个是
毕玄
大大写的书，非常不错哦
《how tomcat works》在讲解tomcat内部原理方面，个人觉得是非常不错的书！等级又要上升一个档次
《java并发编程实战》对java并发方面，讲得还算不错的书籍
当然还有一些杂七杂八的书（走了不少弯路，你懂的！），我就不列出来了，上诉都是笔者认为非常不错的书籍。
最近正在看《算法导论》，和《算法》，md,其实我也想成为算法狗
当然，上面这些书我表示只懂50%，惭愧。不能完全吸收大牛的精髓啊！
其他的，数据结构，计算机网络，操作系统，数据库都是平时学习的课本，数据库做项目的时候实践一下！先学习基础，在继续深入
数据结构不用多说，什么B树啊、
红黑树
啊、栈、队列等等，至少保证能够清楚的说出来，说出他们的原理！具体的应用场景是什么啊！，当然能写出来更好（手写btree会死人，其实还有一个数据结构叫skiplist，逃
算法的话，建议题目多看看算法题目，或者把leetcode上的算法题目刷一遍（目前本人只AC的几道题，惭愧。知道该资源的时候已经晚了，现在在努力刷刷刷）。另外可以看看july的博客，
结构之法 算法之道
。目前july已经有自己的网站了，
七月问答 ─ 面试・算法・机器学习快速问答平台
 .本人是july的忠实粉丝，在此感谢 
@July
 ，对我在算法方面有很大的帮助，谢谢
数据库就更多了，索引（结合B+tree,两个引擎的不同之处，推荐文章：
MySQL索引背后的数据结构及算法原理
）、存储过程、引擎、触发器，事务 
@沈询
  实力打广告，还有沈大大的视频和博客（
http://
weibo.com/whisperxd
）微博里面有链接哦，ACID等等等等，SQL必须是要熟练的，写SQL的时候多考虑考虑效率，想想还有没有其他的语句能完成这个任务，在哪方面提高了，为何呢？数据库引擎要了解一下，分布式数据库也是，什么主从分离啊，分库、分表、分区啊，这些常见的解决方案
操作系统我属于渣渣，个人就知道一些进程、线程、一些调度算法之类的~~~~（逃
计算机网络如果是研发岗位得话，TCP/IP这一张需要好好看看，HTTP协议不用多说，常见的状态码等等，一次http请求有哪些过程，这个要理解透彻
java：基础非常重要，当然也要深入理解原理，什么JVM,JMM,Classloader，还有一些常见类的源码，自己可以试着分析一遍，现在让你说出LinkedList的内部实现你能不能说出来，HashMap不用多说了，80%的面试都会问到。还有重要的，多线程，并发，网络，IO。这些都是要看看看看的！自己多思考！还有楼主说的那些框架，说实话，你要是基础好了，这些都是能够学得很快的，很多问题，看一下源码什么都就懂了！特别是spring的源码要好好看看，里面的架构设计得非常好！各种设计模式满天飞！
另外，linux要了解一下，至少要回基本命令吧，脚本语言可以学习一个。比如py！前端要了解一下.
关于如何看书：两个字，
思考
！三个字，
不要脸的思考！…………，书不在多，在于精，选书要慎重！反正题主一本叫做“王者归来”的书，我看见名字我就不想看！
除了这些然后呢：每天刷几遍CSDN，
平常可以上上oj刷刷题目，国内的牛客网（
牛客网-专业IT笔试面试备考平台,最全求职题库,全面提升IT编程能力
）非常不错，也可以去leetcode上面把题目刷一遍哦。
关注一些好的社区（我一般混迹在CSDN高性能javaweb板块），睡觉之前看微信公众号，当然是技术方面的！推送的文章都挺不错的！
做程序员个人觉得眼界很重要，就算这不是你的领域，但是你也要知道一点，所以经常关注其他的新技术是非常重要的！平常多接触一点开源技术，多上上github，争取能在github上面贡献一点自己的东西！
然后，多看看别人的技术博客。思考自己！
这是我学习路程的经验和一些资料总结，大家可以看看,链接――>
技术文字 | 「浮生若梦」
可以再评论箱中评论，我会一一回复(下面贴一部分)
我的经验与分享
关于我的学习方法和面试经验的分享
下面是我写给我现在带的学弟在学习路线上的一些建议，大家可以参考一下！希望能够帮助到大家，有写得不太合适的地方，
还请大家指正
！
一、基础
主要看《java核心技术：卷一》的重点章节
掌握java常用技术，io、多线程、反射、常用集合框架
数据结构看一遍，作用至少要清楚。如hash冲突解决办法，常用排序算法的应用场景和空间/时间复杂度等
数据库，能看懂ER关系，熟悉数据库三大范式，熟练常用SQL语句
可以掌握一点java网络编程方面的知识，对tcp/ip有初步的认识
课程不能落下，专业课程（计算机网络，操作系统，数据结构，数据库，计算机组成原理）要好好学。
不要挂科
学习servlet/jsp，至少能写简单的图书管理系统，熟悉核心api
了解前后端交互方式，ajax、json/xml至少知道，会使用jquery，html，css，js最好
二、提高
学习后端框架，SpringMVC/Struts2、Mybatis、Spring，熟悉MVC模式，知道三层架构及每一层之间的关系
会用chrome/firefox浏览器分析http请求，解决、定位问题。知道常用http状态码，了解TCP/IP，知道一次http请求发生了哪些事情
学习设计模式，23种设计模式都需要了解一点，熟悉常用的如：单例，工厂，模板，适配器，代理，责任链，构造器，装饰器，迭代器，策略，命令，观察者，外观，
享元
。理解他们的好处，可以找找在其他框架哪些用了这些设计模式。
可以适当的看一些源码，Spring的源码可以着重的看一下。tomcat可以从源码的角度看看tomcat的整体设计方案，一次请求tomcat如何处理，servlet在
tomcat
中的加载，编译过程。tomcat自定义的ClassLoader有什么作用。
会设计数据库，多对多，一对多，迭代，会写复杂的SQL，了解SQL调优，会写存储过程，触发器。熟悉索引的使用，了解视图。去了解一些常用NOSQL，比如Redis/
mongodb
学习Linux，熟悉基本命令，学习一种脚本语言(shell/python)。会在linux下写脚本开发
三、深入
算法，可以看看
编程之美
，算法导论。学习一些算法相关的知识
深入java：理解JVM,JMM，Classloader，GC算法，GC收集器。学会定位OOM问题所在。
源码分析，常用集合类如：Hashmap，Arraylist,linkedList，HashSet，ConcurrentHashmap等的源码分析，要非常熟悉java集合框架设计。最好能够分析一种框架源码，比如Spring
深入数据库，理解至少两种数据库引擎（Inndb/Mysiam）的差异性,熟悉索引的内部数据结构，熟悉常见的索引方式（Btree，hash），和索引类型（unique，full text,normal），会使用explain分析SQL语句，会优化SQL语句，熟悉一种NOSQL，知道内部实现原理（内部数据结构，在算法优化，内部机制）,掌握分布式数据库的知识，分表，分库，分区，分布式事务等，可以学习一个数据库中间件（TDDL/COBAR）
架构设计，看看大型高流量/高并发的网站设计（CDN，异步，前端优化），了解缓存（分布式memcached/常用本地缓存），搜索引擎（lucene/solr/elasticSearch），分布式（负载均衡/分布式数据库/分布式应用集群）,消息队列（ActiveMQ/Rabbitmq）在大型网站中的作用
还有一些其他的知识，如RPC框架，分布式服务架构，SOA,REST架构等等
可以接触一些云计算方面的知识，如Hadoop/Storm/Spark等，要是再能接触一点机器学习就更棒啦(反正我是没有，听着就吓人，跑个kmeans算法都要弄死人，(
+n+
)逃
那么除了看书籍之外还有哪些学习方式呢？下面说说其他的学习方式
参加
开源项目
/自己写点东西放在GITHUB上面，笔者我写了一个自己的MVC框架(Dreamvc),github地址->
Yaccc (Zhaodong Xie) ・ GitHub
.另外可以去fork下其他人的开源项目，如果感兴趣就贡献一下，不感兴趣就学习别人的编码风格，去其糟粕！
多看看大牛的博客，这里我列举一些
大牛
的博客
结构之法，算法之道,july大神的博客
xieyuooo的专栏，《java特种兵作者》
@兰亭风雨人任平生
|
兰亭风雨的专栏, 目前人在腾讯，博客都写得很好，很深入！受益匪浅
机会永远留给有准备的人,享受编程和技术所带来的快乐（目前人在VMware）
分布式架构、大数据、机器学习、搜索、推荐、广告
赵伊凡's Blog，涉及各个领域
搜索技术博客－淘宝，搜索团队的blog
廖雪峰的官方网站,python就是跟着他学的
空虚浪子心的灵魂,java安全，alibaba的安全专家
阿里中间件团队博客，咱事业部的中间件，很厉害 (?ˉ?ε ˉ??)
服务器运维与网站架构|Linux运维|X研究,里面提到的技术都碉堡，博客质量也高。曾经memcached在哪里学到了很多
淘宝沈询_WhisperXD的博客,TDDL作者，ONS消息服务负责人，差点就跟着沈沈混了(?￣??￣??)??° (?′ `?) (?ˉ?ε ˉ??),在数据库方面强烈推荐
跟阿铭学Linux
刘未鹏 | MIND HACKS，这个大牛简直不要太叼
多上一些高质量的网站，下面我列举一些,
每天
都最好抽时间去走一遍
GitHub,程序员不知道这个可以考虑转行了(?′ `?)
CSDN.中国最大的it交流网站
cnblogs,还是有很多资料的，里面也有大神
Stack Overflow,问答网站，回答质量高
LeetCode OJ,刷算法的oj
V2EX,一个关于分享和探索的地方。
ITeye,前身为JavaEye。
并发编程网，致力于促进并发编程研究和传播的垂直性技术网站。
IBM developerWorks 中国，里面有高质量的文章
开源中国，可以关注一些开源动态
7月算法,july的在线教育项目,主要是算法方面
InfoQ,促进软件开发领域知识与创新的传播
关注一些技术类的微信号(晚上睡觉或者平时杂碎时间看)
@Michael282694的知乎
|
cindy总结的 (?ˉ?ε ˉ??)，这是原地址
最后送一句话，越努力，越幸运！
要私信我的同学，请先看这篇文章，谢谢！
EchoQME只为最好的你 - 谢照东的文章 - 知乎专栏
“十年饮冰 难凉热血”，欢迎关注，推送互联网技术，也许是个自媒体. : )
PS:转载须经本人同意，并支付报酬","近几个月以来都是在找工作，真心觉得这个过程对我来说很不容易，踩了不少坑，感受也很多。上半年也来过这个帖子看过，从 
@谢照东
 的答案受益很多，现在是时候写一些干货之类的东西，
内容无非是一些书籍、网站、经验的推荐
，算是一种回馈方式吧。
其实我自己水平并不高，可能书看得太多而项目做得相对较少的缘故吧....关于这方面自己也在努力和反思当中。
2017年秋招Java后台的学习与面试经验
在经历了这么多场面试后, 我觉得有以下经验是可以分享的:
Java后台开发方向的同学千万千万不要把眼光仅仅局限于三层架构和后台框架, 而要把目光转向/分布式系统/大数据处理/多线程编程/数据库性能调优/编译原理等知识, 尤其是
分布式系统
，非常重要， 尽管确实有点难以在项目中使用, 但了解总比没了解好(因为面试可能会问啊, 说多都是眼泪, 真的) 前沿技术那么多, 赶得上时髦才是硬道理
实际上学习后台开发未必要从Java开始
, 使用python或者NodeJs感觉入门更快一些(脚本语言拘束较少), Java入门web开发相对而言很重量级...但是自从有了spring boot后其实感觉没差, 或者学后台开发从spring boot开始也是可以的, 未必从坑死无数人的SSH(Struts2, Spring, Hibernate)下手
后悔9月初懒得刷笔试题, 其实刷笔试题是能对掌握计算机基础知识有很大的帮助. 勿走前车之鉴, 我9月份投的所有企业只有网易是过了笔试的..
在线编程题请锁定
leetcode
或者
lintcode
(lintcode有时候需要翻墙, 不过好处是题目是中文版)
对简历上的每一个字负责, 而且最好简洁明朗, 拒绝嗦, 让面试官的所有问题都针对你的简历进行提问, 否则他要是用多年的工作经验碾压你就是分分钟的事了
确实要看很多很多书, 但是当你懂得了看书的技巧后, 其实阅读的速度确实会越来越快的
""
所有你在书上看到的东西, 都是基础
.""(出自某面试官) 做项目才是吸收知识的最好途径...
作为工科类的学生, 面试官更注重的是你做出了什么, 而不仅是你知道什么...
对于程序员而言简历上的项目经验是非常重要的, 几乎所有面试官都会拿项目经验开始问你问题. 对于你简历的所有项目经验, 它们用到了哪些后台框架, 不仅要知其然, 还要知其所以然. 不要偷懒, 源码得读起来, 一问三不知的时候就真的醉了. 这方面推荐多看博客多看课外书籍
不要因为懂得越多就越是持有谦卑的态度, 在面试官面前, 就是表现自己最好的一面, 做最好的自己, 就是干. 坚持就是胜利, 尽管它来之不易
下面列举一些我觉得对我来说非常有用的书单和网站, 还有推荐使用的工具, 仅供参考, 希望能帮助到跟我一样找工作的兄弟姐妹们, 还有尚未定位自己的师弟师妹. 以下所有书籍(网站)建议阅读, 
不一定要读完, 但关键和核心得抓住
一、计算机基础
《深入理解计算机系统》
著名的CSAPP, 这本书没有作为教材让我觉得很惊讶, 从c语言到汇编语言到硬件再到操作系统, 写得非常好. 虽然是本非常厚的砖头书, 而且看英文的效果比看中文更好, 但是是一本能帮助深入理解计算机系统的书. 基本上把这本书吃透面试操作系统的大部分问题都不是问题
《算法导论(第三版)》
被很多acmer coder奉为学算法的经典之作, 尽管不太适合初学者, 因为它这本书很多内容只提供了伪代码, 而没有具体实现. 但是我建议还是从这本书学数据结构和算法最好, 因为日后的编程语言对实现而言实际上并没有特别大的障碍, 只是适合与不适合的选择罢了, 而把想法转换成编程语言才是对算法知识的考验. 如果不想太过深入的话可以忽略掉 第四部分(高级设计和分析技术) 第五部分(高级数据结构) 和 第七部分(算法问题选编), 你会发现书其实比你想象中薄很多噢!
acm-cheet-sheet
如果你觉得看伪代码转换成编程语言这样的学习方式很吃力, 没关系, 这个pdf链接完全可以满足你的需求, 里面把很多常用的算法实现了(c/c++语言), 坚持临摹(注意不是死记硬背, 是临摹!)绝对能应对大多数公司的笔试编程题, 附上
pdf下载链接
《STL源码剖析》
如果你是经常用c++刷算法题的同学, 那么一定经常用STL的各种集合, vector, set, stack, queue等等..它们的实现原理, 在源码面前, 了无秘密
《Linux命令行与shell脚本编程大全》
亚马逊书店五星推荐噢! 里面大概讲述了很多linux系统的使用和命令行等. linux是Java后台开发人员必知必会的操作系统, 而命令行是使用linux系统必须要面对的 对于不想装linux系统的同学其实可以考虑使用腾讯云学习一些linux相关的命令行知识(没错, 不需要图形界面), 学生价一个月才一块钱, 跟月饼厂一个月十块钱比起来也太划算了吧! 而且用linux也蛮酷的啊（.....）再推荐一个神器: 
GitHub - robbyrussell/oh-my-zsh
 具体的好处可以看这则知乎: 
mac 装了 oh my zsh 后比用 bash 具体好在哪儿？ - 软件
@defcon
 的解答.
另外关于linux命令行的详细使用, 有一个网站也特别好用: 
Linux命令大全(手册)_Linux常用命令行实例详解_Linux命令学习手册
. 将相关命令的功能, 配置项和使用案例讲得非常详尽.
VIM
vim编辑器相对其他编辑器来说确实难用了一些, 入门的学习成本也很高, 不过在linux系统中使用vim可以说是必须掌握的技能. 记得我大一的时候程序设计课的TA就开始安利我们使用vim了, 不过当时真的是太愚钝, 根本就学不会(说得好像现在就学会了一样...)
网上关于vim的教程很多, 不过有的感觉太专业(比如自定义功能之类的), 我个人认为只要你安装了vim后, 命令行输入
vimtutor
, 把那个教程过一遍基本就可以了....入门的难点主要是理解vim的三种模式: 编辑/命令/视图...理解了这个后就顺风顺水了
至于自定义功能的话, 交给网上的其他大牛来完成吧233333, 这里强烈推荐 
GitHub - spf13/spf13-vim: The ultimate vim distribution
 . 效果如下,  比以往的效果好了太多:
《计算机网络: 自顶向下方法》
软件学院的计算机网络教材, 里面将计算机网络从顶层到底层逐章分析了一遍, 非常适合初学者阅读, 不过最好能够结合一些实验来辅助理解, 因为里面的讲解确实蛮抽象的
《图解HTTP》
日本人著的介绍HTTP协议的书, 对理解HTTP协议的一些细节有非常大的帮助, 插画也很多(日本人的行文风格, 感觉就像看漫画一样), 很容易就理解了
《
TCP/IP详解卷一
》
觉得上面两本讲解网络的还不够深入?我很钦佩这本书的作者, 能把枯燥的知识讲得那么那么那么细致, 非常强烈推荐这一本, 看完相应章节后大概能够明白为什么TCP/IP要这么设计了. 面试的时候经常问到三次握手和四次挥手, 还有各种状态的转移, TIME_WAIT的时间为什么是2*MSL...
《UNIX网络编程卷一: 套接字联网API(第三版)》
中文版快800页, 不过我只看了一些章节, 这本书也是把TCP/IP的细节讲得很深很深, 此外还有非常重要的基本套接字编程, 就是写网络程序的时候那些bind, accept, listen, send, receive函数之类的, 内容非常多, 但是这些是理解多路复用模型所需要掌握的...select/poll/epoll这些系统调用解决了什么问题? 事件机制能不能理解? 就看这本书的前六章了
《数据库管理系统(原理与设计)》
这个也是web开发中离不开的东西, 必须划重点学会的是ER图/SQL语句/存储数据(磁盘|文件|RAID|缓冲池等)/三大范式/索引以及相应的数据结构/事务相关的所有概念, 尤其重点学习SQL, 附上学习
链接
 .之后学会使用mysql workbench来进行数据库建模/逆向工程生成建表语句/根据SQL生成JAVA实体类等就不赘述了, 开发过程中百度谷歌一下就知道啦, 然后如果习惯在windows下开发的同学推荐利用navicat这个好东西, 当然如果说想训练自己写sql语句的能力那纯粹用命令行也无所谓...
html/css/javascript
这个是做web开发基础中的基础, 个人感觉学习难度不大, 但是建议一口气学完并尝试利用它们做一个简单的个人简历, 否则学习曲线会比较断断续续, 不够一气呵成, 具体教程可以参考 
html/css
javascript入门
javascript进阶
Javascript深入浅出
emmet cheat sheet
做前端的应该都知道这个玩意的了，简单地说就是能让开发更加方便吧，解放生产力的一个工具，至少大于号和小于号不用再按来按去了...
比如说要打出下面的代码测试列表效果之类的：
借助emmet插件只需要这么写：
.list-block.list-block-search.searchbar-found>ul>(li.item-content>.item-inner>.item-title{$})*6
然后按tab键就能生成了....
更多的用法详情请见：
Cheat Sheet
jQuery/Bootstrap/AngularJs
关于javascript, 其实纯粹使用原生javascript开发网站的话很麻烦, 所以就萌生出了这么一些框架: jQuery解决了浏览器兼容性的问题(虽然据说要过时了), Bootstrap可以很无脑地开发出看起来蛮好看的网页(其实还有很重要方面是响应式前端); 而AngularJS主要是有一个很重要的思想:MVVM, 随后崛起的
vue.js
也如出一辙而上手更快...对于Java Web开发程序员而言建议刚开始有选择性地进行学习, 可能真正涉猎深了就可以随意转换了. ps: 我的前端基本都是在
慕课网
学成的, 我觉得这个网站真的业界良心. 去官网搜索吧!
JS的原型链与闭包
可能利用上面框架开发的时候会遇到一些很棘手的问题不知道如何解决或理解, 那么建议先看看王福朋的博客: 
《深入理解javascript原型和闭包系列》
, 我觉得看完理解了以后定位js的bug应该会更容易一些
SublimeText
一个对于前端开发工程师来说非常强大的编辑器, 可以提供各种各样的自动补全(必会emmet插件语法), 附上教程 
快乐的sublime编辑器
 和 
前端开发工具技巧介绍―Sublime篇
. 自从用了SublimeText, 我再也不畏惧前端编程了...如果觉得教程看得不过瘾, 知乎上这几个帖子可以让你领略SublimeText的
奇淫技巧
WebStorm
Jetbrain旗下的
前端IDE
, 我觉得相比SublimeText它更好的一点就是不需要你自己去装插件就已经有了很多方便的功能, 上手比SublimeText快
VSCODE
微软开源的编辑器, 知乎上也有比较详细的
讨论
. 个人认为好看/高雅/好用, 如果习惯SublimeText入手vscode并不难, 反正我现在已经转战VSCODE了, 就因为它可以设置背景为萌萝莉喔, 是不是蛮可爱的, 感觉打代码更有精神了
Github
将
github
列为基础可以足以说明它的重要性, 其实主要是理解版本控制与分支协作的概念, 不过使用这个网站之前得先学git, 
廖雪峰的博客
就介绍得非常到位. 建议刚入门github的时候可以将github当成成云仓库(你甚至可以把东京热的种子放在github里哈哈哈), 熟悉一些基本命令. 到后面团队作业的时候强制使用github进行协同合作, 会渐渐发现和理解github的好处的. 除此之外github还是一个搜索开源优质项目的好网站（下图源于
怎样使用 GitHub？ - GitHub
@珊姗是个小太阳
  的答案）
Markdown
markdown也是很相见恨晚的东西, 我觉得markdown类似于html, 但是比html更简单简洁, 对于喜欢做网上笔记或者个人博客的同学而言是值得推荐的工具. 半小时应该就能上手了, 教程在此
Markdown――入门指南
...附上vscode的markdown笔记截图(分栏看预览效果, 感觉高大上了呢), 你会爱上markdown的(虽然我个人笔记整理得很乱- - 等我闲下来再好好整理)
二、Java
《疯狂Java讲义》
个人认为Java入门最好的书籍, 虽然真的很厚, 不过里面重复的话会写很多遍(每天坚持看一点, 一次性读完, 印象也会很深刻的)...对于这本书而言, 
除了图形界面编程以外, 其他内容最好认真读完并实践一遍
, 会对理解Java Web有不少的帮助
《Effective Java》
建议有一定项目经验的人才去看这本书, 里面列举了很多开发必须注意的条目. 说实话这本书真的不那么好看, 但是你会发现在某些笔试题上会出现这本书的很多条目
Intellij IDEA
学习Java怎么能不知道有这么个牛逼轰轰的IDE! 可以说彻底提升了我的开发效率, 简直相见恨晚, 在所有教程中我觉得极客学院做得最为认真, 附上学习教程（之前推荐的是极客学院的网址，但是现在那个网址的图片好像都看不了了- -）
https://github.com/judasn/IntelliJ-IDEA-Tutorial
Maven
为什么我把Maven放在这里? 因为它蛮重要的(其实用
gradle
也可以). 一个解决java web项目开发中所需要的依赖问题, 同样论工具的使用教程, 
极客学院
最给力, 附上
教程地址
《轻量级Java EE企业应用实战》
(阅读此书时建议把基础部分的全部搞定,)这本书跟《疯狂Java讲义》是配套的, 里面先讲解Servlet/Jsp(Java Server Page)等技术, 然后就是SSH(Struts/Spring/Hibernate)等后台框架的各种使用, 其实说白了就是把这些技术的官方文档给翻译一遍给你而已. 有人觉得struts2都过时了还有没有学习的必要? 我认为理解一下也不会花太长时间, 因为学习任何框架的重点也不仅仅是用而已. 初学者把重点放在一些思想上的东西(尽管很虚, 但是后续的框架基本都会延续这些思想), 比如控制翻转IoC|面向切面编程AOP|对象关系映射ORM|模型-视图-控制器MVC等, 把这些弄懂后之后的SpringMVC, mybatis等后台框架上手会很快的. 这些东西真的太太太太太太基础了, 搞不懂就要考虑转行了(= . =) 另外看这本书入门Java web的时候不要对作者那种用记事本编程的方式太较真, 会debug到天昏地暗的, 使用Intellij Idea就好了(如果不懂使用Intellij Idea可以先去慕课网或极客学院或csdn等网站看看别人是怎么操作的即可). 还有想说的就是, 请务必学会使用maven, 手工导jar包学习Java Web的方式简直就是弱智行为, 而我居然坚持了三个月..最后, 把这本书当成工具书比较合适: 初次阅读理解就好没必要动手实践, 等到需要的时候再翻阅查询
《Spring Boot实战》
还在用xml配置各种依赖注入/数据源/事务管理器? out啦! 随着微应用的流行, 以注解替代xml配置的开发方式将越来越流行. 作者汪云飞没有讲太多废话, 内容基本都是说Spring Boot的某个特性然后举个例子实战, 有利用SSH开发过简单项目的同学可以尝尝先(我去实习的岗位早就开始用了, 觉得蛮新颖的) 实际上学习任何一个框架的时候要先了解这个框架解决了什么问题, 只有理解了这个后才能更有针对性也更有效率地去进行学习
《Head First 设计模式》
隆重推荐这本神书, 很有趣. 刚开始读觉得很深, 但是和《轻量级Java EE企业应用实战》一起看, 思考那些设计模式存在的意义, 会对软件架构方面的知识豁然开朗...
《Java并发编程实践》
又是个歪果仁写的书, 里面详细介绍了Java并发工具包java.util.concurrent的各种工具以及很多的并发编程实践之道, 是并发编程的入门之作.
《Java并发编程的艺术》
国人写的书, 也是写Java并发编程的, 与上一本相比个人认为比较凝练/干净/易懂
三、Java进阶
《架构探险: 从零开始写Java Web框架》
作者叫黄勇, 一本非常让我拍手叫绝的书....首推! 绝对干货! 如果你不想看spring源码也没有太大关系, 这本书带你一步步地开发出一个类似spring mvc的简单框架, 并且逐步地增加需求和完善, 理解了每个细节对于理解Java Web的开发是很有帮助的
《深入分析Java Web技术内幕》
这本书我觉得是必看的, 可以说是对我帮助最大的一本技术书籍, 覆盖了Java Web很多方面的知识, 比如计算机网络|Tomcat结构|Spring架构|SpringMVC原理|模板引擎实现原理等, 绝对很有收货, 足够有深度也很有难度
《Spring源码深度剖析》
一本比较详细的书, 其实对于阅读源代码, 跟着作者的思路读, 再结合自己的断点调试进行学习的方式是最好的
《深入理解Java虚拟机-(JVM高级特性与最佳实践)》
想知道Java虚拟机为什么会帮你自动收集垃圾而不需要你管理资源释放吗? 想知道Java虚拟机的内存区域是如何划分的吗? 想知道Java虚拟机是如何唯一确定一个Java实现类, 并且如何加载类的吗? 想知道JVM凭什么能够将远程服务器发送的网络字节加载到JVM内存, 从而实现远程过程调用的吗? 这本书你值得拥有!(感谢这本书让我回答出RPC的实现原理)
500 lines or less
500行代码! 尽管跟Java没有太大关系, 强烈推荐, 里面的程序主要是一些玩具轮子, 都是用python实现的, 学习这个主要是理解别的程序员在开发软件的时候所做的决策/思路/取舍, 虽然我也没看完, 但是觉得这个资源很赞!!! 
官方网址
《MySQL技术内幕-InnoDB存储引擎》
其实讲道理这种书应该给DBA看才对, 不知道为什么Java Web开发也要看- - 有次面试就问到说对mysql数据库的性能调优有什么看法, 所以就列在上面. 不过说真的有点晦涩难懂, 如果想简单粗暴地应付面试的话就看
这个博客
 这篇博客应该是我目前看到的对于mysql索引的解释最最通俗易懂的了
四、分布式系统
《大型网站技术架构: 核心原理与案例分析》
李智慧著, 确实是很好的入门书籍. 实际上如果有操作系统和Web项目后台开发的基础话阅读起来不会特别困难, 主要内容是介绍当今企业应对大型网站高并发请求的种种策略
《分布式Java应用-基础与实践》
这本书比较深, 介绍分布式Java应用和相应的应用场景, 什么远程过程调用(RPC)呀, 基于服务的体系架构呀(SOA)等, 同时也讲了很多java比较底层的知识, 最后介绍构建高可用/可伸缩系统的工程经验
《大型分布式网站架构: 设计与实践》
与上一本书类似, 不过个人觉得更偏向于""介绍""互联网安全架构和分布式系统的各种组件(比如分布式缓存|消息队列|搜索引擎等), 目前我只接触了Redis, 相应的组件实在太多了- - 此外对系统监控和数据分析等也做了相应介绍, 这些我感觉比较偏向运维岗的工作人员
《Redis实战》
Redis的基本用法和在生产环境的应用, 值得拥有, 虽然书籍是用python, 不过
官方github也有放java的源码
《
Redis设计与实现
》
Redis的源码解读, 怎么说呢, 反正比spring源码好读太多了....而且作者读得很用心, 整理出了带注释版本的redis源码, 
去读个痛快吧少年
五、博客与网站
博客
这里再着重推荐两个大神的博客, 都是歪果仁
Jenkov
: 丹麦资深Java开发人员, 从事软件开发十多年, 如果你觉得李刚的教材看腻了, 可以看看他写的教程, 非常适合初学者, 发现知乎很多Java程序员都是在这里学并发编程的
Baeldung
: 这系列教程是我觉得讲spring的用法讲得最好最全的.. 尤其是讲
spring security
讲得真的很详细...
网站
此外还有一些常用的学习网站:
慕课网
: 首推, 自己真心感谢这个网站
实验楼
: 地位和慕课网相当, 让我觉得编程有趣的一个学习网站
优达学城
: 一个相见恨晚的网站，里面的视频图文并茂，非常生动好理解，只是可能需要翻墙。另外针对后端有一个课程蛮不错的：
后端入门
。很基础不过讲得很好，适合小白。
天码营
: 里面有很多Java项目值得临摹
掘 金
: 一个致力于为广大程序员推送文章的app(PC端也能看), 干货不少
coursera
: 这个不多解释了, 如果想跟国际接轨(英语授课)的话这个网站很适合你, 里面有很多全世界优质的课程, 知乎上也有总结得很详细的课程列表, 适用于任何人(
Coursera 上有哪些课程值得推荐？ - MOOCs
)
Quora
: 知乎的鼻祖, 但是抖机灵的人比较少, 外国牛人也是很多的, 上了才知道
有一些很好的开源java web项目值得借鉴和参考，多看别人写的代码才发现：这个功能原来可以这么实现，原来有这种api，原来还有这种jar包（第一次知道）...（也希望各位能推荐给我一些好玩的开源java web项目进行学习）
jcalaz/jcalaBlog
 
spring-io/sagan
 
Raysmond/SpringBlog
 ","两年前写的回答，现在陆陆续续还能收到一些赞。很高兴能够对找工作的各位有所帮助。现在会看之前的答案还算满意，不过工作两年也有了一些心得体会和经验教训，在这里分享给大家。这些纯属个人体会，如果不喜欢可以直接跳到后面看原答案。希望能够对各位有所帮助
技术这种东西脱离了实践都是
空中楼阁
。一个校招生，没有参与过公司的项目，没有上过线解决过bug，说实在的我感觉看什么高并发意义不大。因为只是知其然而不知所以然，根本不知道为什么这么做，即使是看书知道了，和有经验也有很大的差异. 过来人应该都深有体会，我说的是实话，面试被拒了说明综合实力没达到要求，也建议这部分同学可以将目标放在线下，不要只着眼于书本，现在有挺多优质的实践项目就是帮助小白把理论知识去落地，来补充应届生面试大厂的短板，怎么说呢，据我招过来的同事分享，面试时效果确实为单枪匹马加了很多Buff，下面分享一个我身边人觉得体验口碑挺不错的项目课，大家可以根据需要自取
技术这东西只是工作能力的一部分，在职场上混的好不好最重要的是
向上管理
的能力
我们是一个人，人是有多面的。职业只是其中的一面。程序员因为工作的原因接触比较多的是同行，再加上周末。我很建议大家多了解其他行业，多读书，多和其他行业的朋友交流。保持谦逊才能够看到更大的世界。这一点我做的也不是太好，尤其是多读书这一点。
以下为原答案：
// 我知道的国内技术栈以Java为主的公司是美团和阿里，百度和腾讯是C++。
今年拿到了美团的offer，现在在美团实习。从找工作到现在对这些大概有了一点点体会，来谈谈自己的想法。
简单说下我的经历，我就是个普通的本科生。暑假什么都没干，开学申请支教一直到9月底才参加校招。当时大部分牛逼的互联网公司笔试都结束了，我只参加了百度和美团的笔试，感觉很差，因为没复习很多东西都不会。
到后面面试的时候我的简历上是没有项目的！
校招看重基础，就是语言掌握如何，算法题做的怎么样，计算机网络的基础（TCP三次握手，和UDP区别，HTTP协议），后台开发的话还会问些数据库的东西。有项目的话最好，没有的话本科生应该也可以吧（我就没有项目）
必备技能：
1.Java基础(JavaSE)：
多线程（这个必考，美团3次技术面两次问到了多线程）
，String，集合（HashTable和HashMap区别，迭代器，快速失败等等）…… 
我学Java是看视频自学的，能写之后再看的《Java编程思想》，感觉事半功倍。不过也有人说看视频学的不系统，这个看个人喜好吧。不过书是一定要看的，视频可以选择优质的系统的视频来学习，其实最推荐的还是找个好的培训班系统的提升一下，效果远比埋头单枪匹马的自学强，好的培训班会有非常体系的教学架构，并且效率和学校效果都比自学强很多，对个人来说，有人引导会比自学效率高得多，尤其坚持不下去的小伙伴，可以试试下面这个入门课程，有
大牛
老师带着入门，能少走很多弯路。只要跟着老师一行行敲代码，坚持下来就会发现Java非常容易，想要0基础入门的同学现在可以领取课程试试啦
2.算法数据结构
链表，二叉树，堆（10亿个数找topk）
。红黑树可能比较复杂没见考过，图算法就阿里电话面试的时候问过。有时间还可以去看一些大数据操作的算法（topk），面试也问到过。
推荐书籍：《算法（谢路云译）》《剑指offer》等
推荐网站：牛客网，leetcode
《算法》这本书学算法的时候看很棒，尤其是关于红黑树那里讲的很好。网上大部分讲红黑树的博客感觉都是抄来抄去，一个插入删除操作复杂到根本不想看。这本书把
红黑树
和2-3树（也可以是2-3-4树）做了一一对应，方便理解。
如果是临时抱佛脚准备笔试面试，那直接看面试题吧。我准备的晚就只做了《剑指offer》上的题（
剑指Offer_编程题_牛客网
），leetcode都没做过。值得一提的是看这种书最好拿到题目先去做，然后再看后面的答案。其实你会发现《
剑指offer
》上面大部分的题目你都是可以自己解决的。
3.计算机基础知识（操作系统，网络，数据库，Linux）
如果学校的课还有印象的话，看学校专业课的书吧。操作系统和网络术语很多还是比较难理解的。单纯准备面试的话问的多的也就是：TCP协议，线程和进程，cache替换算法等等
推荐网站：
慕课网(IMOOC)-程序员的梦工厂
里面讲解Linux的视频感觉不错，也涵盖了一些操作系统和网络的基础
推荐书籍：《
鸟哥的Linux私房菜
》
下面的内容了解过的话我认为还是很好的，应该会给你加不少分。而且也不难。
1.Servlet
这应该是JavaEE的基础了吧，其实并不难。学习
servlet
对理解HTTP协议是非常非常有帮助的（Session,Cookie等）。HTTP协议只看计算机网络书上那一点肯定是不行的。
2.Spring IoC和AOP，设计模式，面向对象
现在正在学习Spring。Spring的Ioc和AOP有了JavaSE的基础就可以学习了，不过你最好之前写过一定量的代码，否则可能并不能理解使用Spring的好处。
Spring IoC，控制反转，背后的实现就是工厂模式，学习Spring IoC你可以较为深入的了解什么是工厂模式，
单例模式
。这和你直接去走马观花的看设计模式的书是完全不同的。
Spring AOP，
面向切面编程
。不知道你在学校写代码的时候有没有记录过程序的执行时间，你通常会在main方法里调用前记录时间调用后记录时间然后相减。记录完成之后把加载记录时间中的代码替换掉再去测。如果是排序算法的话一共有五六个算法所以你要替换五六次（有重载替换更多）。AOP就是解决这个问题的。
AOP的实现是代理模式，要去学习下JDK的动态代理。
学习框架最大的收获就是更深入的理解面向对象编程。在学校写的那些代码用的虽然是
面向对象语言
，可你的思维可能还是C语言那种面向过程的。如果你写代码经常使用ctrl+c和ctrl+v，或者添加一个小功能需要更改许多个地方，那说明你还不够了解面向对象。
推荐视频：马士兵
由于我们是学习Spring IoC和AOP的原理，所以不必拘泥于版本。
马士兵
的课是我听到过讲的最好的，毕竟人家是清华毕业的，水平摆在那里。
还有两个是不得不说的：
1.github
如果你活跃于github上面有自己的项目还有许多星，我觉得这样的水平参加校招应该会被抢着要
如果你没做过什么项目，你可以把自己在学校做的实验代码发到github上来，fork一些别人的项目（贡献不了自己的代码起码要看一看，只是
fork
了不去看我觉得就是作死了……），读一读人家的代码了解下是怎么实现的。面试的时候能说出这些我觉得也是很大的加分项了
2.博客
博客就是自己的总结，我觉得这体现一个人的学习习惯，也能让面试官快速知道你学习过那些东西，掌握到了什么程度。
博客一定要原创
，抄来抄去真的很没意思。
其实有项目的话还是最好的，因为企业也知道大家准备招聘的时候回去看各种
面试宝典
突击一下，面试的结果其实并不能反映一个人的真实水平。在项目中做了什么才是最好的衡量标准。不过本科生可能有项目的人很少，那除了这些算法题，你应该要让面试官知道你是有真本事不是临时抱佛脚的。所以github和博客就是你一个很好的说明。
先写这么多吧，日后想起来再更。祝大家都拿到理想的offer。对了，最后分享的一些免费Java学习资料大家不要忘了领取。","秋招拿到了阿里的offer，研究生一枚，学了两年多Java，现在在阿里搬砖，分享一些最干货的Java学习经验，希望能对各位想要进大厂的同学有所帮助，我相信对本科生和研究生都是有用滴！
我写过一个Java工程师学习指南，我把它分为了四个部分，第一步是打好Java基础，掌握Java核心技术，第二步是掌握Java Web技术栈，能够做一些项目，第三步是掌握Java方面的进阶技术，包括网络编程、并发编程、JVM等，第四步是掌握后端进阶技术，比如分布式、缓存、消息队列等技术。
按照这样的一个脉络，我觉得能够掌握这里面的绝大部分内容，并且有过相应的一些实践，那么可以算是学好了Java。当然，学好Java只是一个开始，要真的干好活，做好项目，以及其他各方面的技术工作，则是在学好Java的基础去延伸和展开的。
接下来就是具体的四篇文章，建议大家按顺序阅读，有点长，收藏的时候记得点赞或者评论哈。笔芯！
本文提到的知识点整理文章现已全部整理到我的个人博客：
https://
how2playlife.com/
Java工程师学习指南
入门篇
最近有很多小伙伴来问我，Java小白如何入门，如何安排学习路线，每一步应该怎么走比较好。原本我以为之前的几篇文章已经可以解决大家的问题了，其实不然，因为我之前写的文章都是站在Java后端的全局上进行思考和总结的，忽略了很多小白们的感受，而很多朋友都需要更加基础，更加详细的学习路线。
所以，今天我们重新开一个新的专题，分别按照四篇文章讲述Java的学习路线（分别是入门篇，初级篇，中级篇，高级篇），笔者也打算趁此机会，回忆一下自己的Java学习历程。今天我们要讲的是，小白同学如何入门Java。
先声明一点，文章内容不会详细到每一步怎么操作，只会提供大致的思路和方向，给大家以启发，如果真的要一步一步指导操作的话，那至少需要一本书的厚度啦。
本文所述的方法不一定适合所有人，如有错误敬请谅解。
这里推荐一个Java技术仓库，学Java的朋友可以看看，每个知识点你都可以在里面找到对应的文章，从基础，到原理，再到源码讲解，都有涵盖，算是整合了很多Java大佬好文的一个优质Java技术仓库了。
目前已有1k+star，希望你也给一个star让更多人看到它吧！
h2pl/Java-Tutorial?github.com
01 
前期准备工作
开发环境搭建
这一步我们往往会直接跳过，但既然是面向小白的教程，这里就提一下吧。首先你需要一台电脑，然后安装好JDK和JRE，JDK提供的是Java开发工具，也就是一些必备的
jar包
，JRE则是Java的运行环境组件，我们熟悉的JVM就在这里面。
安装好这两个东东之后，一般还要配置一下环境变量，否则有一些目录可能无法被正确找到。
IDE选择和安装
IDE指的就是本地开发编辑器，没有了它，你就只能直接在记事本这类工具里敲代码了。IDE最大的好处就是整合了大量的工具和功能模块，让你非常轻松地完成开发。
以前大家都用eclipse，不过eclipse已经不流行了，现在我推荐你直接用intellij idea作为你的第一个代码编辑器。如果是用过eclipse的同学，基本上也可以无痛切换。
intellij idea可以直接在官网上下载，试用版30天，如果想要永久使用，网上也有一些办法滴。
关于jar包
jar包是什么，其实就是将一堆class格式文件打包，Java中把它称为jar包，这些jar包在编译器中能被直接识别，让开发者使用。
对于新手来说，可能只需要用到JDK自带的一些API，但是如果你要引用外部jar包，可能就会遇到一些困难了。对于idea来说，导入外部jar包有两种办法，一种是手动导入jar包，一种是使用maven。后者会在Java Web相关的文章中讲起。
手动导入jar包其实也不难，你需要先下载好jar包，然后在对应的项目下选择导入jar包即可，具体的方法这里就不展开说了，因为在网上都找得到。
02 
学习Java基础的几种方法
了解基础语法
学习一门语言，最开始要做的事情就是学习它的语法。我最早学习Java语法是在Runoob，这个网站可以让你对任意一门语言完成最快速的语法入门，当然，这只是相当于你浏览了一遍基础语法。
想要真正掌握Java语言基础，光看基础语法还远远不够，我在大三第一次接触Java课程，听老师讲面向对象三大特征听得一头雾水，连数组的初始化方式都理不清楚，但这些内容都是我们需要掌握的。所以，为了学好Java基础，我们还需要看视频或者看书进行学习。
看视频
视频的话，可以到极客学院或者慕课网听Java基础课程，当然也可以看我分享的Java视频课程。大家也都知道，现在Java的培训班非常多，基本上学的东西也都大同小异，不过它们的有些课程还不错，大家有渠道的话也可以去看一看。
看视频的好处是你可以更好地接收知识，同时也会耗费你更多实践，所以，有时候你也可以选择看书。
看书
看书的话，对于小白来说不推荐太复杂的书，比如《Java编程思想》这种书，新手千万不要看。我个人建议，你只需要先看看《Java入门到精通》这种类型的书就足够了，因为这个部分的学习只是为你后面的学习开个头，你以后可能还要回过头来重新研究这些内容。
现在市面上介绍Java基础的书籍实在太多了，质量参差不齐，内容同质化严重，笔者看过的其实也不多。给大家一个建议，你只需要挑一两本书来看即可，这里推荐两本最简单的吧，《head first java》和《Java从入门到精通》。
看博客
这里再推荐另一种学习方式，就是看博客，博客比起书籍来说，更适合对于某个技术点的学习，你可以很容易地在网上找到这个知识点相关的原理，实现方法，以及代码范例。
我的博客
里没有讲解特别基础的东西，如果你看一些比较基础的文章，可以到Runoob等网站上查看。如果你有一个很明确的知识点想要学习，相信搜搜引擎会给你更好的答案。
代码实践
除此之外，一般的Java书籍或者视频课程都会要求你相应完成一些练习题，这部分内容你需要自己在电脑里使用IDE完成。
在IDE里，你可以很好地熟悉Java语言的使用，基本代码的实现，同时可以尝试各种各样的API,并且测试一些语言特性，比如继承，封装，多态等等。
另外，这也是你熟悉IDE的一个好机会，因为在公司里做开发可能要用到IDE各种各样的功能，提前熟悉好IDE绝对是有益无害的。
03 
Java入门必备知识点梳理
在Java入门阶段，你可能需要接触到以下这部分知识，不管你是从通过哪种方式学习，这些内容都是你学习Java基础时绕不过的重点。
Java基础知识
这部分内容是你必须要掌握的内容，在入门阶段你需要把这些基础打扎实，以便于在学习后面的内容时可以更上一层楼。
如何把基础打扎实呢，最好的办法就是在IDE上把书上或者视频上的每个例子都实现一遍，当然有的时候你也可以自己写一些有意思的例子。
1 基本数据类型
比如int，double，char，以及其包装类。
熟悉基本数据类型的使用，了解每种类型所占的字节数，以及它们和包装类之间的相互转换。
2 流程控制
比如for循环，if else，while循环等等
如果是学过c语言的同学，这部分可以跳过了。
3 字符串类型String的使用
字符串类型是Java中很重要的类型，它不是基本数据类型，但却很常用，熟悉和实践String相关的api，开始你对字符串的学习吧。
4 数组
数组的初始化方式有哪些，二维数组应该怎么写，把数组当成方法参数又该怎么处理？
5 类和对象
Java中最重要的两个概念：类和对象，它们有什么用呢，有什么区别和联系呢，请在代码中实践它们吧。
Java核心技术
对于这部分内容，我相信很多小白只能了解它们的基本使用方法，但是并不明白其背后的一些原理：比如为什么接口和抽象类有这些区别，多态的意义是什么，为什么要有反射。
新手在学习这部分内容时，只需要知道怎么用就可以了。当然，你最好把这些特性都实现一遍，以加深印象。
至于为什么有这些特性，这些特性背后的原理是什么，不是我们现在讨论的内容，这些内容我们将在初级和中级篇中讲述。因为，要了解这些原理，你得了解JVM，了解并发技术的基础，了解网络基础，甚至更多。显然，这不是你现在能做到的。
1 接口和抽象类
写一些接口，同时写一些实现类去实现这些接口，并且了解一下为什么我们需要接口，为什么子类需要实现接口里的方法。
同理，去实现一些抽象类吧。然后，看看它和接口有什么不同。
2 继承，封装和多态
如何理解继承，子类和父类之间有什么联系呢。
封装是一种保护代码的方式，有哪些方式可以实现封装呢。
多态一般分为重载和重写，它们分别怎么使用？
3 异常处理
Java中的异常处理主要用于捕获和处理错误，请你写一些try catch代码块去捕获错误吧。
4 集合类
集合类是我们经常需要打交道的东西，List，Map，Set等等，赶快去熟悉API，然后写一些测试例子吧。
5 IO输入流和输出流
IO输入流和输出流可以操作文件，网络数据等内容，如何在Java代码中完成这么复杂的操作呢，其实只需要简单的几个api就可以了。
6 多线程
为了让系统资源最合理地分配和调度，我们需要多线程，多线程会让程序变得有趣，也会带来很多问题，使用Thread和相关API，去尝试这些有趣的事情吧。
可选内容：
1 反射（了解即可，不是入门必须）
2 枚举类型和泛型（了解即可，不是入门必须）
3 网络通信（了解基本的socket使用即可，需要网络基础）
4 数据库操作（了解基本的JDBC即可，需要数据库基础）
04 
总结
总而言之，对于一个Java小白来说，入门Java可以分为这几步：
1 首先搭建好Java开发环境 2 通过Runoob等一些网站熟悉Java的基本语法 3 通过看书看视频等方式熟悉Java基础知识，通过代码实践加深理解 4 通过看书看视频等方式初步了解Java核心技术，通过代码实践加深理解。
本文主要是为大家提供一个学习的思路，以及推荐一些学习方法，如果你能够按照这样的步骤去学习，并且配合上一些适合你自己的学习方法来完成学习计划，相信你可以很好地完成对Java的入门。
Java工程师学习指南
初级篇
最近有很多小伙伴来问我，Java小白如何入门，如何安排学习路线，每一步应该怎么走比较好。原本我以为之前的几篇文章已经可以解决大家的问题了，其实不然，因为我之前写的文章都是站在Java后端的全局上进行思考和总结的，忽略了很多小白们的感受，而很多朋友都需要更加基础，更加详细的学习路线。
所以，今天我们重新开一个新的专题，分别按照四篇文章讲述Java的学习路线（分别是入门篇，初级篇，中级篇，高级篇），笔者也打算趁此机会，回忆一下自己的Java学习历程。今天我们要讲的是，小白同学如何入门Java。
先声明一点，文章内容不会详细到每一步怎么操作，只会提供大致的思路和方向，给大家以启发，如果真的要一步一步指导操作的话，那至少需要一本书的厚度啦。
本文所述的方法不一定适合所有人，如有错误敬请谅解。
01 
Java Web项目指南
jav在上一篇文章中，我们讲到了入门Java的几个步骤，先搭建好环境，然后熟悉基本语法，接着熟悉Java的一些核心技术，并且在代码中进行实现。
如果你已经完成了这部分内容的学习，应该会感觉自己对Java已经有一定了解了，可以轻松地写出一些Java代码，比如实现多线程输出数字，再如操作
IO流
等等。
当然，这些代码通常只是一些demo，我们在实际的项目中可能并不会这么简单地使用这些技术，我们可能会同时使用集合类，多线程，以及操作数据库的API。
所以，在今天的初级篇中，我们就来谈谈怎么做项目吧。
Java Web项目
对于大部分Java新手来说，最适合他们入门的项目就是Java Web了。因为Java天然适合做Web应用，并且生态完善，更有很多开源的工具和框架去支撑这些应用，比如Spring，Hibernate，SpringMVC等等。
那么，如何开始着手做一个Java Web项目呢。个人认为最好的方式就是看视频了。因为，看书的话，很多内容比较过时，并且一般不会提供源代码。也有一些大佬喜欢推荐开源的项目（在GitHub上面的项目），但是对于小白来说，如果没有很完整的文档去指导他们，那也是毫无意义的。
曾几何时，Java Web的项目还在使用JSP + Servlet进行开发，后来出现了Struts2，再后来，出现了我们现在也一直在用的SpringMVC，说实话，不论使用哪种开发框架，你都需要先花一些时间去学习相关的技术，否则你会发现，即使是看视频，你也不知道里面在讲什么。
要想做好一个JavaWeb项目，你不仅需要一个好的项目课程，还需要足够的知识储备，下面就让我们来理一理这些内容把。
知识储备
Java基础部分的内容咱们上次说过了，这里就不再重复啦~下面我们分别来说说其他几方面的知识储备把
02 
前端知识
推荐资源：在w3cschool学习html，css和js，支持在线测试代码。
既然是做Web，就难免要涉及到前端技术，不过，现在前后端分离已经是一种趋势，所以，如果你对前端不感兴趣，也没必要花太多时间去学习。
对于大部分同学来说，你最好要了解html的基本标签和格式，自己能够写一些简单页面，CSS的话，也可以稍微接触一些。相对于前面两个服务于样式的技术，我们倒是更应该去学习一下JavaScript，了解它的一些基本语法，以及ajax的使用，因为在前后端交互时，ajax是非常重要的。
所以，做一个Java Web项目，你不需要花太多时间在写前端页面上，如果有源代码可以直接使用，当然，对于一些需要修改的前端页面，你得怎么去做修改它，因为有时候你需要使用JSP，JSP既包括前端代码也包括Java代码，如果你完全看不懂前端代码的话，那就很尴尬了。
03 
Java Web常用技术
JavaWeb的技术栈其实比较庞大，所以我们不要求面面俱到，只是希望你能够熟悉一下项目中可能用到的技术。下面列举一些常见的技术，大家最好要了解一下。
1 JSP和Servlet
推荐资源：《JavaWeb入门到精通》，慕课网、极客学院等网站上的JavaWeb基础课程
这是Java Web开发最原始的形态，现在很少直接使用了，但是后来的各种框架其实也是建立在
servlet
之上来做的。你们需要了解这两个技术分别是用来干什么的，最好能写一些demo来实践。
对于JSP，有时候你可能还要学习jstl等标签语言，因为这些标签可以让你更方便地往JSP中插入Java代码。
2 Spring和SpringMVC
推荐资源：《Spring实战》，慕课网、
极客学院
等网站上的SpringMVC基础课程。
事实上，除了上述资源之外，你也可以直接到官网上查看快速开始文档。
Struts2早已被时代抛弃，Spring则是当今的霸主，你需要了解Spring如何使用，以及SpringMVC如何使用，并且学会在项目中使用它。
由于SpringBoot最近很火，并且搭建方式比SpringMVC更简单，你也可以先学习SpringBoot，以便更快速地搭建起你的第一个Java Web项目。
3 MySQL
推荐资源：《Sql必知必会》，Runoob上的MySQL基础教程，慕课网、极客学院等网站上的视频课程
一个JavaWeb应用一定要有数据啊，所以我们需要用到数据库，其实搭一个mysql数据库是非常简单的，但是对于初学者来说最麻烦的就是写sql了，所以，先学会建表，熟悉sql，对你以后做项目也是大有裨益的。
4 Hibernate和Mybatis
推荐资源：Runoob上的Hibernate和Mybatis基础教程，慕课网、极客学院等网站上的视频课程
当你学会了使用sql去查询数据，可能还不足以让你在项目中很方便地处理数据，因为我们还需要一个步骤，就是把数据库的数据转化成Java里的对象。orm框架就是为了解决这一问题而出现的，它可以让一张表和Java类一一对应，让数据查询变得非常方便。Hibernate和Mybatis都是orm框架，只不过现在mybatis越来越火了。
所以，你需要了解这一技术，因为它会广泛地运用到大部分Java Web项目中。
5 Maven
推荐资源：《maven实战》，易百教程里的maven教程，慕课网、极客学院等网站上的视频课程
刚才咱们已经说过了Spring，orm框架，以及MySQL等方面的技术了。实际上，一个简单的Java Web项目也只需要这些东西了。
但是，有一个问题，就是：一个项目里用到这么多技术，所需要的jar包也会很多，我们如何管理这些jar包呢。如果直接导入所需jar包，那当jar包更新或者需要替换时，每次都要手动操作，非常麻烦。另外，当jar包很多时，项目打包后的war格式文件也会很大，不利于传输。
为了解决上述问题，maven应运而生了。maven通过pom.xml文件来指定所需的jar包，并且自带了很多构建相关的功能，比如编译，打包，运行单元测试等等，因为它本身就是一个构建工具。
当然，新手可能还难以理解这些概念，你必须要知道的是，大部分Java Web项目需要用maven来管理，你需要学会maven的基本用法，最基本的用法就是：学会修改pom.xml文件。
6 Tomcat
推荐资源：慕课网、极客学院等网站上的视频课程。
对于小白来说，Tomcat相关的技术是非常复杂的，毕竟它是一个应用服务器啊，事实上这个时候，你只需要学会如何安装Tomcat即可。毕竟，它在项目中的作用就是提供一个运行环境而已。
正常来说，你只要下载解压Tomcat的压缩包即可。由于现在的IDE都支持集成Tomcat，所以一般情况下你都可以在IDE中配置好你的Tomcat路径，然后设置好你的项目路径，IDE会自动把你的工程代码部署到Tomcat服务器上。
如果你使用想跳过IDE直接部署工程到Tomcat上，也可以直接编译工程并且打包得到war格式的文件（这个步骤可以使用maven来完成），然后拷贝war文件到Tomcat下的特定目录即可。
上述两种部署方式的详细步骤请到搜索引擎寻找答案。
7 Git和GitHub
推荐资源：
廖雪峰
的Git教程，GitHub官网，
慕课网
、极客学院等网站上的视频课程。
既然要做项目，为什么不把它发布在GitHub上。当你熟悉了Git指令之后，你可以很方便地发布你项目中的每一次更新，并且同步到GitHub上，这样既可以让你更好地管理项目版本，又可以让你GitHub更加活跃，为你未来的面试加分。
所以，赶紧学好Git指令，然后开启你的项目之旅吧。
04 
其他常用组件
除了上面几种必备的技术之外，有时候我们在项目中还会用到其他东西，在这里我们把它们叫做组件。这里只做简单的介绍，至于具体怎么使用，在网上都可以很容易地找到相关文章。
1 
日志系统
当项目代码比较多的时候，容易发生错误，日志可以很好地记录代码运行时的错误，常用的日志系统有log4j,logging等等，另外你还需要了解一下slf4j。
2 单元测试
日志系统可以记录代码问题，单元测试则是为了避免代码出错，常用的单元测试组件主要是JUnit，建议你找个文档看一看，然后下载下来玩一下。
3 JSON
JSON逐渐成为前后端数据交互的标准格式，为了在项目中使用JSON的API，你也需要导入它的jar包，一般我们都会使用阿里提供的fastjson，赶快下载来玩一玩吧。
当然，常用的Java Web组件还有很多，比如HTTPClient，再比如一些加密工具，一些压缩工具等等，这里就不再一一列举了。
5 
总结
今天的内容就到这里了，与其说是初级篇，反而更像是“项目篇”呢。因为学完基础内容之后，做项目是最好的复习和实践方式了。所以这篇文章围绕着做项目来展开，也就不足为奇了。
今天我们主要讲的是，做好一个JavaWeb项目，需要哪些知识储备，需要了解哪些技术，并且我也推荐一些比较精品的视频课程。
后面我还会写一篇文章，专门讲一讲怎么做项目，会更加详细，更加侧重怎么去做，敬请期待吧。
若觉有用，请点赞支持下丫，给我提供更多干货的动力~
我的其它回答可能对你有很大帮助：
本科生如何才能进入腾讯，阿里等一流的互联网公司？
(9K 赞同，26K 收藏）
一毕业就能进阿里的人有多厉害？
（7K 赞同，17K 收藏）
搞 Java 的年薪 40W 是什么水平？
（8K赞同，30K收藏）
Java学到什么程度才能叫精通？
（3K 赞同，10K 收藏）
你考研到底是为了什么？
（3K 赞同，5K 收藏）
-----------------------------------------我是分割线-------------------------------------
PS：私信很多，因知乎不常上，有事可以来公众号找我
1、点赞、关注、支持一下我的回答8，收藏数是点赞数3倍真的扎心哇
都看到这里，不点个赞就说不过去了~
欢迎关注我的微信公众号【黄小斜学Java】 目前专注分享Java领域干货，不限于BAT面试，算法、计算机基础、数据库、分布式、spring全家桶、微服务、高并发、JVM、Docker容器，ELK、大数据等相关知识，希望我们可以一起进步。","哈哈，恰好关注了 
@winter
 和 
@赵
 。看到他们的回答，感觉好欢乐，哈哈。。
正好自己是Java方向，今年3月份通过了阿里的实习招聘，暑假实习后目前转正通过，来答一发。
熟话说，大公司看基础。
阿里校招研发工程师岗位考察的基础可以大致总结如下：
1，操作系统。尤其是内存/线程/进程方面
2，计算机网络协议，重点关注 TCP/UDP/HTTP。
3，数据结构与算法。我本人也没搞过
acm
,，目测考察得算法不是ACM那种级别。这一块儿系统学习后，后面再多刷刷大公司的笔试题就ok了。
4，数据库，这一部分倒没怎么问我。不过资料显示数据库通常考察以下几点 1） mysql存储引擎中索引的实现机制；2）.数据库事务的几种粒度；3）.行锁，表锁；
乐观锁
，悲观锁
5，设计模式，熟悉常用的几种设计模式就行。
6，Java语言基础。熟悉java语言基础，了解JVM、内存模型，重点考察 面向对象、集合框架（继承关系，实现原理）、异常体系、IO体系、并发集合、多线程。熟悉多线程编程/并发/线程安全明显可以加分。
7，J2EE，熟悉Spring/Spring MVC , ORM 什么的吧。看过源码，了解原理之类的也明显可以加分。
8，Linux，熟悉基本的linux命令就行吧  - - 
9，自己做的项目。
10，其他发散性的问题。拼人品了。
不要想得太难了。但是能做到以上几点的，也是很少数应届生。
不过楼上几位大神说的也都是对的，你这些书看完和吸收的话，不是
阿里星
就是p8了吧。。",看了这么多的书，平均一本书厚的1000页，我最快大概的看，不求甚解，也要一个半月，这个看完只记得名词，只是熟悉，你的这么多书，真的看完了吗？那些课后题你全是你独立完成的吗？,"这是一个不知名的本科生的一点心酸经验啊，我当年（大二）也是想逃离学校流水线培训的传统，想去主流的互联网公司，所以就奋斗啊奋斗啊，现在大三，在北京中关村实习，校招关键还是看基础，因为工作的软件各种各样，进公司就靠基础去学习的，几乎每一个公司的面试官真的对一些问题是必问，要做的是天天有计划地积累！写代码！看书！总结！看别人的面试经历！考考自己！在深度的基础上又有一定广度，还有就是实习和项目的问题，真的有那些经验的确可以加分，毕竟节省很多培养你的成本，但是没有也可以，你的基础一定要扎实，我当年在学校就没有实习机会，也没有高端的实验室，所以只能自己找找资料，看看学长们的学习经验，好好把基础学好，多写写软件！
目标的话：面试的时候你能够很自信的表现自己的积累就很棒了，
面试分享 - IT面试 专业的IT面试社区 - Powered by Discuz!
（还有这里面的问题你也要能说出大部分的回答）！
说说我觉得重要的几点吧：
1，数据结构，原理，应用，复杂度等基础一定熟练，结合算法写代码。
2，算法，说白了，面试的时候面试官不是来为难你的，大都会问到经典的题目，平时肯定要多写代码，有篇文章总结常考算法题目很不错的：
让 BAT 的 Offer 不再难拿
。每天练两三道吧，时间一久你就有了那种做算法寻找的突破口的思维了，刷刷题leetcode，
牛客网
（比如网易校招就会在牛客网上考，好多标准格式输入输出，不会啊~）。
3，java，我个人认为一定要写软件，最好是可以开源，那种感觉真的不一样，比如你写一个使用注解的
mvc
，你就有机会吧代理和注解好好学一遍，比看书学这两块儿好多了，或者了解mvc三个模块儿的交互，bean管理等等，写软件就是以结果为导向，真正为了达到一个目标动用和熟练自己的能力，而不是一味的写demo来寻求提升。
4，校招java肯定会问到jvm的，垃圾收集，内存模型，内存管理，线程安全，ClassLoader，类加载，字节码编译（挺重要的），javac等等，出名的书有《深入理解java虚拟机》，《分布式java应用:基础与实践》也有一些jvm的总结，写点demo，准备面试前看看别人的面经，自己试着回答回答，慢慢记得
jvm
就很熟练了。
5，其他一些比较重要的java基础有nio，io，集合框架源码等，我之前面试几家知名互联网公司，这些都问到了，看看Netty的源码，不用复杂，看netty3也很好了，可以的话自己用NIO写一个可以搭建echo服务器框架demo，这样你的nio就很熟练了，还有看看Map，Collection接口下的集合的源码，比如HashMap，ArrayList等等，是否可以为空，线程安全否，排列，异常处理，遍历等等。
6，数据库我觉得和java一样重要吧，虽然现在NoSQL什么的，MySQL仍然使用非常广，使用可以网上查查不用看书了，《高性能MySQL》确实不错，挑挑重要章节看，面试一般都会问数据库的，比如索引优化，分区分表，查询优化，索引数据结构，sql语句熟悉，看了这本书还怕被问MySQL？怕个锤子。
7，并发，这个内容也很多啊，比如《java并发实战》这本书就可以看得出，比如Semaohore，
读写锁
，显式锁，看看并发集合的源码，学学人家的源码怎么应用高并发的，比如ConcurrentHashMap的热点域，分段锁，别人怎么解决死锁的，我记得LinkedBlockingQueue里面的每次上锁和放开锁的方式都是一致算是个方法。可以写写demo，测测运行时间，压测，不断增加复杂的同时也提升了自己的并发编程能力（我觉得面试官很喜欢文ThreadLocal啊哈哈）。
---------------------------------------------------书
说说我觉得不错的资料吧：
《
剑指offer
》自己时间比较紧只是挑看了些，但是和编程之美一样，需要好好读的。
《
编程之美
》。
《effective java》好多面试深入的java问题在这上面能解答，真是非常值得一读，比如问你在什么时候需要定义自己的序列化？虽然翻译不好~。
《
架构探险
――从零开始写Java Web框架》从demo到玩开源的升华，虽然是大神的经验，但确实可以学到好多。
《
设计模式之禅
》这个书很有趣，也可以为了节省时间，可以作为网上设计模式博客资料的补充。
《深入理解java虚拟机》很经典，我也至少看了4遍。
《分布式java应用:基础与实践》个人觉得非常好，让你少走弯路啊。
《
how tomcat works
》这个就是知其然，知其所以然的好资料了。
《Java并发编程实战》这个应该是必读吧，并发单独写本书，课件内容需要好好研究的，多写代码压测也很有意思的。
《gradle实战》或者《maven实战》个人觉得maven在工作中用的多些，但gradle更新。
《高性能MySQL》看了这个面试mysql的知识也不怕什么了吧~
《MySQL技术内幕:InnoDB存储引擎》高人推荐，看的不多，但是绝对厉害啊。
《Java核心技术》没看过第二卷，其他知识从另外的书上积累的。
《
tcp/ip协议
 卷一》经典，个人觉得记不了那么多啊，面试问的网路很少问得生僻~。
《重构》个人觉得挺好的，不然实习的时候负责的老师会叫你改改改，开玩笑，最主要是提升效率，方便维护。
---------------------------------------------------资料（待补充~）","大家可以关注我的公众号：
Hollis
，和我交流。关注后，在后台回复：成神导图，可以获得Java工程师进阶的整套思维导图哦。
自己在几年前参加的校招，经历过很长一段时间的复习，在当年的校招中拿到了很多公司的offer，最后入职了阿里。
那段时间，自己看了很多大厂的面经，从各个面经中总结出一套我认为『应届生应聘互联网公司Java职位必会的题目』。
这些面试问题不仅仅涉及到Java语言，还会包括很多其他知识，比如计算机基础知识（数据结构、计算机网络、操作系统等）、C语言基础、Java底层知识以及一些框架相关知识等
C语言基础
Java基础
Java高级
Java Web
设计模式
知识的综合能力
工具使用
项目相关
技术热情
表达能力
思考方式
其他
推荐阅读
还有，我知道很多人会问关于这些题目的答案问题。答案我都有，由于篇幅有限没办法直接贴上来。这些题目的答案我会在我的公众号及
知识星球
中给出，感谢关注。
为了方便，我把他们分了类，有一些是必看的，我用！标注，有一些进阶型的我用%标注，有一些需要了解的，我用？标注。
必会关键字
void
 
byte
 
int
 
long
 
char
 
short
 
float
 
double
 
String
 
StringBuffer
 
StringBuilder
 
Array
 
Collection
 
Collections
 
List
 
ArrayList
 
LinkedList
 
Vector
 
Set
 
HashMap
 
TreeMap
 
LinkedHashMap
 
ConcerrentHashMap
 
Set
 
TreeMap
 
HashMap
 
synchronized
 
volatile
 
transient
 
implements
 
extends
 
public
 
private
 
protected
 
this
 
super
 
static
 
final
 
const
 
run
 
start
 
thread
 
enmu
 
stack
 
queue
 
list
 
heap
 
throw
 
throws
 
try
 
catch
 
finally
 
break
 
continue
 
instanceof
计算机基础知识
数据结构
！1、什么是队列、栈、链表
！2、什么是树（平衡树,排序树,B树,B+树,R树,
红黑树
）、堆（大根堆、小根堆）、图（有向图、无向图、拓扑）
！3、栈和队列的相同和不同之处
？4、栈通常采用的两种存储结构
%5、两个栈实现队列，和两个队列实现栈
算法
！1、
排序
都有哪几种方法？
！2、会写常用的排序算法，如快排，归并等。
%3、各种排序算法的
时间复杂度
和
稳定性
 ，重点快排。
！4、单链表的遍历和逆序
！5、
深度优先搜索
和
广度优先搜索
？6、最小生成树
！7、常见Hash算法，哈希的原理和代价
%8、全排列、贪心算法、KMP算法、hash算法
？9、一致性Hash算法
操作系统
？1、虚拟内存管理
？2、换页算法
！3、进程间通信
？4、进程同步：生产者消费者问题、哲学家就餐问题、读者写者问题
！5、死锁的四个必要条件，避免方法
！6、Linux的一些基本命令，如
ls
、
tail
、
chmod
等
计算机网络
！1、tcp,udp区别
！2、HTTP请求和响应的全过程
！3、HTTP常见响应码：200、301、302、404、500
！4、get和post的区别
！5、forward和redirect的区别
！6、
osi
七层模型
！7、
tcp/ip
四层模型及原理
！8、TCP和UDP区别
！9、TCP的三次握手，四次关闭
%10、丢包,粘包，
？11、容量控制，拥塞控制
？12、子网划分
%13、IPV4和IPV6
？14、HTTPS和HTTP/2
数据库：
！1、
范式
！2、数据库事务和隔离级别
！3、为什么需要锁，锁定分类，锁粒度
%4、
乐观锁
，
悲观锁
的概念及实现方式
！5、
分页
如何实现（
Oracle
，
MySql
）
！6、Mysql引擎
？7、MYSQL语句优化
%8、从一张大表读取数据，如何解决性能问题
！9、
内连接
，
左连接
，
右连接
作用及区别
！10、
Statement
和
PreparedStatement
之间的区别
%11、
索引
以及
索引的实现
(B+树介绍、和B树、R树区别
？12、什么是数据库连接池
海量数据处理
%1、海量日志数据，如何提取出某日访问淘宝次数最多的IP
%2、上亿数据，统计其中出现次数最多的前N个数据
%3、5亿个int，找出他们的中位数
%4、两个文件，各存放50亿条URL，每个URL占64字节。内存限制是4G，找出两个文件中相同的URL
%5、有40亿个不重复的unsigned int的整数，没排过序，现在给一个数，如何快速判断这个数是否在这40亿个数当中。
？6、提示：分治、Hash映射、堆排序、双层桶划分、Bloom filter、bitmap、数据库索引、mapreduce
C语言基础
构造函数、析构函数
！1、构造函数和析构函数
%2、为什么不要在构造器中调用虚函数
%3、为什么不要在析构函数中抛出异常
c++相关
！1、面向对象的三大基本特征，五大基本原则
%2、C++继承的内存布局
！3、C++多态的实现机制
！4、new/deletr和
malloc
/free的区别
其他
！1、为什么使用补码
%2、C语言中的内存泄漏
！3、进制转换
% 4、自己编写strlen/strcpy/strcmp
！ 5、C、C++以及Java之间的区别和各自优缺点
Java基础
封装、继承、多态
！1、Java中实现多态的机制是什么，动态多态和静态多态的区别
！2、接口和抽象类的区别，如何选择
！3、Java能不能多继承，可不可以多实现
%4、
Static Nested Class
 和 
r Class
的不同
！5、重载和重写的区别。
！6、是否可以继承
String
类
！7、构造器是否可被
override
?
！8、
public
,
protected
,
private
的区别?
集合相关
！1、列举几个Java中
Collection
类库中的常用类
！2、
List
、
Set
、
Map
是否都继承自
Collection
接口？存储特点分别是什么？
！3、
ArrayList
、
LinkedList
和
Vector
之间的区别与联系
！4、
HashMap
和
Hashtable
、
TreeMap
以及
ConcurrentHashMap
的区别
！5、
Collection
 和 
Collections
的区别
%6、其他的集合类：
treeset
,
linkedhashmap
等。
异常相关
！1、
Error
和
Exception
的区别
！2、异常的类型，什么是运行时异常
！3、
final
、
finally
和
finalize
的区别
%4、
try-catch-finally
中，如果在
catch
中
return
了，
finally
中的代码还会执行么，原理是什么？
！5、列举3个以上的
RuntimeException
！6、Java中的异常处理机制的简单原理和应用
其它
！1、
String
和
StringBuffer
、
StringBuilder
的区别
！2、
==
和
equals
的区别
%3、
hashCode
的作用，和
equals
方法的关系
！4、
Input/OutputStream
和
Reader/Writer
有什么区别
！5、如何在字符流和字节流之间转换？
！6、
switch
可以使用那些数据类型
%7、Java的四种引用
！8、序列化与反序列化
！9、正则表达式
！10、
int
和
Integer
的区别，什么是自动装箱和自动拆箱
Java高级
多线程
！1、进程和线程的区别
！2、并行和并发的区别和联系
！3、同步与异步
！4、多线程的实现方式，有什么区别
！5、什么叫
守护线程
%6、如何停止一个线程？
！7、什么是
线程安全
？
！8、
synchronized
 和 
lock
的区别
！9、当一个线程进入一个对象的一个
synchronized
方法后，其它线程是否可进入此对象的其它方法?
！10、启动一个线程是用
run()
还是
start()
?
！12、wait和sleep的区别
%13、notify和notifyAll的区别
%14、线程池的作用
%15、Java中线程池相关的类
JVM底层技术
！1、
gc
的概念，如果A和B对象循环引用，是否可以被GC？
%2、jvm gc如何判断对象是否需要回收，有哪几种方式？
！3、Java中能不能主动触发GC
！4、JVM的内存结构，堆和栈的区别
！5、JVM堆的分代
%6、
Java
中的内存溢出是什么，和内存泄露有什么关系
！7、Java的类加载机制，什么是双亲委派
！8、ClassLoader的类加载方式
IO
！ 1、NIO、AIO和BIO 之间的区别
？2、
IO
和
NIO
常用用法
其它
？1、
hashcode
 有哪些算法
！2、反射的基本概念，
反射
是否可以调用私有方法
！3、Java中
范型
的概念
？4、JVM启动参数，
-Xms
和 
-Xmx
%5、
代理机制
的实现
！6、
String s = new String(""s"")
，创建了几个对象。
Java Web
Servlet
！1、
JSP
和
Servlet
的区别，
Servelt
的概念。
！2、
Servlet
的生命周期
！3、Servlet中的
session
工作原理 ，以及设置过期时间的方式
！4、Servlet中，
filter
的应用场景有哪些？
？5、JSP的动态
include
和静态
include
%6、web.xml中常用配置及作用
%7、Servlet的线程安全问题
MVC框架
！1、介绍几个常用的MVC框架
！2、什么是MVC
！3、
Struts
中请求的实现过程
%4、
Spring mvc
与
Struts mvc
的区别
？5、
Service
嵌套事务处理，如何回滚
！6、struts2 中拦截器与过滤器的区别及执行顺序
%7、struts2拦截器的实现原理
http相关
！1、
session
和
cookie
的区别
！2、HTTP请求中
session
实现原理？
%3、如果客户端
禁止Cookie能实现Session吗
？
！4、http中 
get
和
post
区别
！5、
redirect
与
forward
的区别
！6、常见的web请求返回的状态码。404、302、301、500分别代表什么
SSH相关
？1、
Hibernate
/
Ibatis
/
MyBatis
之间的区别
？2、什么是
OR Mapping
%3、hibernate的缓存机制、一级和二级缓存
！4、使用Spring的好处是什么，Spring的核心理念
！5、什么是
AOP
和
IOC
，实现原理是什么
！6、spring bean的初始化过程
！7、Spring的
事务管理
 ，
Spring bean注入
的几种方式
%8、spring四种依赖注入方式
容器相关
！1、什么是web服务器、什么是应用服务器
！2、常用的web服务器有哪些？
？3、
Tomcat
和
weblogic
的区别
web安全
！1、什么是
SQL注入
 ，如何避免。
%2、什么是XSS攻击，如何避免
%3、什么是CSRF攻击，如何避免
动态代理
！1、Java的动态代理的概念
%2、Java的动态代理的实现
编码问题
！1、常用的字符编码
！2、如何解决中文乱码问题
其它
%1、XML的解析方式，以及优缺点。
%2、什么是ajax，
Ajax
如何解决跨域问题
设计模式
%1、谈一下自己了解或者熟悉的
设计模式
！2、
Singleton
的几种实现方式，实现一个线程安全的单例。
？3、
工厂模式
和
抽象工厂模式
之间的区别
知识的综合能力
！1、请介绍一下一个http请求的全过程，描述的越全面越好
！2、当你在浏览器地址栏输入
http://www.
taobao.com
，敲下回车之后都发生了什么
工具使用
！1、知道git/svn是干什么的吗？用过吗
！2、知道maven/gradle是干什么的吗？用过吗
！3、平常使用什么IDE，为什么
！4、平常使用什么浏览器，为什么
！5、平常开发机器是什么操作系统的
！6、会在Linux上开发吗。Linux常用命令会吗
项目相关
！1、请简单介绍一下你的这个项目
！2、你在这个项目中充当什么角色
！3、这个项目的技术选型有做过么。
！4、选择某项技术做过哪些调研和对比
！5、这个项目中遇到的最大的问题是什么？你是如何解决的。
！6、项目中是否考虑过性能、安全性等问题
技术热情
！1、当前Java的最新版本
！2、Java8的lambda表达式
%3、Java8的stream API
%4、Java9的模块化
%5、Java10的局部变量类型推断
%6、Spring Boot2.0
%7、HTTP/2
%8、会翻墙么，知道翻墙的原理吗
！9、你最近在读什么书
表达能力
！1、能不能简单做一个自我介绍。
！2、能不能描述一下杭州给你的印象。用三句话概括一下。
思考方式
！1、如何估算杭州有多少软件工程师
！2、你最近读过的印象最深的文章是什么
！3、这篇文章中有几个观点，你最赞成哪一个，最不赞成哪一个
其他
！1、你对加班怎么看
！2、你还有什么问题要问我（面试官）的么
推荐阅读
程序员面试笔试宝典
程序员面试金典
Java编程思想
Effective Java
深入理解Java虚拟机
大话数据结构
剑指Offer
！Hollis技术博客（
http://www.
hollischuang.com
）及个人公众号（Hollis）","要问各大公司对应届本科生有什么要求，最简单粗暴，却也最有效的方法，就是去看他们每年都考应届生们什么问题。
牛妹这里整理了111篇各大互联网公司Java工程师笔经面经，希望能够帮到大家。
阿里巴巴，美团等各大互联网公司Java工程师笔经面经：
今天斩获今日头条 实习offer 特来分享
WAP onsite interview面经
BAT面经，暑假前趁热来一发吧
怒斩阿里、百度、微软、华为offer
蚂蚁金服面试经历（内含大量干货）
WAP在线面试经历
轻松搞定58同城面试
【百度、腾讯、阿里等】+【JAVA开发实习生】+春招面试经验
万革始(Works Application)的面试经验
爱奇艺校招面经
新鲜出炉的迅雷面经
如愿以偿获得Google（北京）技术岗工作
阿里视频面试 研发工程师java
软件研发春招总结（已拿百度、京东offer）
今日头条图片搜索实习生面试经历
笔试和面试不太难，大家加油（上海爱奇艺）
春招总结
携程面经(offer get)
爱奇艺校招面经纯干货
春招总结
【阿里】阿里 Java 研发岗位面经
记录一点春招
网易游戏-直播平台-后台开发-已拿offer
滴滴新锐(牛客网视频面)
金山WPS服务端开发工程师面试经历
渣渣的CVTE、阿里、去哪儿、腾讯面经
阿里+华为实习已拿offer
渣渣的春招总结
【回馈分享】2017春招8家公司面试汇总
阿里面经
蚂蚁JAVA的面试
CVTE 一面二面总结
我的春招应该到此结束了
蘑菇街一面 Java 开发工程师
谷歌微软实习面经
腾讯实习面经(offer)
终于等到心心念念的offer
网易实习生面经
分享面经与总结（京东+搜狐+CVTE，offer已get）
阿里巴巴2017实习面试分享（技术三面+HR面）
阿里B2B面试经验（5轮技术面+HR面）
学渣的春招路
网易杭研java面经_413
一个菜鸡的春招经历合集（美团点评、搜狐、cvte、招银网络）
京东暑期实习面经
头条第一批面经 后台开发
京东java后台开发HR面试 
京东美团Java研发暑期实习面经
我的京东Java开发实习生面试经历
网易杭州_实习_Java开发_2017.4.13
去哪儿实习生面试总结分享
录一下我这次的春招面试经历
华为面经（java）
去哪儿网面经
人人实习生一二面面经分享
分享一波美团的面经攒人品（已拿offer）
对一个多月的实习春招问到的问题做个汇总
CVTE后台实习面经
oppo java一面
携程2017暑期实习一面二面经验
2017年校招【京东面经】 哈尔滨站
 
秋招面经分享，赠人玫瑰，手留余香~_笔经面经_牛客网
 
完美JAVA一面_笔经面经_牛客网
 
乐视java（1面+2面）_笔经面经_牛客网
 
西安，美团面经 java_笔经面经_牛客网
 
一直在牛客作伸手党这么久，发点这两天美团面试攒攒人品_笔经面经_牛客网
 
招银一面_笔经面经_牛客网
 
京东Java研发（1面+2面）_笔经面经_牛客网
招银电面_笔经面经_牛客网
招银网络科技一面，攒人品_笔经面经_牛客网
武汉京东一面面经_笔经面经_牛客网
招银网络一面...（好像是按照成绩进行面试的..）_笔经面经_牛客网
招银科技 一面_笔经面经_牛客网
招银网络一面_笔经面经_牛客网
兄弟我分享一面面经_笔经面经_牛客网
分享携程笔试两道编程，AC(java版)_笔经面经_牛客网
CVTE 西安 java面经_笔经面经_牛客网
热乎的面经之“远景能源”2017校园招聘_笔经面经_牛客网
JD(北京)复试_笔经面经_牛客网
谈谈我那的京东面试，伤心_笔经面经_牛客网
创新工厂涂鸦移动内推面经_笔经面经_牛客网
京东校招一面_笔经面经_牛客网
京东一面面经_笔经面经_牛客网
阿里JAVA开发校招笔试 很好很强大
网易杭研，Java工程师，面经，已拿offer_笔经面经_牛客网
华为28号粤港澳招聘面经_笔经面经_牛客网
百度一二面面筋以及视频面是什么状况？_笔经面经_牛客网
微店电面_笔经面经_牛客网
CVTE内推校招第一个Offer好突然_笔经面经_牛客网
微店面经_笔经面经_牛客网
华为面试感觉有点坑啊_笔经面经_牛客网
网易java研发面经_笔经面经_牛客网
华为优招面经-干货_笔经面经_牛客网
【面经】一面+二面+HR面【网易内推】【java开发工程师】_笔经面经_牛客网
网易互联网Java内推面试经验-19号_笔经面经_牛客网
校招季一路走来面经分享_笔经面经_牛客网
网易+阿里内推面经_笔经面经_牛客网
渣渣养成记（中兴+腾讯+CVTE+乐视+京东+七牛云）_笔经面经_牛客网
120道java面试常考题目（附答案）_笔经面经_牛客网
[java后端]线下笔试及面试复习资料[一]--数据库_笔经面经_牛客网
[java后端]线下笔试及面试复习资料[一]_笔经面经_牛客网
华为28号粤港澳招聘面经_笔经面经_牛客网
我的2017年校招历程_笔经面经_牛客网
校招总结：美团点评/滴滴/360/微店/小红书/有赞_笔经面经_牛客网
校招总结~_笔经面经_牛客网
挖财网面试_笔经面经_牛客网
2017年秋招Java后台的学习与面试经验_笔经面经_牛客网
技术渣渣的面经_笔经面经_牛客网
去哪网offer面试总结（java开发）_笔经面经_牛客网
欢聚时代 Java开发工程师_笔经面经_牛客网
2016秋招面经_笔经面经_牛客网
更多名企笔试真题解析、面试经验交流、招聘信息内推，尽在牛客！
求职之前，先上牛客！快快下载拿offer！
最后附赠一个彩蛋~
JavaWeb后端工程师技能图：
最后，祝大家都能成功斩获offer~","看了前面 
@林子云
 的答案，说实话，很震撼！我看回答的时间是 2014 年，他在那年的 3 月份通过阿里的实习招聘，并且在暑期转正了
！
时隔 8 年，大佬总结的阿里校招研发工程师岗位考察的基础，可以说依然适用
！
遗憾的是，大佬只给出了轮廓，具体该怎么学，并没有给出，我想，这应该是很多同学关心的问题。借这个机会，我给大家详细地梳理一波，记得收藏哦！
（收藏是点赞的三倍，哭了TnT，顺带把赞也安排上呢）
重申一下我学习计算机的观点，我想这会对你快速建立起自己的知识体系很有帮助！并且，你应该按照我这个观点从大一就开始实践起来！
如果你要学习物理，我推荐你顺着物理的发展史学习，先学习牛顿的经典物理，再学习热力学、电磁学，然后学习相对论、量子力学这些彻底推翻经典物理的，最后学习电动力学这种硬核的。
整个学习过程，是
自底向上
的。但是学计算机，这样行不通。
先学习电路，然后学习冯诺依曼结构，造一台计算机？接着再学习如何用汇编写个 mini os？接着学习如何写一个简易版的编译器？最后再学习高级编程语言，比如说 Java、Python？
显然这样是行不通的！
计算机的学习最好是自顶向下
。
什么是顶？我想一门高级的编程语言就是，比如说 Java！
当你学习到 Java 并发编程中的“原子性”、“同步”、“异步”、“进程”、“内存分配”这些概念的时候，你自然而然会产生很多疑问，然后就会去学习计算机组成原理、操作系统，然后你的一系列问题就会逐渐被解决。
当你发现，用 Java 实现某个业务需求时，人家的算法实现比你快得多，你自然会好奇，为什么会这样？然后你发现人家用的数据结构和你的不同，
然后你就会去学习数据结构，接着了解一些高效的算法
，比如动态规划等。
一、Java 语言基础
大佬把 Java 语言基础放在了第 6 的位置，我认为应该放在第一位。
你不要一上来就去读《Java 编程思想》这样的经典黑皮书，因为你还没有一丁点编程基础，去看这本黑皮书很容易劝退。你可以先看看
我整理的这份 GitHub 上星标 115k+ 的 Java 教程，里面涵盖了 Java 所有的知识点，包括 Java 语法、Java 集合框架、Java IO、Java 并发编程和 Java 虚拟机，内容不多，只讲重点
。
这些，全部都是校招面试中考察的重点。为了整理这份 PDF，我可是费了老大劲，希望你能珍惜。
然后你可以去看视频入门，无论是动力节点的，还是尚硅谷的，我觉得都可以，你可以每个看那么五六节，感觉哪个老师的风格更适合你就选哪一个。
看着弹幕学着习，就是那么朴实无华。不过，这两份视频教程的内容实在是太多了，以至于有些内容是可以跳过的，这样能节省不少时间。比如说：
环境变量配置
editplus
 的安装
JDK 的安装
PATH 环境变量的配置
MyEclipse
等等
因为现在都用 IDEA 作为集成开发环境了，完美不需要再搞这些事情。在这之后，推荐给你三本书：《Java编程思想》、《Java 并发编程实战》和《深入理解Java虚拟机》。我桌子版摆了一大摞 Java 相关的书籍。
Java 并发编程和 Java 虚拟机是校招面试中的核心，我把一些题目列出来，你可以拿来自测。
并行和并发有什么区别?
线程和进程的区别?
守护线程是什么?
创建线程有哪几种方式?
说一下 runnable 和 callable 有什么区别?
线程有哪些状态?
sleep() 和 wait() 有什么区别?
notify()和 notifyAll()有什么区别?
线程的 run()和 start()有什么区别?
创建线程池有哪几种方式?
线程池都有哪些状态?
线程池中 submit()和 execute()方法有什么区别?
在 java 程序中怎么保证多线程的运行安全?
多线程中 synchronized 锁升级的原理是什么?
什么是死锁?
怎么防止死锁?
ThreadLocal 是什么?有哪些使用场景?
说一下 synchronized 底层实现原理?
synchronized 和 volatile 的区别是什么?
synchronized 和 Lock 有什么区别?
synchronized 和 ReentrantLock 区别是什么?
说一下 atomic 的原理?
Java 内存模型（JMM）、重排序与 happens-before 原则了解吗？
AQS了解么？原理？AQS 常用组件：Semaphore (信号量)、CountDownLatch （倒计时器） CyclicBarrier(循环栅栏)
ReentrantLock 、 ReentrantReadWriteLock
CAS 了解么？原理？
说一下 JVM 的主要组成部分?及其作用?
说一下 JVM 运行时数据区?
什么是双亲委派模型?
说一下类装载的执行过程?
怎么判断对象是否可以被回收?
说一下 JVM 有哪些垃圾回收算法?
说一下 JVM 有哪些垃圾回收器?
详细介绍一下 CMS 垃圾回收器?
新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?
简述分代垃圾回收器是怎么工作的?
说一下 JVM 调优的工具?
常用的 JVM 调优的参数都有哪些?
二、 Spring / SpringBoot
虽然大佬在第 7 点没有提 Spring Boot，那是因为 2014 年的时候 Spring Boot 还没有走入大众的视野，当时的 SSM（Spring+SpringMVC+MyBatis）还是顶梁柱！
框架部分不仅仅是要掌握怎么用，更重要的是要知道原理，Spring 的核心说一千道一万，就是 AOP、IoC。
AOP（Aspect-Oriented Programming），也就是面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
IoC（Inverse of Control），也就是控制反转，是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。DI（Dependency Injection），也就是依赖注入，原来叫 IoC，能让人更加直观和清晰地理解其背后所代表的含义。
Spring 怎么学？可以到 B 站上看一下
江南一点雨的视频教程
。
先学习 SSM，再学习 Spring Boot。Spring Boot 的出现，并不意味着 Spring 和 SpringMVC 已经过时了，从设计目的上来说，Spring Boot 只是实现了 Spring 的自动装配，降低了项目搭建的难度。
从技术角度来说，Spring Boot 的底层依然是 Spring 的核心机制，也就是 AOP 和 IoC，Spring Boot 只是一个承载者。在我看来，学习 Spring 的正确路径应该是 
Spring -> Servlet -> Spring MVC -> Spring Boot
。
三、C 语言
大佬没有提 C 语言，为什么我要提呢？为什么学了 Java，又要学习 C语言呢？
这是因为，归根结底，我们学的是计算机科学（CS），而不是编程语言。
我在 GitHub 上开源了一份 CS 自学指南，涵盖了 Java编程语言、数据库、数据结构与算法、计算机组成原理、操作系统、计算机网络、英语、简历、面试等等，欢迎 star。
要想进阿里、美团这样的大厂，计算机组成原理、操作系统、计算机网络、数据结构与算法这些知识点又是不可获取的，而这些知识，有很大一部分是建立在 C 语言的基础上的。
给你推荐一门课，浙江大学
翁恺
教授的《程序设计入门――C语言》，国家级精品课，很适合初学者。
这门课就是关于计算机的那些程序是如何被写出来的，写出来的这些人就是普通的人，那么我们当然也能学会怎么把程序写出来。学习编程最基础的那些东西，无非就是如何表达数据，如何计算，如何在计算的时候使用判断啊、循环啊这些手段
。
四、计算机组成原理
为什么要学习计算机组成原理呢？
我逐渐发现，学习各种编程语言、框架，就好比在练拳法招式，可以在短时间内提高你的武力值，但想要进一步更上一层楼，就必须得扎马步，练习内功心法，对于我们程序员来说，什么是内功心法，当然是计算机的基础知识，比如说计算机组成原理。
大家都知道，
计算机是由 CPU、内存、输入输出设备，这些硬件组成的，但我们程序员，往往从事的是软件开发的工作，怎么在硬件和软件之间搭起一座桥梁呢
？来学习计算机组成原理吧！
学了计算机组成原理，你就可以学习编译原理、操作系统这些硬核的计算机基础知识，不然的话，学起来就会缺少根基。
明白了计算机组成原理的重要性，你肯定要问，如何才能学好这门课呢？
先来分享一些学习资料。
1）入门学习资料
推荐两本书，《计算机是怎样跑起来的》和《
程序是怎样跑起来的
》。
同时，可以配合北京大学的《计算机组成》公开课来学，讲师为陆俊林博士，在线地址：
https://www.
coursera.org/learn/jisu
anji-zucheng
两本书都不厚，属于浓缩精简版的，配有大量的图文。相比较来说，《程序是怎样跑起来的》比《
计算机是怎样跑起来的
》读起来更容易上手一些。
北京大学的这门公开课一共也就 10 多个小时，所以不用花太多时间就能搞明白。
2）进阶版学习资料
同样推荐两本书，《
计算机组成与设计：硬件 / 软件接口
》和《深入理解计算机系统》。
这两本
黑皮书
，读起来就需要花一些时间和精力了。
《深入理解计算机系统》又简写为 CSAPP，在网上有配套的视频课程，地址：
https://www.
bilibili.com/video/av24
540152/
中文字幕是通过 Google 翻译后重新校对的，精校版见：
https://www.
bilibili.com/video/av31
289365
如果想看英文原版的，见地址：
https://www.
youtube.com/playlist?
list=PLmBgoRqEQCWy58EIwLSWwMPfkwLOLRM5R
另外，《编码：
隐匿在计算机软硬件背后的语言
》这本书对理解计算机硬件会有很大的帮助。
再来分享一些学习心得。
学习计算机组成原理的时候，会涉及到很多很多概念，每个概念剥茧抽丝后，又会牵扯出很多相关的概念，比如说你想理解 CPU 是如何实现加法运算的，你就会遇到算术逻辑单元这个概念，然后还要理解计算机是如何把整数表示成二进制数的等等。
这些概念你很难在短时间内全部消化掉，所以你需要隔一段时间重新去学习，并且要结合实际的工作需求去理解。
比如说，涉及到金融计算时，为什么不能直接使用浮点数？
这背后的原因就是，计算机存储的是二进制，而二进制是无法精确地表示浮点数的。但二进制可以精确地表示整数。
（至于为什么，就需要深入地学习计算机组成原理了。《程序是怎样跑起来的》这本书的第二章和第三章就会详细地解释）
所以实际的工作当中，一般会用整数来表示金额，比如说 1.11 元，会乘以 100，用 111 来表示，返回给用户的时候再除以 100，免得在计算的过程中丢失精度。
五、操作系统
也就是大佬提到的第一点，需要关注内存/线程/进程等方面。
为什么要学习操作系统呢？第一，面试要考；第二，无论学习哪门子编程语言，比如说 Java、C/C++，都需要和操作系统打交道，像 Java 中的多线程技术，其实是由操作系统来负责进程和线程管理的；第三，学习操作系统，还能学到内存分配方面的知识。
《
操作系统概念
》 （“龙书”）和 《
现代操作系统
》 是操作系统领域的经典书籍。只不过，这两本书对学生来说，不是特别友好，所以遭到了很多批评。
操作系统是计算机系统中负责管理各种软硬件资源的核心系统软件，为应用软件运行提供良好的环境。
清华大学操作系统课-学堂在线
这门课程以主流操作系统为实例，以教学操作系统 ucore 为实验环境，讲授操作系统的概念、基本原理和实现技术，是一门非常值得推荐的视频课。
六、计算机网络
鉴于那么多的关于网络服务端和客户端的软件工程，计算机网络是计算机科学中价值最为“立竿见影”的领域之一。
计算机网络-自顶向下方法
是一本我比较钟爱的书籍，书中的小项目和习题非常值得练习，尤其是
Wireshark labs
部分。B 站上的这个
计算机网络微课堂
视频课非常不错，强烈推荐。
其他书籍：
网络是怎样连接的
图解 HTTP
图解TCP/IP
TCP/IP详解 卷1：协议
需要关注的重点：
七层结构，简单介绍一下每一层。
输入 URL 后，将发生什么？这个问题会涉及到很大一部分的计算机网络基础。
HTTP 和 HTTPS，DNS 解析
TCP、UDP、拥塞控制、三次握手、四次挥手、滑动窗口
IP 和 ARP 协议
七、数据库
也就是大佬提到的第 4 点，可能不会问得特别多。SQL 语法需要准备一下，有的面试会让你根据场景写出 SQL。MySQL 和 Redis 是面试中常问的两个数据库，这里推荐看《MySQL 技术内幕 innodb 存储引擎》和 《Redis 设计与实现》。
索引：B+ tree索引、哈希索引、全文索引、覆盖索引等
存储引擎简单介绍，如 InnoDB, MyISAM
主从复制
事务特性简单介绍
在线学习网站：
MySQL Tutorial
其他书籍：
MySQL必知必会
MySQL技术内幕-InnoDB存储引擎
《
Redis 深入历险核心原理与应用实战
》
《
高性能 MySQL
》
《
SQL 必知必会
》
八、设计模式
也就是大佬提到的第 5 点。常用的几种设计模式必须得清楚，比如：
我认为设计模式是初中级程序员迈向高级程序员的必经之路。有不少程序员，前期冲劲十足，但后继乏力，都是吃了设计模式的亏。在工作的前几年，大部分程序员都处于熟悉编程语言的阶段，也就是处于“技”的阶段，随后就要进入“术”的阶段了。在编程领域，“术”的典型代表就是“设计模式”。
你可能听说过，学习设计模式非常的重要，那么为什么这么重要呢，设计模式到底是什么？打个比喻学编程就像学武功一样。武功要练得很牛逼，有两样东西不能丢。第一，是内功；第二，是武功秘籍。内功对应到编程就是我们编程基础能力，那编程的设计模式就可以想象成武术中的武功秘籍。
这里给你推荐一份全网阅读超过 500 万次的设计模式 PDF，持续霸榜 GitHubTrending
。
九、数据结构与算法
像阿里、美团，这些互联网大厂，对算法都比较痴迷。给你看看阿里校招对 Java 研发岗的要求。
可以看得出，校招不同社招，更看重的是你的计算机基础功底和你的学习能力，对数据结构与算法的要求甚至高过计算机网络和编程语言。
数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。 它包含三方面的内容，逻辑关系、存储关系及操作。 不同种类的数据结构适合于不同种类的应用，而部分甚至专门用于特定的作业任务。 例如，计算机网络依赖于路由表运作，B 树高度适用于数据库的封装。
为什么数据结构这么重要呢？清华大学计算机系
邓俊辉
教授有过这样一段描述：
数据结构是计算机科学的关键内容，也是构建高效算法的必要基础。其中涉及的知识，在相关专业的课程系统中始终处于核心位置。以 ACM/IEEE Computing Curricula（计算机教学大纲）为例，其中对于几个相关专业（计算机科学、计算机工程、信息系统、信息技术、软件工程）的共同要求中，数据结构与算法作为程序设计概念与技能的核心，紧随在数学之后，排在第二位。
算法研究的目的是为了更有效的处理数据，提高数据运算的效率，数据运算是定义在数据结构上的，大厂的笔试基本都考这个。如果你想拿到更多的 offer，拿到更好的 offer，LeetCode 上的题要能刷个一百到三百道，有时间有精力的话，最好参加一下 ACM 竞赛，在找工作的时候会非常有优势
。我这里有一份美团大佬的刷题笔记，强烈推荐给你！
展示点内容给你看下。
十、练手项目
也就是阿里大佬提到的第 9 点，大学阶段，做什么练手项目呢？推荐你看看我之前的一个回答。
一共十条，刚好十全十美。
最后，给你聊一下我认为学编程当中最重要的三点，尤其是针对大学生来说。
热爱
努力
坚持
先说热爱。
有的同学是一开始就热爱，所以选专业的时候就选择了计算机专业；有的同学是误打误撞，比如说我就是，大学其实选的是机械自动化，后来被调剂到了计算机网络专业，属于典型的后知后觉型。
一开始，和大多数新人一样，我认为编程好难学，班里面的好多同学也认为好难学，能转专业的就转，只有不能转的才留了下来。
十几年前的计算机专业远没有现在这么热闹，很多学校都是作为边缘专业来录的。和我同届的高中同学，我认识的当中，没有主动选择计算机专业的。
所以，我对计算机的热爱，纯粹是经过后天刻意练习的。很多同学可能会不解，热爱也能练习？
当然。
当我发现这个专业找到工作，能养活自己，能不再伸手向父母要钱的时候，热爱就一点点的来了。随着年纪的增长，我越来越喜欢这个专业了，不是因为它充满魅力，而是它让我的生活变得越来越好。
对，我是个俗人。
有了热爱，你自然就会去努力！这是水到渠成的一件事情。
但往往很多时候，你可能会迷茫，不知道该往哪里去努力，不知道自己的劲往哪里使！
那看完了这篇回答，你就知道努力的方向了，剩下的就是坚持。送你一句话：“伟大的牛逼之前总是傻逼式的坚持。”
最后，送你一份
计算机必读经典书单（可 download）
。
我是二哥 
@沉默王二
 ，希望回答能够帮助到你~笔芯~","阿里巴巴
要的不是平台型人才，它要的是计算机人才。
平台型人才可以培养，
什么叫计算机人才？掌握操作系统，数据结构，等等","楼上很多大牛都给出了很多阅读资料，很值得好好阅读巩固基础。
我也看过一个比较“精华”且实用的阿里面试问题的帖子，不仅仅适用于社招，也适用于校招。
大家可以参考下：
LZ会分为四个部分来谈论这个问题，由于LZ本身是Java出身，因此关于主语言的问题，都是与Java相关，其它语言的同学可以选择性忽略。此外，面试的时候一般面试官的问题都是环环相扣，逐渐深入的，这点在下面大家可以更明显的感受出来。
1、主语言本身以及它的高级特性。
 
　　主语言当然就是你平日里拿来赚钱的家伙。不要告诉LZ你没有主语言，你会N多种语言，或者是你精通N多种语言，你要非这么说的话，你可以来杭州试试，LZ保证不打死你，最多打残。
LZ的主语言很显然是Java，那么对于Java来说，它的语言本身以及它的高级特性，都有哪些比较容易在面试中问到呢？
　　一般情况下，主要有以下知识点很容易被问到。（PS：以下所列举的，都是一些Java相对而言比较高级一点的知识点，因为这里谈的是社招，而不是校招）
1）Java的数据结构相关的类实现原理，比如LinkedList，ArrayList，HashMap，TreeMap这一类的。以下简单模拟一个数据结构的连环炮。
　　比如，面试官先问你HashMap是不是有序的？
　　你肯定回答说，不是有序的。那面试官就会继续问你，有没有有顺序的Map实现类？
　　你如果这个时候说不知道的话，那这个问题就到此结束了。如果你说有TreeMap和LinkedHashMap。
　　那么面试官接下来就可能会问你，TreeMap和LinkedHashMap是如何保证它的顺序的？
　　如果你回答不上来，那么到此为止。如果你依然回答上来了，那么面试官还会继续问你，你觉得它们两个哪个的有序实现比较好？
　　如果你依然可以回答的话，那么面试官会继续问你，你觉得还有没有比它更好或者更高效的实现方式？
　　如果你还能说出来的话，那么就你所说的实现方式肯定依然可以问你很多问题。
以上就是一个面试官一步一步提问的例子。所以，如果你了解的不多，千万不要敷衍，因为可能下一个问题你就暴露了，还不如直接说不会，把这个问题结束掉，赶紧切换到你熟悉的领域。
 
2）Java并发包当中的类，它们都有哪些作用，以及它们的实现原理，这些类就是java.concurrent包下面的。与上面一样，咱们也简单的模拟一个并发包的连环炮。
　　比如面试官可能会先问你，如果想实现所有的线程一起等待某个事件的发生，当某个事件发生时，所有线程一起开始往下执行的话，有什么好的办法吗？
　　这个时候你可能会说可以用栅栏（Java的并发包中的CyclicBarrier），那么面试官就会继续问你，你知道它的实现原理吗？
　　如果你继续回答的话，面试官可能会继续问你，你还知道其它的实现方式吗？
　　如果你还能说出很多种实现方式的话，那么继续问你，你觉得这些方式里哪个方式更好？
　　如果你说出来某一个方式比较好的话，面试官依然可以继续问你，那如果让你来写的话，你觉得还有比它更好的实现方式吗？
　　如果你这个时候依然可以说出来你自己更好的实现方式，那么面试官肯定还会揪着这个继续问你。
为什么说面试的时候要引导面试官，原因就在这了。因为面试官的提问很多时候都是有迹可循的，你如果抓住了他的轨迹，能够猜到他下面很可能会问什么，那你在回答的时候就可以往你想要谈的方向去说。这样面试时就会显得更加从容，更加的游刃有余。
 
3）IO包和NIO包中的内容。这部分里面NIO会是重点，IO包大部分都会比较熟悉，因此可能会直接略过，直接问你NIO的内容。
　　IO包和NIO包的内容相对来说不是很多，首先NIO模型要熟悉，特别是其中的
selector
一定要非常清楚它的职责和实现原理。其实NIO的核心是IO线程池，一定要记住这个关键点。有的时候，面试官可能也会问你IO包的设计模式（装饰器模式），为什么要这样设计？
　　有的面试官还会问你有没有更好的设计，这个时候如果你不知道请果断说自己现在的水平有限，想不出来更好的设计，千万不要信口开河，随意YY。
4）Java的虚拟机的内容。这部分主要包括三部分，GC、类加载机制，以及内存。
　　一个
GC部分简单的连环炮。
面试官可以先问你什么时候一个对象会被GC？
　　接着继续问你为什么要在这种时候对象才会被GC？
　　接着继续问你GC策略都有哪些分类？
　　你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？
　　你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？
　　你如果选出来了，继续问你，为什么要选择这个策略？
下面是关于类加载机制的简单连环炮。
首先肯定是先问你Java的类加载器都有哪些？
　　回答了这些以后，可能会问你每个类加载器都加载哪些类？
　　说完以后，可能会问你这些类加载之间的父子关系是怎样的？
　　你在回答的时候可能会提到双亲委派模型，那么可以继续问你什么是双亲委派模型？
　　你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？
　　你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？
再来一个关于内存的连环炮。
首先肯定就是问你内存分为哪几部分，这些部分分别都存储哪些数据？
　　然后继续问你一个对象从创建到销毁都是怎么在这些部分里存活和转移的？
　　接着可能会问你，内存的哪些部分会参与GC的回收？
　　完事以后，可能还会问你Java的内存模型是怎么设计的？
　　你回答了以后，还会继续问你为什么要这么设计？
　　问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？
　　你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。
基本上Java语言本身以及语言稍微高级点的内容就是以上部分，如果你能把以上四部分了解的非常透彻，那基本上Java这部分就没啥问题了，因为光以上的内容就够你跟面试官聊很久了。你聊这些聊得久了，自然问你其它问题的时间就会短点。
 
　　你从LZ写这些问题的过程也应该能感受出来，很多时候，面试官都是顺着一条线一路问下去的，如果你觉得这条线你不熟悉的话，就要及时拐弯，引导面试官去问其它方面的问题。千万不要一直往下深入，直到自己跳不出来为止，那就尴了个尬了。
 
　　2、讲述自己的项目，并在中间穿插着问题
这一部分是面试过程中必问，也是聊得最久的一个阶段。除非你前面的语言部分非常扎实，扎实到面试官问了一两个小时，依旧没有探出你对语言本身的了解到底有多深。否则的话，你一定逃不过自己的项目这一关，而且一般情况下聊得时间不会太短。
这一部分内容，一般的模式就是你自己去讲你做过的项目，然后面试官会冷不丁的让你去解释其中某一部分，比如让你解释当时为什么要这么做，或者问你现在觉得有没有更好的办法。而这些穿插的问题，大部分与你的项目所用到的技术有关。而你需要做的，就是充分、再充分的去总结自己做过的项目（尤其是最近的一两个项目），挖掘出一个甚至N个亮点，以备于到时候可以让面试官产生眼前一亮的感觉。如果你能达到这种效果的话，基本上离你成功就不远了。
　　这部分内容由于和每个人自己的经历息息相关，因此这里也没法列举可能问到的问题。这篇文章《
程序员面经：面试前到底该不该刷题以及面试前该如何准备
》是LZ之前写的，里面大概讨论了下如何在面试前总结，有兴趣的可以去了解一下。
3、额外的加分项
　　上面两个阶段基本上是必问的，还有一些加分项。这些加分项中，有些内容面试官也会问你（比如TCP/IP协议、算法），但更多的是会先问你了解不了解，你了解的话再继续聊，不了解的话就直接略过了，不至于因为这种问题而直接把你打入地狱。
　　下面LZ列举一下这些加分项，如果可以的话，这些加分项还是要争取一下的。
　　1、
计算机系统原理
。
 
　　2、网络通信协议（TCP/IP，HTTP等）。
 
　　3、数据结构与算法。
 
　　4、著名
开源项目
的源码。
 
　　5、你自己有很棒的开源项目。
 
　　6、你的个人博客。
 
　　7、待评论区补充。
　　这几项当中，对于前1-3项，如果你之前就比较了解，只是由于时间问题忘记了的话，还是可以临时抱佛脚一下的。至于后面4-6项，就需要你日常的积累了，不是一时半会儿能做到的。如果你平日里没有积累，那么后面这三个加分项只能抛弃了。
4、与你职位相关的内容
　　其实这最后一项是对前面三项的补充，你应该尽量去主攻和你面试的职位相关的内容。比如你面试一个实时计算的职位，那么你的算法最好要厉害，对于著名的实时计算开源项目要熟悉，最好阅读过源码，而且还要对分布式系统有一定的见解。
　　因此，这个第4部分没有具体的内容，只是提醒你，如果你很明确自己的面试职位，最好在面试前准备的时候，尽量朝职位的需求方向靠拢，这样成功的可能性更大。
来源：
回答阿里社招面试如何准备，顺便谈谈对于Java程序猿学习当中各个阶段的建议 - 左潇龙 - 博客园","那些年我看过的书 ―― 致敬我的大学生活 ―― Say Good Bye ！
### 开头
2017.08.21  正式开启我入职的里程，现在已是工作了一个星期了，这个星期算是我入职的过渡期，算是知道了学校生活和工作的差距了，总之，尽快习惯这种生活吧。下面讲下自己的找工作经历和大学阅读的书籍，算是一种书籍推荐，为还在迷茫的你指引方向，同时为我三年的大学生活致敬！也激励我大四在公司实习能更上一层楼！
### 找工作经历
这段经历，算是自己很难忘记的经历吧。既辛酸既充实的日子！也很感谢自己在这段时间的系统复习，感觉把自己的基础知识再次聚集在一起了，自己的能力在这一段时间提升的也很快。后面有机会的话我也想写一系列的相关文章，为后来准备工作（面试）的同学提供一些自己的帮助。自己在找工作的这段时间面过的公司也有几家大厂，但是结果都不是很好，对我自己有很大的压力，当时心里真的感觉 ：“自己真的有这么差”，为什么一直被拒，当时很怀疑自己的能力，自己也有总结原因。一是面试的时候自己准备的还不够充分，虽说自己脑子里对这些基础有点印象，但是面试的时候自己稍紧张下就描述不怎么清楚了，导致面试官觉得你可能广度够了，深度还不够（这是阿里面试官电话面试说的）；二是自己的表达能力还是有所欠缺，不能够将自己所要表达的东西说出来，这可能我要在后面加强的地方；三是我的学校问题，好些家公司面试官对我的学校都有问及，可能觉得我的学校在上海，但是觉得上海好像没这么个学校，在此澄清下，我的学校是华东交通大学，在南昌，不是在南昌，要说和上海交大有没有渊源，我只能说有，具体请去百度查。在面了几家公司失败后，终于面了家公司要我了，我也确定在这家公司了。很幸运，刚出来，就有一个很好（很负责）的架构师带我，这周就给了我一个很牛逼的项目给我看（虽然自己目前还没有思路改里面的代码），里面新东西很多，说吃透了这个项目，以后绝对可以拿出去吹逼（一脸正经.jpg）。目前我的找工作经历就简短的介绍到这里了，如果感兴趣的话，可以加群：528776268   进来和我讨论交流。
### 书籍推荐
大学，我不怎么喜欢玩游戏，自己也还算不怎么堕落吧，看了以下的一些书籍，算是对我后面写博客、找工作也有很大的帮助。如果你是大神，请忽略，如果你还是还在大学，和我一样不想把时间浪费在游戏上，可以看看我推荐的一些书籍，有想讨论的请在评论下留下你的评论或者加上面给的群号。
#### Java
1、《Java 核心技术》卷一 、卷二              两本书，算是入门比较好的书籍了
2、《疯狂 Java 讲义》                                很厚的一本书，里面的内容也是很注重基础了
3、《Java 并发编程的艺术》――  方腾飞 、魏鹏、程晓明著        方腾飞 是并发编程网的创始人，里面的文章确实还不错，可以多看看里面的文章，收获绝对很大。
4、《 Java多线程编程核心技术》――  高洪岩著   这本书也算是入门多线程编程的不错书籍，我之前还写了一篇读书笔记呢，[《Java 多线程编程核心技术》学习笔记及总结](
《Java 多线程编程核心技术》学习笔记及总结
)  , 大家如果不想看书的可以去看我的笔记。
5、《Java 并发编程实战》 这本书讲的有点难懂啊，不过确实也是一本很好的书，以上三本书籍如果都弄懂了，我觉得你并发编程这块可能大概就 OK 了，然后再去看看线程池的源码，了解下线程池，我觉得那就更棒了。不想看的话，请看我的博客：[Java 线程池艺术探索](
Java 线程池艺术探索
)  我个人觉得还是写的很不错，那些大厂面试也几乎都会问线程池的东西，然后大概内容也就是我这博客写的
6、《Effective Java》中文版 第二版       算是 Java 的进阶书籍了，面试好多问题也是从这出来的
7、《深入理解 Java 虚拟机――JVM高级特性与最佳实践》第二版     这算是国内讲 JVM 最清楚的书了吧，目前还是只看了一遍，后面继续啃，大厂面试几乎也是都会考 JVM 的，阿里面 JVM 特别多，想进阿里的同学请一定要买这本书去看。
8、《深入分析Java  Web技术内幕  修订版》许令波著   里面知识很广，每一章都是一个不同的知识，可见作者的优秀，不愧是阿里大神。
9、《大型网站系统与 Java 中间件实践》―― 宪杰 著    作者是前淘宝技术总监，见证了淘宝网的发展，里面的讲的内容也是很好，看完能让自己也站在高处去思考问题。
10、《大型网站技术架构 ―― 核心原理与案例分析》 ―― 李智慧 著   最好和上面那本书籍一起看，效果更好，两本看完了，提升思想的高度！
11、《疯狂Java.突破程序员基本功的16课》 李刚 著       书中很注重 Java 的一些细节，讲的很深入，但是书中的错别字特多，可以看看我的读书笔记：[《疯狂 Java 突破程序员基本功的 16 课》读书笔记](
《疯狂 Java 突破程序员基本功的 16 课》读书笔记
)
12、《Spring 实战》   Spring 入门书籍
13、《Spring 揭秘》―― 王福强  著   这本书别提多牛了，出版时期为 2009 年，豆瓣评分为 9.0 分，写的是真棒！把 Spring 的 IOC 和 AOP 特性写的很清楚，把 Spring 的来龙去脉讲的很全。墙裂推荐这本书籍，如果你想看 Spring，作者很牛，资深架构师，很有幸和作者有过一次交流，当时因为自己的一篇博客  [Pyspider框架 ―― Python爬虫实战之爬取 V2EX 网站帖子](
Pyspider框架 ―― Python爬虫实战之爬取 V2EX 网站帖子
)，竟然找到我想叫我去实习，可惜了，当时差点就跟着他混了。作者还有一本书  《Spring Boot 揭秘》。
14、《Spring 技术内幕》―― 深入解析 Spring 架构与设计原理     讲解 Spring 源码，深入了内部机制，个人觉得还是不错的。
15、Spring 官方的英文文档          这个别提了，很好，能看英文尽量看英文
16、《跟开涛学 Spring 3》  《跟开涛学 Spring MVC》  京东大神，膜
17、《看透springMvc源代码分析与实践》    算是把 Spring MVC 源码讲的很好的了
见我的笔记：
[1、通过源码详解 Servlet](
通过源码详解 Servlet
)
[2 、看透 Spring MVC 源代码分析与实践 ―― 网站基础知识](
看透 Spring MVC 源代码分析与实践 ――  网站基础知识
)
[3 、看透 Spring MVC 源代码分析与实践 ―― 俯视 Spring MVC](
看透 Spring MVC 源代码分析与实践 ――  俯视 Spring MVC
)
[4 、看透 Spring MVC 源代码分析与实践 ―― Spring MVC 组件分析](
看透 Spring MVC 源代码分析与实践 ――  Spring MVC 组件分析
)
18、《Spring Boot 实战》
19、Spring Boot 官方 Reference Guide        网上好多写 SpringBoot 的博客，几乎和这个差不多。
20、《JavaEE开发的颠覆者: Spring Boot实战》
21、MyBatis 当然是官方的文档最好了，而且还是中文的。
自己也写过几篇文章，帮助过很多人入门，传送门：
1、[通过项目逐步深入了解Mybatis（一）](
通过项目逐步深入了解Mybatis（一）
)
2、[通过项目逐步深入了解Mybatis（二）](
通过项目逐步深入了解Mybatis（二）
)
3、[通过项目逐步深入了解Mybatis（三）](
通过项目逐步深入了解Mybatis（三）
)
4、[通过项目逐步深入了解Mybatis（四）](
通过项目逐步深入了解Mybatis（四）
)
22、《深入理解 Java 内存模型》―― 程晓明 著      我觉得每个 Java 程序员都应该了解下 Java 的内存模型，该书籍我看的是电子版的，不多，但是讲的却很清楚，把重排序、顺序一致性、Volatile、锁、final等写的很清楚。
#### Linux
《鸟哥的Linux私房菜 基础学习篇(第三版)  》
鸟哥的Linux私房菜：服务器架设篇(第3版)    鸟哥的书
#### 计算机网络
《计算机网络第六版――
谢希仁
 编》
《计算机网络自顶向下方法》
#### 计算机系统
《代码揭秘：从C／C.的角度探秘计算机系统 ―― 左飞》
《深入理解计算机系统》
《计算机科学导论_佛罗赞》
#### 数据库
《高性能MySQL》
《Mysql技术内幕InnoDB存储引擎》
#### Python
这门语言语法很简单，上手快，不过我目前好久没用了，都忘得差不多了。当时是看的廖雪峰的 Python 博客
自己也用 Python 做爬虫写过几篇博客，不过有些是在前人的基础上写的。感谢那些栽树的人！
#### 工具
Git   ： 廖雪峰的 Git 教程
IDEA：[IntelliJ IDEA 简体中文专题教程](
judasn/IntelliJ-IDEA-Tutorial
)
Maven：《Maven实战》
#### 其他
《如何高效学习-斯科特杨》   教你怎样高效学习的
《软技能：代码之外的生存指南》    程序员除了写代码，还得懂点其他的软技能。
《提问的智慧“中文版”》
[《How-To-Ask-Questions-The-Smart-Way》](
ryanhanwu/How-To-Ask-Questions-The-Smart-Way
)   作为程序员的你，一定要学会咋提问，不然别人都不想鸟你。
### 优秀网站推荐
1、GitHub     别和我说不知道
2、InfoQ		文章很不错
3、CSDN	经常看博客专家的博客，里面大牛很多，传送门：[zhisheng](
https://github.com/zhisheng17 - CSDN博客
)
4、知乎 		多关注些大牛，看他们吹逼
5、掘金		自己也在上面写专栏，粉丝已经超过一万了，传送门 ：[zhisheng](
zhisheng 的个人主页 - 掘金
)
6、并发编程网	前面已经介绍
7、developerworks     上面的博客也很好
8、
博客园
		里面应该大牛也很多，不过自己没在上面写过博客
9、微信公众号	关注了很多人，有些人的文章确实很好。
10、牛客网		刷笔试题不错的地方，里面大牛超多，怀念叶神和左神讲课的时候，还有很有爱的牛妹。
11、优秀博主的博客地址了
### 优秀博客推荐
[廖雪峰](
Home - 廖雪峰的官方网站
)  Git 和 Python 入门文章就是从他博客看的
[阮一峰的网络日志](
阮一峰的网络日志
)
[酷壳-陈皓](
酷 壳 - CoolShell
)
[RednaxelaFX](
知乎用户
)   R大，牛逼的不得了
[江南白衣](
花钱的年华
)      老司机
[stormzhang](
等待跳转中......
)     人称帅逼张，微信公众号写的不错
[你假笨](
你假笨
)    阿里搞 JVM 的，很厉害
[占小狼](
占小狼 - 简书
)
[泥瓦匠BYSocket](
泥瓦匠BYSocket | 01001000-01001111-01001101-01000101
)
[崔庆才](
静觅丨崔庆才的个人博客
)   写了好多 Python 爬虫相关的文章
[纯洁的微笑](
keep pure more smile
)	SpringBoot 系列不错，其他的文章自己看了感觉是自己喜欢的那种文笔
[程序猿DD](
程序猿DD | 博客
)
[周立](
周立|Spring Cloud
)
[芋艿V的博客](
https://www.
yunai.me/
)     好多系列的源码分析
[zhisheng](
Zhisheng的博客
)       这个是我不要脸，竟然把自己博客地址的写上去了
### 最后
送一句话，**越努力，越幸运，祝早日成为大神！**
***
这些地方可以找到我：
+ blog:  [
Zhisheng的博客
](
Zhisheng的博客
)
+ GitHub: [
zhisheng17 (TZS)
](
zhisheng17 (TZS)
)
+ QQ 群：528776268",努力吧，阿里之星等着你。,"本人有幸参加了2020的校园秋季招聘，基本所有的互联网大厂都面过，面试、笔试参加了少说也有几十次，收获颇多，同实验室的小伙伴也基本拿到了5、6个大厂offer。笔者找的大部分都是Java后端相关职位，特来分享经验，请诸君多多指教。
本经验贴适用
所有专业
，不论什么本科、硕士期间是什么专业，都可作参考。
今年的大厂薪资还没有出炉，用去年的老图镇楼，不过根据已出炉公司的薪资数据来看，今年月薪普遍上调2-3k。
废话不多说，直接上干货。互联网大厂注重基础，这里我会详细的把要学习的计算机知识总结出来。（注明：这里我即针对的方向是
Java后端
，其他方向如：客户端、测试开发等可稍作参考。）
【操作系统】
这一部分面试必问，无论你技术做哪个方向都会被问到。推荐书籍：《操作系统-考研复习指导》（
王道考研
系列-考研408计算机专业基础综合四门课之一 ） 操作系统用王道考研打基础再好不过，建议配合视频学习，效果更好，视频直接去B站搜就行，这里就不贴链接了。
除了基本概念，一些Linux操作系统的基本命令面试也会被问到，这里推荐《
鸟哥的Linux私房菜
》。
操作系统这里我就推荐这两本，贪多嚼不烂。尤其是操作系统的基本概念，一定要记牢。
【计算机网络】
同样，这一部分面试必问。
推荐入门书籍：《
图解HTTP
》、《图解TCP/IP》、《
网络是怎样连接的
》。
推荐核心书籍《
计算机网络-自顶向下方法
（原书第7版）》
前面三门书做入门即可，但这本书一定要反复地看，反复的理解，计算机网络记忆的部分比较多，要多看多记。
【算法与数据结构】
这一部分我说是全文最重要的部分也不为过，概念性的东西，面试的过程中说不清楚或者比较模糊都问题不大，但你算法写不出来铁定凉凉，互联网大厂每一面必定会让你写一道算法，其重要程度可想而知。
推荐入门书籍：《算法图解》、《漫画算法：小灰的算法之旅》。
推荐核心书籍《算法-第四版》
这本书真的写得非常棒，书中的代码一定要自己实现一遍。其实还有一本好的算法书《算法导论》，但本书艰深晦涩，数学证明很多，不建议用来应对面试。除了看书以外，算法一定要刷题，这里推荐在力扣上刷，附链接：
如果无从下手的话，可以从
《
剑指offer
》
专栏开始刷，刷完之后，在刷推荐的专题部分，一般来说能刷到接近300道题（掌握），就差不多可以横扫国内互联网了。
算法一定要重视，至少预留半年刷题时间，刚开始刷肯定很痛苦，坚持下去吃就好了，慢慢自己就会摸索出规律。（PS：吐槽一下，算法真的是无穷无尽呐，感觉自己永远也刷不完，永远无法完全掌握，上一次给我这种无力感的科目是《高等数学》，o(ini)o）
【数据库】
数据库也基本每一面必问，一般来说是概念相关的问的比较多，偶尔也会让写sql语句。推荐入门书籍：《Mysql必知必会》，这本书主要是一些基本命令的学习，基本的查询一定要会。
推荐核心书籍：《高性能MySQL（第3版）》，反复看，反复体会。
数据库除了书本的学习之外，一定要多看博客，多做总结，B站上一些好的视频也可以用来学习。
除了Mysql数据库之外，Redis也要掌握，推荐书籍，《
Redis设计与实现
》。
Redis同样建议搭配视频学习。
【Java部分】
语言其实只是一门工具，大厂面试其实不是很注重你掌握的编程语言是什么，主要考察计算机基础的能力。故我将此部分放在最后。Java可分为三部分学习：
1.Java基础
推荐书籍《Java核心技术卷1基础知识》《Java核心技术卷2高级特性》
2.Java虚拟机
推荐书籍《深入理解JAVA虚拟机》
经典之作，不多做解释了。
3.Java并发编程
推荐书籍《实战Java高并发程序设计》《Java并发编程之美》。
以上关于Java的三个部分都建议配合B站视频学习，网上的相关学习视频非常多，找一款适合自己口味的就行。至于框架，像是Spring全家桶什么的，其实大厂问的不是很多，稍作了解即可。
【总结】
除了以上列出的书籍外，在找工作的过程中一定要去牛客网（附链接：
牛客网-找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网
）多看面经，多总结多思考。需要看的东西很多，肯定都不可能全部记住，要把重点、常考的东西记牢。找工作最考验人的心态，一定要把心态放平，多面试多总结，前期可能会被面试官毒打，后期面的多了，自然就好了。
祝各位都能找到满意的工作！
ps：打个小广告，本科的同学如果想要继续读研深造的话，可以选择西电，考研难度还好，找工作真的很强势，观察往年的就业报告以及我个人的秋招体会，在互联网行业，西电真的不差，身边的很多大佬把大厂offer拿到手软。西电现在又在广州设立了研究生院，正是抄底的好时候，性价比真的很高，欢迎报考。o(*￣幔*)o",每次看到这种问题就有一种大学白上了的感觉。。。,"事实上，不同公司的技术基础要求不一样，工资待遇当然也不一样。不提阿里巴巴和美团了，就说说爱奇艺吧，这家公司想要的
Java开发工程师（校招岗位）
是这样的：
工作内容： 
负责大流量应用服务的设计与研发
职位要求：
 
1. 扎实的计算机基础知识，精通Java；
2. 爱好技术开发工作，具备高效，健壮，简洁的设计和代码风格；
3. 熟练掌握SQL语句，熟练使用关系数据库，熟悉数据库设计与性能调优；
4. 有主流NoSQL(Mongo，Redis,HBase等)使用开发经验为佳； 
5. 对Http ，TCP/IP 网络协议有清晰理解； 
6. 熟悉Linux 开发环境，有 shell/awk/python等系统脚本编写能力为佳； 
7. 计算机科学或相关技术学科的本科及以上学历；
8. 正直诚信，易于沟通。
其实，大部分校招岗位的招聘岗位要求如下：（共通性）
1、本科以上，可以全职参与工作，实习时间6-10个月；
2、Java基础较好(熟悉常见类库，大多时候可以扔掉baidu和google两个拐杖独立行走)；
3、对于Java单词后面多加个Script，还需了解html5,css,jquey以及电商前端开发技术； 
4、了解springMVC、spring，hibernate及其内核，还需了解中间件及数据库集群。
Java是一门技术活，如果你想蒙混过关，这恐怕不是长久之计。即使你进了企业，没有掌握纯熟的技术，企业也会让你走人的。想学就好好学，把技术学到极致，offer自然不会飞，或有更高的造诣，成为Java界的大牛。
另外，需要提醒你的是：我不知道你选择的专业是否与计算机相关。如果是，你就不但要有着过人的敏捷的思维和一堆繁琐的算法，而且最重要的是对学科的热爱：像是编程，软硬件，网络都要手到擒来，要不你这四年就算白过了。 
说一些个人观点：
计算机相关的知识是更新最快的，在学校学的80%到社会里都用不上。你主攻的科目很可能在你的公司里一点都用不到。你要把那些永远都是基础的东西学透：
比如算法，数据结构，组合数学，计算机组成原理，汇编语言和嵌入式，计算机网络的概况，编程语言学会C或C++就行了。因为新的一门语言都是换汤不换药的，改改语法和约素，厉害的程序员几天就能学会一门新的语言。
真正想锻炼自己思维的话还是多从网上找课题项目来编，当你编出一个题目时，成就感油然而生，而且你会更感兴趣，编多了你的思维就能上一个层次。
如果有条件，还是建议你是去外企的软件公司，或者自己研究个项目，要完成什么功能。因为实践出真知，牛人们都是从一行行代码培养起来的，只有亲自动手才会有提高。",看书动手实践写代码可以掌握70%的知识，看书写文章可以掌握40%的知识，只看书只能掌握20%的知识,"算法方面最重要，4本书
算法导论
（有点厚，和thinking in java差不多）
编程之美
编程珠玑
剑指offer
java方面5本
thinking in java
深入
虚拟机
effective java
设计模式
还有进阶
看完并理解你就说大神","根据前辈们所描述的知识和书籍，我整理了两个月从三月份入学开始（现在5.4）中间也在图书馆借阅了部分书籍，终于整理出来了部分学习计划
已经学过知识：
1.JAVA基础（第一行代码JAVA）
2.SQL基础语法（极限IT第一节）
3.JAVAWEB基础（黑马32期）
4.maven和gradle初步使用（
慕课网
）
5.初步会使用框架（ssm和
springboot
）
根据以上知识可以在学校老师的工作室进行实践项目开发，然后就是目前的计划！！
五月一号至六月三十号学习计划（书要读三遍，第二遍开始通过代码学习，第三遍写博客）：
1.《JAVA编程思想》（已看完一遍）
2.《深入理解JAVA虚拟机》（已看完一遍）
3.《
head first 设计模式
》（看完一半）
4.《JAVA并发编程实战》
5.《编程之美》
6.《
剑指offer
》
七月一号至八月三十一号学习计划（这里需要复习所有的计算机基础知识，包括学过或者没学过的）：
1.《计算机网络（自顶向下方法）》
2.《TCP/IP详解：卷一协议》
3.《
深入理解计算机网络
》
4.《现代操作系统》
5.《数据库系统：基础篇》或者《高性能MySQL》
6.《鸟哥的Linux私房菜》
按照我的经验，一个月看三本是我的极限了，但是，突破极限才有进步，所以再列出来两本书
7.《编译原理》
8.《算法导论》（我看过《算法》这本书，觉得没有《算法导论》好）
九月一号我就步入大三了，接下来将会进入JAVAEE的学习，大致方向是理解框架的原理，具体计划还没有接触出来，毕竟框架是学不完的，理解原理才是最正确的选择
今天2018.5.4，为了20届毕业生的阿里实习生资格，明年2019.3.1日的阿里网申报名！！
还有一点就是，有没有师兄师姐帮忙内推阿里实习生啊，有点怕，知识和能力方面绝对不负你们！！
送高中语文老师讲过的课外的一句话：
刻鹄不成尚类鹜
，画虎不成反类狗。勉励自己！
－－－－－－－－－－－－－－－－－－－－－
对不起自己，蹉跎了岁月
打卡:大三2018年12月15日
现在和以前最大的区别是特别的迷茫
现在掌握的知识
JAVA后端方面:
框架学习了常用了框架，现在使用的框架是SpringBoot，springmvc，jpa，thymleaf。
前端HTML方面:
现在使用的框架是vue.js
现在在老师工作室做项目，功能基本百度使用（不知道要不要记住怎么写），然后就是运用各种插件。学习不知道怎么学习，感觉学了不一定有用，还不如去百度。
基础知识方面
1.计算机基础知识
忘记了很多，现在要重新捡起来，没有在18年下半年参加软件设计师考试，真的是我的问题（沉迷游戏）
2.算法基础知识
努力了很久，学好了数据结构以及算法。但是，今年四月份参加完蓝桥杯之后（省二，参赛人的前百分之三十水平）真的菜啊，都说特别好进国赛，我没进。然后没有碰过算法了，现在十二月份又是一年蓝桥杯报名，又把算法捡了起来。
然后就是目标
1.蓝桥杯（算法）
2.软件设计师（基础知识）
3.参加各个公司的实习生招募（算法+基础知识+项目经验）
蹉跎了大半年之后，又一次把这些东西摆上台面，认真对待
其实这么算来，我差的也不多→_→
感觉二个月时间（从现在到明年开学）可以刷题以至于计算机基础知识和算法都可以复习的很好
差点忘记看面试题了啊啊啊啊啊啊啊啊！
所以说，现在开始刻不容缓，三件事情，一件都不能落下
－－－－－－－2019.01.04－－－－－－－－－
感谢B.MATCH的小姐姐，焦哥，自己给我电话面试的面试官，在这次电话面试我学到了很多。
首先，你需要有一份拿的出手的简历，具体什么叫拿的出手，你要想你的简历要经历五轮甚至六轮面试，你要拿出去让别人看得出新意！内容要充实，不充实怎么给别人提问的机会？
其次准备好一门主要的语言比如JAVA和两个从头到尾自己独立完成的项目，具体什么项目，你可以在学校和老师做，可以自己接外包，可以跟着往上教程做，但是必须要，自己一步步的做完。
接着，准备好许多的问题等待面试官来提问，确保他问你的问题，你能够答出来，或者能够在他的引导之下答出来！
然后，你要留两个问题问一下面试官，具体什么问题我会补充的，那可能是以后了。
最后，刷一下面试题，面试都过不了还想要笔试吗？！！！
--------------------------------2019.2.7------------------------------
首先更正一点，大部分的公司只有三轮面试，也就是说问到的不会那么详细，只会捡重点去问
下面是我总结的一些经验吧:
面试知识
第一步java基础知识：JVM，多线程，I/O，类库
加分项：计算机相关知识（计算机网络，数据库，Redis，Linux等...），设计模式，算法，数据结构
第二步java开发知识：写过的项目，以及框架的常用的使用技巧
加分项：框架的实现原理
第三步发散性思维，诸如：如果我想要这样，你该怎么做？项目开发中遇到的难点，你如何解决？项目中有什么不合理的地方，你认为怎么不合理？等...
-----------------------------2019.02.25-----------------------------
        
牛客
投了23封简历，被拒了8个，3个已查看，9个待处理，1个笔试待安排，1个一面暂停(已经发邮件过来说凉了)，1个待面试(这个公司所有都是待面试)
可以说是非常失望，作为一个从去年暑假就开始准备的我来说，这是远远不够达到我的期望的。
问题在哪？
准备了什么？基础+算法+项目
基础深度不够，比如IO，多线程，集合，JVM。唯一一个能够说深度够了的就只有JVM，可惜这个所有人都会，并且我的语言表达能力可能没别人好。算法随心所欲，一直以来的老毛病了，有点能力就飘，太难的不愿意研究，太简单的不愿意动手写，眼高手低。项目研究不够广，项目中用了SpringBoot，Spring，SpringMVC，JPA，MyBatis，Redis，Mysql，Thymeleaf，Freemaker，甚至我还会前端vue.js框架。可是还是不够，你需要懂分布式原理，需要懂微服务架构，需要懂Spring Cloud，Dubbo，甚至有的还需要你懂大数据，我觉得大数据和我之前列举的框架应该是两种路线了吧，学不懂！
简历写的怎么样？
简历也是我静心包装过了的，选了我最熟悉两个项目智慧校园和微信点餐系统，在
超级简历
上修改了很多遍，it技能一遍遍的提炼，自我介绍突出重点。
准备怎么样？
准备了自我介绍以及项目介绍，以及项目中怎样实现的介绍。然后疯狂刷面试题，刷去年面试题算法，我不知道别人学的怎么样，我不敢松懈。
结果呢？---------春招还在继续，还有希望！
学历是一块敲门砖，语言表达能力非常重要，知识深度广度一定要够，算法一定要扎实。
可能是太紧张，神经太过紧绷，无法说服自己过一些太过轻松的生活，想要过得更好，太累了，可是不努力一把，又怎么能得到更好的发展呢？
加油＾０＾~！                                 加油＾０＾~！
～～～～～～～～～2019.4.25～～～～～～～
下面是面试必备19点知识，学会很好，学不会也要看会，面了5家，第一家
吉比特
和第二家阿里面试稀里糊涂。第三家字节跳动三面挂了。小公司拿到了offer，可惜不愿意去。还有一家
七牛云
，一面很顺利，面了一个小时，我觉得应该有二面吧。
基础知识
1.mysql，2.redis，3.linux，4.计算机网络，5.操作系统，6.算法，7.数据结构，8.设计模式，9.组成原理
JAVA知识
1.JAVA基础2.JAVA多线程3.JAVA容器4.JVM 5.I/O
分布式五点知识
1.分布式缓存2.分布式储存3.分布式消息队列4.分布式搜索引擎5.怎样设计一个高可用，高并发的分布式系统
什么都不说了，只要不放弃，一定有一家好公司等着你呢。
～～～～～～～～～2019.10.28～～～～～～～
实习被坑了，上上周告诉我部门没有转正hc,上周投简历，赶上秋招尾巴，这周收到了offer，南京13k，我和朋友说这次怎么这么顺利，他们说这是我努力的结果。。。
总结了一下自己，还是有很多不会，这里定下看书目标，这个帖子从2018年更新到现在，虽然没有进大公司，但是我二本，现在这个样子的确是我努力过的结果。。。
定个目标吧，春招还可以再战斗
目标:
1.<刷题>《Leetcode》
2.<PDF>《Spring,SpringMVC,SpringBoot经典面试题》 
3.<视频>《Java程序员进阶知识》
4.<视频>《左神算法进阶》
5.<实体书>《Java并发编程实战》
6.<实体书>《TCP/IP详解(卷一)》
7.<实体书>《深入理解Kafka核心设计与实践原理》
8.<视频>《Elasticsearch核心技术与实战》极客时间
9.<实体书>《netty实战》
10.<实体书>《从Paxos到Zookeeper(分布式一致性原理与实践)》
11.<实体书>《Spring源码深度解析(第二版)》
12.<实体书>《
鸟哥的Linux私房菜
》
种一棵树的最好时间是十年前，其次是现在。"
,,,,,,,,,,,,,,,,,,,,,
为什么大多数的程序员的编程界面背景都是黑色的?,None,"我现在截图给大家感受一下，把下面这张图放大，盯上五分钟。
然后换这张图，盯上五分钟。
哪个五分钟你觉得眼睛更舒服？
反正我是肯定不会选第一张图，程序员需要连续盯着屏幕的时间不止五分钟，肯定会选择让自己最舒服的背景色。
其实，纯黑的背景色并不是最好的， 纯黑背景看时间长了也很累，最好使用深色但是不纯深那种，比如这样的。","如果有幸沐浴在阳光下，
写着一行行代码，
大概率会把界面改成亮色。
PS：这个时候就很考验屏幕激发亮度这玩意了~
PPS：MBP这一块屏幕确实顶得住~
如果是在夜色中写代码，
暗色主题能让自己更专注。
扩展阅读：
喜欢计算机但是受不了996，007怎么办（急需回答）？
码农要故意写屎山代码吗？
为什么知乎现在越来越没意思了？","多年前我研究配色的时候制作了几套配色方案。
仔细研究，我自己的研究结果是：黑色背景下，字体的前景色改变会显得更加明显。而白色背景下，前景色改变的效果并不明显，背景色跟字体粗细的改变更加明显。
简单测试就是同样把字体颜色的RGB各加0x11，黑背景下，改变的字体差异非常明确，而白背景下两者的差异就小一些。
所以在现实中，两种不同的语法元素，在黑背景中可能只差距0x33-0x66就可以轻松辨识，到白背景中可能就要用0x88-0xff才能达到同等的辨识效果。
由于程序员的语法着色主要是基于字体前景色的改变，因此使用黑背景能够得到更好的视觉分辨效果。
--
一句话结论：由于程序员编程需要进行语法着色，而黑背景语法着色的效果更好。所以更多的编程 IDE 设计时选择了黑背景。
以上是我的看法。","之前甲同事给我的建议是豆沙绿，后来我遇见了乙同事，告诉我黑色背景对眼睛最好。我问他为啥，他反问我：显示器什么时候对眼睛的伤害最小？
我想了半天没想出来，他告诉我：显示器在关了的状态下对眼睛的伤害最小，所以最接近关了的背景对眼睛伤害最少。","因为现在几乎所有的显示器的显示原理都是――发光。
CRT：电子束轰击荧光材料，从而在屏幕上激发闪光，显示字符/图像。
LCD：整块背板发光（反射背光灯管发出的光），借助液晶材料的电致浑浊，遮蔽不需要的光，从而把字符/图像显示出来。
LED：微型发光二极管发光，组成字符/图像。
作为对比：
黑/白板：利用不同物质（颜料）对环境光反射能力的不同，书写/绘制字符/图像
纸张：同上
墨水屏：同上
两者最根本的不同，在于CRT/LCD/LED本身都是光源，是一种发光体；而后者本身不发光，必须反射外部光源照射过来的可见光，才能在人的眼底形成图像。
自然界的发光体极少。日月，萤火虫，火……
若不是现代的光污染，没有月亮的夜晚，伸手不见五指才是正常。
这个差别是极为关键的。
对反射体来说，它的亮度总是和环境相协调的――环境光有多亮，它就会有一个对应的亮度。
烈日下的纸张也会亮的刺眼；星光下的宝石黯淡无光……
我们的眼睛，早就习惯了这种场景。
换句话说，反射体会“自适应于环境光亮度”；我们的眼睛经过亿万年的演化，也早已适应了这种场景。
但是，电脑显示器这种发光体完全改变了这一切。
它自身是发光的；因此烈日下，它的光芒显得太过灰暗，你自然看不清它显示了什么；黑夜里，它照样可以有500流明甚至更高的光通量，使得一下子从黑暗中到它前面的你睁不开眼。
室内的光通量并非一成不变。早上，中午，晚上，照度各有不同；但显示器的亮度，除非你随时调节，否则总是一成不变的。
它的亮度和周围环境的反差极易造成眼睛的不适应。因为我们必须不断的在不同的光亮度之间切换：一看显示器，500流明，瞳孔要缩小，要衰减神经信号强度；眼睛余光一瞥手边摊开的书本或者从身边走过的同事，
100流明
，瞳孔要放大，要增强神经信号强度……
哪怕只是看一小会儿，过亮/过暗的显示器都会造成极大的眼部疲劳；何况程序员们要在电脑前一坐一天。
除非采光条件极差、所以一天到晚完全依靠灯光照明的办公室，否则，这种显示器亮度和环境光亮度的不匹配无法避免。
而且，为了有效显示字符/图像，显示器亮度必须要压住环境光亮度，否则很容易看不清屏上字符、造成更大的视疲劳。
尤其对程序员来说，他们不光要看清每一个字符，不同字符串究竟是什么――是关键字、运算符、变量、类、对象还是函数；一段内容究竟是声明还是调用还是注释；变量/函数公开还是私有、是否const、是字符串还是整型、浮点，等等等等――这无穷多的细节，遗漏一点都是灾难。
而为了帮程序员快速区分这些不同属性，他们使用的编辑器（
Emacs
/vim/各种IDE）可以很智能的自动分析代码、然后把不同代码“染”上不同颜色，从而使他们可以一目了然。
然而，人眼对黑白图像的分辨力远高于彩色。这是因为，人眼中负责识别颜色的视锥细胞数量少，而且灵敏度低也比不上负责识别明暗的视杆细胞――因此古人说“夜不辨色”，关于阴曹地府的传说也总是黑白的。晚上你也可以关上灯，拉上窗帘，看看彩色的杂志封面是不是颜色暗淡了。
因此，想要让程序员一眼看出“这玩意儿是个类名所以染成了藏青色”“那东西是编译期常量所以用了天青色”“这东西是个函数所以用了淡绿色”……那么，显示器的亮度就必须足够高。否则真的没办法一眼分辨出这么几十种不同的颜色。
换句话说，由于职业原因，程序员使用电脑时，往往习惯性的把屏幕调的过亮，否则容易看不清字符颜色。
同时，由于职业原因，程序员面对的屏幕，必然绝大多数地方空白、只有少量字符（代码）。
提高显示器亮度，对大片白色背景来说，这就是一大片的高亮发光区――你敢调的稍暗，上面的字符就看不清了。
此外，由于显示器会发光，过亮的大片白色区域还会造成很强的遮蔽效应，使得字符颜色更难分辨。
因此，如果使用白色等高亮背景，这种“眼前屏幕亮度和环境光亮度的不匹配”造成的影响就会被放到最大。这和反射体是完全不同的。
如果使用黑色背景呢，显示器本身相当于一块黑板，仍然有一定的反射环境光的能力（从而产生了一定的自动调节能力）；同时高亮度的字符如同细小的、闪亮的宝石，非常容易识别。盯着这种屏幕自然就不太容易引起视疲劳了。
当然，黑色屏幕虽然仍然能有一定的光反射能力，但反射效果并不好，容易让人觉得显示器那块亮度（相对于环境亮度）过低，仍然不太协调。如果选择灰色之类存在一定基础亮度的暗色，那么显示器背景和环境光强之间的差距就可以进一步降低。这就是很多人说自己“更喜欢深色而不是黑色背景”的原因。",Because light attracts bugs,"同搬砖, 建筑界画图就没这么问的. 
CAD一水的黑色背景, 因为无论白红绿蓝, 他们都是高明度的颜色, 混在高明度的白色背景中, 远没有低明度的黑色背景清晰. 
程序界面也是同样的道理, 字符是细小的矢量线条, 不同类型的keywords用不同颜色区分, 其中不乏高明度的颜色, 与白色差距较小, (可以当成没那么白的浅灰色), 识别起来很费力. 所以保持低明度的底色, 高明度的线条, 是能保证清晰度的办法.
当然, 对比度不是越大越好的, 伤眼睛. 而且颜色背景不同还会有暗环绕的问题. 在此不多展开. 最有伤害性的是，程序员为了搞创造性工作，免不了时常要切换网页，非常费眼睛。因此如果你学一些东西，建议换成亮色的背景。",Because light attracts bugs,"最开始白底用半年，眼睛爆炸
后来换黑底，舒服了一年
再后来发现好像
干眼症
，换了水墨屏，换回了白底
其实很简单你专注思考的时候，眼睛不自觉地盯着看，查个api什么的盯着看。一天盯8小时白底，和盯灯泡有啥区别
亮度低点，眼睛是聚焦模式啊。","其实这个配色最舒服，但是我只在Termius里面见过原生的这个配色，叫Novel（小说）。
vscode
里面这个主题实际上还是有些区别的，比Termius这个差很多",,大概是由于BUG有趋光性 ,表达了程序员对黑色秀发的向往 ,"vscode
默认界面是深色的。
vim默认界面是深色的。
sublime
默认界面是深色的。
为什么大部分程序员编程背景都是黑色的？
没有那么复杂，只是纯粹地懒得换而已~
不信你去看看用VS开发MFC, win32的程序员，他们的背景是不是白色的(逃","这两年的潮流。
35年前，大多数程序员的编程背景色都是蓝色的
25年前变成白色
10年前变成黑色
我个人还是喜欢浅色一点，眼睛看着不累，黑底的反差太大了。
不过其实黑色也算是复古，我小时候用学习机的时候，不管是LOGO还是BASIC都是黑底白字的
说浅色蓝光多的，自己把色温设定成4000k或者更低啊","我认为，多数开发环境的编辑器采用深色背景的主要原因语法高亮越来越智能，用到的颜色越来越多，白色底下已经很难分辨清楚。
咱们以Visual Studio 2019为例，看看黑色和白色主题的差别。","亮度调最低的时候暗色比亮色看着更舒服
适用场景：
晚上室友都睡了以后还在赶作业的我
半夜三更突然有点子的我
某个无聊的要死的讲座的时候可以猫在下面干活（划掉）","我的回答基于科学和事实，无关个人喜好。
见 
Dark or white color theme is better for the eyes?
 
Hynes
的回答。其中引用了多篇论文。
简单小结一下，
研究证明浅色主题在各种环境下都易于辨识
深色主题对某些视觉障碍的人更有效
但深色主题有利于防止近视，所以如果长期使用屏幕，从健康角度看深色主题更好一点。
何种主题最好，还是基于数据比较好，下载最多的主题一定是比较优秀的。我对于Emacs社区还比较熟悉，其插件下载网站有主题下载数量统计：
http://
melpa.org/#
/?q=theme&sort=downloads&asc=false
我自己下载了排名前100的主题，启动编辑器时随机载入主题。
redguardtoo/emacs.d
顺便推荐我的文本文件操作术教程： 
如何提高编程速度 - Emacs高手教授轻松精通所有编辑器和IDE的秘诀","不光编程IDE软件界面是黑色，市场上很多软件也是黑色或灰色背景为主，比如PS、Pr、AutoCAD等。很多商业PPT、设计广告是黑色背景，这几年不少汽车品牌logo也改成单黑色。
看来黑色不光是程序员的偏爱，也是符合大多数人需求的颜色。
我理解编程界面以黑色为主，有以下几个原因：
1、黑色背景让人更专注。
我们日常生活见到最多的颜色就是黑色，夜晚也是黑色。人习惯了黑色，能够更加心静和专注。
其实看看周边物件也会发现，大多数电脑、鼠标、键盘、手机也是黑色的。
2、黑色不容易造成疲劳。
白色和其他颜色强光会更会造成眼睛疲劳。程序员可能一天盯屏幕十几个小时（不知道在干啥），黑色背景多多少少能保护眼睛。
3、黑色能更好衬托其他颜色。
有首歌叫作夜空中最亮的星，黑色作为背景色能更好地凸显其他颜色。
在代码框中，一般黑色背景也会比白色对代码颜色的渲染效果更清楚，除非你是用深色的代码。
通常黑色界面会配鲜艳的字体， 然后一些class， function，或者method会用相同的颜色，更容易被眼睛捕捉到。
4、黑色更有高级感。
黑色似乎显得更加有高级感，这不管是在软件界面，服饰搭配、汽车设计等都表现如此。
5、黑色比较正经。
如果你作为程序员，端坐在电脑面前，被别人看到一脸绿、一脸蓝、一脸红...会有多尴尬。
就算你用白色，加班到深夜，满脸亮光老板以为你在摸鱼。","因为MsOffice是白色的。
这样就可以区分，写软件的人和用软件的人。
（手动狗头）"
,,,,,,,,,,,,,,,,,,,,,
室友想抄我的代码，给还是不给?,"一门编程课临近截止，但几个大实验舍友全都没有写，打算照搬我的，但是这次作业老师提前说了会进行代码查重，舍友虽然承诺说会修改，但估计顶多改几个变量名，万一真的查风险还是很大的。
而且我的代码也是花了大量时间问同学问学长才写的差不多的，他们直接这样照搬我的成果最后再依靠突击考出比我高的分我内心有点不平衡
但我们几个平常关系很好，直接不给势必会影响关系，所以我是该给还是不给呢？大家能给我一点意见吗？","给，但是换一种方式，别微信传，也别U盘。
Github上创建一个
Repository
，先空着。让他Star你。当然他一个人还不够，让他想办法发动更多人去Star。
超过10 Star，你就把代码Push上去，然后让他Fork。
超过100 Star，都不用他修改变量名，服务到家，你帮他改。然后用他的Github账号Pull Request。
这个Repository留着，以后学弟学妹们都用的到。平时Private，有人找你要代码，就把他加为Collaborator。这就是Github允许私有仓库人数无限制的福利。
这么多Star不仅仅是数字，而是你毕业找工作时简历上最亮的那颗Star。
记得找工作期间Make Public。
不是开玩笑，如果我是大学老师，我就要求学生这样交代码作业。这是程序员的必备技能。我会给每一个班创建一个Organization，他们交作业我都知道，代码有问题就发Issue。全专业的学生互相Follow，谁的代码写得好，大家就Star。下次上课，我可以打开Github，讲评一下比较好的代码，也可以让同学们互相学习和评价别人的代码。
大一新生入学，先学习Github的基本用法，然后一项练习就是Star学长们的Repository，为他们找工作贡献一份自己的力量，这个优良传统一届一届传承下去...
软件程序的一个根本特征就是可复制性，这是其他行业没有的特质。开放源代码也是目前软件产业发展的一个主要驱动力。应该让即将从事这个行业的新人们更早更深刻的认识到软件可复制可分享的本质特点。
陈龙
24 次咨询
5.0
294097 次赞同
去咨询
关于如何最方便的浏览
GitHub
上的源代码，我之前专门写过文章。这里只给一个最简单最酷的办法，看这个视频：
视频资源加载失败
演示的是浏览LInux一个C程序代码。
只需要把
http://
github.com
换成github.githistory.xyz就可以浏览当前源代码文件以及它的历史变更。","当然可以给，但是建议你在代码里做点手脚。
最初级的方法是在代码头部加入版权声明的注释，像下面这样子（以 C++ 程序为例）。但这种方法只能针对看都不看，直接原封不动地复制粘贴交作业的室友。
/*

 * 作业：***

 * 作者：
哆啦A梦


 * 时间：2019-6-17 11:30

 * 版权所有，盗版必究

 */



#include
 
<iostream>




#define ___AUTHOR___IS___DORAEMON___ 
// 这里也是在说明作者是谁



// 再下面写程序代码就好了

对于那种稍微警觉一点的，会复查
源代码
的室友，会把以上注释去掉，甚至换成自己的注释，到头你反而解释不清楚了。这时候就需要将版权声明放在稍微隐蔽一点的地方。比如，使用 ASCII 码来代替纯粹的英文字符，将版权声明隐蔽到运行结果里。
#include
 
<iostream>




int
 
main
(
void
)
 
{

    
// 下面这段字符串的值是 FROM: DORAEMON，就是各个字母的 ASCII 码。

    
// 这句注释只是我来向大家解释这段代码是什么意思的，实际操作时千万别写

    
char
 
a
[]
 
=
 
{
70
,
 
82
,
 
79
,
 
77
,
 
58
,
 
32
,
 
68
,
 
79
,
 
82
,
 
65
,
 
69
,
 
77
,
 
79
,
 
78
,
 
0
};

    
std
::
cout
 
<<
 
a
 
<<
 
std
::
endl
;
 
// 打印版权信息


    
// 在下面写程序代码

}
 
// main()

这样的话，室友即使复查你的代码，肯定也看不懂那串数字是什么意思（这都看懂了那还会找你抄代码吗！），越是看不懂的就越不敢乱改，等把作业交上去以后，老师一运行，自然知晓真相。
但是这样还不保险，万一室友运行了一遍程序，发现了你隐藏在代码里的版权信息怎么办？没关系，我们可以用条件触发器，超过指定的时间才显示版权信息！
#include
 
<iostream>


#include
 
<ctime>




int
 
main
(
void
)
 
{

    
char
 
a
[]
 
=
 
{
70
,
 
82
,
 
79
,
 
77
,
 
58
,
 
32
,
 
68
,
 
79
,
 
82
,
 
65
,
 
69
,
 
77
,
 
79
,
 
78
,
 
0
};

    
// 1560816000 是北京时间 2019 年 6 月 18 日 8 时的 Unix 时间戳，以下代码的作用是

    
// 仅当系统时间在 2019 年 6 月 18 日 8 时之后才打印版权信息。

    
if
 
(
std
::
time
(
0
)
 
>
 
1560816000
)
 
{

        
std
::
cout
 
<<
 
a
 
<<
 
std
::
endl
;

    
}
 
// if (std::time(0) > 1560816000)


    
// 在下面写程序代码

}
 
// main()

如此，就既不丢人情，也不怕被卷入抄袭风波了。
更新：补充 cout 和 endl 前漏写的 std 
命名空间
。","现有回答的答案都服务太不到位了。
岂止是要给啊，还要为了不让老师看出来，给改好了再给。
想当年我上大学的时候，老师留的作业，我也是啃了好久才啃出来。
然后，顺理成章地，同学们就来索要了。我说好，为了不让老师看出来，我给你个变种的版本。（你那水平，给你去改我都不放心。这句话没说出来。）
于是，一个作业我写了4份，每份的算法都有些差异。每次我都有新的收获和进步。（那年头，我们一个寝室8个人。）
等我把4份写完了给他们，我再取其精华，充实一下自己的作业，我还是那个最好的。
要不是那样，我怎么能理解内存分配、怎么能掌握调试的精髓？
所以，要给。如果有精力还要多给几份，多改改。
这是不可多得的练习重构代码的机会。
一个附带的效果，就是我虽然人单力薄，但是在寝室里从此说一不二。谁敢忤逆，我就一句话：你还想不想毕业了？
至于他们今后的死活，能不能找到工作……那我就管不了那么多了，我跟他们还没那么深的交情。","我不光给 我还传到校园网上。。。我毕业十年了。。。学校里还流传着我的代码 恶心着一代又一代的老师。。。
话说。。当年的代码写的真是烂啊。。。","某些高赞是想让题主死吗……
伤害室友感情级别，由低到高：
1、给他抄。
2、给他抄，但附加合理的收费。
3、不给抄，但提供帮助/思路
4、礼貌且果断的拒绝，明确表示我不愿意让别人抄作业，关系再好也不行。（让他知道这是你的原则，不是因为你不把他当兄弟）
5、犹豫且模棱两可的拒绝。
6、用拙劣的借口拒绝。
7、拒绝并附带嘲讽（划水挂科活该，您配吗？）
8、爽快答应，但暗中使用手段，使室友被查出抄袭。
你室友想抄你，他自己也会觉得理亏，你不给他抄不太会影响友情。（如果实在来不及了，你们关系又不错，可以适当帮一把）
但你要是答应给他抄，然后背后捅刀子，别说这段友情必然凉凉，你的臭名甚至会传遍整个专业整个学校。
大家都知道xx班有个笑里藏刀的小人，表面装好人，背后害自己兄弟。
做这种事，老师不但不会夸你机智，还会瞧不起你。我们班就有一个偷偷举报污蔑同学被抓包的，老师同学都不正眼看她，可想而知一切奖项好事都没她的份了。
那可真的是药丸了。","当年学期末邻近，
编译原理
大作业让写个C0或者P0编译器。我上网找了个c实现的p0编译器，花了两天看了一遍，自己用Java重写了一份，打包上传交差。注意，我的版本是运行在命令行的。
室友看我写完了，拿走我代码，在上面包了个特别简单的UI，可以选择源文件，然后把编译结果输出在UI里的那种，然后也打包上传交差。
隔壁有个哥们从室友那里拿走了代码(他俩关系比较好，所以没直接找我拿)，扔掉了UI，做了个简单的jsp网页，可以上传源码，然后调用核心代码编译，返回编译结果，美其名曰在线编译。
结果你猜怎么着？？
我60分，室友80分，隔壁那货95分。
所以你看，懂得包装和忽悠是多么重要！！现在我一线搬砖，室友小头目，隔壁那哥们早已不从事技术工作，部门经理，专职忽悠。古人云“三岁看到老”，性格决定命运，诚不我欺。
你所关心的抄不抄，给不给抄之类的都是细枝末节，对以后发展大方向没啥影响的。
PS，我当时对这种做法很不屑，但是后来回头看，这神特么“在线编译“，不就是后来大火的“云服务”思想的萌芽么？当时可是2006年，别说在线办公，互联网几乎各种空白，连新浪微博都没影呢。","你放到github上，贴上一个gpl协议，告诉舍友地址。
你维护的
开源项目
对吧，也有你的维护记录，老师也能看得到。","想起叔当助教那会儿，班上有对儿小情侣，如胶似漆，在我office hour的时候，他俩也不问问题，就在我眼前腻着。叔心如止水，叔
古井无波
。。。
小妹子写的代码就每次都给那个小伙子抄，一模一样的。我也不好意思直接说他俩，叔说他俩自己也心虚啊，毕竟叔年轻时候也。。。。于是就天天暗示他俩代码要自己写才好，学到的东西才是自己的。还苦口婆心跟他们说如果我看到代码雷同，两边都给低分。无果。于是就每次多给给小伙子1～5分，如果小妹子98分，就给小伙子99分，如果小妹子70分，就给小伙子72分这个样子。
真爱啊，那小妹子竟然足足忍了一个月才终于受不了了，责令以后作业都小伙子自己写，然后她抄！
（本故事纯属虚构，如有雷同实属巧合，千万别对号入座。你俩最后要是成了也得谢谢叔，要是没成也不能全怪叔当年评分搞鬼对不对？）
广告
色情片如何损伤你的大脑？
作者 柳叶锈刀
会员专享
￥9.90
去查看
?","我从大一就定下了一个规矩，我永远不会帮你写代码，但我会无条件的指导你思路，让你自己能写出来
时间长了，他们也就都只问我思路了
关系好的关系不好的知道我这么严肃
也就不想抄了
更新分界线
我的回答的核心就是“要自己学会，自己懂”
以下是一个栗子
我努力往好的方向带别人
难道不好么？","原回答：
给啊，为什么不给，不光给，我还会手动帮他们改好，他只需要把名字签上就ok了！
服务就是这么到位，您只需要支付500元就ok了，超值！
什么，您没钱？
吃我一记素质五连！
事实上，作为一个在大学代码写的还行的小哥哥。这种事情是免不的。没人跟你借代码那只能说明你水平不行了，因为大学会写代码的真没几个。
其实我大学的时候有一个同班女生，为人豪爽，跟我兴趣相投，遂结为异性父女。。。。扯远了，就是关系很铁那种，她不会写代码，而我为人懒散不喜欢文案报告之类的东西，我们一拍即合，我承包了她大学本科所有的代码工作，而她帮我搞定了大学本科所有的报告类工作。
而且。。。有一门课叫web开发，只有大作业没有考试，她的代码是我的复刻版，功能有什么还是我手把手的教她说的，结果她分数比我高。。。。
其实现在回想起来，我亏了吗？没有，我觉得血赚好吗！！
她亏了吗，她也血赚好吗！没我给她写代码，就她那水平她要毕业得秃了！
其实吧，我的真实做法是，舍友跟我要代码，我会给，老师查重，我会提醒说你改改，也不会太上心，我这样是因为我不想出国也不要保研所以对分数很佛系，能毕业就行。
评论里也有人会说什么对舍友负责之类的，给别人抄作业是害了他之类的说法。
对不起我不同意这个说法，大家都是成年人，我不需要对他负责。只要他不让我蒙受损失，他需要帮忙，对我来说也是举手之劳，我乐意效劳。就这么简单，他要抄我就给他抄，他有问题问我我就给他解答，他考一百我考60那是他的本事，我不吃亏的。
总有人会觉得教会徒弟饿死师傅，可我从来跟他们都不是竞争关系，他们只是我的舍友朋友好哥们，我才不会说为了他们好而不给他们这种屁话了。
试问我如果这样做了他们会感激我吗？完全不会！他们会觉得我是个自私自利的小人罢了。
为人处事的原则是人人为我我为人人，而不是好为人师教人做人。
或许将来有一天，我有求于他，他会念我当年一码之恩，给我方便，而不是对我说：对不起，我不能帮你，我这是为你好。。。。。
学校的感情是最纯真的。勾心斗角的，何必呢。
你们要的表情包","想起了大学的时候，一个C语言大作业，我写了90%吧。另外一个室友不会码代码，做了一些杂乱的工作(当时还没学数据库，所以自己用
csv
当数据库，这个兄弟的任务就是填充csv，很杂也挺费时)。这个任务是5个人一个小组，按人头排名报上去，每个人根据作业得分和排名再得分。
我们小组分了一个女同学，从头到尾没做事的那种。其实这没什么，有的人做事，有的人不做事，挺正常的。但是最后要交排名的时候，另一个大概做了5%任务的兄弟，居然提议女士优先，让女生排第一个。我当时就不乐意了，凭什么我得这么“绅士”，而你们下课就去LOL没想过作业的事？然后他可能觉得我不好说话，又提议让女生第二。我还是看不过去，你排第三，自己让出排名我没意见，但是凭什么让做事第二多的兄弟让位，慷他人之慨？我室友大大咧咧的北方人，很少计较得失，虽然成绩不行吧，但至少做作业的时候态度是端正的。真就欺负老实人呗？
我觉得你的困境和我室友一样的，当你室友(我故事中提出女士优先的那个男生)先向你提出这个要求的时候，他就已经在借你们间的情分慷你之慨了。但这事有意思的是，如果你不同意，反而最后是你落个口实，说你不够意思(正如我室友不答应可能就被说有失风度，毕竟码农专业妹子那么稀缺)。
借作业的事屡见不鲜，我的建议是，如果对方确实做不了(我室友第一次考试写出过case1-case99这种代码，草稿纸都不够用，笑)，而且成绩差可能挂科，那看看情分能帮就帮；对方是混混日子，亦或是家里有矿不在乎这些成绩，那必然自己要为一些行为负责。别说什么怕挂科，怕影响排名，都尼玛扯淡。不帮他，让他涨一次记性，是为他好。而真正需要考虑排名的学霸，是不会出现找你借专业核心课作业抄的情况的。
就酱！","你问对人了，我这个糟老头子可是坏的很呐
来，试试这个 ：
python代码在线混淆
这个东西大家应该都知道怎么用吧
如果你们是手写实验报告代码的话 嘿嘿嘿
混淆前（你的代码）：
混淆前的代码
混淆后（你舍友的代码）：
混淆后的代码
专治复制粘贴程序猴
哈哈哈，我舍友交实验报告回来了
我去给他开下门∑(′△｀)
他说要把我的头按到键盘上？怎么ke ejdj jfjtiogos   ji de dian ge zan meebfsjf kskfddddk dkskwggdjs
fkskkdmmrmdhdjkdk","前面可以直接跳过，直接从最后三大段看起！
你们老师做的什么事儿啊。。。凭什么不能抄代码？代码界宣传了那么多年的开源开源开源，都喂了狗了吗？以前微软吵吵着要干死开源的，现在不也成了GitHub的大股东了吗？还带着头的搞开源。。。
你同学要问你抄代码，你让他们抄（其实说让他们抄不太合适，应该说让他们参考。。。），首先这肯定不是你的错，因为本着开源的精神，你的做法是值得赞扬的！你同学自己不做作业，被查重查出来了，倒霉也是他自己的事儿，因为这本质上是一个作业，评分标准确实是老师说了算。。。
但是，保险起见，我给你出个招儿吧，绝对不会有问题。
去类似GitHub这种开源网站开个账号，把你的代码传上去，然后挂个GPL3或者MIT什么的license，然后让你同学随便抄好了，查到你头上，就把网站扔给你老师看。
首先，GitHub上的代码说明这是你写的，你是作者，绝对没问题，如果你同学也有GitHub，也把代码传上去了，就看时间戳呗。。。代码是谁的简单明了。
其次，你有了license，这就说明，谁抄都和你没关系，校规还能比版权大啊？后者是有法律效力，受法律保护的。。。
copyleft
保护你的代码随便被人抄的权利神圣不可侵犯，还反了天了不成？
如果这都找你麻烦，那就是你老师的问题了。
有同学问，
抄作业虽然不违法，但是违反校规呀？
我同意
but！抄代码和抄作业还是有很大区别的！如果按照我上面说的做，那么你就会有三个优势
1. 你是被抄，不是抄别人的！你把自己的代码发在github不违反校规吧？(那些把“作业禁止上传到github”写进校规的大学就别往下读了，老师考试前明确表示禁止把作业上传到github的也别往下读了。。。)
2. 别人抄你github的代码，那肯定是别人的错呀……和你没关系！退一万步说，请拿出证据证明是你主动给别人抄的！这种确凿的证据，除非抄你代码的同学想坑你提前给你录音，否则根本不存在！既然拿不出证据证明我是主动给别人抄的，别人抄我的github我又没办法控制的……就奇了怪了，明明我是被抄袭的对象，为什么惩罚我？
3. 不要问我为什么要发github，发github好处太多了，我必须要快点发，早发就可以宣誓主权这点道理不知道吗？
有的同学问，
严格地说，在课程结束之前把代码公开发布就已经违背了学业诚信了
这我完全不同意哦！这种事情不能一概而论的，至少代码不行，因为个人写的代码其实是一种知识产权，并不是普通的考试答案。
我自己本人就很喜欢在GitHub上公开自己的代码，不管是考试的还是paper所属的，从来没听说过有学术诚信问题。谁抄袭了，出了问题自己担着，我肯定是免责的。
核心问题还是在于，你要证明我是故意给别人抄袭。如果是公开自己的作业和笔试考试答案，那肯定逃不了干系的。但是在GitHub上公开代码恰恰不能算做是故意给别人抄袭。因为这和申请专利一样，申请某些专利意味着你要公开你的设计的，这不是给别人抄袭，而是告诉别人，这是我的，不准抄！GitHub是要挂license的，一个道理，告诉别人，这是我的知识产权，你们不可以偷，license确保我可以分享的权利，你们抄了做什么用处和我无关，但是出了问题我是不管的，包括挂科！
所以GitHub的license是一份具有法律效力的免责申明！既然免责，为什么要惩罚我？法盲吗？
另外我要提醒大家！在GitHub上发代码，都会挂一些GPL3、MIT什么的协议，我推荐GPL3，这也是我一直用的，为什么？因为想抄GPL3要满足四个条件
License and copyright notice
 State changes （标明你在哪里更改过）
 Disclose source （必须要把我的源代码也附上）
 Same license （你要使用同样的协议）
其中第二点和第三点就是我的免责理由！因为第二点和第三点其实是在说，如果你想抄我的代码完成作业或者考试，就请自觉去找老师自首。。。要么就别抄！
任何人想要抄你GitHub上的代码，为了完成第二点和第三点，他就有义务自己向老师报告说，“我抄了某某某的代码，哪里哪里哪里是我自己改动的”，所以说，说你违背学业诚信是不正确的。
如果你的同学在你的GitHub上搬走了你的代码，并且他想作业或者考试作弊，必然不会做到第二点和第三点，你的同学不单单是作弊，而且是违反了GPL，所以你也是受害者，更不应该受到惩罚。
注意到这背后微妙的逻辑了吗？你在GitHub上公开了代码，挂了license，这些license是要求抄你的人必须自觉的把你的源代码附上，并告知全世界，他是抄你的，所以你也是在帮着老师奋斗在反对考试作弊的第一线知道吗？
So，你把代码发GitHub的行为，意味着你做到了诚信，你也要求借鉴你代码的人也必须诚信！简直不能太正义了。。。
然后谈谈你的同学，想抄你的代码，既不想让老师知道，又不想违反GPL，那只能学你的思路自己从头写呗。。。
还有知友问，
这是有道德问题的
。。。
这没有道德问题，放心。。。为这种事情较真的老师不单单是法盲，其实连是非都有点分不清的。。。应该去参加一些pedagogical的课好好进修一下。。。
我自己本人也是老师，我不反对学生在GitHub上放代码，相反，我还鼓励！通过这样做，我很容易搞清楚，这代码到底是谁写的。我只想知道真相（谁抄谁的），并不以惩罚学生为乐。。。
但是，谁考试抄袭别人，我就挂谁，就这么简单粗暴。。。其实应该鼓励学生们把代码放在GitHub上公开，比偷偷摸摸的好不知道多少倍，一方面是教会学生如何保护自己的知识产权，另一方面，对老师的查重也带来了极大便利（我挺腹黑的）。
所以从老师的立场来说，这到底是为了什么？是为了杜绝作弊呢？还是为了享受惩罚学生的乐趣？如果是为了杜绝作弊，真的应该鼓励GitHub，让一切真相（代码谁写的）都大白于天下，查重也变得很简单。。。
开源的目的也是这个，让一切放在阳光下，想抄？抄吧，公开的抄比偷偷摸摸的抄更容易监控，你抄了别人的代码，被我发现了，这科挂掉你可别怨我。。。至于把代码发GitHub的那位同学，谢谢你的合作，不然我还真搞不清谁抄谁呢。。。
不要问我，
万一被人偷了代码抢先发了github怎么办？
。。。这是你自己的问题。。。
我明显本意是在反作弊，你们要看成是鼓励作弊我也没办法……
上传github并使用license，本质上就是在保护自己的代码。特别是GPL的第二点和第三点，这就是让抄袭的人自己去自首的意思不是吗？
另外我不支持和老师对杠的做法，只是指出这样做是正确的。至于有些老师会因此给你零分，只能自求多福，人无完人，老师也一样……（有些老师就是不明白GPL的第二点和第三点就是让抄袭的人自己去自首的意思，也不明白鼓励大家使用github其实是对反作弊有利，既然你都上课教人写代码了，自己开个github账号和学生互加好友就那么难吗？还可以长点粉丝啥的。。。一切都很公开透明，查重也变得很容易。。。）
有知友提出这样的观点
前提是你有时间讲道理，并且愿意承担讲道理不成功的风险
我觉得说有道理，这是非常现实的考量，但从另一个角度可以看出悲观情绪。老师都不愿意被学生们当“傻瓜”，可是很遗憾，大多数老师都被学生当成了很容易就是非不分的“傻瓜”不是吗？
我发现很多人都没有仔细阅读这个答案就已经开喷了……
我不支持跟老师对杠！
我不支持跟老师对杠！
我不支持跟老师对杠！
重要的事情说三遍……吃不准，你可以课上问老师啊～问个老师成本有那么高吗？
另外，我开了两个专栏，发了一些干货满满的技术型文章，关注度居然没有这个答案高……个人感觉挺讽刺的……
可以直接从这里开始阅读
我发现很多人就是看不懂我到底在写什么。。。我这里总结一下我到底是在说什么。
我的建议适合这样的你
你不想给同学抄袭
又真心想帮助同学理清思路，能够自己写代码
还不想浪费时间亲自教（自己不好好学习，凭什么让我来给你上课啊？对象除外。。。）
你的情况符合以上三点，并且做到以下两点：
确认不违反任何校规和课程规定。
并且在和老师沟通过之后（把上述三点也告诉老师，如果老师不明白GPL，那就简明扼要介绍一下，老师不愿意接受新鲜事物就算了。。。）。
那么，上传github挂GPL是最安全最正确的做法！
为什么？你的同学面临以下两个选择
你的同学如果想抄，就必须尊重GPL，也就是向老师自首
如果不想这么做，那就借鉴你的代码，然后自己写。。。
两者必居其一！如果违反GPL抄袭，那是明显违反你的主观意愿的！说白了，挂GPL就是给人参考但委婉的不让别人抄！
所以我就不明白了，一个明理的老师为什么要惩罚你这样的好同学。。。这叫什么知道吗？这叫
""You are playing the game! Nothing goes wrong!""
PS、还有人说我一开始就嚷嚷着要抄要抄的。。。喂喂？开门见山也可以是假山好吗？请读下去。。。
关于学生作业的版权归属问题，因为这和雇佣关系有巨大区别，所以学生的代码的版权不应该属于学校，除非例外情况。其实在stackoverflow上早有这样的讨论，请阅读
第一高赞回答的第一句就足够说明问题了：
""If nothing is stated by the school that you signed and agreed to...copyright defaults to you, the author.""
所以沟通很重要。我知道有些学校会事先让你签合同的，真的动笔签哦！。。。这种就别想了。但是这样恰恰说明，默认版权是你的，不然干嘛脱裤子放屁呢？
另外有些学校会控告你misconduct，因为你发布的作业让低年级学生作弊。。。这种情况并不是每个学校都普遍存在的。这些学校会控告，究其根本原因，他们不但允许而且支持老师们可以重复利用课件特别是试题和考题，哪怕换个老师也用一样的。。。
我表示理解！但是我们这儿是不行的，课件可以重复，但是考试绝对不可以重复，因为想想就知道，你以为GitHub是唯一的渠道嘛？私底下就不能问啊？所以我们大学是不允许老师考题重复的！
但。。。我只想说，事先沟通很重要！
既然版权默认是你的，你有选择GPL的自由。大家要讲道理嘛。。。
我还要声明一下，我也没有鼓励大家去和学校怼。。。但是有一点是肯定的（也没什么好藏着掖着的），大多数学校的学生都是弱势群体（北欧大学除外），也就是说，被不公正对待且放弃了上诉权。。。而看多了这些的人觉得这世界就应该这样，所以跑过来笑我naive。。。
实际上，绝大多数事情，你是可以做到有理有利有节的，并且在动干戈之前就可以化玉帛的（事先沟通好，事后就不用互怼了不是吗？而缺乏沟通到最后搞不定的，纯属一手好牌自己打坏了。。。）。
最后，我想留一个问题给大家思考，习题和考试让学生写代码，特别是take home这种，意义到底在哪里？可以互相参考吗？我们是真的想把平时不好好学习的学生们拍死在考试的路上吗？还是希望他们每一个人都能最终能学到东西并写出自己的代码呢？
教育的目的究竟是什么？教育的目的是育人，不是毁人。。。这就是我所说的政治正确，然鹅还是有人嗤之以鼻！
我相信，答案一定是，可以互相帮助互相参考，毕竟老师都让你带回家做了，可以谷歌可以百度不是吗？看谁不是看呢？但是请write your own code from scratch!
所以我个人倾向于鼓励学生互相帮助，因为GitHub可以挂GPL这种优秀license，所以非常适合让学生互相之间公开代码互相借鉴，并保护自己的代码，但是必须要严惩抄袭的学生！
另外，作为一个多年写代码的人，我可以告诉大家，不论你是菜鸟还是代码高手，当你写代码没思路的时候，最好的办法就是去读别人的代码并从中借鉴。。。只要你还在写代码，你一定会一直不停的阅读别人的代码。。。
""Shut up and show me your code!""
开源的出现不是没有原因的。
再这么添加下去，文章要越来越长了。。。我个人不喜欢修改已经写过的东西（除非是错别字这种），会造成上下文缺失。希望这是最后一次添加。。。","最简单的办法，就是掩盖你已经写好代码的事实，反过头去问他要代码。这样一来，他一定不会再跟你要代码了。在最终要交作业的时候，佯装熬个夜啥的，最后一刻提交。既保护了你的代码，也不至于伤害室友关系，某种程度上还能树立你牛人形象，毕竟我在大学期间就特别羡慕那些熬一夜就能解决任何问题的人。
这样做唯一的不好，就是有一点虚伪，对朋友不诚实。
但是我要告诉你，当你今后步入社会之后，会经常遇到类似的问题，我把这类情况总结为：“能帮，不想帮，不帮伤感情，帮了我吃亏”。
朋友借钱，你明明有钱又不想借，怎么办？
同事让你加班帮他干点活，你明明会干，但是就是不想干，怎么办？
亲戚想借你车，你正好不用但是就是不想借，怎么办？
这种情况通常面对的都是非常要好的亲朋好友，你绝对不想因为一件小事而弄得不愉快或者从此心存芥蒂，但是你又不想当包子让自己吃亏。那么怎样才能在不伤害感情甚至不明确说出拒绝的情况下，处理这种情况呢？
很简单，
给自己创造一个和对方类似的诉求
。
朋友买房跟你借钱，你可以说：“老婆想换辆好车，正想找你借点钱呢，看来咱俩手头都紧啊”
同事让你帮他干活，你可以说：“正想找你帮我弄个xxx呢，看来你现在真忙”
亲戚想借车，你可以说：“我也正想借辆车呢，我的车不跑了”
然后，你的困扰就解决了。
当然，诚实永远是优秀的品质，只有面对无理的要求时，适当的不诚实，可以让大家不至于那么难堪。","给。
大学有次，室友抄我代码，把我写在注释上的名字也抄上去了。结果我们连带挂了。
后来我创业，室友从上海赶到北京帮我做了3个月。
我觉得人生就应该这样。有借有还，算那么清楚就没朋友了。大五又如何，大六又如何？","身为一个大学前有点基础的留学生，我大一给几个有些困难的朋友轮流写过作业。
我们有的课程甚至可以复制代码，网上的别人的都可以，但要写明出自哪里。
我喜欢编程，多写点也无所谓。他们不想学就不学，多点时间做自己想做的事。
我也不在乎别人成绩超过我啥的，听起来可能有点虚伪，我甚至不在乎学历一类的，毕竟走出学校去工作去科研，还要看真本事。
人都有自己想干的和不想干的事，想做什么做什么，想给就给，不想给就不给。
说到copy代码，最近看到个笑话挺有意思，大家笑一笑就好
thx~","曾经我把我的
数据结构与算法
课设代码给了别人，然后他又给了别人，然后别人又给了别人，然后又.......
最后他们成绩90+，80+，我却只有74分………………","回答有讲自己经历，讲自己的处理方式的，也有质疑舍友的关系的，这些都不是问题的关键
关键是，题主问了这个问题，答案已经很明显了。
不想给，又不想伤害感情，两难了
这个问题不涉及编程、不涉及代码，也不涉及什么作业……
大体上可以确定，题主犯上了取悦别人的毛病，即不敢说“不”
如果你们几个的关系比较好，你说不让他抄，是不会伤害彼此之间的感情的，但是你拿捏不准，害怕伤害别人，如果我不给舍友抄，一个小小的作业，就让我们的感情散了，不值。
造成不敢说“不”的原因，只有一个，那就是
你也害怕自己的要求，被舍友拒绝。
你高估了说出“不”后，对舍友的伤害。
你拒绝给舍友抄代码，你觉得会伤害感情，舍友不会这么想的，在他眼中，这是小事，一两天后这件事可能就把它忘了，除非你们只是表面兄弟。
当然，说不也是有艺术的。
假如你告诉舍友：“
不给，自己不认真学，怪谁？滚回去好好念书吧。
”
是谁都会种想踢死你的冲动。
最好的方法二十四个字：
贬低自己，抬高别人
提供帮助，敢于说不
切忌拖拉，不伤感情
告诉你的舍友：
我水平很低的，写了很久才完成的，bug肯定很多，bug一样的话很容易被怀疑的，我现在要花很多时间改，来不及了，你看你这么聪明，肯定没问题的。
直接抄，然后再改肯定不行的，要不你看，你写，我帮你看看有没有错，或者倒时帮你找一下bug。
说出类似的话，我不相信会伤害你们之间的感情。
还有，最重要的一点是，
拒绝要果断，不要拖拖拉拉
，越拖，越容易伤害感情，越犹豫，舍友觉得好像有希望，就很想继续劝服你，可是你又不给，来来回回，久而久之，结果就不言而喻了。
――以上是来自W3Cschool的回答。","用rust写代码，我大一一直用的c,cpp写代码，主要也是课程要求，后面没有语言限制了，我就用rust完成我的大作业，因为这语言用的人比较少，老师看了肯定有印象，而且也不好改动，我的室友看了我代码一般都会知难而退，因为这种语言老师一般都会多问几句。","取决于你室友是什么样的程序员
渣渣程序员
：改改variable的名字交了，结果查重99%重复，卒。
普通程序员
：改variable名字，改代码结构，你用for loop，他写个while，你用
array
，他改用ArrayList，运气好查重查不出来，改的差一点的，卒。
未来的BAT
：改variable名字，你用for loop，他写个lambda for each，你用boolean，他用int表示，你用equals，他写个comparator，你代码600行，他代码400行，你甚至一度怀疑自己是不是抄的他的。
其实抄代码也是一门艺术，抄的是思路，不是语句。抄的好
代码整洁
度++，抄不好return重修。"
,,,,,,,,,,,,,,,,,,,,,
大二学生，计算机科学与技术专业，学到数据结构和组原有点心态爆炸了，看不懂敲不出代码，还有救吗 ？,None,"2018-11-26 22:26:40 收藏比赞多，你们忍心吗呜呜呜
其实……我……觉得……大二才开数据结构……还看不懂……确实是……有那么点完蛋……
计组毕竟跟软件离得相对远一点，没把拆机器当消遣的话确实不太容易懂，但是拆过几次机器应该能懂个七七八八。这里先把计组放下不提（其实是我手边没教材也没法系统地串知识点）。
但是数据结构不应该、也不能听不懂啊，毕竟这么简单这么常用这么基础的东西。况且这已经是最不玄学、最容易实践的一门课了，如果这还搞不定的话学到操作系统的页表和端序不得哭出来吗？
如果没错的话，绝大部分学校的
数据结构课程
应该是
线性结构
├顺序表
│├顺序表的增删改查
││└常用排序算法（冒泡、选择、插入、希尔、桶、基数、快排、归并等）
│├队列
│└栈
├链表
│├单链表
││└单链表的增删改查
│├双链表
│└链式队列与栈
├环形结构（选修）
└块状表（选修）
树状结构
│二叉树
│├二叉树的链式存储
│├二叉树的线性存储
│├二叉树的建立
││└哈夫曼树
│├二叉树的先序中序后序遍历
│├二叉排序树
││└二叉排序树的建立
│├完全二叉树
││├堆的概念
││├大顶堆与小顶堆
││└堆排序与锦标赛排序
│└平衡二叉树
│　└二叉树的旋转（选修）
├多叉树
│└B+树（选修）
└森林
网状结构
├有向图与无向图、强连通图与弱连通图
├图中的环
├图的线性存储与矩阵存储
│├边集与顶点集以及邻接表
│├矩阵及稀疏矩阵的链式存储
│└十字链表与邻接多重表（选修）
├图的遍历
│├深度优先遍历（栈）
│└广度优先遍历（队列）
├图的最小生成树
│├
克鲁斯卡尔算法
│└普里姆算法
├图中两顶点间的最短路径
│└
迪杰斯特拉算法
├
AOV网
│└拓扑排序
└
AOE网
　└关键路径
不出意外的话应该就是这些内容，我本科的教材找不到了，有疏漏欢迎补充
下面我们来一点一点说说每一件知识点以及考点。因为我受到的教育十分偏重应用，所以我会举例这些东西能在哪里怎么用。但是我这人比较懒，能磨嘴皮子绝不动手画图，实在是有看不懂的地方……嗯……再说吧。
先说第一块，
线性结构
。这里涉及的主要知识点就是顺序表和链表，以及衍生出来的栈和队列。
顺序表
不必多说，就是内存中一块连续的区域，紧密排列了若干个相同类型的数据。显然，这种设计需要
事先知道
同样的元素一共有多少，不然就无法开辟出合适的内存区域（即会存在浪费或者不足）。为了解决数组这种元素数量不灵活的缺点而提出的方法就是
链表
。链表的基本单位是
节点
，每个节点拥有一个数据区和一个next指针，其中数据区用于存放数据，next指针指向
下一个节点
。与顺序表相比，链表可以根据需要自由选择节点的数量，从而解决了内存分配不合适的问题。
但是链表并不是万能的，是否选用链表要根据实际情况进行斟酌（后面是重点）。
第一
，顺序表可以
随机访问
其中的元素，也就是说，使用顺序表可以以
一个恒定的小代价
访问其中的任意一个元素，即
查找
的时间复杂度为
O(1)
；链表查找其中某一个位置的特定元素则必须从头开始
一个一个
的沿着next指针数过去，即
查找
的时间复杂度为
O(N)
。
第二
，顺序表在
插入
和
删除
元素的时候需要找到特定位置的元素，然后将
其后面的全部元素
都向前移动或者向后移动，以填补或腾出空位，因此顺序表的插入和删除的时间复杂度都是
O(N)
；但是链表只需要摘去或者挂上一个节点就行了，因此链表的插入和删除的时间复杂度都是
O(1)。
顺序表的构造思路十分简单，只要一个一个往里塞就行。在实践中，一般使用一个下标保存当前顺序表的结尾位置，插入元素时直接在这里插入，然后让下标向后移动。链表一般分为
头插法
和
尾插法
两种方式。头插法就是把新节点直接插在节点链的头部，比较适合构造栈；尾插法把新节点插在链表末尾，比较适合构造队列，而且需要额外的指针指向尾节点。插入过程如下：
第一步，将新节点的next指针指向要插入的位置的后一个节点（new_node->next = p->next;）
第二步，把要插入的位置的前一个节点的next指针指向新节点（p->next = new_node;）
删除节点过程如下：
第一步，将要删除的节点的上一个节点的next指针指向被删除的节点的下一个节点（p->next = deleted_node->next;）
第二步，释放被删除的节点（free(delete_node);）
双链表
在单链表的基础上增加了一个前向指针previous，即对于每一个节点可以同时找到它的上一个和下一个节点。这能让链表在构造的时候代码更好写，具体情况参考书上。双链表一般不怎么考，根据需要选用。
队列
和
栈
是被特化了规则的线性结构，属于
逻辑结构
的范畴，并不拘泥于某种特定的
物理结构
实现。换句话说，任何满足
先进先出（FIFO）
的结构都可以被描述成队列，而任何满足
后进先出（LIFO）
的结构都可以被描述成栈。
使用顺序表构造队列需要一个
头指针
和一个
尾指针
。进入的元素在尾指针处插入，取出的元素从头指针处去除；使用链表构造队列需要使用
尾插法
，并从头部移除元素。队列就是简单的排队，在诸如计算机网络的分组交换、CPU时间片轮转等场合有广泛的应用。
使用顺序表构造栈只需要一个
栈顶指针
。元素从栈顶指针处
入栈（push）
，同样从栈顶指针处
出栈（pop）
。使用链表构造栈需要使用
头插法
，并从头部移除元素（此时指向链表头结点本身的指针即为栈顶指针）。栈在诸如编译时的括号匹配、程序运行时的函数跳转等场合有广泛的应用。
在上文中，我们会发现，在使用顺序表实现队列，并频繁地插入和移除元素后，两个指针渐渐会来到表的结尾，这时候我们就需要
逻辑上的环
来避免这一问题。将节点自增从pointer++;改成(++pointer)%length;即可解决这一问题。当指针来到结尾处时会由于模运算回到开头。链表则需要把尾节点的next从悬空改成指向头结点，并且让原来指向头结点的指针指向尾节点即可。这样一来，p即为末尾，而p->next即为开头。
块状表
是一种结合了顺序表和链表的结构。块状表吸收了链表的next指针所带来的动态优势，同时把链表的数据区扩展成一个小的顺序表。这样一来，既可以满足动态请求内存的需要，又可以避免查找元素时O(N)复杂度的困扰（事实上可以把O(N)降低到O(N/M+1)，M是小顺序表的长度）。块状表是一种相对折中的方案，可根据需要选取，并且一般考试不会考。
伴随着线性结构而来的就是常用的各种
排序算法
，我这里只说思路不说实现，并且只提供平均时间复杂度。
最基础的就是
冒泡排序
，基于交换思想。其想法是
将每一个元素与它后边的元素相比，如果前面的更大就交换位置
。对于每一个元素来讲，当交换停止时，都满足
前面的元素小于它，后面的元素大于它
，因此整个数组有序。冒泡排序的平均复杂度是O(N2）
。
除了交换的思想，还有一种常用的思想是插入。基于这种思想的排序法是
插入排序
和
选择排序
。插入排序会
维护一个小的有序队列，在排序开始时这个队列的长度是0，此后，每一次将一个新的元素插入这个有序队列中合适的位置
，则当全部的元素都插入这个队列时排序完成。插入排序平均复杂度是O(N2)。选择排序则是
每一次都遍历所有未排序的元素，从中选出最小的或者最大的元素插入有序队列的头或者尾
，平均复杂度同样是O(N2)。
同样基于插入思想却又与上两者不同的方法是
希尔排序
和
桶排序
。
希尔排序
与插入排序基本相同，但是在开始时会规定一个增量（一般是数组长度的一半），并且
每一趟
将这个增量缩小至之前的一半，直至增量变为1。希尔排序根据增量把
每隔N个的所有元素
分为同一组，
对每一组内使用插入排序。当增量为1时，对整组元素逐个排序
。尽管希尔排序的平均复杂度也是O(N2)，但是在实践中一般比插入排序更快（因为每一次处理的都是部分有序的数列，移动元素的次数较少）。桶排序则更好的体现了插入的思想，
事先将最小值到最大值之间的区间分成N个桶，每个桶涵盖了相同的数据范围。每次从数组中取出一个元素放入对应的桶内，并将其插入到桶内的所有元素组成的小数组中的合适位置
，以此完成排序。最后只需要按顺序把每个桶中的所有元素倒出来就行了。桶排序对于空间的需求相对较大，但是相应的会减少时间上的需求，平均复杂度我懒得算了，但是可以确定是log级别平方级别之间的，但是在桶划分不合理时会退化到O(N2)。
快速排序
则是基于分治法，属于最难理解的一个。
快速排序从局部数组中（在第一趟中，这个局部指的是整个数组）随机选取一个中间数，然后将大于它的数全部移动到右边，小于它的数全部移动到左边，再对左右两个局部数组递归进行上述操作，直至在某一趟中每个局部数组都只有一个元素。
在交换结束时，每一个数都满足左边的比它小，右边的比它大，因此整个数组有序。快排的平均复杂度是O(N*logN)，因此叫快速排序，但是在整个数组已经有序时会退化为O(N2)。
归并排序
同样基于分治法，也是上述所有排序法中唯一一个
外部排序法
。归并排序的基本思想是
合并N个有序数组，当N为1时排序完成
。归并排序主要分为两步，第一步把大数据集分成N个小数据集，并使用任意一种内部排序法对每一个小数据集进行排序；第二步是每次将其中的K个已经有序的小数据集进行合并（称为K路归并）。归并排序的平均复杂度是O(M*N*logN)，其中M为每个小数据集中数据的个数，N为小数据集的数量，log的底数为K。
基数排序
则是最无聊的一种排序法。假设有一个数据集是{456, 123, 789}，基数排序先比较个位数字并排列有序，再比较十位数字并排列有序，最后比较百位数字并排列有序。人类在查找纸质字典的目录时就是在进行基数排序。基数排序不太容易衡量复杂度，也不太可能考。
还有一些常用的排序方法，比如
堆排序
和
二叉排序树
，我们会在后面讨论。另外，要是有人跟你说
睡排序
和
猴子排序
，请直接把他打死。
讲完线性结构，我们再来讲讲
树状结构
。树状结构最基础的就是
二叉树
，我们就从这里入手，顺便看看复杂度中的log是怎么来的。
首先要先普及一些概念：每一棵树有唯一的
根节点
，在此基础上向下生长。每一个节点的所有直接后代称为它的
孩子节点
，孩子的直接先代称为
父亲节点
。没有孩子的节点称为
叶子节点
。树中
不能有环
，每一个节点都必须
有且仅有
一个父亲节点（根节点除外）。根据定义我们同样可以推理出，以每个非叶节点的每一个孩子节点作为根节点，都可以得到一棵
子树
。从根节点到叶子结点的
最长
路径称为树的
度
（或者
深度
）。
在此基础上，每个非叶节点
至多
只有两个孩子的树称为
二叉树
。显然二叉树的深度介于log?N与N之间。当深度为N时，二叉树退化为线性表。二叉树节点的两个孩子分别称为
左孩子
和
右孩子
，同理会衍生出
左子树
和
右子树
的概念。
链式存储
的二叉树十分直接，每个节点包含一个数据区和两个孩子指针。数据区用于存储数据，孩子指针分别指向两个孩子，如果没有孩子就悬空。这一节的重难点其实在二叉树的
线性存储
，即将二叉树保存在顺序表中。这种方式会成为堆排序的理论基础，并且在存储完全二叉树时有明显的优势。下面我们将展开来讲。
在说明线性存储之前，我们必须要引入
满二叉树
的概念。根据定义，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树被称为满二叉树。如下图
满二叉树（图片来自CSDN博客）
对于一棵满二叉树，我们按照
从左到右，从上到下
的顺序给每一个节点编上号（我的教材是从1开始编号，因为方便运算），就能轻易发现一个事实：假设某一个节点的编号是N，那它的的两个孩子节点的序号分别是2N和2N+1。下面，我们把这个编号作为数组下标，就可以得到二叉树的线性存储方式了。
二叉树的线性存储（图片来自同一篇博客）
对于不满的二叉树，我们要先把它补齐成满二叉树，然后把补上的节点空出来，就可以完成线性存储。存储一棵二叉树所需的总的线性空间与它的度有关，即2的N次方。显然，满二叉树极少浪费线性空间，而偏差较大的二叉树会极大地浪费线性空间。
建立一棵二叉树十分简单，一般有两种方式：
从根向叶子
和
从叶子向根
。前者可以被用来建立
二叉排序树
，一会儿会讲到；后者可以用来建立
哈夫曼树
，网上资料很多，有看不明白的地方自己再查一下。这两种树都属于常考内容，应用也十分广泛。
正常的树都是从根向叶子生长，所以逆生长的
哈夫曼树
就显得比较特别。哈夫曼树一般用于压缩算法，可以用来生成前缀码。
前缀码
指的是，在一套编码体系中，
任何一个字的密文都不是其他字的密文的前缀
，或者说
对于任何一个字的密文，从头开始连续截取任意长度，得到的结果都不能构成另外一个字的密文
。不是前缀这个特性保证了编码没有歧义，因此可以按顺序处理而不必担心出现错误。摩斯电码是非前缀码，因此每两个字之间需要提供明显的停顿用以显示表明这是不同的两个字。如果这个停顿不够明显，也就是发报速度比较快，就比较容易造成歧义。
前缀码的一个特性就是每个字长短不一，显然出现频率更高的字使用更短的密文能获得较大的空间和时间优势。所以，哈夫曼树的第一步就是从
统计字频
开始的。这一步只需要遍历文本流就可以，很简单，按下不表。
第二步就要开始建树了。由于
哈夫曼树
是逆生长树，采取的是
合并子树
的思想，所以最先被选择的一定是
最深
的子树。合并子树的方法如下：在最开始的时候，把
每一个节点
都视为一棵
只有一个根节点的树。
每一次迭代，选取
频率最低的两棵子树
进行合并，直到最后只剩下一棵树为止
。
举例来说，假设刚开始有a，b，c三棵子树，频率分别是0.1，0.2，0.7，那么第一次迭代就会选择0.1跟0.2进行合并，得到一棵频率为0.3的新子树，然后再把这棵新子树与0.7合并完成建树。显然，从根节点开始，寻找c只需要一步，而寻找a和b各需要两步，平均字长为1.3。
建立哈夫曼树的目的是为了进行
哈夫曼编码
。前文也提到了，这是一种压缩算法。压缩的过程就是建立上述的哈夫曼树，然后遍历哈夫曼树写出每个字的密文，再按照查字典的方式把每个字转换过去。而解压缩的时候，则需要先重建哈夫曼树，再一位一位对照密文从树根开始向下寻找，找到叶子结点就可以认为解码出了一个字，然后下一位回到树根重新寻找。解码的过程比较类似状态机模型，要写成模块化的模式还真不是太好写，反而是面向过程的方式比较好写。在具体编码过程中，指定左孩子的编码为1或是右孩子的编码为1都不会影响结果，事实上也没什么标准，甚至在中途随意翻转都可以。不同的程序员跑出来的哈夫曼编码结果不同是很正常的一件事，只要不影响编码和解码的使用就行。
说完了不正常生长的哈夫曼树，再来说说正常生长的二叉排序树。
二叉排序树
的定义是：
每一个节点的左孩子小于它，而右孩子大于它
（等于的情况事先声明一下放左还是放右就行，对于结果无实质影响）。根据这个定义，我们可以递归地得出性质：
对于每一个节点，其左子树全部小于它，其右子树全部大于它
。因此，为了满足性质，在建立二叉排序树时只需要
从根节点开始，递归地比较每一层元素，如果其比要插入的元素大则走向其左孩子，反之走向其右孩子，直至最终来到叶子结点
，并把该元素插入。当全部的元素都被插入了，二叉排序树就建立完成了。
接下来就要取出其中的有序数列了，也就是进行
二叉树的遍历
。二叉树的遍历一般分为
先序遍历
、
中序遍历
和
后序遍历
三种。先序遍历即先访问根节点，再寻找左孩子，最后寻找右孩子。中序遍历是先寻找左孩子，再访问根节点，最后寻找右孩子。后序遍历先寻找左孩子，再寻找右孩子，最后访问根节点。可以说，先中后指的是
访问根节点的时机
。由于遍历是递归的，使用
中序遍历
一路寻找到的最“左”的左孩子就是二叉排序树中的最小元素，且中序遍历的输出顺序就是
从小到大
的顺序。根据
前序遍历和中序遍历
或
后序遍历和中序遍历
可以重建整棵树，这也是考试的热点和难点。
二叉排序树的平均复杂度是O(N*logN)，其中的log就来自于二叉树的深度。当数组已经有序时二叉排序树会退化为O(N2)，而且绝大部分时候都建不出漂亮的二叉树，所以这个log其实是有很大水分的。
为了尽量建出漂亮的二叉树，人们想出了很多办法，其中一项就是
平衡二叉树
（AVL树）。平衡二叉树是指
每一个节点满足左子树的度与右子树的度相差不超过1的二叉排序树
。由于其限制了节点的左右孩子，因此能让整棵树更加紧凑，从而大量挤出了log中的水分。建立AVL树需要用到复杂的旋转操作，几乎不会考到，所以我不讲了。
使用二叉排序树排序尽管复杂度较低，而且十分容易理解，但是需要O(N)级别的辅助空间，并不是很划算。仔细想一想，既然能把二叉树存放在顺序表里，那顺序表本身是不是也能被看成是线性存储的二叉树呢？答案是肯定的。一张顺序表可以被看做是一个
完全二叉树
，即
除了最后一层外每一层元素都是满的，且最后一层的元素全都集中在左边
的二叉树。显然，满二叉树是完全二叉树。
完全二叉树（图片来自百度百科）
堆
就是完全二叉树的一种应用，硬要说的话也属于反向生长。常用的堆分为
大顶堆
和
小顶堆
两种，前者满足
父亲节点大于孩子节点
，后者满足
父亲节点小于孩子节点
。根据递归我们可以推算出，
大顶堆堆顶的元素是最大的
，
小顶堆堆顶的元素是最小的
。
堆排序
就是在不断地重复建堆并移走堆顶元素的过程，显然平均复杂度是O(N*logN)，而且由于完全二叉树的性质，这个log没有水分。
堆排序最神奇的地方就是
它不需要借助一个链式的二叉树的辅助，而是直接在顺序表中操作元素
，因此它的空间复杂度是O(1)级别的。回想一下二叉树的线性存储相关的内容，我们会猛然想起父亲节点与孩子节点的序号之间的关系，从而明白为什么不需要辅助树。
第一步，在逻辑上建堆。这一步要求我们根据实际情况（即数组下标从1或者0开始）来推演父亲节点与孩子节点真实的下标关系，在脑海中建立这个堆。
第二步，满足堆的性质。这一步我们要对所有的非叶子节点从下到上进行调整，使其满足大顶堆或者小顶堆的性质。具体做法是找到第一个非叶子节点，并对它与它的孩子节点进行调整，使其满足堆的性质；然后从这个节点开始向前
线性地
调整每一个非叶子节点，直至根节点。此时整个堆都满足性质。
第三步，取得堆顶元素。这一步会把堆顶元素与堆内序号最大的元素进行交换，并且堆内元素数量减一。显然这个堆顶元素满足
剩余未排序元素都比它小或比它大，而前面的已排序元素都比它大或比它小
，因此它在已排序队列中的相对位置是确定的，即头或尾。
第四步，恢复堆的性质。由于刚才把一个无序元素插入了堆顶，导致堆的性质被破坏，接下来我们需要恢复它的性质。这一步不需要逆序遍历，而是从堆顶开始，将刚插入的元素逐步向下落，直至停在合适的位置。举例来讲，对于大顶堆，要保证堆顶元素是最大的，因此要把它分别与左右孩子进行比较，并且把三者中最大的一个升上堆顶。由于左右孩子在刚才的操作中都没有变动，因此各自满足
在子树中是最大的
的性质，此时若堆顶元素比他们两个都大，便能推理出堆顶元素是最大的。同理，升上去的三者中最大的元素也能满足这个推理。将堆顶元素向下落的操作要递归地进行到该元素不需要再进行交换为止，此时整个堆恢复性质。
第五步，重复第三步和第四步的操作，直至堆被清空。此时，整个数列有序。
堆排序非常喜欢考，不仅考方法论还要考实现，而且这东西略抽象，不是很好掌握。刚才突然心血来潮写了个实现，凑合着看一下吧。我比较懒，用CPU时间换了内存，数组下标里面各种运算。其实可以拿临时变量装一下来节省CPU的。C语言需要事先声明函数才能使用，我也没照顾可读性写函数原型，看的时候记得倒着看。
#include
 
<stdio.h>




void
 
reconstruct_heap
(
int
 
a
[],
 
int
 
index
,
 
int
 
last
)


{

    
int
 
tmp
;

    
    
if
(
index
 
*
 
2
 
+
 
1
 
>
 
last
)
  
// 检查是否有孩子

    
{

        
return
;

    
}

    
    
if
(
index
 
*
 
2
 
+
 
1
 
==
 
last
)
  
// 检查是否只有左孩子

    
{

        
if
(
a
[
last
]
 
>
 
a
[
index
])

        
{

            
tmp
 
=
 
a
[
index
];

            
a
[
index
]
 
=
 
a
[
last
];

            
a
[
last
]
 
=
 
tmp
;

        
}

    
}

    
else

    
{

        
if
(
a
[
2
 
*
 
index
 
+
 
1
]
 
>
 
a
[
index
]
 
&&
 
a
[
2
 
*
 
index
 
+
 
1
]
 
>
 
a
[
2
 
*
 
index
 
+
 
2
])
  
// 左孩子最大

        
{

            
tmp
 
=
 
a
[
index
];

            
a
[
index
]
 
=
 
a
[
2
 
*
 
index
 
+
 
1
];

            
a
[
2
 
*
 
index
 
+
 
1
]
 
=
 
tmp
;

            
reconstruct_heap
(
a
,
 
2
 
*
 
index
 
+
 
1
,
 
last
);

        
}

        
else
 
if
(
a
[
2
 
*
 
index
 
+
 
2
]
 
>
 
a
[
index
]
 
&&
 
a
[
2
 
*
 
index
 
+
 
2
]
 
>
 
a
[
2
 
*
 
index
 
+
 
1
])
  
// 右孩子最大

        
{

            
tmp
 
=
 
a
[
index
];

            
a
[
index
]
 
=
 
a
[
2
 
*
 
index
 
+
 
2
];

            
a
[
2
 
*
 
index
 
+
 
2
]
 
=
 
tmp
;

            
reconstruct_heap
(
a
,
 
2
 
*
 
index
 
+
 
2
,
 
last
);

        
}

    
}


}



void
 
establish_heap
(
int
 
a
[],
 
int
 
last
)


{

    
int
 
i
 
=
 
(
last
 
-
 
1
)
 
/
 
2
;

    
    
while
(
i
 
>=
 
0
)
  
// 使每一个元素满足大顶堆的性质

    
{

        
reconstruct_heap
(
a
,
 
i
,
 
last
);

        
i
--
;

    
}


}



void
 
heap_sort
(
int
 
a
[],
 
int
 
n
)
  
// n为数组长度

{

    
int
 
tail
 
=
 
n
 
-
 
1
,
 
tmp
;

    
    
establish_heap
(
a
,
 
tail
);
  
// 建立大顶堆

    
    
while
(
tail
 
>
 
0
)

    
{

        
tmp
 
=
 
a
[
0
];
  
// 取出堆顶元素

        
a
[
0
]
 
=
 
a
[
tail
];

        
a
[
tail
]
 
=
 
tmp
;

        
tail
--
;

        
        
reconstruct_heap
(
a
,
 
0
,
 
tail
);

    
}


}



int
 
main
(
void
)
 
{

    
int
 
a
[]
 
=
 
{
13
,
 
8
,
 
3
,
 
0
,
 
7
,
 
16
,
 
18
,
 
15
,
 
12
,
 
11
,
 
19
,
 
10
,
 
9
,
 
6
,
 
1
,
 
14
,
 
17
,
 
5
,
 
4
,
 
2
};

    
int
 
n
 
=
 
20
,
 
i
;

    
heap_sort
(
a
,
 
n
);

    
for
(
i
 
=
 
0
;
 
i
 
<
 
n
;
 
i
++
)

    
{

        
printf
(
""%d ""
,
 
a
[
i
]);

    
}

    
return
 
0
;


}
锦标赛排序
很多书上都不写了，但是在这里我想提一下。锦标赛排序是选择排序的优化版，每一次将相邻的两个元素进行比赛，选出其中的优胜者（较大者或较小者，看需求）。其思路类似于
小组赛-十六强-八强-半决赛-决赛
的过程，在决赛中选出的一定是全局最优元素。接下来我们提取这个全局最优元素，然后抹除其存在，并且把它参与过的所有比赛进行重赛，从而得到全局次优。当最后所有的元素都被抹除，锦标赛排序就完成了。锦标赛排序最聪明的地方就在于它保存了之前已经进行过的比赛，从而在选取了全局极值以后不需要对绝大部分比赛进行重赛，因而节省了时间。其平均时间复杂度为O(N*logN)，空间复杂度为O(N)级别。这里的log同样没有水分，因为建立起来的比赛树几乎是满的（但不必是完全二叉树）。
虽然绝大多数情况下我们见到的树都是二叉树，但是并不妨碍
多叉树
在日常生活中起到重要作用。一个经典的例子就是3D
计算机图形学
中使用的
八叉树
，用来分割三维空间，在查找元素时能大大加速。多叉树相对于二叉树来讲没有孩子数量一定的限制，因此通常用一个
孩子列表
来保存全部的孩子节点，这一种应用在网页的DOM中尤其广泛，倒不如说整个XML规范文档以及JSON规范都可以抽象成多叉树。操作系统的目录树也属于这一应用范畴。这个孩子列表在实践中一般是个块状表，既保证伸缩性又保证快速访问。
森林
就是多棵树，这个没什么好讲的。
最后我们来提一下
B+树
，有的教材上也用
B树
来代指B+树。B+树是一种极其鬼畜的多叉树，结构复杂但是十分有效，极其常用于索引的建立，包括数据库索引、目录树索引等等（散列同样常用，但是我忘了在书上的哪一章节了）。B+树的主要难点在于节点的分裂与合并，非叶节点与叶子结点的大小的上界与下界，以及树深度的伸缩，属于研究生课程的范畴，我不打算深入去讲，因为非常抽象并且不好实现，甚至比AVL树的四种旋转还要难理解。在设计B+树时需要考量节点大小，而这个大小一般是由计算机的一些物理性质决定的，缺乏计组的基础我觉得我也给你说不明白。总之，这东西很有用，但是不考。
最后一部分是
网状结构
，也就是图论相关的东西。这一章东西不多，除了三种常用算法以外大部分知识点在以后也很难用到，实在学不会可以考虑跳过。另外，离散数学课程里会再讲一遍这部分内容，迟早会学的滚瓜烂熟的。
关于图，有一些概念是要先提及的。首先，图是由
顶点
和
边
组成的，根据边的方向性又可以分为
有向图
和
无向图
（这一点看地图上的单行路就明白了）。如果在一个
有向图
中
任意
两个顶点可以
相互
到达，则称这张图为
强连通图
；反之，若不满足强连通图的定义，但是将所有的
有向边修改为无向边
后原有向图能构成连通图，则称该有向图为
弱连通图
。由于不像树一样要求唯一的父亲，图是允许有
环
的，并以此分为
有环图
和
无环图
。
通常存储图有两种方式，即
集合
的方式和
矩阵
的方式。前者维护两个集合，即一个
顶点集合V
和一个
边集合E
。顶点集合中保存了
所有顶点的信息以及序号
，边集合保存了被一条边连通的两个顶点的
序号
以及边的
代价
（无权图可认为每一条边代价都是一样的）。由于稀疏图占了日常生活中的图的绝大多数，因此集合的方式是保存图的主要方式。矩阵的方式取消了边集合，改用一个矩阵保存
每两个顶点
之间的代价。显然，顶点与自己的代价是0，与邻居的代价已知，与不直接相连的顶点代价为无穷大。只有在绝大多数顶点都彼此直接相连的情况下，矩阵的方式才能更节省空间。
图中每个顶点的
入度
和
出度
，也就是
汇入顶点的边的数量
以及
顶点发出的边的数量
，往往具有重大的意义。边集合往往只能快速统计其中的一项，而统计另一项开销较大。显然，矩阵的方式是更直观的，可以以O(1)的代价查找任意两个节点之间的连通情况，反而是集合的方式必须以O(N)的代价进行查找。在统计入度和出度上矩阵的方法看上去也更快。根据具体需求选择时间换空间或者空间换时间是算法选取的一大原则。
为了节省矩阵的空间开销，矩阵的
链式存储
应运而生。这种方法只关心矩阵中存在的元素，而忽略不存在的元素。每一个矩阵会被存储为一个行数组和一个列数组，以及一系列节点。两个数组中的每个元素各带有一个指针，指向该行或该列的第一个元素；每个节点保存了行号和列号，同时带有两个指针，分别指向该行的直接后继和该列的直接后继。使用这种结构的矩阵平衡了空间和时间的开销，对于稀疏矩阵提升尤其明显，但是随着矩阵中元素数量的增加效率会降低。
集合的方式这边也拿出了
邻接表
来进行快速查找。邻接表就是很简单的使用链表，为每一个节点建立一个链式的出度表，从而达到快速查找的目的。如果需要统计入度，那么应同时维护一张
逆邻接表
来对入度建立索引。当然，无向图可以把出度和入度混在一起记录，反正是无向的。
为了克服需要同时维护两张表的缺陷，人们发明了
十字链表
和
邻接多重表
，分别用于处理有向图和无向图。十字链表将每一条边作为节点，这个节点记录弧头和弧尾，同时拥有一个head指针和一个tail指针；每个顶点也拥有两个指针，一个指向第一条入度的边，另一个指向第一条出度的边。使用时，顶点的入度指针沿着head指针一路找过去，完成对入度的遍历；而出度指针沿着tail一路找过去，完成对出度的遍历。我本来不太喜欢画图的，但是这东西不用图讲不明白了：
有向图（来自CSDN博客）
考虑这样一张有向图，并假设顶点集合和边集合都已经整理好了。那么，根据这两个集合，我们可以建立十字链表：
十字链表（与上图来自同一篇博客）
其中绿色的就是入度指针。从图中我们可以看出顶点A的入度一共有CA和DA两条边，因此沿着head指针能找到这两条边；同理，黄色的是出度指针，沿着tail指针就可以完成对出度的遍历。十字链表巧妙地节省了一张表。
邻接多重表基于对邻接表的改进。由于其适用于无向图，所以不存在head和tail，但是依旧有两个指针。邻接多重表的节点结构与十字链表类似，并且同样用于存放边，不同的是每一个顶点后面紧跟着一个指针，并且每个节点还多出来了一个标志位用来存放是否被访问过。举例来讲，假设一个节点其中的顶点序号是2和5，那么2后面的指针会指向下一个出现了2的顶点（顶点顺序无所谓），而5后面的指针指向下一个出现了5的节点。顶点节点只保留一个指针，指向第一条连接此顶点的边。假设顶点序号是2，那么只要跟随每一个节点中编号为2的顶点后面的指针就可以完成对出入度的遍历。由于与十字链表类似我就不画图了。
说完了图的存储，下面来聊聊图的
遍历
。遍历就是从一个顶点出发，沿某一种规则访问全部的顶点，并且每个顶点只访问一次。遍历主要分为
深度优先
遍历和
广度优先
遍历两种。顾名思义，深度优先就是
一条路走到黑再回头
，广度优先则是
每条路都走一点
。深度优先使用一个栈，对于每一个顶点先把它全部
邻接的、未被访问的
顶点都压入栈，然后从
栈顶
弹出一个节点作为接下来要访问的顶点。形象地说，当顶点有邻居1时会去访问邻居1，然后访问邻居1的邻居1，直到没有新的邻居再退回来访问邻居2。当栈被清空时遍历结束。广度优先则使用一个队列，对于每一个顶点先把它全部
邻接的、未被访问的
顶点都压入队列，然后从
队列头
弹出一个节点作为接下来要访问的顶点。形象地说，当顶点有邻居1时会去访问邻居1，然后访问邻居2，直到没有新的邻居再退回来访问邻居1的邻居1。当队列被清空时遍历结束。这段话写得应该不抽象，很好理解。
深度优先遍历在诸如迷宫求解的时候应用较好，如果途中有环则需要记录已经访问过的顶点，否则不需要；广度优先遍历适合浅层的关系，比如AI寻路（作为A*算法的基础），比如通过社交关系网查询两个用户之间的距离。当然，不使用队列和栈也可以，那样就要使用递归。
图的
最小生成树
的作用是去除图中的环，同时使整体代价尽可能的小。常用算法包括
普里姆算法（
Prim
）
和
克鲁斯卡尔算法（Kruskal）
。普里姆算法的思想是将图划分为已连通和未连通部分，初始时已连通部分为任意顶点，在每一次迭代中计算每一个已连通部分的直接邻居到已连通部分的代价，然后选取代价最小的顶点连通，直至最后连通整张图。这只是思路，实现上并不是这么写的，有很多玄妙的部分，但是这里我懒得写了，因为要用到太多的辅助图。克鲁斯卡尔算法则是首先将所有的边按照代价排序，并假设所有的顶点各自处于一个聚类中，每次迭代选取一条
连接两个不同聚类的、代价最小
的边（即连接同一个聚类的边即使代价更小也必须舍弃），然后将这两个聚类划拨为同一个聚类，直至最后只剩下一个聚类。
最小生成树算法可以应用于网络布设中，使用最低成本达到连通所有节点的目的。但是，这种做法并不能保证任意两个节点之间的距离都是最短的，同样也容易造成星型布局，并使得上游节点遭受随之而来的带宽压力。但这种做法可以使总成本最低。
如果需要求某一个顶点到所有顶点的
最短路径
，常用的算法是
迪杰斯特拉算法（Dijkstra，对，就是提出goto有害论的那个）
。迪杰斯特拉算法会维护一张表，记录该顶点到所有顶点的距离。初始时只把该顶点的直接邻居全加入并更新代价，从中选取代价最小的邻居作为新的起点，再把
新的起点到它的所有的直接邻居的代价加上起点到它的代价
与表中已有代价对比，选择代价较小的保留，比较结束后选择代价最小的留下，作为更新的起点，直至最后所有顶点都被留下。
迪杰斯特拉算法在计算机网络中有大量应用（
OSPF协议
），也就是在路由器估计网络拥塞状况并智能选择更空闲的路径。计网中还有一种RIP协议，你们学到了就知道了。
以上三种算法年年考实现。
看到这里，如果所有的知识点你都能掌握了，那么已经足够你拿到优秀了。剩下的部分是拓扑排序，不是很喜欢考，但还是提一下。
拓扑排序
用于清理
AOV网（Activity On Vertex）
。比如某一系列课程的复杂的前置关系就可以看成是一个AOV网，它是一个
有向无环图
。拓扑排序负责从其中找出一个顺序，可以在不违反所有前置课程条件的情况下完成对每一门课程的学习。拓扑排序每一次移除一个入度为0的顶点，然后移除该顶点的所有出度边，重复此操作直至最后移除全部的顶点。拓扑排序亦可用于复杂关系网的死锁检测。这是十分工业而且贴近管理的东西，一般不会在代码项目中遇到。
此外还有一个更贴近管理的东西叫
AOE网（Activity On Edge）
，同样记录了前置条件，但是目的是找出打成最终目标的最长路径（
关键路径
），从而估算出工期。小范围调整非关键路径上的活动不会影响最终的工期。概括来说，要求关键路径分为以下几步：第一步，从起点开始到终点为止，计算每个活动的
最早
开始时间。这里的最早开始时间指的是
这个活动无论如何也不可能早于这个时间开始
，因为它的前置条件还没有完成。第二步，从终点的最早开始时间反推回去，求每个活动的
最晚
开始时间。这里的最晚开始时间指的是
这个活动无论如何也不能晚于这个时间
，不然它后面的活动不能按时开始。第三步，相减。那些最早开始时间
等于
最晚开始时间的活动就是关键活动，所有的关键活动组成的就是关键路径。
数据结构这门课其实就这么一点点东西，每个计算机系的学生都应该能做到烂熟于心，因为这点概念太基础太常用了。如果这些理解不了，后面的高阶算法还有算法优化啊、设计模式啊什么的课程统统完蛋。计算机四大门最起码直接挂掉三门，剩下的计组也是凶多吉少，不如早做打算换专业。
写了四个小时，打字不易，点个赞呗
我没翻课本，可能有些内容没回忆起来，欢迎补充
2018-11-26 00:22:51 修改了强连通图与弱连通图的定义。
2018-11-26 00:31:49 修改了二叉树的遍历部分的错误。
2018-12-04 12:08:22 规范了顺序表的术语的使用，增加了哈夫曼树。
2018-12-07 10:14:00 修改了二叉树重建部分的错误。
2018-12-16 13:32:36 修改了链表构造栈的一个错别字。
2018-12-27 13:50:12 添加了堆排的实现","算法太难懂？那是你不知道有这些模拟网站
算法的难点在于，根本没办法在脑子里抽象出它的步骤啊
对于做个几何题都费劲的男孩子来说，那更是要了他的亲命了。
今天，我就给大家推荐几个算法可视化的网站。
没错，就是写了代码以后，可以看见他们是怎么一步步求出结果的。
1、
https://
visualgo.net/en
目前网站支持中文，印尼文，日文等多语言版本。
最关键的是，它几乎包含了所有算法！！！！
在搜索选项中你可以根据关键词查找到你想要的算法。
点进去一个具体的算法之后，会有两种方式的可视化呈现方式，一种是电子讲座模式，一种是示例模式。其中示例模式是以动画方式呈现，你可以控制动画的快进与倒退，电子讲座模式是以知识点讲解模式呈现，你可以手动控制页面的进度。两种方式都可以帮助你演示每个步骤的过程代码。
接下来我们演示一下冒泡排序的执行过程，如下图所示：
另外，你还可以创建一组自定义的数，然后让动画显示“你的算法”。
除此之外，还支持在线测试哟~
2、
Algorithm Visualizer
在Algorithm Visualizer，大家可以很清楚的看到算法运行的整个过程，很直观，便于大家学习。
大家可以很清楚的看到，网站分为三部分，最左边是算法目录，大家可以选择自己感兴趣的算法，目前已经包括了很多算法了，比如二叉树、图、排序算法、动态规划等等经典算法 。中间区域主要是算法演示以及运行log。右侧是代码以及算法运行按钮。
我们用它来演示一下冒泡排序的执行过程，如下图所示：
同时它是开源的，目前有35K个star，足以可见该项目的欢迎程度，这里推荐给要学习算法的各位。
https://
github.com/algorithm-vi
sualizer/algorithm-visualizer
3、
Data Structure Visualization
目前已经有很多常用的
数据结构与算法
的可视化，如：常见的数组、链表、队列、
二叉搜索树
、
红黑树
、各种排序等，如下图所示：
比如，我们用它来模拟一个二叉搜索树，如下图所示：
我们再用它来演示一下快速排序算法，如下图所示：
把这些内容学会，算法应该说是非常牢固了，无论是校招还是工作，都已经非常够用了。
三、怎么学习算法
我大学时候也很傻，为了校招，看了不下于五本算法书，加上牛客，刷了大半年。
总共一两千道题啊……不刷怕考到……忘了刷，刷了忘……毛都快掉没了……
现在工作近十年，辗转几个大厂，由当年的应试者变成了出题人，才知道，完全不必这么辛苦。
任何事情都遵循28原则，我们只要把握住那20%，就能拿到80分！
凡事都讲究性价比！
省下来的时间，谈个女朋友，它不香么？？？！！！
这里把我这些年的出题经验告诉大家，希望大家知道哪些是重点，应该怎么学数据结构和算法
。
直接上干货，我花了两天的时间做了一张图，涵盖数据结构和算法书籍中都会讲到的知识点。并给出了常用算法的平均时间复杂度，对于必须要学的内容前面加了星标
这里面涉及到了近二十种数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；超四十种常见算法思想：递归、排序、二分查找、搜索、哈希算法、
贪心算法
、分治算法、回溯算法、
动态规划
、字符串匹配算法。
掌握了这些基础的数据结构和算法，再学更加复杂的数据结构和算法，就会非常容易、非常快。
需要高清无水印思维导图源文件的小伙伴，可以点击这里获取：
学习算法的套路很简单，多看、多写、多上机，既然是思想的集合，看得多了，自然无师自通。
至于刷题，很多同学都知道要刷牛客。
牛客题库：（415题）
总共400多道题，而且有些题，非常难，想全部刷透，也至少刷半年。这显然不适合绝大部分同学。
所以，我们要找到最核心、最重要的题集，即可
比如，如果时间紧张，可以先刷《面试必刷TOP101》里的题目，总共101题。
刷完以后，有时间，可以再刷《
剑指offfer
》的题目，共81题。
因为这两本书，都是面向面试的高频题汇总，自然有很多题目是重合的。这也正能说明这两本书的重要性。
如果专攻面试的话，还有两本不错的书推荐：
《
编程珠玑
》这本书的豆瓣评分非常高，有 9 分。
这本书最大的特色就是讲了很多针对海量数据的处理技巧。这个可能是其他算法书籍很少涉及的。面试的时候，海量数据处理的问题也是经常会问的，特别是校招面试。不管是开拓眼界，还是应付面试，这本书都很值得一看。
《
编程之美
》这本书有多位作者，其中绝大部分是微软的工程师，所以书的质量很有保证。不过，这里面的算法题目稍微有点难，也不是很系统，这也是我把它归到面试这一部分的原因。如果你有一定基础，也喜欢钻研些算法问题，或者要面试 Google、Facebook 这样的公司，可以拿这本书里的题，先来自测一下。
当然，我也有一本谷歌师兄总结的高频面试算法习题集，包含了常见的数据结构和算法汇总，无论是排版还是内容，都是非常棒。
所有这些书，我都为大家找到并下载好了，需要的小伙伴可以直接领取。这回得帮我点赞了吧
计算机组成原理
组成原理应该是所有课程里最难的课了，它是一门衔接数电和汇编的一门课。整个课程的核心就是使用数字逻辑电路和触发器搭建一个可以运行汇编指令的机器.
单纯看书、看视频的学习，会极其枯燥，必须搭配实验性小游戏，才更容易理解并坚持下去。
如果你需要提前感受一下可以去玩一个叫人力资源机器的游戏.代码区就是ROM,中间箱子是寄存器,两边输入和输出的会和并到一起装到RAM,小人就是运算器.
这篇文章里有这个游戏的简介和玩法：
你可以从这个游戏做为一个开始。
再回来问题上来，我们先推荐学习资料，最后再推荐一些实验性游戏。
视频首推
卡内基梅隆大学
的《深入理解计算机系统》系列课程，英语不好？没关系，有中英文字幕，看完这套视频，不仅能学到知识，指不定六级顺带也给过了。
配套教材建议选用《深入理解计算机系统》，这个视频应该也是用的这个教材。
组成原理游戏推荐：
Oxygen Not Included
 里面的逻辑电路相关的内容可以提供具体案例,提高对逻辑门的感性认知.同时可以衍生出很多机制相关的思考,比如 具体的问题转化为数理逻辑,小人作业并发冲突,随机地图生成,权限管理,复杂功能分区规划等等.
Human Resource Machine
 这个可以最直观的展示指令和运算的关系,上文也说过了和组原大作业有千丝万缕的联系.另外通过关卡提供了较为平稳的曲线,可以提前规避因为理解力不足带来的挫败感. 这个游戏还有一个多线程版本:
7 Billion Humans
=
Opus Magnum
 前置知识要求低,极为艺术的逻辑呈现,完成之后真的会有炼金一般的快感.
Silicon Zeroes
 一次性解决触发器!!!
TIS-100
 汇编王中王
把这些内容学会，通过校招笔试，完全不是问题。
但校招不光有笔试，还有面试环节，面试考的就是项目实战能力了。
有关校招的内容非常多，这里我就不一一列举了。我把我这些年的所知所得，整理成了一本书，开源到github上了。相信会对大家很有帮助，大家可以去看.
目前还在持续更新，欢迎大家star。
地址：
https://
github.com/harvic/Fight
ingCoder
好了，这篇就到这了，希望大家毕业都能找到好工作。
我是 
@启舰
 ，原创不易，帮我点个赞吧。
本人所有文章皆为原创，著作权归@启舰 所有，未经授权，转载必究","以前我当了好几年
数据结构与算法
的TA，像你这样的孩子我见的多了，没啥，千万别以为自己笨，很多人也是一开始不行，后面慢慢赶上来的。
学不会数据结构往往有以下几个原因：
前面的编程课没学好（这种情况是最多的），一般数据结构之前，学校会开一门101/102的课，一般是c/c++或者java，这个课对学数据结构很重要。如果你没学好，你先至少花一两个礼拜，把这个课好好再学学。编程课的复习中注意两个点，一个是循环，一个是函数。你也可以请人给你补习一下，别难为情，很多人都和你一样不懂。
有些同学都学到树和图了，却还没理解两个最基本的概念，就是数组和链表，一切复杂的数据结构都是数组和
链表
的变形和组合。我建议你至少花一两个礼拜把数组和链表的程序练熟了，什么在一个数组中找最大值这样的，最好连倒转链表这样的程序也随手能写。学东西要循序渐进，后面的树和图等先不着急。
还有好多同学不太理解递归。递归不是你日常生活能碰到的概念。你如果不经过学习和训练，是很难理解和设计出
递归
的算法的。我建议你多找TA和老师，多练习。学好了递归才能比较好理解树的遍历以及深度优先算法。
我就两点建议：
首先别贪多，前面我说的欠账先补上，然后只要你能把栈和队列搞明白了，你数据结构这门课就没白学。这两个搞明白了，你后面才能学好深度优先和广度优先。而且如果以后你成为一个程序员了，栈和队列也是妥妥会遇到的数据结构。
二叉树是本科数据结构的核心精华，也最常考。你要是能把
二叉树
搞透了，你这们课及格就不难了。搞懂了二叉树，你才能搞明白AVL平衡搜索树和
二叉堆
。二叉树是树的最基本应用，而树又是图最小联通子集。你在图中做dfs或者
bfs
，你可以把这个过程想象成一棵树（当然也不全是）。很多东西没有那么难，就那么一两个pattern，是不用死记硬背的。
少则得，多则惑，是以圣人抱一为天下式。算法并不是死记硬背的科目，从最简单的小算法开始理解，多数人都是可以赶上来的。","首先忘掉你女生的身份比较好……先把问题变成“大二学生  计算机科学与技术专业学到数据结构和组原有点心态爆炸了，看不懂敲不出代码，还有救吗”
然后分析一下究竟是什么问题，前导课程（C语言）学得怎么样，学明白了吗，大作业是自己顺利做出来了还是抄的？如果前导课程学的就有问题，那需要先补前导课程；如果前导课程没问题，那可能是老师教的不太好，可以找一些其他的资料学一下，我只知道《
算法导论
》，不知道难度是否适合你。
组原是说
计算机组成原理
吗？也是一样的道理，先看数电学的怎样，分析方法大同小异。
我可以提个类似于总纲的心法概要给你，学不学得成还看你自己：
数据结构研究的是怎么
将有用的数学模型存储在内存中
的问题。它包括数学模型与它在内存中的存储方式两部分，其中
数学模型的部分是绝对的重点
，而内存中的存储方式一般是显而易见的。由于要学习数学模型，有一些
抽象代数
的基础会比较好（简单的集合、运算、关系就够了）
数据结构一般包括以下部分：
存储的数据本身
数据与数据的关系
对关系的建模
关系的约束（重要）
能保持这个约束的合法操作
例如，线性表意味着有限个元素，构成了一个
全序关系
，可以映射到0 - (N-1)的整数。通过映射建模，就得到线性表数据结构；如果通过全序关系建模，则可以得到链表结构。线性表的约束是它的元素一定构成与0 - (N-1)的整数的一一映射，意味着它可以增加元素、删除元素、修改映射到的元素，但中间不能跑出一个洞来，也不能有两个元素有相同的下标。
再比如，树结构意味着所有节点是相互连通的，而且不存在环，任意两个节点之间的路径是唯一的。如果选中一个节点作为根，则形成有根树，所有与根相邻的节点各自构成一棵子树，可以通过链式结构递归表示。如果按照到根节点的距离排序，则每个节点到根节点的路径都会有一个“下一跳”，定义为这个节点的父节点的话，也可以通过每个节点到
父节点
的链接表示这棵树。树上的节点数永远等于边数+1，因此增加一个节点就需要增加一条边，删除一个节点也需要删除一条边。
而这个结构在内存中的表示是有套路可循的，最常见的是用
结构体
存储数据，用指针表示关系，熟悉了之后会发现其实没有什么难度。
关于
微机原理
：
微机原理研究的是
如何用数字电路实现冯诺依曼机
。所谓
冯诺依曼机
就是存储器+运算器+控制器+输入设备+输出设备，后两个计算机组成原理一般不怎么讲。冯诺依曼机按照存储程序的原理工作，控制器从内存中读取一条指令，通过解析指令驱动运算器，运算器从存储器中读取数据进行运算然后存回存储器，特殊的指令则可以从输入设备中读取数据，或者将数据写出到输出设备。执行指令之后，PC指针按照执行的结果移动，进行下一条指令的执行，就可以让计算机持续不断地执行下去。
存储器就是RS触发器为基础的SRAM，除此以外还有成本更便宜一些的DRAM
运算器就是数字电路中的各种加法器、乘法器等组合逻辑与
时序逻辑
，配合从SRAM中读写数据的电路
控制器可以是简单的组合逻辑电路，通过指令使能ALU的不同组件
好了微机原理学完了，剩下的简单学一下汇编就行了。","你们别再吓楼主了，，，，，，，，，
不过你们大二才学数据结构，确实。。。。。。
不过有一说说，学算法，没啥捷径，最大的捷径就是刷题。
但，千万别盲目刷题！
不然就得
一台电脑一包烟，一道题解整一天
，最后你会在知乎发起另外一个问题：
一道题做半天，另外半天看这道题的题解，，是我智商有问题吗？
下面讲一讲我的刷题经验吧
一、刷题前的一些准备
如果你连最基本的数据结构，例如链表，队列，栈，二叉树都没有接触过，那么我是不建议你去 leetcode 刷题的，所以得先入门一下
数据结构与算法
，当你学习了这些基础的数据结构之后，其实已经具备了刷题的能力了。（不知道你这几个基础的知识掌握的如何）
一、基础数据结构与算法知识
1、时间复杂度
2、空间复杂度
一般最先接触的就是时间复杂度和空间复杂度的学习了，这两个概念以及如何计算，是必须学的，也是必须最先学的，主要有最大复杂度、平均复杂度等，直接通过博客搜索学习即可。
文章推荐：
什么是时间复杂度？)
3、线性表
列表（必学）
链表（必学）
跳跃表（知道原理，应用，最后自己实现一遍）
并查集（建议结合刷题学习）
不用说，链表、列表必须，不过重点是链表，跳跃表可以放一放，并查集可以刷题的过程中学习，但链表得至少掌握增删改
别再问我什么是跳跃表了
4、栈与队列
栈（必学）
队列（必学）
优先队列、堆（必学）
多级反馈队列（原理与应用）
4、树
二叉树：各种遍历（递归与非递归）（必学）
哈夫曼树
与编码（原理与应用）
AVL树（必学）
B 树与 B+ 树（原理与应用）
前缀树
（原理与应用）
红黑树（原理与应用）
线段树（原理与应用）
我写过的文章：
别再问我什么是二叉堆了
别再问我什么事AVL 树了
别再问我什么是红黑树了
别再问我什么是 trie 树了
树相关是知识还是挺多的，建议看书，可以看《算法第四版》，入门看《
数据结构与算法分析
C语言描述 版》
不过刷题前也不需要准备这么多，先把最基本的二叉树学了就可以了
书籍推荐看这里：
视频推荐看这里：
二、常见算法思想
Leetcode 刷题我还是希望你能在学习一些
算法思想
，一般就这几种
1、递归
2、枚举
3、贪心
4、回溯
5、动态规划
但是，其中最重要的，我觉得就是
递归
，其他的几种算法，也都会有
递归的影子
，并且我刚才说图相关算法、二叉树的遍历等，也都包含递归的使用。
所以，在你刷题之前，或者在学习二叉树、图相关算法遇到递归的时候，我希望你能静下心来，去学一学递归，我也会告诉你，
对于初学者，递归很难
，我是被无数次折腾，无数次看答案
似懂非懂
之后，才突然醒悟了。
你不需要把它学的很精通，但是你要懂一些基本的递归题，知道递归是怎么一回事，例如最简单的
斐波那契数列
得会用递归做吧？
阶乘
也会吧（虽然不是最优解）。
所以，死磕入门数据结构，可以学习下一些算法思想，而
递归
，你必须得入门，至于动态规划、回溯，我觉得慢点学也没有，可以后面刷题遇到时在学，而枚举、贪心，相对比较简单。
这里推荐一份字节大佬的刷题笔记，把各种算法模版都总结好了，跟着学就行：
我写过的文章：
1. 告别递归算法，谈谈我的一些经验
2. 告别动态规划，谈谈我的一些经验
3. 动态规划优化的一些经验
4. 递归训练一：Leetcode 104.二叉树的最大深度
5. 递归训练二：Leetcode 62.不同路径
6. 递归训练三：剑指 Offer 16. 数值的整数次方
7. 递归训练四：Leetcode 4. 寻找两个正序数组的中位数
8. 动归训练一：Leetcode 198.大家劫舍
另外也整理成了手册：
最后，上一波思维导图
二、如何刷题
终于，到了刷题这一部分了，如果要说学算法的捷径，那么
刷题便是最好的捷径
，如果你刷的题很少，达不到一定的量，那么再多的捷径，估计也没啥用，只有在满足一定题量的情况下，才适合来谈论所谓的
技巧
。
1、先说一说互联网算法笔试
不过在刷题之前我想先说一说
笔试
，如果笔试不考算法，面试也不考算法，那么我可能在学习算法的这条路上，会少了很多的积极性，你可能会觉得我很功利，但是我觉得，带着功利性的目的去学习算法，也是完全没问题的。
在校招的笔试中，其实这些笔试题还是挺难的，你在 leectode 可以做出 hard 级别的题，但在笔试中，可能连 medium 级别的都做不出，因为笔试的题，都比较灵活，基本都会通过实际的例子来引出一道题，你可能不知道要使用哪种方法来做比较好，有些还是多种方法的结合。
对于笔试的题型，我之前也总结过，无非是以下几种
（1）、基本数据结构的考察：这类题我觉得是比较简单的，主要考场基本数据结构的操作，例如二叉树的层序遍历，链表的逆序等，当然，它不会直接告诉你，让你来逆序或者遍历。
（2）、某种算法思想的掌握：这类题你掌握了某种算法思想，就会比较容易，如果不懂，那就凉凉了。例如动态规划、回溯、枚举、深度/广度、贪心、二分等。其中，我觉得动态规划考的挺多，还要就是 回溯+深度/广度。
（3）、边界条件的考察：这类型的题，估计你一看就有思路，知道该怎么做，但是，它的边界条件特别多，需要分很多种情况来讨论，特别容易出错，有时候会让人陷进去，越做越复杂，这类题主要考场你的思维严谨程度。
（4）、找规律、数学公式：这类型的题，主要是根据数据之间的一些关系，来找一些规律，进而推出他们的通用公式，就像我们高中时，找数列的同项一样。
2、按分类刷题
上面我列了笔试的题型，并且跟你说了笔试是真的挺难的，那么对于我个算法小白来说，该如何做好呢？
我的建议是，
分类刷题，阶段性总结
。例如最开始可以在 LeetCode 按照链表/二叉树/递归等这些标签来刷，因为这样可以让你深入掌握每一种方法。
例如链表相关的题型
当然，笔试的题之所以难，是因为我们往往不知道用哪一种方法做好，或者说具体属于哪一种题型，那么还有必要分类刷题吗？
答是有必要的，只有当你熟悉每一种题型，你才能灵活使用他们，进而解决各类复杂的题，这就如同你在练功夫的时候，前期你需要把每个招式都打扎实了，之后才能灵活把各个招式连接起来，融合贯通。刷题也是一样，前期先分类，把每个题型掌握起来，后期咱们再随机练习，慢慢着就能灵活应用了。
不过，每次刷了一部分题型之后，我觉得还有必要做一些总结，或者说总结一些
刷题模版
，例如对于二分法查找，其实好几种题型总结起来，就是
开闭区间
的组合，你可以把他们总结起来，例如什么时候用开区间，什么时候用闭区间。
有人可能会说，模版是死的，真的有必要总结吗？
我觉得
有必要总结，但没必要死记
，总结，
只是加深你的理解
，当然，如果你在做题的时候，刚好记住了自己的模版，可以直接套上去，那肯定更好。但是，就算忘了也没事，通过自己的总结，你其实是知道怎么做的了，只是还需要你多花一点时间，快速模拟讨论下各种情况，一样能够做出来的。
也就是说，最开始刷题的时候，可以分类刷题，并且阶段性总结，如果你是初学者，可以先从简单的题做起，例如我刚才说的，简单的递归题，之后一些二叉树、链表的题，因为你可能刚刚学习数据结构不久，刚好可以加深你的理解。
这里给大家推荐一份字节大佬的分类刷题笔记：
3、书籍推荐
刚才我说了很多种题型，对于按题型刷题总结，首推《程序员代码面试指南：IT名企
算法与数据结构
题目最优解》，这本书真的挺不错，大部分题型都总结了，而且每个专题有十几二十道，这里建议大家买本来学习。
还要一本我大一看的，感觉也挺不错，叫做《挑战程序设计大赛》，不过这本比较适合不急着面试的吧，这本不像上面那一本，专门来总结各种题型应付面试。
《编程之美》、《
编程珠玑
》也建议看，这两本我觉得比较有趣，不是说让你一直刷题一直刷题，这两本你可以买来看看，会给你带来一些思路，这两本我是只看，没动手打代码。
Leetcode 刷题的时候，也是可以分题型刷滴，所以也可以去 leetcode 刷题，不过刷题的时候，我这里有个建议，就是别在本地 IDE 写代码，直接在网页端写就行了。因为面试的时候，一般就让你在记事本写代码，不会给你 IDE。如果你不习惯，估计很容易写错代码，而且，有些库函数你也把名字忘记了。网页端其实也是挺方便的，也会有一些代码提示。
书籍这里找：
三、刷题时的一些注意点
当我们在做一道题的时候，可能会遇到两种情况，一种是这道题，特么秒杀，一眼就懂思路；一种是，一脸蒙蔽，太难了吧。
一眼就懂思路，有必要做吗？
我的答案是，有必要做。千万不要眼高手低，看着简单，做起来不一定简单，AC 之后，你还要去讨论区看看大佬们是怎么做的，因为有些人的代码，真的写的很简洁，看着就很舒服，咱们可以多学一学的，当然，也有可能那个人就是你自己。
代码写多了，有时候，你就会发现自己真的变强了，写起代码来，bug 也越来越少了，分分钟 AC 一道题。
尽量最优解
其实对于很多题，如果不看时间复杂度和空间复杂度，单单只是 AC，那还是很容易的，但是一提交，你的代码可能只打败了百分之几的人，显然我们是不能满足于这种代码的。
当你做一道题时，一开始可以先暴力做，但后面，还得想想该如何优化，想不出也没事，可以讨论区找空间/时间复杂度更低的代码，或者直接搜索引擎搜索，一般都能搜到别人的代码。
之后跟着别人的代码，自己再实现一波，尽可能把最优解的代码实现起来。千万不要为了 AC 而 AC，不是 AC 的越多就越强的，当你入门之后，更多的是要总结方法，寻找高效率的代码。
这里推荐一份大佬的刷题笔记，总结了 leetcode 上的题解，每道题的题解都是
beat100%
，非常值得大家学习：
顺便讲解一些算法技巧吧
说到算法技巧，必须再给大家再讲一波好用的算法技巧，不信，你继续往下看
1. 巧用数组下标
数组的下标是一个隐含的很有用的数组，特别是在统计一些数字，或者判断一些整型数是否出现过的时候。例如，给你一串字母，让你判断这些字母出现的次数时，我们就可以把这些字母作为下标，在遍历的时候，如果字母a遍历到，则arr[a]就可以加1了，即 arr[a]++;
通过这种巧用下标的方法，我们不需要逐个字母去判断。
我再举个例子：
问题：给你n个无序的int整型数组arr，并且这些整数的取值范围都在0-20之间，要你在 O(n) 的时间复杂度中把这 n 个数按照从小到大的顺序打印出来。
对于这道题，如果你是先把这 n 个数先排序，再打印，是不可能O(n)的时间打印出来的。但是数值范围在 0-20。我们就可以巧用数组下标了。把对应的数值作为数组下标，如果这个数出现过，则对应的数组加1。 代码如下：
public void f(int arr[]) {

       int[] temp = new int[21];
       for (int i = 0; i < arr.length; i++) {
           temp[arr[i]]++;
       }
       //顺序打印
       for (int i = 0; i < 21; i++) {
           for (int j = 0; j < temp[i]; j++) {
               System.out.println(i);
           }
       }
   }
利用数组下标的应用还有很多，大家以后在遇到某些题的时候可以考虑是否可以巧用数组下标来优化。
2. 巧用取余
有时候我们在遍历数组的时候，会进行越界判断，如果下标差不多要越界了，我们就把它置为0重新遍历。特别是在一些环形的数组中，例如用数组实现的队列。往往会写出这样的代码：
for (int i = 0; i < N; i++) {
       if (pos < N) {
        //没有越界
        // 使用数组arr[pos]
        else {
          pos = 0;//置为0再使用数组
          //使用arr[pos]
         }
        pos++;
   }
实际上我们可以通过取余的方法来简化代码
for (int i = 0; i < N; i++) {
  //使用数组arr[pos]   (我们假设刚开始的时候pos < N)
  pos = (pos + 1) % N;
}
3. 巧用双指针
对于双指针，在做关于单链表的题是特别有用，比如“判断单链表是否有环”、“如何一次遍历就找到链表中间位置节点”、“单链表中倒数第 k 个节点”等问题。对于这种问题，我们就可以使用双指针了，会方便很多。我顺便说下这三个问题怎么用双指针解决吧。
例如对于第一个问题
我们就可以设置一个慢指针和一个快指针来遍历这个链表。慢指针一次移动一个节点，而快指针一次移动两个节点，如果该链表没有环，则快指针会先遍历完这个表，如果有环，则快指针会在第二次遍历时和慢指针相遇。
对于第二个问题
一样是设置一个快指针和慢指针。慢的一次移动一个节点，而快的两个。在遍历链表的时候，当快指针遍历完成时，慢指针刚好达到中点。
对于第三个问题
设置两个指针，其中一个指针先移动k个节点。之后两个指针以相同速度移动。当那个先移动的指针遍历完成的时候，第二个指针正好处于倒数第k个节点。
你看，采用双指针方便多了吧。所以以后在处理与链表相关的一些问题的时候，可以考虑双指针哦。
4. 设置哨兵位
在链表的相关问题中，我们经常会设置一个头指针，而且这个头指针是不存任何有效数据的，只是为了操作方便，这个头指针我们就可以称之为哨兵位了。
例如我们要删除头第一个节点是时候，如果没有设置一个哨兵位，那么在操作上，它会与删除第二个节点的操作有所不同。但是我们设置了哨兵，那么删除第一个节点和删除第二个节点那么在操作上就一样了，不用做额外的判断。当然，插入节点的时候也一样。
有时候我们在操作数组的时候，也是可以设置一个哨兵的，把arr[0]作为哨兵。例如，要判断两个相邻的元素是否相等时，设置了哨兵就不怕越界等问题了，可以直接arr[i] == arr[i-1]?了。不用怕i = 0时出现越界。
当然我这只是举一个例子，具体的应用还有很多，例如插入排序，环形链表等。
5. 与递归有关的一些优化
（1）.对于可以递归的问题考虑状态保存
当我们使用递归来解决一个问题的时候，容易产生重复去算同一个子问题，这个时候我们要考虑状态保存以防止重复计算。例如我随便举一个之前举过的问题
问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？
这个问题用递归很好解决。假设 f(n) 表示n级台阶的总跳数法，则有
f(n) = f(n-1) + f(n - 2)。
递归的结束条件是当0 <= n <= 2时, f(n) = n。因此我们可以很容易写出递归的代码
public int f(int n) {
       if (n <= 2) {
           return n;
       } else {
           return f(n - 1) + f(n - 2);
       }
   }
不过对于可以使用递归解决的问题，我们一定要考虑是否有很多重复计算。显然对于 f(n) = f(n-1) + f(n-2) 的递归，是有很多重复计算的。如
就有很多重复计算了。这个时候我们要考虑状态保存。例如用hashMap来进行保存，当然用一个数组也是可以的，这个时候就像我们上面说的巧用数组下标了。可以当arr[n] = 0时，表示n还没计算过，当
arr
[n] != 0时，表示f(n)已经计算过，这时就可以把计算过的值直接返回回去了。因此我们考虑用状态保存的做法代码如下：
//数组的大小根据具体情况来，由于int数组元素的的默认值是0
   //因此我们不用初始化
   int[] arr = new int[1000];
   public int f(int n) {
       if (n <= 2) {
           return n;
       } else {
           if (arr[n] != 0) {
               return arr[n];//已经计算过，直接返回
           } else {
               arr[n] = f(n-1) + f(n-2);
               return arr[n];
           }
       }
   }
这样，可以极大着提高算法的效率。也有人把这种状态保存称之为备忘录法。
(2).考虑自底向上
对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。
不过，有时候当n比较大的时候，例如当 n = 10000时，那么必须要往下递归10000层直到 n <=2 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。
对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道
f(1) = 1;
f(2) = 2;
那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来做。
代码如下：
public int f(int n) {
       if(n <= 2)
           return n;

       int f1 = 1;
       int f2 = 2;
       int sum = 0;

       for (int i = 3; i <= n; i++) {
           sum = f1 + f2;
           f1 = f2;
           f2 = sum;
       }
       return sum;
   }
我们也把这种自底向上的做法称之为递推。
总结一下
当你在使用递归解决问题的时候，要考虑以下两个问题
(1). 是否有状态重复计算的，可不可以使用备忘录法来优化。
(2). 是否可以采取递推的方法来自底向上做，减少一味递归的开销。
6、找出不大于N的最大的2的幂指数
传统的做法就是让 1 不断着乘以 2，代码如下：
int findN(int N){
    int sum = 1;
   while(true){
        if(sum * 2 > N){
            return sum;
        }
        sum = sum * 2;
   }
}
这样做的话，时间复杂度是 O(logn)，那如果改成位运算，该怎么做呢？如果要弄成位运算的方式，很多时候我们把某个数拆成二进制，然后看看有哪些发现。这里我举个例子吧。
例如 N = 19，那么转换成二进制就是 00010011（这里为了方便，我采用8位的二进制来表示）。那么我们要找的数就是，把二进制中
最左边的 1 保留，后面的 1 全部变为 0
。即我们的目标数是 00010000。那么如何获得这个数呢？相应解法如下：
1、找到最左边的 1，然后把它右边的所有 0 变成 1
2、把得到的数值加 1，可以得到 00100000即 00011111 + 1 = 00100000。
3、把 得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 >> 1 = 00010000。
那么问题来了，第一步中把最左边 1 中后面的 0 转化为 1 该怎么弄呢？我先给出代码再解释吧。下面这段代码就可以把最左边 1 中后面的 0 全部转化为 1，
n |= n >> 1;
n |= n >> 2;
n |= n >> 4;
就是通过把 n 右移并且做
或
运算即可得到。我解释下吧，我们假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后，那么得到的结果中第 k+1 位也必定为 1,然后把 n 与右移后的结果做或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;同样的道理，再次把 n 右移两位，那么得到的结果中第 k+2和第 k+3 位必定是 1,然后再次做或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，如此往复下去....
最终的代码如下
int findN(int n){    n |= n >> 1;    n |= n >> 2;    n |= n >> 4;    n |= n >> 8;   n |= n >> 16;// 整型一般是 32 位，上面我是假设 8 位。    return (n + 1) >> 1;}
这种做法的时间复杂度近是 O(log(logn))，重点是，高逼格。
另外，上面的所有书籍，都可以在这里下载到，送给大家
少走弯路，必读计算机经典书籍推荐（含下载方式）
?
mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=100010970&idx=1&sn=91f14c2c08e9fb8a0539c55b7459d60a&chksm=4e43a00e79342918ed8052851f455faa705a6a137eefec91ee04debc885302bc86c5032f5368#rd
当然，算法固然重要，但也别忘了计算机基础知识的重要性，例如计算机网络，操作系统，
计算机组成原理
这些，大厂面试基本必考！！这里给大家推荐一本总结好的资料：
图解操作系统、网络、计算机组成 PDF 下载！
?
mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=100010867&idx=1&sn=8621362987a89a9a8131ac8ae44a3965&chksm=4e43a0a7793429b1ee0dd9edc488c32145ae03d64371fb72d412f4bc80bf51fa795a52b19afb#rd
最后，欢迎来帅地的个人网站学习：
帅地玩编程
?
www.iamshuaidi.com/","感觉就是代码敲得少了，多看，多敲，多思考，慢慢就练出来了。
看完下面的
数据结构基础
，再去LeetCode刷过200题就算入门了吧。
原文链接：
https://
medium.com/free-code-ca
mp/the-top-data-structures-you-should-know-for-your-next-coding-interview-36af0831f5e3
原文作者：
Fahim ul Haq
原文平台：medium
学计算机的课程之前，需要掌握好至少一门计算机语言，常见的语言选择有：Python，Java，C++.
选择C++的小伙伴怎么可以跟着这两门限时优惠的课程来学习：
广告
学好C++才是入职大厂的敲门砖！ 当年要是有这课，我的C++也不至于这样
已失效
?
学Python的小伙伴，跟着这门课来学，用游戏闯关的形式，学习python基础，有趣且高效。
广告
仅限100名！3.9元入门python。游戏闯关式教学，小白也能轻松学会！
已失效
?
下面咱们就来看看数据结构的主要内容吧。
尼克劳斯・维尔特，瑞士计算机科学家，在1976年写了一本名为《
算法 + 数据结构 = 程序
》的书。
40多年转瞬即逝，但这个公式依然成立。这也是今天我们程序员面试的时候，需要展示自己对数据结构以及他们应用场景的掌握的原因。
几乎所有的问题都需要面试者证明他们具有扎实的数据结构基本功。无论你是刚毕业也好（从大学还是编程培训营），还是有N多年的经验。
有时候这些面试题则是专门提到某种数据结构。比如，题目描述是这样开头的“给定一颗二叉树。。。”。其他的时候则是那种隐式的，比如说，“我们找到每个作者相关的书籍数目”。
学习数据结构是非常重要的，哪怕你只是想在当前的工作岗位上变得更赞一点。所以，就让我们从基础开始吧。
啥是数据结构？
简单来说，数据结构就是一种容器，按照某种既定的方式存储数据。这种“方式”能让一个数据结构在某些操作下很高效，相反，在另外的操作下就不太理想了。你的目标是为了理解这些数据结构，从而可以能从不同的数据结构中选择适合当前所面对的问题的那一种。
为啥需要数据结构？
因为数据结构是用来有规则地存储数据的，加上数据结构在计算机科学中神一般的存在，他们的价值就不言而喻了。
不过你要解决的问题是啥，你反正都得需要数据结构，方式可能不同而已。无论是面对员工工资，还是股票价格，购物清单，还是简单的电话本，这样的场景。
根据不同的应用场景，数据需要按照不同的方式存储。我们有好多可以将数据按照不同方式保存下来的数据结构。
常用的数据结构
我们先来列一下最最常用的八种数据结构，然后接下来我们会慢慢将他们讲明白。
数组
栈
队列
链表
树
图
字母树（其实他们就是树而已，但还是值得单独拿出来讲的）
哈希表
数组
数组是最简单也最常用的数据结构。其他的数据结构诸如栈和队列，都是从数组衍生出来的。
下面是一个拥有四个元素的简单数组，包含了元素1，2，3，4.
每个元素都依附于一个正整数，称作索引，它就对应于数组中该元素所在的位置。大多数的编程语言中，数组的起始索引都为0 （0-based，译者注）.
数组一般有以下两种：
一维数组（上图所示）
多维数组（数组里面包含数组）
数组的基本操作
插入 ― 在给
定位
置插入一个元素
取值 ― 返回给定位置的数值
删除 ― 在给定位置删除元素
元素总数 ― 数组包含元素的个数
数组类常问问题
数组中第二小的数
数组中出现的第一个无重复的数
合并两个已排序数组
重新排放数组的正数和负数
栈
我们平时熟悉的软件操作中的撤销（回退）操作，基本会出现在所有应用中。你好奇过它是咋工作的吗？原理是这样的：你把之前的状态（有限的数量）都存到内存中，存的顺序是最新的操作存在最近一个。这个光靠数组是不能实现的。这是栈擅长的地方。
现实中也有栈的例子。比如你把一大堆书垂直叠（一本压着另外一本）起来放。为了拿到他们里面靠中部位置的书，你得把上面的书都拿走才行。这就是著名的LIFO（后进先出）的工作原理。
下图是一个包含有三个元素的栈，数值为1，2，3. 元素3在栈顶，它会被最先删除。
栈的基本操作
进栈 ― 在栈顶插入元素
出栈 ― 把栈顶元素弹出（删除）
判空 ― 返回栈是否为空
栈顶元素 ― 只返回栈顶元素而不删除
译者注：对于栈所有的操作，都只出现在栈顶这个地方
栈常见的面试问题
借助栈来计算后缀表达式的值
将栈里的元素进行排序
判断括号表达式是否合法
队列
和栈类似，队列是另外一种线性数据结构。这种数据结构将元素按照顺序的方式存储。和栈最本质的区别就是：和后进先出相反，队列实现了先进先出的特性（FIFO， First in First Out）。
队列在生活中有非常贴切的例子：一堆人排在售票台前面。如果新来了一个人，这个人得排在队尾，而不是队伍前面。另一方面，排在第一的人则能第一个买到票，然后离开队伍。
下面是一个包含了四个元素的队列（1， 2， 3， 4）。1站在队头，会被第一个删除。
队列的常用操作
进队 ― 在队尾加入一个元素
出队 ― 从队头删除元素
判空 ― 判断队列是否为空
队头元素 ― 返回但不删除队头元素
常见的队列题
用队列实现栈
将队列里面的前k个元素翻转
借助队列来产生从1到n的二进制数
链表
链表是另外一种重要的线性数据结构。链表初看起来和数组很类似，但他们在内存分配，内部结构，以及像插入和删除这样的基本操作上，都是不一样的。
链表就是一串 串起来 的节点，他们的每一个节点都包含了数据和指向下一个节点的信息。链表有头结点，指向链表中的第一个元素。
链表结构经常用来实现文件系统，哈希表，以及邻接表。
下图是一个链表的内部结构图示。
我们常见的链表有以下两种：
Singly Linked List (Unidirectional)
Doubly Linked List (Bi-directional)
单链表 （单一方向）
双链表
 （双向）
链表基本操作：
末端插入 ― 在链表的末尾插入给定元素
头部插入 ― 在链表的头部插入给定元素
删除 ― 在链表中删除给定元素
头部删除 ― 删除头部第一个元素
搜索 ― 判断给定元素是否存在于链表中
判空 ― 判断链表是否为空
常见的链表问题
翻转链表
检查链表中是否有环
返回距离尾部距离为N的节点
删除链表中的重复元素
图
图包含一系列的节点，这些节点通过网络相互连接起来。这些节点也被称为Vertcies。对于每个对子（x, y)，我们则称为边，表示节点x和节点y是相连的。边也可能包含权重或是花费信息，表明了从x到也所需要的消耗。
图的类型：
无向图
有向图
在计算机语言中，图通常用下面两种方法表示：
邻接矩阵
邻接表
常用的图遍历算法：
宽度优先搜索
深度优先搜索
常见的图问题
实现宽搜和深搜
判断一个图是不是一棵树
数图中的边数
找两个节点之间的最短路径
树
树是非线性数据结构，它也是由节点和边组成的。因此树和图类似，但他们最大的不同是树上没有环存在。
树被广泛应用在AI和其他复杂算法中，因为它能提供高效的存储，使得问题能得以解决。
下面是一颗简单树，图中也包含了常见的树的术语。
我们可以有以下的各种树的形状：
N叉树
平衡树
二叉树
二叉搜索树
AVL树
红黑树
2-3树
上面这些树中，以二叉树和二叉搜索树最为常用。
常见的树的问题
求二叉树的高度
求二叉搜索树中的第k大的数值
找离根节点距离为k的所有节点
找给定节点的所有祖先节点
字母树
字母树，也叫做
前缀树
，是一种树形的数据结构，它是一种解决字符串相关的问题的高效数据结构。能快速查询回馈信息，经常用在字典中查询单词的场景下，它能为搜索引擎提供自动补全，甚至能帮到IP查询。
下图演示了如何将三个单词（top, thus, their）插入到字母树中，并保存下来：
在字母树中，单词都是从下至下一个字母一个字母保存起来的。绿色的节点（p, s, r）表示的是该节点是一个单词的最后一个字母，p对应top，s对应thus，而r则对应于their。
常见的字母树问题：
数字母树中的单词总数
打印字母树中所有的单词
用字母树排序数组
借助字母树来从字典中取单词
建一个满足T9的字典（译者注：T9 stands forText on 9 keys）
哈希表
哈希是一个分辨不同的实体，从而将每个实体存储在某个预先计算好的索引上，这个预先算出来的值被称作“键”。因此，实体都是由键值对的形式存放的，把一大堆这样的东西称为字典。每个实体都能通过键来找到。基于哈希这种思想的数据结构有不少，但最常用的是哈希表。
哈希表一般通过数组来实现。
哈希表的效率取决于以下三个因数：
哈希函数
哈希表的容量
冲突避免方式
下面这图演示了我们是怎么从哈希值匹配到一个数组中的。该数组的索引是通过函数函数求出来的。
常见问题：
找数组中的对称对子
追踪旅程的完整路径
检查一个数组是否为另一数组的子集
检查多个数组之间是不是没有共同元素
上面就是八种你在算法面试之前必知必会的数据结构。
具体的学习，可以参考原文作者开发educative上的
数据结构课程
：
专门针对数据结构的课程则有：
C++:
JavaScript：
Java：
Python：
我上过其中的Java版本，课程是把数据结构里面的
基础数据结构
都用java实现了一遍，对于用java的同学特别有帮助，java的基础在刷题的过程中，还是要必须掌握的。
（如果你需要上面这些算法课程，那么你可以使用 
awesome-developer
 的折扣码获得网站所有课程的
额外15%off
！上面的折扣码针对单独购买所有课程有效。
单独买课的折扣码有效期最后两周，大约到2021年1月22号左右
。 
如果想买
订阅
（
Subscriptions
）的小伙伴,则可以用
ZHIHUEDU-10
（必须一模一样输入）的coupon code来获取额外九
折
的优惠
按年和按月均适用
。
计算机的其他核心课程，参考这个回答：","作为一个cs专业的现任老师，正好教的就是ds。我来说两句。学ds导致心态爆炸的原因大部分可能是老师没教好。而且还不是ds老师没教好，，而是程序设计。
数据结构课程
是深理论并强实践的课程，得益于（呵呵）伪代码描述，好像看起来
数据结构理论
都懂其实一写代码就gg。
我从学生时代开始就深有体会，我考研数据结构分很高呀，为什么我就写不成算法程序呢？拿着程序去问老师，老师说，他没写过cpp代码。。。。
当时的中国（十几年前了）高校程序设计课程大多是啃语法（c+++b+++a那套玩意），写过代码，做过项目的老师反正在我校是极少，我很不幸没遇到过。然后
cpp
学个一知半解就去上用严奶奶教材的伪代码课学ds，后果可想而知。
等我研究生毕业，it行业摸爬滚打n年之后回到高校执教发现，嗯？现在的大学怎么还这么教？我敲踏马。。。
于是乎我这四年在弊校（一所四非大学）做的事就是，重新架构程序设计
数据结构算法
课程，计算思维贯通其中，大量增加练习数量，带着高年级学生做助教给新生答疑，虽然阻力重重，但是我坚持下来了。从过程上看，刚开始的两年老师，学生给予的评价大多是负面，但是结果上看，学生们的代码能力正在提升，你看icpcccpc我校也都能拿奖了不是。
说了这么多，我想告诉题主，你要分析判断一下自己崩溃的根本原因，对症下药。","正常啦，不要怕，相信我，你的同学也好不到哪里去，按我之前面试人的经历，10个9个不过关的，刚毕业的，1~5年经验的大把人不过关的。
然后我想跟你说的是，学数据结构只是学计算机遇到问题的一个缩影而已，以后，你会遇到类似的问题，看着很蒙，完全没有头绪。
那该怎么办呢。
首先，你得把心态放平，不要急躁，然后把不懂的这个数据结构或者算法，以它为关键字，开始在google，bing，baidu上面查，一篇篇文章的看，记得一边看，一边在纸上写，写关键点就可以了（这个是嗑瓜子原理，嗑瓜子其实很无聊，但是不断有瓜子吃，就容易保持兴趣，你写下来也一样，容易错觉你学到东西了）。有时候网上资料不多，或者还是看着很蒙，你就去看看有没有相关的书籍，毕竟书籍里面是经过提炼过的，有时候会好一点。
不过有时候，可能全部看了一遍还是不行，还是不要急，重新把你看过的，挑你看着顺眼，觉得好的，再缕几遍。
最后，还是不要急，一般情况下，因为是个新概念，所以没法一时间想通，你要把周期拉长一点，比如一个数据结构，你定成1周或者2周掌握，相信我，肯定行的，不过前提是你要时时刻刻念叨着人家数据结构才行，念念不忘必有回响嘛。要是这么搞都不行，来，有空我手把手教你。
最后的最后，给你很泛的缕下整个数据结构要怎么学吧，你可以这样来。
对比着看看数组和链表的区别，想想我要快速插入一个元素，删除元素，获得一个元素，分别用哪个好。如果想着不明显，你把数据量弄大一点，就很容易看出来了。后面学到map（
散列表
）了，你也可以重新回来对比下这三个。
对比着看栈和队列，一个先进后出，一个先进先出，这个在什么场景下会用到，比如停车场呀，排队呀，这些场景你琢磨琢磨，难一点的场景比如你要做个
科学计算器
，那些科学表达式a*b-(c+d)
e怎么弄，有写过SQL语句吧，select 
 * from table where a >1 and b<3...那些where的条件语句如果要你解析给系统用，你怎么写。
几个排序，常用的不多，可以从冒泡和快排开始，记得对比他两的不同。
不过快排有时候很好，可是冒泡几句话就写完了，而快排要写好多，容易出错，如果没有api的情况下，有时候我就排10几20个数这么小量的，可能就直接用了冒泡了。
树的话，从二叉树开始，学怎么
前序遍历
，中序遍历，后续遍历，然后他们是递归的嘛，有精力了你就看看怎么不要递归的来。
接着图，你就看看
深度优先搜索
，广度优先搜索，这两个就会用到前面的队列和栈，你记得对比下，想想应用场景。比如你要做个消灭星星的游戏，你用哪个好。
大概的版块就这样，然后你再去学，丰富他们就好了，不过这些下来应该也差不多一个学期过去了。
对了，肯定有人会给你推荐
算法导论
，那书很好，可是太厚了，看着有压力，容易打击信心，不太适合初学者，至少我是断断续续看了5年以上，其实教科书基本就写得很好了。","我们学
数据结构
的时候老师让用的语言是c语言，c语言大一学的，我基本不会，数据结构的代码我也敲不出来，书上也没有c的实现代码，这门课程最后我糊弄下来了，其实班上也没有几个人能敲出来，再后来，我找了一套讲的很好的数据结构视频看了两遍，里面有c的实现过程，我也跟着敲了，这样，原理和实现都可以说是了解了。
总之，自己在花点时间，自己学，找好的学习资料。
搜索引擎查一下，郝斌
谢谢一位大佬的赞同，郝斌老师的
数据结构课程
b站上有，想看的自己去搜索了。
这个人讲的数据结构不错的。
需要的话可以私信我，我发给你。
谢赞
介绍一下郝斌老师的四套课程吧，分别是java，c语言，数据结构和算法，数据库，四套课程都是基础课程，讲课的风格跟聊天差不多，合适入门，虽然我觉得这套教程不是最好的的，但是我觉得聊天讲课的方式不枯燥，也不是那种念ppt的讲课形式，我
计算机入门
就是这四套视频教程，非常感谢
郝斌
老师。
关于版权，郝斌老师在课程中就已经声明，课程可以在非商业的情况下自由传播。
视频不是我上传的，估计也不是郝斌老师上传的，我第一次看的时候应该是2013年。
数据结构 
https://www.
bilibili.com/video/av61
59200
java语言  
https://www.
bilibili.com/video/av30
421591
C语言 
https://www.
bilibili.com/video/av80
74534
数据库
https://www.
bilibili.com/video/av17
863069
最后，看视频学习效率低一些，不过如果一开始就看书的话对于零基础的同学们会很困难，我一开始也是看书，一本think  in java 到现在没看完，入门可以看视频，有基础以后建议看书学习。","作为一个985CS专业，毕业拿到多个BAT Offer，最终加入腾讯的师兄，必须强答一波了。
先说结论：你目前的状态挺正常。
千万别听信一些题主的回答，什么真有点完蛋、什么快没救了。。
完全是为了高赞危言耸听、骇人听闻，这样做真的好吗，作为过来人耽误了后辈，责任你们担负得起吗？
大二看不懂数据结构和组成原理很正常，原因可能是没认真学、又或者大一的基础太差。我大一大二玩了两年，大三都没写过一行代码。。依然通过大三一年的强行冲刺，考上华科研究生，毕业加入大厂。
关于大学期间如何学习，毕业才能冲击BAT的offer？可以看看我的这个1000赞回答，包括了生活和专业学习的建议：
接下来重点说下我自己的经历吧，希望对题主和大家有所启发：
大一刚入学，因为追一个女孩惨遭拒绝，这之后开始自暴自弃，长期混迹于网吧，甚至有一次住网吧长达17天。放荡到什么程度呢？曾经玩星际争霸，连续刷了几百局，整个过程就吃泡面馒头，喝点白水。
玩到大三，突然有一天学校发给我一张：开除警告书。
看着这张死缓通知书，这个结局我并不意外，长期翘课、挂科无数。那时候水到计算机专业大三了，连一个HelloWorld都不会写。
本科就读的大学坐落在一座山中，那一天上山再下山，不断往返，完全感知不到时间的流逝。整整走了一个白昼，累得精疲力尽，瘫坐在草丛之中，看着深邃的天空和地上的花朵。
那一瞬间我突然做了一个改变自己一生的决定：与其成为游戏的消费者，不如做游戏的创造者。
于是我定下里加入游戏行业的目标。因为大学前两年全荒废了，所以大三是冲击的一年。
大三我先后学习了C语言、数据结构和算法，同时补习数
计算机组成原理
、计算机网络这些核心课程。之后我考入华科CS专业攻读研究生。
大三还养成了一个习惯：疯狂刷算法题，成为了一个算法做题家，这个习惯一直延续到研究生毕业。
另外，程序员要想进大厂先从刷算法做起是个好方法，算法厉害的人进大厂非常容易，这里给学弟学妹们送一本阿里P8撰写的算法刷题笔记，身边不少朋友通过它加入大厂：
此外，还学了一门影响我职业生涯的语言： C++。
学习C++是从大三开始，大四和研究生两年也都一直在系统性的学习。
看的第一本书就是：《
C++ Primer
》，可以说上面的每一个例子，都上机造过轮子。
随后开始啃
《Effective C++》、《More Effective C++》、《
C++程序设计原理
》、《深度探索C++对象模型》、《STL源码剖析》、《
计算机网络系统方法
》、《TCP/IP详解》。
除了疯狂自学，毕业的压力也很重，
但掌握的东西越多，你对未来就越笃定。
疯狂学习的过程是枯燥且伴随痛苦的，编译报各种不通过的时候让人无比抓狂，知识点学不会的时候会让你怀疑自己的智商。
曾经看过的一部分书籍：
掌握了C++之后，我还用它做了不少有趣的东西，比如：万年历、五子棋、俄罗斯方块等等，俗话说兴趣是最好的老师，建议大家在学习编码的过程中也不妨挖掘出一些有趣的东西：
我写的五子棋程序：
俄罗斯方块：
这个就稍微复杂点了，当时用了mfc
虽然简陋，但这种训练给我的编码能力带来了极大提升，还训练了程序思维。
读研期间，不仅C++开发能力突飞猛进，同时还一直在训练算法能力，曾经在北大ACM网站上疯狂刷题：
请原谅我当时年幼无知之下取的账户名
《
算法导论
》这本巨作也被我反复翻看，反复实践：
曾经的算法小抄笔记：
还记得当年为了更快的进步，跑去蹭研究生的课程，听到NP难问题不由感叹：算法世界太奇妙了。
读研期间，计算机基础+C++语言+算法，这三个都被我一一攻克，这也是我毕业就加入腾讯的硬核技能。
在我那个时代，线上资源并不丰富甚至是匮乏！今天各种论坛、公开课、学习资料非常丰富。
核心就是计算机底层 + 通过反复造轮子的方法学习计算机基础课，主要要攻克三个方向（攻克了会让你如虎添翼）。
最后真心想说一句：千淘万漉虽辛苦吹尽狂沙始到金。
程序员这个行业不轻松，甚至可以说是很艰难，但大家只要做到：静下心来多看书、多看源码、多上机，一定能不断高速进步！
最后，这本算法笔记再次推荐！算法真的是重中之重：
看看这本书的目录和排版！相当经典！
祝大家前程似锦，在编码的道路上一马平川。
要是觉得不错的话，那就帮我
@findyi
点个赞，一键三连呗，硬核码字不容易，笔芯～","想学明白这些，说真的
1.我建议你把所有的教科书扔了去，在我看来中国的这些垃圾教科书除了给你植入一堆庞杂的概念让你云里雾里不知所云之外，并无太大用处，真正好的书不是这样的，一点兴趣的引导都没有上来先瞎死你让你无形烦躁再说。
2.我建立你上课千万不要听讲，因为我觉得大部分学校的老师(少数的不要对号入座)，读PPT，死讲是他们的基本功，兴趣引导？寻寻渐进？清晰明了？言简意赅？不好意思，不存在的，有时候我都不明白这些老师都是咋上到博士的，把一个本该很有意思的知识讲到你自闭。
那你要问了，我该怎么做？
强烈建议从最有兴趣的书看起来，数据结构和算法推荐《算法图解》《
啊哈算法
》来入门，我相信你要是知道这些东西这么有意思而且可以这么深入浅出的话，你根本不会再恐惧，当然这些肯定是不够的，你说看书无聊？看视频总不无聊了吧？云课堂，
mooc
上很多好课为什么不去听听呢？我个人非常喜欢
翁恺
老师的讲的课，还有浙江大学的《数据结构》，看完这些，动手实践起来啊？不会的，看博客，有的博客写的那叫一个拍案叫绝，所以真正让你恐惧的不是知识本身，而且那些吓唬你的老师或者教科书！
最后我想说，如果一旦你对一个东西感到恐惧了，千万别觉得这是你笨，这是放屁！我可以负责任的告诉你，你要给自己一个信念，这些东西根本就不难，顶多就算是个复杂！组成原理这种硬件课知晓大概的原理就行，没必要死磕到底，这东西死磕到底你就是折磨自己，除非是你要走这行非搞不可，否则就算你硬学了，过不了多久你肯定会忘。能让你记住的东西只有原理和思想！不要被一大堆的概念给搞的晕头转向，否则那是舍本逐末！","其实，数据结构并没有你想的那么难。
作为一个算法和数据结构的布道者，我一直致力于用最浅显易懂的方式，为大家分享数据结构的各种知识，希望大家能够真正理解数据结构，喜欢上数据结构。
首先自我介绍一下：
我是小灰，微信公众号【
程序员小灰】
的运营者，这是算法和数据结构领域的第一大公众号。
同时，我也是技术图书
《漫画算法》
的作者，在2019年上半年，《漫画算法》被评为京东最畅销的科技类新书。
许多程序员对算法和数据结构望而生畏，认为这是一项高深莫测的学问。
以前我曾经面试过一个小伙伴，起初考察他的技术功底和项目经验，他都回答得还不错。接下来我对他说：“OK，那我考察一下你的算法和数据结构水平吧。”
题目还没说出口，小伙伴立马摆摆手说：“不要不要，我算法不行的！”
我还是有些不甘心，接着说道：“我只考察最最基础的，你说说冒泡排序的基本思路吧？”
小伙伴仍旧说：“我不知道，我算法一点都不会.....”.
算法和数据结构真的有那么难，真的有那么无趣吗？
恰恰相反，算法是编程领域最有意思的一块内容，也并没有许多人想象的那样难以驾驭。
许多人把算法比作是程序员的“内功”，但小灰觉得这个比喻并不是很恰当。内功实实在在，没有任何巧妙可言，而算法天马行空，千变万化，就像是金庸笔下令狐冲的一套
。
学习算法，我们不需要去死记硬背那些个冗长复杂的背景知识、底层原理、指令语法......我们所需要的只有对算法思想的领悟、对空间和性能的理解、开动脑筋去寻求最佳的解决方案。相比编程领域的其他技术，算法更纯粹，更接近数学，也更具有趣味性。
我一直希望写出一些东西，让更多的IT同行们能够领略到算法的魅力，可是用什么方式来写呢？
2016年9月，一次突如其来的灵感，让我创造了一个初出茅庐的菜鸟程序员形象，这个菜鸟程序员名叫小灰。
程序员小灰的故事活跃在微信公众号上，用漫画的形式诉说着他的一次又一次面试经历，倔强的小灰屡战屡败，屡败屡战。小灰是我本人刚刚入行时的真实写照，相信许多程序员小伙伴们也能从中看到自己的影子。
以下是几篇具有代表性的漫画：
今后，小灰还会努力创作更多更精彩的作品，让数据结构和算法不再枯燥乏味！
如果你觉得这个回答对你有用，希望帮忙点个赞，让更多的朋友看到它。
也欢迎关注公众号 【程序员小灰】，里面有更多精彩的内容等着你。","同大二，计组亲妈爆炸
你看，一堆一堆的人教你怎么学数据结构
为啥？写代码有意思呗欺软怕硬呗数据结构真的不难呗
真正头疼的是计组啊少女，你看有几个人提到过计组？为啥？他们也不会咯。
偶尔几个提到的无非大略告诉你计算机从底层开始怎么工作，这都屁话你都工作多少年了我比你懂多多了，我知道从电路到模电到数电到CPU到操作系统再到编译链接怎么运行能给你讲得头头是道，我还拿Verilog写过单周期多周期流水线呢，有用？考试就考边边角角概念我他妈就是记不住不想记不行？
以上是喷人的。数据结构那么多人都给你建议了我就不多说了，建议看
邓俊辉
老师的mooc，连我这种完全看不下网课的人都能刷差不多，参考另一个回答
链接
。
至于计组，学学就行了，至少得知道怎么从c到汇编到机器码，CPU怎么解析机器码，取指译码执行访存写回经典五级流水，单周期多周期流水线大概什么流程，再学点cache，这些东西有助于写程序帮助理解底层，还有虚存页表，操作系统要用，考试要么刷题要么听天由命。
@周环
 
这个回答
有点参考性，大概我上面说的东西学学，将来还可能有点用，另外一些边边角角没用玩意混过考试就行。
然后容我再喷一遍傻逼计组你他妈是想我背完这六七百页的书就直说傻逼玩意考尼玛。
最后，以上均为没有逻辑的屁话。
－－－－－1月25更新－－－－－
出分了，平时分给满的浓浓师生情正好90","    遇到这个问题，首先排查是老师没教好还是自己不适合这个专业，数据结构确实抽象，我所认识学这门课的班级，一个班能有两个照着书本实现链表程序，就已经很不错了，很多同学连指针是什么都不知道，依然过的逍遥自在，考试准备一下，及格就行。
  不过听你的意思想死磕到底，既然想学好，我觉得有必要分享一下，作为一个非CS专业的物理学转电子行业恰好路过计算机学科过来传授一下不靠谱的经验
  我们班虽然也学C语言 ，但浅尝辄止，老师教完for循环基本上学期就结束了，指针什么的考试也不考，大二的时候，我还没意识到自己想要做什么，C语言69分飘过，每日懒懒散散的，但是。。但是  随着我在实验室呆的时间够长，自己会的简单的C语言已经满足不了我日益壮大的需求了，百度个宏编译，百度一下结构体貌似也还行，解决了一些基础问题，但是，别人的开源程序里好多指针怎么办啊，看着百度给的答案基本上要崩溃，爆炸，心情一度down到谷底，感觉这么简单的程序也看不懂真够衰，宛若一个智障，还不如好好学物理当个老师吧，自己真的不适合这一行
   但是，内心的斗争总会有个头，最终我选择了CS，我仔细分析了一下计算机学科的专业课程，发现有四大基石，数据结构，组成原理，操作系统与计算机网络，我不知道哪来的自信，坚信学完这四门课，从此人生将会得到升华，想法变成了行动，甚至决心跨考CS的研究生(学之前)，我问电子专业借了(要了)相关的书以及自己买了点资料，自学第一周的时候真是要每日爆炸，最简单的链表一直没有运行起来，不是烫就是程序已停止运行，那时候完全没有编译原理的思想。
  为了折中，我想了一个周全的办法，大三的时候，数据结构还是要学的，并坚信这也将成为我以后的知识根基，我继续看后面的内容，只看自己能看懂的东西，队列，栈和二叉树，这些设定都很有意思，和生活中的一些情况也很像，不写程序还有点喜欢这门课，同时我也有一个致命障碍，
一指禅
，简直不能忍，看书看累的时候，就系统的练一下指法，一度上瘾，一周就可以不看键盘，三周实现每分198个字母，顺便练了五笔，现在更喜欢用双拼。手法跟得上，敲代码无压力，没人带飞，再次尝试时，我还是没能实现链表，我可是都学了一遍数据结构了呀，到这个时候再次想放弃，但是觉得还能再救一波
  我想那些厉害的大学，学的东西应该都一样吧，于是歪打误撞报了mooc上陈越姥姥的数据结构，不报不知道，简直爱上了这个老师，讲课通俗易懂，深入浅出，知道我不擅长用指针，实现队列竟然用数组，然后我只是按照她的思想，就用数组实现了队列与栈，第一次让我感觉自己在这方面有天赋，随着后面的课程进行，渐渐对指针的深入了解，指针式的图算法也能轻松看懂实现，  从此感觉换了一个人，与此同时，其他三门课也在同时学习，不能说自己学的多优秀，但是很有成就感，至少能看懂大部分开源代码了，思路清晰，而后也意识到文档，框架设计，重构的重要性，又学了软件工程。
    大四伊始，别的小朋友都去考教师，考公务员，找工作了，我还在天天愁着这不会那也不会，后来发现是我多虑了，找了第一份工作直接坦诚说没有工作经验，还好技术主管问了我一个数组越界的问题，然后拿了6k的薪水，干了6个月，主要工作是打杂，做硬件电路，焊接，采购，提交设计文档，工作期间没有给公司写过一行程序，有一段时间加班回去好累也不看书了，但是后来决定还是要走的，这样下去会废掉的，于是又复习了一下数据结构，准备换工作，面了好几家都拿到了offer，在第二家公司主要写程序，直接挑战了我的极限，嵌入式操作系统对内存使用很严格，有点DS与操作系统的底子直接刚，什么
消息队列
，秒懂秒用，很快融入新工作，慢慢的，老板注意到我了，四大根基在这时候起了很大的作用，和老板聊天各种吹，后来也开始面试新人了
  来面试的小朋友，失望了一次又一次，很多人把工作简历写的很厚，随便两个基本问题就问倒了，数据结构不会已经没关系了，面试了10个 ， 只有两个会指针的，还不愿意来，有些三五年工作经验简直更是不能忍，一度怀疑HR是不是闭上眼筛选的简历，或者  很多人不把这四门课程作为顶梁柱了吧  但是我相信他们以后一定会吃亏的","这有啥好心态爆炸的，必须有救啊！
刚开始的时候看不懂，不是很正常嘛，哪有一上来就看懂的。
再说敲不出代码，你看都看不懂，你能敲出个锤子来。
其实说实话，对于
数据结构和组成原理
这种计算机基础课，只要你不是在大学混日子的，就肯定能学会。
如果你学不会，那就是学习的方式方法不对。
没有学不会的计算机基础课，如果学不会，那就是姿势不对。
说下背景：本科二本，ACM 金牌选手，今年刚从某 985 软工毕业。
下面来说下我总结的数据结构和组成原理的学习路线吧，相信肯定会对你有所帮助，
记得帮我 
@Rocky0429
点赞呀！
一、数据结构
关于数据结构与算法的学习我从以下
四个方面
来讲：
什么是数据结构？
数据结构怎么学？
可视化动画带你理解数据结构
实战
1.什么是数据结构
程序 = 数据结构 + 算法。
数据结构经常与算法放在一起，这就造成很多同学懵圈，有些同学认为这就是一种。
其实
数据结构主要讲解数据的组织形式。
就是我们要怎样把这些数据存储起来，所以有数组、链表、栈、队列、树、图，这是数据结构的重点。
数据结构，不管你怎么想，一定要认真学！不管面试还是考研都是必考！
学习数据结构与算法的第一课，我永远都选复杂度分析，在我看来，这是
数据结构与算法
中最重要的知识点，且不接受任何反驳。
复杂度分析主要包括以下两个：
时间复杂度
空间复杂度
时间复杂度，也就是指算法的运行时间
。
对于某一问题的不同解决算法，运行时间越短算法效率越高，相反，运行时间越长，算法效率越低。
空间复杂度反映的也是一种趋势，
只不过这种趋势是代码运行过程中临时变量占用的内存空间。
强烈推荐阅读下面这篇文章，看完保证会！
2.数据结构怎么学
数据结构内容
离开了数据结构，几乎任何的程序都会失效。
要单纯的掌握常见的数据结构，就如同拆解一个个精妙的仪器件一样有趣和简单。
数据结构重要的主要是下面这几个：
数组（Array）
链表（Linked List）
栈（Stack）
队列（Queue）
散列表（Hash table）
堆（Heap）
树（Tree）
图（Graph）
不同数据结构有着不同的特性，因此
想要学好数据结构，图解是必备武器
。
而我最近就在做这件事，
有趣有味的方式，学习有价值的编程知识。
比如
数组
的文章：
蛋蛋惨遭数组滑铁卢，面试官建议回村养猪。
其中对数组操作：
比如
链表
的文章：
链表，画几下就整明白了！
对链表的操作：
比如
栈和队列
的文章：
呔！“栈”住，队列！
对栈和队列的操作：
数据结构书籍推荐
《大话数据结构》、《
数据结构与算法分析
》
《大话数据结构》这本书与市场上的同类数据结构图书相比，内容更加趣味易读，算法讲解细致深刻。
是一本非常适合自学的读物。
这本书通篇以一种趣味方式来叙述，大量引用了各种各样的生活知识来类比，并充分运用图形语言来体现抽象内容，对数据结构所涉及到的一些经典算法做到逐行分析、多算法比较。
如果你还是看不懂，可以看我写的图解，不过有点慢，但是绝对通俗易懂：
复杂度分析：
保姆级教学！彻底学会时间复杂度和空间复杂度
数组：
蛋蛋惨遭数组滑铁卢，面试官建议回村养猪。
链表：
链表，画几下就整明白了！
栈和队列：
呔！“栈”住，队列！
字符串：
关于字符串，你知道这些么？
书籍地址：
视频教程推荐
《数据结构》，浙大
陈越
和何钦铭教授联合授课，其大名在计算机领域可谓耳熟能详了。
链接：
数据结构_浙江大学_中国大学MOOC(慕课)
3.可视化动画带你理解数据结构
可视化的动画真的对我们理解数据结构和算法非常有帮助。
尤其是在学习之初，堪称很好的防劝退工具，所以我对这些做了一些整理，希望能帮助到你。
数据结构在线模拟器
这个在线的模拟器包含“栈”、“队列”、“堆”、“BST” 等数据结构，每个数据结构以图像的方式展示在我们面前，同时又有各自的帮助文档，可以用鼠标对数据节点进行拖拽，还可以实现各种数据结构的增删改查。
还有一点好的是，这个网站还伴随着一些数据结构的教学材料、简要的复杂度分析、数据结构使用实例，对于理解各种数据结构的原理及运用可以说是相当丝滑了…
网址：
https://
iacj.github.io/react-da
tastructer/#/
VisuAlgo
VisuAlgo 可以说是知名度比较高的一个通过动画学习算法和数据结构的网站了，它最初的建立就是通过可视化让学生更好的理解数据结构和算法。
VisuAlgo 的功能更丰富，它包含了很多的数据结构和算法，从简单的到复杂的都一一包含，而且对于一些新出现的算法也有涉猎，通过可视化动画的方法，帮助我们更轻松透彻的理解算法及原理，尤其是对一些通过文字描述很难理解的算法而言，简直是生命之光。
VisuAlgo 还支持搜索和多种语言的切换，英语不好的同学可以切换成中文，但是现在有一些算法中文翻译的并不全，所以如果能看英文的话还是建议看英文的。
网址：
https://
visualgo.net/zh
4.实战
数据结构与算法的学习，往往要伴随着“刷题”，如果没特殊情况，我建议大家刷 LeetCode 就好。
刷题按照分类来刷，如果不知道刷哪几道题，可以看下这个前字节大佬的刷题笔记：
针对 LeetCode，题的解法有很多，我们往往追求的是最优解，这里有一份清华学长整理的 LeetCode 最优解，强烈推荐：
我在大学的时候参加 ACM，拿过亚洲区预赛银奖，刷题贯穿了我的整个大学生涯，总结了一些刷题的经验，感兴趣的可以看下。
顺便来分享下自己总结的【
LeetCode 刷题顺序
】，希望能帮助大家少走一些弯路。
这份清单我会一直更新，同样也会一步步的把
每个知识点的入门讲解
和
每道题的题解
用“图解”的方式分享给大家。
站在初学者的角度，
用最直白的方式和最易懂的代码，最大可能摒除不同编程语言的带来的干扰
，理论 + 实战，带你彻底搞定数据结构与算法。
下面就是我为大家精心挑选的 LeetCode 题目清单，
按照知识点进行分类
，大家可以根据知识点，有针对性地刷题。
二、计算机组成原理
计算机组成原理，即“计算机”“组成”的“原理”。
我觉得它是所有计算机基础课程中最难学的一门课，整个课程的核心就是使用数字逻辑电路和触发器搭建一个可以运行汇编指令的机器。
1.书籍推荐
《
计算机是怎样跑起来的
》、《
程序是怎样跑起来的
》
正是因为计算机组成原理难学，所以对于初学者来说，比起其他几门，这门课的入门书籍选择就更得友好。
《
计算机是怎么样跑起来
》和《程序是怎么跑起来的》，这是两本很薄，作者用大白话的方式来阐述知识，图文并茂，对初学者来说相当 nice。
相比学习的心态，更多是带着好奇心的心态去读。
《计算机是怎样跑起来的》
本书倡导在计算机迅速发展、技术不断革新的今天，回归到计算机的基础知识上。通过探究计算机的本质，提升工程师对计算机的兴趣，在面对复杂的最新技术时，能够迅速掌握其要点并灵活运用。
《程序是怎么跑起来的》
本书从计算机的内部结构开始讲起，以图配文的形式详细讲解了二进制、内存、数据压缩、源文件和可执行文件、操作系统和应用程序的关系、汇编语言、硬件控制方法等内容，目的是让读者了解从用户双击程序图标到程序开始运行之间到底发生了什么。
书籍地址：
2.视频推荐
视频首推
卡内基梅隆大学
的《深入理解计算机系统》系列课程，英语不好？没关系，有中英文字幕，看完这套视频，知识＋六级顺利拿到手。
链接：
【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频_哔哩哔哩_bilibili
看这个视频的配套教材是《深入理解计算机系统》。
此外，国内的可以看下哈工大刘宏伟老师的课程（135讲）
链接：
计算机组成原理（哈工大刘宏伟）135讲（全）高清_哔哩哔哩_bilibili
希望对你有所帮助
关于题主现在的情况，相信我下面的回答也会对你有所帮助：
码字不易，如果觉得不错，记得帮我 
@Rocky0429
 点个赞呀。","我是软件工程大三的学生，同女生，大二上学期修了数据结构，下学期修了组成原理
而且我是转专业来软工的，还要补修大一的课程，课多到爆炸，上学期学数据结构的时候还没搞懂C语言指针，数据结构学的一塌糊涂（这学期重修了），大二开了一门数据结构课程设计，具体内容就是老师带着我们做ACM和PAT的题，一开始也觉得很难，但是坚持下来就觉得越来越轻松，之前完全不理解的东西慢慢都明白了
如果题主在C语言上有短板的话建议先补C语言，然后多做做题，很多问题都可以解决
然后是
计算机组成原理
，这门课我是混过考试了（八十来分还凑活吧，我是学渣），在学组成原理之前我没学过电路相关的东西，并且这个老师说话声音小还吞音，一节课下来都听不清balabala在说啥，很痛苦，而且这学期因为要补修大一下的课，我一共选了十门课_(:з」∠)_所以我做出了一个大胆的决定，这门课直接放弃治疗，课也不去上了，匀出时间来搞定剩下的九门，然后最后一节课老师画重点的时候去听，按着老师给的重点结合之前布置的作业题，考前一周死磕，把作业题都搞懂考试就八九不离十了
至于现在，当然是和没学过一样_(:з」∠)_
如果想混过考试，大可不必紧张...如果题主是好学生的话，还是不要像我学习了_(:з」∠)_","其实……我觉得……大二学到数据结构看不懂……确实是……有点没救……
 
之前我认识的连数据结构都学不会的同学，现在已经转行做产品了orz
不过有一说一！算法难学是很多刚入门码农们的共识，觉得难啃，在我看来原因有二 
 
1、算法本身就很难，这东西对于人类本身来说就是学起来费劲！ 
2、学习方法有问题，又或者老师讲的太烂！ 
说实话，即使你把算法啃完了也未必有用，因为除了面试，实际工作中都是使用现成的模块，所以一般只需要了解算法的目的和时空复杂度，再刷刷题就足够。 
所以，不要给自己太大压力！！
 
下面根据题主的情况，我搭建了一条学习路径，一起来看下吧： 
一句话总结就是：数学基础，算法基础，编程能力，项目实战。
 
算法基础和编程能力靠啥提高  
很多人觉得算法难，大多都是在背算法（包括我）就跟背菜谱一样。但算法和菜谱的区别在于，算法的问题变化莫测。如果你啃过算法书应该会有同感，明明当时理解了的证明，为什么过段时间就忘了呢。 
所以我更推荐丢掉课本，通过项目实操的形式学算法。 
这里推荐一些可视化提升算法的学习网站： 
Data Structure Visualization
 
一个
数据可视化
和算法可视化的网站，用它可以生成各种各样的数据结构，模拟它们添加和删除的过程，而且还可以用它来演示算法的执行过程。 
Tutorialspoint
 
我朋友推荐给我的，也看到知乎里有不少人推这个网站。可以说这是一个资源丰富的在线学习的网站，可以学到的语言不仅限于通用的编程语言。
九章算法
 
北美硅谷程序员创办的程序员编程学习平台，面向国内及海外的程序员用户。课程分类清晰，
前后端、大数据、AI
等都有覆盖，全中文授课，口碑和质量都非常不错。 
对于基础薄弱的同学推荐
《算法基础班》
，用Java+Python双语言授课，从编程基础知识讲起，手把手教coding；对于想精进的同学推荐
《九章算法班》
，九章的王牌课程，由FB架构师
令狐冲
讲解，让你对编程和刷题有全新的理解。 
这个网站还超有底气的开了
免费试听
，感兴趣的朋友可以先
白嫖两章
。 
掌握了算法技术后怎么准备算法面试 
简单来说就是三句话
：边看学习视频，边敲代码，边做题练习。
 
这个过程中你需要思考为什么，而不是单纯的刷题敲代码背答案，这样在面试中的表现才会更好。 
这里分享北大学长整理好的
大厂面试常考知识点及考察频率
 感兴趣的也可以移步 
《九章算法班》
学习更多应试小技巧。 
①字符串处理：
考得很多，主要注重代码实现能力，算法上没有太多难点，通常是处理麻烦。 
②
双指针算法
：
高频算法之王，变形特别多，算法不算特别难，但能快速想到和写好不容易。 
③
二分法：
考察频率中等，能写好写对不容易，二分答案的问题甚至很难想到算法，要背模板。 
④
分治法：
考察频率中等，一般和二叉树一起出现和考察，题一般不难。 
⑤
动态规划：
国内大厂基本都考、北美主要是G/F喜欢考，其他公司考得比较少。 
⑥
拓扑排序算法
：
考察频率中等、但每个公司基本都有一个这个算法的题。 
⑦
链表：
中小公司考得多，大公司近年来考得少，题目一般不难，主要考察reference。 
⑧
堆：
高频，经常会用到，原理必须掌握，但不用掌握代码实现，应用必须掌握代码。 
⑨
树状数组
：
不太考，与其学这个不如学线段树。 
⑩
红黑树
：
只有G可能会问到，也只是问大致原理，能干啥，Java会用TreeMap就行。 
面试该如何刷题？ 
按公司面试难度刷题：
 
①像是
字节、美团、Google、微软
这类竞争激烈的公司，必须要刷难题。算法考察范围很广，特别喜欢DP和红黑树 Red-black Tree，线段树 Segment Tree。 
②其他一线大厂，比如
腾讯、阿里、Facebook
刷中等题就够了。 
③其他中小厂，比如
搜狗、爱奇艺、
蘑菇街
，
刷中等题就够了，算法面试考察范围很窄，Binary Tree, LinkedList, String, Array 这些基本数据结构相关的题掌握即可。 
按岗位面试难度刷题：
 
不同的岗位算法面试难度不同，
越后端越难，越前端越简单
。 
难度排序（从易到难）： 
Data Scientist / Data Analyst / Data Engineer 
Web Frontend Engineer / Mobile Engineer 
Software Development Engineer 
Product Engineer 
Infrastructure Engineer / Software Reliability Engineer 
Machine Learning Engineer 
顺便分享一个非常小众的刷题网站 
LintCode
 
内含算法，系统设计，数据库，并行计算，大数据，linux命令行，git命令行等。
非常适合快速巩固算法，我当时就是为了快速通过算法面试才发现了这个宝藏软件。里面的题集划分的非常细致，感兴趣的可以自己体验一下。 
对于基础薄弱的编程小白来说，还可以来尝试
【新手必刷编程50题】
，从基本数据类型、判断语句、数组与循环等方面讲起，从
最简单最基础
的题刷起，逐步找到对编程的兴趣，上线至今已收到了不少好评。 
对于正在备战大厂算法面试的朋友，也可以来
LintCode
体验我刚上线的
【企业题库】
，汇集了
字节、腾讯、阿里、谷歌、FB
等头部大厂的面试高频题，突击算法面试。  
好啦，以上就是我的分享，如果对你有帮助的话，就给我点个赞吧！ ","你并不是看不懂敲不出代码，你只是不愿意下狠功夫拼命学。
请问你到底有没有认认真真地学过一遍？！如果没有，请你先认真踏实地把每一个字每一句话每一行代码认真地看一遍！如果还是不懂，回去再看，看10遍之后，当那些概念那些推导过程在你脑子毫无违和感，你想不懂都难。实在静不下心看不下去，就读10遍，不想读就抄，抄简单吧，抄10遍，你不可能不会的。
别笑我迂腐，别嘲笑这个方法蠢，有多少人能够做到这个程度DD把一个陌生的待学习的新事物重复10遍？！做到这个的，想不掌握都难！
我们都想成为很厉害很厉害的人，但是，大部分人都做不到。不是因为方法不对，方法不对，这句话很多情况下，只是懒惰人的一个借口。不懂怎么下手？网上到处都是大神的经验谈，你可以去查！
学不会，好难等等这些全都是借口，是你逃避的挡箭牌。
很多人缺的不是方法，而是行动，是日复一日地重复练习自己想要掌握的技能的自我约束的能力。
别问我怎样获得这种能力，你不自救，谁也救不了你。
不要抱怨了，踏踏实实去做你该做的事，一点一滴地积累，才能有量变，才能有质变。
唯有行动，才有希望；
行动之外，再无希望。","希望我做的这十张图能让你看懂十大经典排序：）
在公众号 五分钟学算法 内回复 github 可获取这十大经典排序所有超清慢动画：）","你好，首先冷静，不要慌张，大家都是这么过来的，我当初接触编程的时候，
t
 
=
 
a
;


a
 
=
 
b
;


b
 
=
 
t
;


就这3行代码我还愣住了，怎么就互换了？
现在想想不是显而易见的，有什么好思考的。
我当初在学校从大一开始做ACM，数据结构还没学，那时候就是看问题，想，用极其粗糙的办法去解决问题。
实在不行就看看别人的代码，慢慢就死磕过去了，后来开始学数据结构，稍微翻了一下就明白了，感觉没什么意思。只不过可惜没有早点看到这个，当初学得不够系统。
你现在就在我当初死磕的阶段，人刚开始接触新事物的时候，自然是有适应期的，这段时间，熬住，过了就好了，回头来看不过如此。
好了，理论说完了，给你讲讲方法。
我觉得数据结构初学者最重要的是 
可视化 
，把各种队列，树，图，增删改的时候状态的变化画出来。
比如，一颗树，1，2，3，4，5，6，7，8，9，10，这10个数，一个个加到树里面，每加一个，树变成什么样了，都一步步画出来。
加完了删，每删一个，变成什么样了，一步步画出来。
加一个删一个，一步步画出来。
这一套下来，树就基本理清了，画好的画，多看看，记在脑子里，以后代码忘记了，想想怎么画的，自然就会写了。
最后推荐一本书，<
啊哈!算法>
 
当初做ACM相见恨晚的一本书，把一些算法和数据结构都可视化了，非常容易理解。
希望有帮助~~"
,,,,,,,,,,,,,,,,,,,,,
程序员看剧的时候，如果看到有敲代码页面，会暂停看代码吗？,"今天在看剧的时候，突然有个疑问，因为现在的很多电视剧经常会有敲代码的页面出现，就想问下各位程序员大佬们，会在这个片段暂停看代码么？然后判断是真的还是假的之类的？代码对不对之类的？或者不深究对错，就看下这段代码啥意思？要做什么？
【不要凶～大家就友善交流自己的看法哦⊙⊙】
上图是《庭外》第03集  00:36:18以及00:36:22、00:36:51、00:36:53的代码页面截图，目的是要伪装一个网页～","为了回答这个问题，我翻了过去好几年的qq空间和
pyq
，终于找到这三张截图了。
编剧视角的程序员是用word写代码的。放弃吧，写不写得出来，公司都要完了。","必然看啊，这是以前看报纸时留下的习惯。
网友评论：
护士在那里满脸笑容的接电话 ，可是你倒是把电话线接上啊？！","战狼1中
龙小云
的入侵病毒的源代码。
一共包括5段功能代码。
第一段是输出
斐波那契数列
的前20项。
第二段是找100到200之间的所有质数。
第三段是找100到999之间的所有
水仙花数
。
第四段是通过键盘输入一个整数并找出其所有因数。
第五段是根据键盘输入的分数评出ABC等级。
通过以上几段残缺不全的代码，成功入侵红军指挥系统，并导致对方系统瘫痪。
没想到大家对这个话题这么感兴趣！一个礼拜之内浏览量30w+，获赞居然上了3k。
不胜惶恐。感谢各位！
找到一张图片，
《独立日》
中的。看起来像是往外星人的mother ship传送病毒的脚本源代码。","以前看过一个段子，讲的是一个计算机大牛给一部剧集模拟一个蠕虫病毒入侵的场景。
这个大牛就写了个病毒，结果导演说就这？
最终剧集上映的时候，展现蠕虫病毒入侵的画面是：显示器放一段蠕虫在那爬来爬去的Flash……
这大牛回来说千万别说是他写的……","程序员不知道。
但是作为一个学物理的，第一次看到群友发出下面这个图的时候，仔细看了看黑板上求解氢原子
薛定谔方程
的过程（角动量算符，分离变量等等）有没有问题，然后心满意足地关闭了图片。
（前面的女人挡住我看公式了，可恶！）","额，看过很多代码，可以说没有几个是能看的。
之前看
《微微一笑很倾城》
的时候，主角的代码都是用QQ影音直接播放的。
最近看的《天才基本法》里面的代码是真的找了一段相关的代码在那里，这个应该是最认真的了。","2023.11.10更新，孤注一掷电影中，黑同事演讲直播，用的是
sqlmap
。注出web管理员密码，然后登录视频放映的后台。也非常贴合真实攻击场景。
后面黑掉小头目手机的场景其实不太现实，黑手机的方法主要靠钓鱼，而小头目后面剧情有准备，所以不太可能中钓鱼。
如果是0 click黑手机，借助第三方软件漏洞才比较容易，不依赖第三方软件太难了，和前面的sqlmap完全不是一个级别。
所以不如黑航空网站比较现实(PS:2018年未经过几轮hw的航空公司真的很简单)。
黑客帝国2中的一个镜头，是非常贴合真实攻击场景的命令行片段。
手机打字，所以在B站找的截图，注意存在中文字幕和弹幕。
第一个镜头22/tcp这段，是经典的
nmap
扫描之后的开放端口截图。
sshnuke 10.2.2.2 -rootpw=xxx
这段是使用sshnuke这个攻击程序，攻击了10.2.2.2服务器，将root账户的密码重置为xxx。
而sshnuke，是sshv1 crc32整数溢出漏洞的攻击程序。这是一个真实存在且流行过的漏洞，通过溢出可以直接反弹shell，或者像电影中一样修改ssh密码。
ssh 10.2.2.2 -l root
此时已经完成密码篡改，所以可以直接以root用户登录ssh。
到这里，就是一个不复杂但很标准的渗透流程，收集信息――发现漏洞――利用漏洞――拿到shell。
在第二个镜头中，存在多个窗口。除了第四层的窗口（最外层）是第一个镜头中出现的窗口，其他窗口分别如下。
第一层（最里层）窗口，攻击机的本地登录。
第二层窗口，sshnuke程序的汇编代码。对于溢出类漏洞，实时调试和分析非常正常。
第三层窗口，另外一个更多扫描结果的nmap截图。
依旧非常符合真实的渗透流程。
随后便是用获取到的shell关闭电力程序，这个肯定是假的，但做的也非常逼真。","影视剧里面程序员写代码的时候，像打字员一样噼里啪啦一顿输出。一看就知道是扯淡。
现实里面程序员一天写不了几行代码。写几行停下来查bug，网络上搜bug解决办法。",翻出来了一张N多年前自己发的朋友圈。。。,"曾经有个剧，一个“程序员” 用word写代码。
我暂停个锤子啊","看过一部国产剧，网警A在跟黑客聊QQ，网警B要求A尽可能拖延时间好让他追踪黑客的IP地址。
你是不是觉得这样很辣眼？Naive！
... ... ...
网警B在cmd窗口里狂敲了一堆乱码之后叹气 ―― 糟了！他用的是无线网络，没有IP地址！",,"奋斗者的
线段树
打错了","不是程序员，会点ps前两天刷抖音刷到一个视频，妈妈把儿子几年心血画的毕业作品毁了
如图所示
会ps的都沉默了...","会啊，
何同学","还真注意过。
1998 年的日本动漫《
Serial Experiments: Lain
（玲音）》，一部充满了抽象艺术手法和超前理念的科幻动漫。其中三次出现了具体的代码。
第一集，老师上课一言不发地板书 C 语言，可以看出似乎就是入门级别的东西，只不过好像是用货币符号￥代替了转义的反斜杠，不知何故。
第一集
第四集，铃音开始深入“连线世界”，并且意识到“Knights”们的小动作。这个时候她已经开始小露身手了，毕竟不是每个初中女生都能在自家卧室里搭出一个集群……
第四集
这之后她的显示器上滚动了一段时间 
MIPS
 汇编代码，
第四集
第四集
上世纪八九十年代正是
精简指令集
（
RISC
）对以 x86 为代表的
复杂指令集
（CISC）发起冲击的时候。在动画播出的 1998 年， MIPS 指令集已经风靡了十多年，只不过后来日渐式微（被 Arm 干倒了），而继承 MIPS 正统衣钵的 RISC-V 指令集还要十多年之后才问世。
顺便说一句，动漫里的“Knights”这个黑客组织也不是虚构的，它的真实原型是一个半虚构组织：
λ演算骑士团
（
Lambda Calculus Knights
）。（我估摸就是个黑客和理论计算机爱好者的小团体 :-）
第七集，
玲音
在成神之路上越走越远（想描述一下剧情但是描述不出来……太意识流了 QWQ）。这集里有一段，她在课上没有认真听讲，而是在玩手机（？）
第七集
其实不能说是“手机”，而是类似于智能手机或者说
掌上电脑
的一个玩意，准确来说是“HandNavi” 即掌上 Knowledge Navigator，上世纪八九十年代的一种未来产品构想，原型大概是苹果公司于 1993 年发布的 
Apple Newton
。
那么玲音在“玩”什么呢？她在看 
Common Lisp 代码
……
第七集
第七集
我还是写过几句 Common Lisp 代码的，她第一个程序定义了一个叫 life 的递归函数，里面依稀可见还调用了 
make-world 函数
等等（逼格拉满）。第二个程序里定义了俩函数 environment-function 和 
environment-macro
，但似乎有 bug，因为注释里写着“这个似乎没用到”、“这个在 alpha 版本里能用，但现在出了问题……不太确定，我们得问问苹果的人”，看起来铃音大神在给别人 debug（笑）。
（最后铃音可郅い
神の微笑
神のどきどき",程序员甚至会在坐电梯的时候思考电梯的调度算法,"这截图来自《战狼》：
这截图来自《黑客帝国》：
＜战狼＞和＜黑客帝国＞入侵代码对比，《黑客帝国》这是一个TESO写的攻击ssh的exploit（就是真正的攻击代码，非常专业）；然而，《战狼》里面那一堆
printf
是什么鬼啊，这代码现在就一小学生水平。。。你们管这叫黑客？你们网络安全部队就这水平？能不能走点心？真不是我黑战狼，导演组真的是不用心。。。
大家加油，我的第一个破千赞就快到来了，感谢各位哥哥姐姐、弟弟妹妹、叔叔阿姨、叔叔婶婶～","当然，作为职业病，在看一些影视剧上的高科技镜头的时候，不免会想多看上两眼。其实这有时也造成了一些观影上的“出戏”，刚刚沉浸进去的剧情，结果被一些看着特别假的“高科技”镜头给逗笑了，然后还要在心理默默的告诫自己“专心剧情，专心剧情”。比如一些大的谍战片经常有黑客插上U盘，然后在命令行上煞有介事的敲一个命令，然后终端输出一堆文字。其实写过终端脚本的都看得出来那就是电影特效，其实背后什么都没有执行，单纯的终端输出一堆看着高深的字符而已。此时就很容易出戏，仿佛在看一个“跳大神”的在假装请神装神弄鬼一样。当然只要做的不那么假，我们也没有必要嘲笑，毕竟模拟也就只能这样了。真“实战”的场面看起来比电影要……无趣的多……
记得曾经在电脑上观看某部《终结者》电影的时候，电影里有一个天网调取T-800资料的画面，如下：
这个图粗看没什么问题，特别是画面最前面的明确显示着T-800的简要信息，仿佛就是在调取它的资料。但是当时电影画面可以清楚的看到后面的很多字符，暂停后仔细查看的话就比较搞笑了。后面那些字符其实和电影本身并没有什么关系，只是为了显得天网的高大上而随意显示出的一些文本信息。因为在大家的印象里，“黑底白字”一堆文本信息的画面就容易和黑客和高端计算机技术联想到一起。其实这地方应该把背景稍微虚化一点，这样直白的展示出来让从事计算机的人看到还是蛮尴尬的，容易出戏。
首先从上图（此图经过了压缩可能看不太清了，建议找到电影原片段观看）我们可以看到有一个打印当前内核版本号的命令以及其执行结果，可以看到电影中最厉害的天网竟然是使用的Linux-4.1.15版变种内核……就类似我这样做：
图片左右两侧大部分都是类似'ls -l'出来的普通文件信息，这些文件/目录基本上都属于root用户，且可以看出都是在当年12月19日下午16点左右被最后访问过的。就类似我这样：
图片中间那个窗口，T-800信息下面还可以清楚的看见一条iostat指令。
这个指令一般来自于Linux系统中sysstat这个软件包，比如我的系统当前执行iostat就是这样的：
$ iostat
Linux 6.1.0-rc3 (bogon) 	11/10/2022 	_x86_64_	(32 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           2.18    0.02    0.95    0.01    0.00   96.85

Device             tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               9.71       108.95        83.07    1894351    1444254
dm-0              3.57        86.14        15.86    1497759     275726
dm-1              0.00         0.13         0.00       2336          0
dm-2              6.41        21.63        70.68     376060    1228944
对比上图iostat的输出，就能看出基本是一致的。通过图中iostat的输出，我们可以看出当时最先进的人工智能、想要毁灭人类的天网系统，其空闲率高达99.23%。说明它根本没有使出全力来对付人类，仅仅使出了0.77%的能力，你说它是有多闲。连我现在写回答的这个电脑都比它忙差不多3个百分点 [手动滑稽]。
存储设备也只看到sda和sdb两块磁盘，其中的sdb显然还不怎么使用，sda用的较多，但是TPS也才7.55，连我笔记本的sda的TPS都9.71。这个天网CPU闲也就算了，IO也这么闲，这是对毁灭人类这个计划有多么不屑一顾。
sdb的平均读写速度和读写量都太弱，不值得说，我们还是以sda这个设备来说，总写入量看不全，但是总读出的数据量（你可以理解为累计的流量）才1357670665 Blk，这里的Blk一般是指512个字节，所以1357670665 Blk也就是才695GiB…… 试想一下，一个世界上最高端的人工智能机器，应该有多少的数据读写量才对，695G实在是有点太不够看了，随便一家互联网公司的随便一台服务器估计都比这个高吧。
当然了，以上内容纯属娱乐，抬杠的话也有很多可以抬的地方。我只是就着这个问题说一下搞计算机人看电影时的职业习惯罢了。当然，这些小地方并不太影响我的电影观感，我更注重剧情上的自圆其说，和故事性的渲染和表达，至于和科学技术细节有关的东西，只要不是过于严重的错误，并不影响我对电影本身的感受和评价。
大家如果有什么其它电影的带有终端运行画面的截图也可以发到评论区大家一起讨论，其实还是蛮有趣的。","天才基本法里，男主写的自走棋代码
还真是自走棋游戏代码，据说来源是
https://
github.com/sunbcy/drugw
ars-battleclient/blob/master/client/js/table/highlight.js
挺用心的。还有女主偷偷进男主家偷代码的时候，能看到游戏代码文件夹还分客户端，服务端，简直太用心了。"
,,,,,,,,,,,,,,,,,,,,,
新手想玩硬件，买单片机还是树莓派好？,会一点点 C。,"这个问题本人应该比较有发言权了 :D
先说一下我自己的经历，我从大二开始入门单片机，硬件至今做了有五六年了，目前也是Arduino
中文社区
的版主；然后差不多大四的时候开始对Linux和操作系统感兴趣，研究生从EE转到了
CS
方向；目前刚刚毕业，在某绿厂AI实验室做深度学习算法方面的研究工作。
所以不管是Arduino还是树莓派，我都算玩得比较彻底了哈哈，下面先介绍一下软硬件开发的区别和联系，然后会给出学习建议~
先上几个视频：
视频资源加载失败
视频资源加载失败
也自己设计过
“树莓派”
单板↓
接下来回答题主的问题：新手想玩硬件，买单片机还是树莓派好？
这个问题其实还不是很准确，题主首先要知道
“玩硬件”
是个什么概念，硬件是个太宽泛的定义，实际上任何技术都是多少和硬件相关的（哪怕是纯算法工程师，也要考虑硬件架构才能设计出最优算法）。
我想楼主想说的应该是
嵌入式硬件
开发
在
嵌入式开发
中，具体分下来：底层可以到模拟电路（射频、电源等），数字逻辑电路（FPGA、
CPLD
等）；上层一点有汇编开发（比如
Bootloader
，纯硬件相关）；再上层一点有
Kernel
驱动开发（连接硬件和软件）；再往上就是操作系统层级了，各种APP应用软件就在这一层；继续往上抽象，就是软件框架和算法层面了。
所以我们来看看，Arduino的开发其实属于Kernel那一层，也就是裸机程序，而树莓派则一般在操作系统那一层（不考虑驱动开发），这样题主应该就知道他们的本质区别了。
抽象的层级越高，要实现某个功能会越来越容易，但是相应的自由度会越低。这么说题主可能还是不太直观，给题主看几个我之前做的项目：
这是我之前的一个回答，这个回答中我介绍了制作迷你机器人的过程，其中就有从第一代用
纯Arduino
实现，到最新款的用纯APP实现的效果：
不知道题主看完觉得对哪个机器人最感兴趣？如果是前两个的话，那么Arduino适合你，对于这种玩具类的设计Arduino有天然的优势，那就是数不清的开源硬件库；而如果题主觉得最后那个手机实现的机器人比较有趣的话，那么可能更适合做APP开发，不论是树莓派的Linux还是Android和ios也好。
当然如果题主不想限制自己的知识边界，那么软硬件结合的技术栈才是王道（小孩子才做选择，你全都要 :D）。
比如上面链接回答中我也提到了，那个
Vector机器人
其实就运行了操作系统的，允许我们直接用python编程来实现一些功能，但我想实现用它来控制智能家居，而它却没有给我提供相关接口怎么办？
如果没有底层硬件和驱动的支持，我们的自由度就只限于
SDK
的范畴了
。这也是我决定自己重新从硬件开始设计那个机器人的初衷。
对于我自己的经历经验来说，我最早是从学习
51单片机
开始入门电子设计的（大一学完了C语言），当时用51就是制作一些电子钟，简单的小车之类的；然后偶然中的必然遇上了Arduino，才感觉开源硬件世界向我打开了大门，沉迷于当创客无法自拔；使用Arduino很长一段时间之后，已经熟悉到可以自己设计Arduino板卡、编写Bootloader，这时候才触及Arduino作为8位单片机的天花板，也就是性能，所以又转而开始学习
STM32
，上面的那个磁悬浮就是基于STM32的，对于这样需要运行复杂控制算法的项目来说，Arduino已经力不从心；DIY到了一定程度，肯定会想追求更专业的作品，于是你需要开始思考产品化中的技术：PCB设计、结构设计、工业设计、软件封装...用做产品的思路和技术去玩项目，这才是创客的最高境界。
说了这么多，对于题主有几点建议：
1.从Arduino入手，找几个
开源项目
熟悉开发流程，最重要的是培养兴趣和成就感
2.用什么硬件平台以及工具取决于你想做什么东西，没有万能的工具
3.不要局限自己的知识边界，没有人说玩单片机就不能用树莓派了，电子世界其乐无穷，进一寸有一寸的欢喜 :D
长期搞各种脑洞项目，大家不嫌弃的话也可以点上面关注一下～不定期更新项目
顺便微博@  
_稚晖
我的其他回答：","陆陆续续做了很多硬件项目5-6年了， 说说我作为一个非专业
创客
的经验：
简单答案： 1.新手从Arduino入手培养兴趣  2.进阶用树莓派实现高级功能 3. 高手自制电路定制化
我的经历：
本科电气工程但是并没有好好学习，不喜欢课堂上理论为主实践几乎为0的方式。大三左右（2009？）开始对单片机感兴趣，那时候什么都不懂，
51开发板
， 教程都买了，还自己照着书焊开发板，可惜手残都不能通电。当时的感觉就是，没有一套统一的平台或者教程，链接电脑也不方便还要买转接器， 软件也特别不友好。（如果现在不一样了欢迎指正。） 个人一句话总结： 51可能更适合做开发，不适合新手入门， 如果以后我不做产品的大量生产复制，可能都不会碰到51.
本科之后就转行学了设计，本科基础都慢慢忘光了，所以我可以说是从新手小白一路学过来的。
2013年左右了解到了Arduino的存在， 立即买了官方的新手包，里面附了一本小书和很多简单配件，一个星期就可以全部做完，还能做出几个小小的作品， 成就感爆棚。 
几个Arduino项目，不见得多么复杂。
2019年的生日加情人节礼物，Arduino Nano +Neopixel
视频资源加载失败
五年前做的另一个生日礼物，用了Arduino和LED矩阵，定制了动画。
这两年也做了一些套件，很方便入门
视频资源加载失败
视频资源加载失败
2014年因为一个项目需要做到无线视频传输，入门了树莓派，可以说功能相当强大了，但是要学的东西很多很多。 刚开始压力会比较大比较烦躁。
视频资源加载失败
这个坦克算是我第一个大型项目，从机械设计，3D打印，用树莓派控制，到远程视频传输和遥控软件，当时有点无头苍蝇但是也不管三七二十一的做了出来。现在的知识和技能都有了增强，但愿这几年能重做一个2.0。
下面是几个平台的比较。 
51平台不甚了解就不说了
首先第一点要明确的是Arduino和树莓派的区别： 
Arduino英文的定义是 Micro controller。所谓控制器，接到输入，进行处理，再进行输出， 通常来说是单线程的。 所以适合做一些不复杂的项目。这里的输入可以是按键，传感器，数据等等， 输出可以是数据，声光，电机等等。 
树莓派是一台电脑， 一台超小型的功能没那么强大的电脑。多线程，可以安装操作系统，有多样接口等等等等。  
所以很大程度上，平台的选择是根据项目的实际需求决定的。 
入门价格： 
Arduino：
 祖国版完全够用，Uno 二三十块， 小的Nano十块钱左右一个。 淘宝一百多的新手包完全够入门了。 
树莓派
：一个板子就200多，你还要考虑各种配件。新手不弄headless的话得需要显示器吧，需要hdmi吧，老版的需要再买USB Wifi，USB不够用要买USB hub，还有键鼠套装。这还不包含面包板小元件什么的。当然可以一上来就headless。
新手学习，万一有个短接什么的很平常，用Arduino， 烧了就烧了不心疼，Pi的话不差钱您随意。
还有就是你做项目的自由度， 同是200块钱， 你可以做20个Arduino项目，每一个都可以随时拿出来把玩。 Pi只够同时做一个，要做20个项目的话还要每次重新连接，每次运行不同程序，想想都心累。
第一次使用：
Arduino：
学学怎么接线，usb插好，IDE下载好，运行示例程序。就是这么简单。
树莓派：
首先得看卖家提供了什么样OS， 如果没有的话，你要先格式化SD卡，研究好要用什么OS下载好，（Headless模式： 设置Wi-Fi信息启用SSH，用一堆你没听过的软件设置另外的电脑端。）接好外设,  启动，设置用户名密码，利用linux连接Wi-Fi。下载必要的软件，开始编程。
入门学习成本：
电路连接方面，两者都需要基础的电路知识，Arduino的Pin口相对树莓派的GPIO友好很多。根据项目边做边学，不求甚解也没关系，慢慢就开窍了。
编程方面：
Arduino：
题主说有C基础，C也是大部分人的大一基础课，不难上手。IDE也很简单，编好程序一键编译上传。多看看示例和别人的教程，高级的功能多搜索。
树莓派：
大部分OS启动后是直接进入命令行的，bash command不见得每个人都会，怎么新建文件，怎么保存，怎么退出程序，怎么关机，你可能统统不知道。你当然可以一开始就使用StartX进入GUI体验下linux系统，跟Mac OS和Win操作还是有区别的。 下面你可以开始编程了，大部分Pi的程序是Python写的，虽说Python相对好学，但如果从零开始的话也是额外的一个负担。
上面说了这么多，好像看起来Arduino又便宜又方便，为什么还需要学树莓派呢？
树莓派虽然相对昂贵复杂，但能为Arduino所不能。 举几个栗子：
树莓派跟你的电脑一样，可以多线程，同时运行多个程序执行不同任务。
可以运行更复杂的程序，比如用python做抓取，
遗传算法
，机器视觉等等。
有更好的网络连接性。
当然也有相对弱于Arduino的（功能方面），比如运算实时性不高不适合精确的时间控制。有很多项目也是通过树莓派控制Arduino来各取所长。我自己喜欢把两者的关系比作人脑，树莓派就像大脑一样负责观察体验（
机器视觉
），思考（AI），做出决定（指令传送到底层）；底层的功能如呼吸消化（系统自检，电源），
本能应激反应
（自动避障，
陀螺仪
）， 身体控制（电机）等交给Arduino来更快速的解决。
有什么说的不准确的还请大家指正！
Happy Making!
关于我:
自己平时会做些各种各样的小玩意，激光切割，3D打印，Arduino，Unity什么的。欢迎关注ins： Chenthedesignmaker   微博@ 设计极客Chen
还有我的youtube频道：
目前在做各种科技diy向的节目和教程，请多指教！","玩硬件很多人说很贵，但是我觉得其实现在是玩硬件最好的时候。1万元对于本科生来说相当于两年的大学费用。对于3本的学生来说相当于1年的费用。1万元估计都不能上的起某些单片机，java，深度学习的培训班。但是1万元自己投资自己做硬件却可以学到真正的知识。
骚年你渴望力量吗？这里有一份器材清单我看与你有缘免费送给你吧。
首先 仪器类
1。示波器 2100元左右 双通道100MHz模拟带宽1Gsps。 可以carry各类模拟电路的试验以及工程。
2。
逻辑分析仪
 360元左右可以买到200MHz采样16通道的虚拟逻辑分析仪（计算机外接adaptor usb传输到计算机显示波形的那种）。
3。万用表 不去搞强电也就30快能买一个主流的了。
开发板类的：
1。 FPGA开发板。玩硬件如果不会fpga你觉得你会爽吗？fpga一时爽，一直用一直爽。最开始入门可以买那种点个数码管，外面挂一个
sdram
那种的烂大街300块左右的fpga开发板。后期的话直接用
zynq
也就800元左右。
2。单片机开发板。我不建议开始就去买单片机的开发板。单片机入门从
51单片机
入门最好。现在有大学教材会吧51的结构，指令集和外设讲的很全面。结合模拟电路和数字电路的知识可以自己来搭建自己的51系统。比如用80c31外扩 6116的SRAM和通过74HC373外扩EEPROM 2817。通过这个过程你了解到的不仅仅是单片机的原理。更重要的是你对存储器模型有了一个很深的了解。儿存储器模型是现代计算机的根本。所有的计算机内部的数据传输均是基于
锁存器
的。
51搞完了就可以进军stm32了这时候你就会发现你比那些一上来就搞
stm32
得人有哪些优势了。
PCB设计
自己拥有pcb的设计能力是很重要的。而现在就是最好的pcb设计时代。4月初某两家
pcb样板
厂商打架硬是把以前就很划算的打样费用打到了5元每款（10x10cm的双层样板每次打样只要5元）。厂商关键词jlc
进阶
搞完了以上这些基础的工具类知识基本上做一些简单的东西就游刃有余了，此时的你会很爽。但是不应该仅仅局限于简单的东西。下来就应该做一些更牛逼的东西。比如数字信号处理。神经网络之类的。做这些你就需要接触一些高端的板卡了比如fpga类的你就需要一些逻辑资源大的比如55k LE或者110k LE这种资源的。我有幸有一块530K LE的板卡吼吼吼 后期准备部署我自己的深度学习加速模块。这些板卡价格也还算能够接受。一般的85K LE等级的板卡比如zynq 7z020 也就800左右吧 altera类的 cyclone v soc 有一款110k LE的也就800多吧。有了这些利器做什么都会很爽。
最后你会不甘于仅仅只是把你的想法在开发板上运行。这个时候就是体现你pcb功底的时候了。自己定制一款自己的单板，砍掉所有不需要的功能，尺寸做的小乔玲珑不要太爽。对付bga封装的芯片其实现在也不是很复杂。jlc的4层板制程已经可以满足0.8 ball patch的bga设计 而他只需要每款样板100元。bga焊接也不需要去专门的厂家自己就可以搞定。我是这么做的
没错使用这种恒温加热板就可以焊接bga了
再po一张焊接好的
下面这张图是板上有一个0.5ball patch的
bga
。
当然后面你还是会不爽因为你也想自己做结构件了。那就整一台3d打印机吧 现在1500元就可以买到一台3d打印机对于我们这些只做结构的人来说太合适了。
走到这里你已经成为一个硬件产品经理的
candidate
了。 找工作更是不用愁。而这一切你只是花了不到1万块和几年的成长时间而已。","单片机和树莓派是截然不同的两个东西
。不要盲信高票答案，他俩，不是进阶关系。
做出炫不炫的东西是个人爱好，不是拿来说明差异的工具。
1、单片机主要用在控制领域。
这一点Arduino也罢，51也罢，绕过Arduino直接上AVR也罢，一步到位STM32也罢，差别在系统复杂度不同，功能强弱不同，资源多少不同，但共同的特点是一般都不上OS直接裸奔，要上也是RTOS，即它们共同强调一个特点，就是
实时性
。
即便如今已经能跑到220M的CortexM7，ST的高端型号甚至都上了A系列都没有的双精度FPU，依然没有MMU这个东西，说明压根就不是给完整的操作系统准备的。相比之下，只能跑80M的ARM7TDMI却能运行完整的linux（当年红遍全世界的GBA就是这个内核，不过主频低得多）。
学习单片机，主要是要学习数字电路知识和一部分简单模电，核心是计算机体系结构。这就是为什么大学的
微机原理
喜欢用8051或者8086这种老掉牙的东西来讲，因为简单，但该有的都有。
可以说单片机是
硬件工程师
入手的必经之路。
2、树莓派是个软件开发平台。
树莓派的核心是跑架构、跑库、跑算法，GPIO是附带物。没有人裸奔
树莓派
，因为这样根本发挥不出它的功力。大家是用linux强大的网络功能和开源本质，以及C++带来的强大封装和模版化，来无视底层、无视硬件，让创客专注于算法和模块的设计。
所以树莓派开发恰恰是为了最大程度绕开和硬件的接触。你看到的树莓派和硬件的结合，是最小化硬件操作之后的产物。所以别人的代码down下来编译一下就能跑了。单片机代码你要是无视对方的电路设计，跑一个我看看？
所以单片机还是树莓派这个选择要看你的倾向，硬件还是软件。
实际上如果你要选择这个方向从业，两个迟早都要玩的，别选了。
顺带一提。我在dji厂做算法工程师一年多，跑在CortexA平台上，和树莓派一个类型，以前自己玩四轴的时候是用CortexM4，这俩东西相互不能取代。
高票答案太限定在自己是一个创客的角度了，无意冒犯，但做个彩灯这样的东西晶体管都能实现，不能拿来解释架构上面的东西。倒是
亚克力
加工我觉得值得肯定。","建议新手从树莓派上手。因为树莓派本身是一个单卡计算机。只要你会操作linux，只要你会点python或c语言，你就会使用
树莓派
。
当你会使用树莓派之后，你可以尝试一下单片机。比如
arduino系列
。
我从树莓派开始研究，后来玩arduino，现在开始玩esp8266。
这是使用
esp8266
制作的一款游戏。下面是演示。
视频资源加载失败
其实玩硬件有很多种方式，不要去纠结如何选择，我建议你把所有硬件都玩一遍。","我个人建议不要从任何SBC（单板电脑，比如树莓派、
香橙派
）开始。
SBC实际上定位非常尴尬。
搞物联网（
GPIO
），代码复杂度、搞通的难度远高于
ESP32
和STM32，
搞Linux，又比PC和服务器增加了很多不必要的麻烦，有的项目不支持
ARM
，硬件结构不一样……
我的建议是，对接传感器、屏幕等，先从ESP32开始。入门难度之低，超乎想象。
STM32也行，但随着国产化的浪潮，我认为前途不如ESP32。而且ESP32自带wifi和蓝牙，太接近我们平常玩的东西了。STM32更偏离线的设备。
想对接硬盘，从PC或者VPS开始。Sata，NVMe这些高速率的东西，ESP32完全搞不定。
等你把这两边的基础都搞通了，再向SBC平台进军。
树莓派、国产各种派，主要优势是体积小。他们更多的还是对标PC和服务器的，只是兼具一些GPIO能力而已。
而且他们的GPIO配件，基本是厂商高价定制集成的，某种意义上带有一点智商税。
适合给小孩当教学玩具玩，不太适合真想学点知识搞实用的人。
另外说下入门成本。
ESP32开发板，第一块大概24元包邮，送
type c数据线
。
第二块就可以买9.9元包邮的
ESP32-C3
了。
屏幕啥的可以去淘0.5元一块的二手，电机有2元左右的二手，各种转换接口0.5元（普遍6元邮费，我基本都是一次淘20元的，降低邮费成本）
二手的尾货外壳大概也能2块钱一个淘到。（你得有这个意识，很多东西买了直接拆外壳）
万用表大概十几块钱，电烙铁8块。
最贵的其实是电压电流计，这玩意要60-100元。试过买5块钱和13块钱的，用起来累心，不适合查错时用。
启动成本非常低的。","玩硬件是个大坑，我上大学的时候，看到那种编程的
双足机器人
，觉得炫酷的不得了，就开始找攻略。
网上说先从做四驱车开始，我买了
树莓派
及其各种配件大礼包，总共花了1200多，照着视频一步一步做完。
然后我就感觉我行了，牛逼了，准备着手开始做双足，买了好多
舵机
，装舵机的架子又花了，还自学soildworks做外壳。
玩了半个月，啥也没玩出来，小两千的一大箱子硬件在角落吃灰，我那一学期都没吃过一顿好的。
结论:哪个便宜玩哪个，等发现自己真的喜欢了，入门了，懂行了，就自然明白了。不然就像我这种失败例子一样，每天都看着那一箱电路板，回忆着那半年吃糠咽菜的生活，在浅色的床单上哭泣。","大家为啥非要争个你死我活呢
用过51/STM32/Arduino UNO/ATTINY85(DigiSpark)/ESP8266/OrangePI(类树莓派)写过HelloWorld（即点亮一颗LED），简要对比下特点，供题主选择
51:
优点：结构简单，工业化使用时间长，资料齐全
缺点：没有板载adc，pwm需要使用定时器模拟，基本上干点啥都需要扩展外围电路；计算能力有点捉急
补充：比较新的51已经有了pwm和adc口
最小系统价格：stc89c52<10元
STM32：
优点：片上资源丰富，该有的都有了；处理器性能强大；工业使用也有一段时间了，资料也很丰富齐全
缺点：实在找不到啥缺点，非要说的话，开发环境配置比其他的复杂算不？
最小系统价格：stm32f103c8t6<10元；stm32f407vet6<50元
Arduino UNO：
优点：开发环境配置简单，片上带adc，
arduino
有各种库存在，有开发效率加成；
缺点：IO口数量有点少；片上资源，性能上与STM32差了不止一个数量级
最小系统价格：国产ch340+贴片328p版本<20元
ATTINY85(DigiSpark)：
优点：使用
arduino
开发，USB支持（模拟键盘，
加密狗
等玩法），IO口支持adc/pwm/i2c/spi等都支持，用来玩足够了；价格便宜
缺点：ram太小，io口就6个
最小系统价格：<10元
ESP8266：
优点：
原生WIFI支持，
刷nodemcu固件后可以用lua开发，或者直接使用
arduino
开发，IO口支持adc/pwm/常见的总线等，尤其适合IoT
缺点：资料丰富程度不及51或
stm32
最小系统价格：esp12f+ch340<15元，单芯片（不带串口芯片）约为10元
树莓派
/OrangePI等：
优点：资料相对丰富，ram足够（高达数百到上千兆，跟单片机几百字节到几兆字节相比，高了几个数量级），可以买到支持rj45或者wifi的版本用来做IoT（实际上，xxxPI更适合作为IoT设备的中心节点而不是直接控制硬件）
缺点：非实时系统，价格相对较贵
部分参数对比：
备注：esp8266 ram为64K instruction RAM,96K data RAM
关于片上资源说法比较粗略且不严谨，详细差别可以参考各芯片的选型手册
关于示波器/屏幕的问题：取决于需求而不是控制器。
关于开发板：我个人都是直接上手最小系统板，从开发板上手容易导致只会用开发板，容易知其然不知其所以然，拿到最小系统容易蒙圈；自己搭外围电路是一种乐趣，自己搭建外围电路，换其它种类的单片机很方便
总结下：不说需求就选型就是开玩笑。先定需求，要不要wifi，需不需要i2c/spi总线，需不需要串口，代码规模大概多大，io口需要几个，预算多少。以上需求确定后，基本上就选出来了。","硬件的正确打开方式很关键，所谓差之毫厘，错之千里。有些回答上来就贬低c51，有些回答就回答arduino。有些为8051辩护，却又不答不到点子上。
单纯地贬低8051，或者单纯说arm，都不在点子上。
首先，玩硬件是一件烧钱烧脑烧时间的事情，并不是买一块8051或者
arm开发板
就完事了。以前，玩硬件的叫发烧友。历史上，国内叫发烧友的，硬件还真能算是第一个。
其次，你玩硬件的目的是什么？是学一门技术，还是玩玩而已。
如果是玩玩而已，在高中/大学混个奖，其实在淘宝上买个什么机器人、自动小车套件，就可以了。
如果真的是对硬件感兴趣，想学门技术，请耐住性子，开始还真不必买什么板子。
proteus
就可以了。玩硬件不是拿个起子捅收音机，那是野路子。虽然有效，但是不正宗。
从电路分析、
模拟电路
开始，公式+proteus验证。
数字电路也是一样，公式+multisim。有朋友说，数电用FPGA，非常同意。不过时间可以放在方向确定之后。
这之后，差不多可以搭建一个最小系统了。用8051也可以，用cortex m3也可以。
之后，再在某个应用方向上扩展功能。到工厂去，到一线去。
这中间的路，远非你想象那样简单。
硬件不重要，反正到了一定阶段，你总会“发烧的”。
重要的是玩法，推荐几个：
单片机
的杂志和期刊，单片机的
会议论文集
：
嵌入式系统
及单片机国际学术交流会论文集
。
当然，如果有经济能力的话，花个几千块，可以体验一把。其实也没有什么好体验的。就当放个大烟花一样，就是看个热闹，看个稀奇，看个新鲜，看个好玩。
放烟花的时候，并没有什么意思。
真正有意思的时间段，是动了买烟花那个念头、挑烟花、一直到点烟花那一刹那。","目前凑合能说是一个单片机职业开发者了，应该能答一下这个题了。
开始之前，看到上面有好几个答主吐槽了51，虽然“
Keil Vision
”这个梗我也是笑了很久，但是强行贬低任何一个仍旧大规模应用的东西的做法我并不赞同。
先看看答主的意思吧，想要玩硬件。但是很有意思的是你说的单片机多数时间更像是偏向于底层的软件开发，并不是硬件开发。
既然我是搞单片机的，那就从单片机的角度先给你一些参考，得益于极高的性价比，目前市场上的主流之一是stm32系列，不管是m3内核的还是m4内核的，应用都非常广泛。至于被一致吐槽的51，这个确实在被慢慢淘汰，但是也不能说一无是处，毕竟一个被各大高校拿来当教材的单片机必然有它的可取之处。因为我开始阶段也都是自学，该踩过的坑都踩过，在我看来，51最大的优势是它的结构相对简单，寄存器很少，甚至达到了可以全部记住的地步。但是同时，51也有足够的能让你理解单片机是什么东西，能干什么的能力，定时器，中断，还有串口，这些做单片机逃不开的东西它都是有的。另外，51的内部资源是非常有限的，如何利用有限的资源，达到更好的效果，这个锻炼的是一种能力。虽然现在更强的单片机让这种不浪费每一个字节的态度已经变的没那么重要了，但是真的等到需要用到的时候，你会感谢以前学到的一些能力。
如果你真的想深入到非常底层的东西，比如代码真实的运行轨迹，怎么实现的中断跳转，甚至怎么实现一个操作系统，51还算合适，仅仅因为它还不是那么复杂，而且各大高校的教材是非常多的。但是为了应用的话，51就只能用来学习一些基本概念了。推荐浅尝辄止就可以了。
应用的话，一个更加主流的方案可以让你遇到问题更加容易解决，毕竟你遇到的BUG，可能其他人早就解决了。个人推荐stm32系列，无非因为便宜。而
stm32
选用库开发是大势所趋，寄存器的概念和操作希望你在开始之前就已经搞懂了。
至于
树莓派
，它很强，但是强也意味着复杂。用它的话基本逃不开linux，社区资源足够的话，你可以有很多教程，但是如果遇到社区所没有的硬件设备需要驱动，那么就会很麻烦，你需要学习linux的驱动开发。而如果有的话则会变得非常简单。
总结来说，单片机更适合一些底层控制，而树莓派用来做服务器或者处理中心更合适。时间有限，随便写点，到此为止。","Arduino
 属于
裸机开发
，可以方便的通过代码，直接控制底层硬件资源。Arduino IDE 库管理器提供了丰富的第三方板级支持包，可以方便的实现诸如传感器、伺服电机、舵机等外围设备的控制逻辑，具体请参见我个人电子技术博客 
UinIO.com
 里的如下文章：
Raspberry Pi
 属于
嵌入式系统开发
，硬件资源的调度与控制由操作系统来完成，程序开发工作主要基于
驱动程序
和操作系统 API 完成；可以通过 
Qt
 进行比较复杂的图形界面开发。相应的，可以参考我个人电子技术博客 
UinIO.com
 里的如下文章：
玩转 Raspberry Pi 4B 开源硬件
?
www.uinio.com/Embedded/RaspberryPi/
无论是 Arduino 还是 
树莓派
，都提供的 UART 串口通接口，因此在实验过程当中，USB 转串口之类的小工具必然是不可或缺的，为此答主专门制作了一个 USB 转 UART 小工具，同时兼容 CP2102 以及 CH343 两款芯片，两者的
波特率
都可以达到 
921600
，希望能够对大家的实验有所帮助：
PCB BOM
UINIO-USB-UART 原理图
答主在成都的 IT 行业工作近十余年，经常会在自己的
 
电子技术博客 UinIO.com
 
当中分享一些产业与技术相关的文章，
赠人玫瑰
，手有余香，大家的【点赞、收藏、加关注】将会是我持续
写作
的最大动力。","我个人看法。。。。。
本人推荐先从啊丢肉（Arduino）开始。
本人4年多前开始玩硬件，一开始是从三极管和集成电路开始搞得（那时候还没听说过单片机），然后就每次都是要很费心思的去设计电路才能搞出一个好点的产品出来。最早我就是连npn和pnp三极管的原理都不懂的，就去拼命查资料，看了n多书才弄明白，紧接着就用三极管做了一个闪灯。不久以后我又接触了555等集成电路，就觉得比三极管方便多了，在这期间我经常去查datasheet，然后又用集成电路搞出了流水灯.“石头剪子布”机.pwm电风扇.打地鼠机等，功放也做了十几个。不过有一些东西用集成电路来搞也很有困难，比如我曾想用555和4017来搞一个闹钟，结果失败了。。。。。。
紧接着我就开始用89c52单片机。我对这东西的第一感觉就是好厉害，写个程序就可以实现很强大的功能！我曾经用集成电路搞失败的闹钟，电压表，温度计等东西用单片机轻松就可以搞的出来。过了一年多以后我又发现89c52的速度太慢了便换了stc15，这下子玩的更爽了。
结果一年前，我们学校有很多人玩Arduino，他们用Starch编程就能够开发出很多好玩的东西，而且还不用焊接和写驱动......但是stc15要写底层驱动啊。。。。我就有了个想法，就是利用Arduino的方便来先搞出一个产品，再研究这个程序，最后搬到stc15上。凭借这样我终于在很短的时间内弄懂了nrf24l01和ws2812还有iic 1602模块，而且也更有成就感了。
然而，我被stm32深深地困扰着。
stm32
太难学了吧，从几个月前学到现在只会操作
gpio
和rtc而已，连怎么建立工程都觉得很难（虽然因为学习忙没啥时间学）。。。。。。
所以我大力推荐Arduino，因为可以不用焊接，有现成的库可以用，不需要太多考虑底层驱动就可以搞出很好的产品，对新手很友好。最重要的，价格极其低，某宝十几块就可以买个UNO板，加上配件100不到就可以玩的很high了
放一些自己做的东西
视频资源加载失败
树莓派
和fpga。。。本人真没用过这些东西。。。。。","这俩完全不是一类东西，有啥好比较/选择的。还有楼上推荐 51/AVR 的怕不是传统工科学出来的……如果你是自学，做 DIY 项目，不打算涉及工程的话 51/AVR 这种
没免费开发环境（其实有，不过国内传统没人用），没
开源社区
的商业产品有啥好学的。网上随便下一个不知啥年代的 Unicode 都不支持的盗版“Keil Vision”来写莫名其妙的类 C 语言（一万个私有扩展语法），而且能找到的示例代码风格普遍一团糟（搞电子的写代码就这个尿性），这种东西真打算让初学者看？能写出东西？
关键问题：
你要做一个什么东西？
你有没有模电数电基础？
好像大家对我鄙视传统几大单片机意见很多。我不给新手推荐这些是因为：
新手和 DIY 用户并不关注硬件成本（几毛钱和几块钱那个成本）
他们并不需要维护现有工业产品
就他们现有的知识而言，传统单片机的学习曲线较为陡峭
第三点可以展开说一下。比如一个人会标准 C 语言，懂模电数电基础，那么他去写 Arduino 只需要学习唯一一个 language extension：PROGMEM（而且这个东西早期是不会用到的）。如果他连电路基础都没有，没事我们有模拟器 
circuits.io
 随你玩，不怕烧真硬件。如果他去写 
51 单片机
，首先他要面临那么多寄存器到底是个什么东西的困惑，然后他会迷失在诸多大大小小的学习板上面（不开玩笑，这样的人我见过不少，有个普遍的认知是板子越大功能越牛逼）。如果他没有电路基础呢，那就得去找 SPICE 模拟来学习了，或者多烧几片 51 嘛，反正便宜。后者的学习曲线是更为陡峭的。
==========
下面看到一个推荐在低功耗硬件上写 JS 的，让我写 JS 我宁愿写 51","新手必推arduino啊。。。淘宝上arduino nano才十几块钱，已经够玩出几十种花样了，而且超级好上手。Arduino nano在官网上已经停了，但是淘宝卖的质量绝对不差，高精尖的实验室都用它。工作了才开始学习硬件，arduino试了两三天时间就上手了，意外的是竟然因为设计硬件给工作带来了好多乐趣。
至于有人提到的必须要买个示波器，因为兴趣开始学习的话，不妨用instructables推荐的方法，直接用arduino搭一个示波器出来。
Arduino - Oscilloscope (poor Man's Oscilloscope)
Arduino Oscilloscope
除了硬件的话，又喜欢编程，估计可以玩树莓派了，树莓派的教学资源比arduino要多得多，甚至官网上有很多专门为小孩子写的教程。假想自己以后有小孩子了，肯定给ta来个
树莓派
玩。。。","很贵的东西才做选择，这么廉价的东西当然是：全都要！
本质上就是一台移动电脑
，有便利的操作系统和软件。因此玩软件占很大一部分。
插个SD卡，跟着网上的教程装系统、装软件，学一点Linux。可学可玩的东西很多，花一两天上手以后，就可以随心所欲了 ：）
树莓派官方推荐Python编程，可以写Python代码直接操作外围电路，这对懂一点编程但是不懂单片机的新手来说，吸引力很大。比如说写一个超声测距的程序，不到20行代码就搞定了。
当然也可以用C开发。
而与树莓派完全相反，
arduino则是一个不折不扣的单片机
（简单来说，单片机一开机就会直接执行你上次烧录的程序）。驱动一个小显示器就得折腾一阵子，和真正的单片机开发是完全一样的。
不过arduino比专业用的单片机开发环境更友好，编译、烧写过程更加自动化，所以才这么受欢迎。
上图是我自己做的便携式游戏机，显示驱动、输入驱动都重写优化过，目前只有这一个游戏 = =
二者都买有一个好处：
接线、面包板、按钮、二极管、各种传感器模块都是通用的，比如你可以买一个arduino小开发包，再加一个独立的树莓派+sd卡，就足够起步阶段的所有需要了，相当方便。
PS：树莓派可以接USB键盘鼠标和任意HDMI显示器，所以不需要买专用设备。以后你玩熟了都是用电脑远程登陆上去操作的，就更不需要显示器了。","附赠一个挑选指南，看看哪个适合你，或者符合你的需求。没有必要一定要从最基本的入手，需求大于一切。
ps:还有什么比用python写硬件更优雅，推荐楼主试试支持
micropython
的pyboard(???)?","树莓派也算是单片机(Single Board Computer).  个人觉得的话, 如果是纯刚入门, 包括编程也不熟悉, 也没有学过 Linux 相关, 但是日后可能是正经学 CS 的, 那么
树莓派
的条件会更好:
有非常好的社区文档和参考案例, 特别是 bootloader, 写玩具操作系统这块很重要
GPIO 的相关生态非常成熟
4B 之后整体 IO 算是比较能用了, 比如终于给了 USB 3.0/能跑满的千兆网卡/HDMI 2.0 还有 4GB 内存和更强的单核的 CPU
Rasbian 算是非常不错的新手发行版, 特别是自带了很多本来要花钱的专业软件, 比如 Wolfram Alpha(一个高级计算器), 还有 Minecraft 这样的小游戏.
但是不见得 RPi 4B 就是唯一选择.
其他便宜的有意思的单片机还有 ESP8266
这个就算是真的 MCU 单片机了, 特色是带了一个完整的 Wi-Fi 802.11 协议栈, 能够用来做很多低功耗的 IoT 玩具, 比如接上红外传感器做防盗感应器, 或者是收集记录温度数据, 也能做一些简单的小车. 价格也不贵, 并且Arduino开发平台直接在 Windows 商店就能下到.
而如果还是想玩 Linux , 但是要尽可能便宜, OrangePi Zero 是目前接口相对齐全的最便宜(百元内)的 Linux 系统开发板.
往上还有支持 HDMI In 的 RK3399 系列开发板, 和支持 Android 神经网络框架的 RK3399 Pro. 
如果是入门学习 FPGA/ARM 协同开发, PYNQ 平台是目前最友好的开发平台, 有着相当完善的生态; 甚至不用学 Verilog, 用 python 就能做 FPGA 开发.","如果是要玩硬件的话单片机比较好点。
相当于一个小型电脑，只不过是硬件配置比咱们用的电脑要低很多，上面跑的是操作系统，你能接触到的硬件部分全让驱动层和操作系统隔离开了，虽然也有引出的io口但功能有限，除非是简单控制一些外设，其他地方io口的功能也发挥不出，比如我要对电机的编码器进行正交解码计算位移和速度这时候树莓派还不如单片机好用。但通常用树莓派做些单片机处理不了的数据量比较大的运算，树莓派直接能支持usb和网络等等这些协议，以上位机下位机的形式与单片机通信，或者搭服务器等等。树莓派可以做很多东西，但需要学习的更多是关于操作系统的知识，就好像让你学习怎么在windows上安装一个软件并使用它一样。
如果是单片机的大学里可能会学51单片机，高级点是stm32，另外有
开源社区
非常广的arduino。要对单片机编程的话首先要清楚硬件连接，如果连io口都对应不上运行结果肯定不正确。也就是至少要在明白硬件连接的情况下才能对单片机编程。
举个最简单的例子:你要用
51单片机
去驱动一个发光二极管的亮灭，都知道发光二极管是单向导电，如果你把发光二极管正极接在5v，负极接在单片机的一个io口，那么让这个io口输出高电平发光二极管灭，输出低电平发光二极管亮。  如果反过来把发光二极管正极接在io口，负极接地，那么情况正好相反，io口输出高电平发光二极管亮，输出低电平发光二极管灭，而且这种情况二极管亮度没有第一种高，因为单片机输出电流能力(拉电流)很小，最高只有几十毫安，而输入电流(灌电流)却可以很大。是如果不知道硬件连接的情况下你可能要费些心思。假设还要求必须是高电平点亮发光二极管而且亮度要高的话就可以加个npn三极管。如果要做个示波器呀，或者巡线小车可能就会用到运放和电压比较器这些集成ic，也是要在了解硬件的情况下写程序。
附上自己曾经做过的一些东西，我很少用到树莓派，基本上都是直接用电脑做上位机进行一下比较复杂的运算然后与单片机进行通信。
视频资源加载失败
视频资源加载失败
视频资源加载失败
一个电子秤，能实现价格累加
视频资源加载失败
视频资源加载失败
另外真的感谢有arduino这个单片机，很多
开源项目
只要能把机构做出来就成了，比如一些3d打印机，激光雕刻机，写字机，画蛋机。。。
视频资源加载失败
视频资源加载失败
可以画A0图纸哦，我们这个专业有时候一张图能让你人工画一整天。
视频资源加载失败
这才是diy的根本，有了它才有了上面的一切。
********************************************","树莓派
 Raspberry PI
Raspberry PI Zero
（上图）
它其实就是个
微型主机
，GPIO接口和相应的拓展板数量少开发较为不便（linux不能算实时操作系统）网上看到有意思的项目主要集中在DIY Gameboy之类。作为只能硬件的核心来说，性能有些overkill了，带来的最大的问题是
耗电。
51单片机
/stm32系
Teensy 3.2 32bit stm board
这类的硬件一般功能强大针对专业选手，学习曲线相对比较陡峭，需要有一定的专业经验比如数模转换、通信接口、寄存器等，本人至今未敢尝试（主要是因为目前遇到的一些需求用arduino已经足够）一般在需要实时大运算量的项目中应用较多，比如机器人、无人机飞控等领域。
Arduino系列
Arduino UNO R3
终于轮到大名鼎鼎的UNO登场了！（不是那个吼到额头爆青筋的UNO牌）综合易学易用、可拓展性和硬件成本首推
arduino系列
！既然题主有C的开发经验，
arduino ide
封装了一整套极易使用的API，5分钟上手，拥有极其强大的社区资源，想做什么项目google一下，基本有人做过或者有很多现成的库可以利用。万能的淘宝上一块UNO板子只用一顿午饭的钱，不小心烧掉一块（玩硬件的日常）也不心疼。
贴点本人接触过的有意思arduino项目
视频资源加载失败
Bare Conductive Touch board 导电油墨控制板
RAMPS for Arduino Mega 2560 3D打印机控制拓展板
不要祈求别人告诉你答案，上面发的这些产品我都摸过做过，没有对的产品，只有合适你项目的产品。找个自己想做的项目Dive in，打开新世界的大门吧！","玩硬件有两种：
一种是自己做数字电路，请出门右转 FPGA 或者左转 Verilog。自己动手才能学得快记得牢。像是 51AVR 这种成型的硬件，你根本没法 DIY，你想加指令，改寄存器？没戏。
第二种就是拿微机做其它设备。这个不一定非得单片机，只有必须用单片机的情况下才用单片机，谁不想省事嘛。
现在绝大多数智能家居、物联网设备都是 ARM 的。所以你如果要玩物联网，赶最近这波潮流，买个树莓派再合适不过。
树莓派上可以刷系统，刷完之后可以面向 OS 编程，省不少事。并且你的选择也多了，什么 Python 啊、Node 啊，不一定非得用 C。
用了树莓派，你的技能树和绝大多数开发/运维是相同的，你能找到的社区、生态，比单片机好到不知道哪里去了。
运行 Node 的硬件都玩到天上去了：
Node.js on a satellite means anyone can be a space programmer - Reaktor.com
。我想你应该不会造出来什么比卫星还复杂的硬件，不过它连卫星都能胜任的话，应该符合你的需求。
最后就是成本，一块
树莓派
 Zero 一百多一点，3B 是一百六十多。3.5 寸 LCD 一百多一点，7 寸的 200 多一点（你手机屏幕尺寸也不到 6 寸）。或者你可以买个 HDMI 和 VGA 的转接线，到你公司或者实验室随便找个显示器。有些人的双标真是 6 ，好像 51AVR 就不需要显示设备似的。"
,,,,,,,,,,,,,,,,,,,,,
在真实工作中的编程是怎么样的，与学校里有什么不同？,本人还是在校学生，学校里每门编程语言课程都是上一点上不完的，实验课写的代码最长一两百行。 很好奇在真实的工作环境中，程序员写代码是怎么样的。每天啪啪啪手敲成千上万行代码这样的吗。和在学校学习时写代码有什么异同。 (????ω????)希望已经工作的前辈们来回答回答。,"/*说说我的经验*/
刚进公司时，在你正式动手写代码前，很可能要理解
code base
。这一过程至少持续1个月，取决于你所在项目的规模。你会发现你不得不使用你浑身所学之能事，理解上古程序员是如何解决一个个实际的问题的。有的时候你沾沾自喜，“哈哈，这个技巧劳资经常用，你们也算有点见识”。但大部分时候你很糊涂。
在此阶段，你每天的工作就是看文档，看设计图，读代码，放断点debug，hack，fix，问同事。
你很累。你很无聊。
此外，刚进公司的你，会发现你的项目组正在使用一些奇葩工具、冷门技术，他们非常不好用，尤其跟你大学时候用的成熟IDE相比。你可能会想砸键盘，“谁特么想出来的用这个工具！谁特么写的这么sb的工具！”
你很失望。
渐渐的，你开始了解了你们的业务领域，所谓的掌握了一定的领域知识，你开始有能力判断哪些是权衡，哪些是权宜，哪些是极精妙的设计，哪些是遗留代码。
你的领导也发现了这一点，于是开始给你安排简单的任务。他们可能是改一些显而易见的bug，可能是实现一个最简单的新特性。此时你会有一种驾驭的错觉，你很快的写好了功能，提交，开始幻想自己精妙的代码收到表扬。当然，不出意料的是，你提交的100行代码里被找出了10个bug，其中2个是很严重的逻辑错误，4个是未实现的需求，2个是ui错误，2个是边界条件未检查。
你心里十分不爽，“妈的劳资这么耪ㄌ斓拇码你们都不懂得欣赏！”
此时你的领导过来轻描淡写地来了一句，“我们提交之前要进行code review”。
于是你找了你身边比较和善经常解答你问题的小哥来代码检视，10分钟之后，你漂亮的代码被改得面目全非，你欲哭无泪，又不想得罪前辈，于是默默地提交了这不知道是谁写的代码。
就这样挣扎着过了几个月，你开始摸清了门道，于是你开始运用你大学时期课内或者课外学到的引以为傲的技巧和知识了。领导自然也发现了这一点，于是他开始安排你组织技术交流会，你精心准备好了ppt，自己在家排练，并且试图加入一些或者高冷或者没品的幽默段子。
会议很成功，你感觉到同事开始对你刮目相看，你开始飘飘然，重新拾回“驾驭”的感觉，心想“就你们这帮码农，劳资以后可是架构师！”
渐渐的，你开始进入了状态，你提交的代码越来越多。刚进公司时你从来没打开过的代码规范文档开始回来找你麻烦，不过这不是大问题。领导开始对你强调质量，而你则在心里抱怨旧代码的设计。你想要重构，你想要创新，你想要搞一个大新闻。
与此同时，组里新来了一位同事老李，是从其他部门调过来的老员工，领导组织组里盛情欢迎了他，你心里不服，但是他是个好人，你们谈笑风生。
机会来了。
公司要紧急实现一个演示功能，百万级的合同能不能拿下来就看这次了，你的领导已经亲自飞往客户那里坐镇，他走时跟你说，“组里就靠你和老李了！”
你十分激动，买好了泡面和零食，准备通宵作战，给领导提供最犀利的火力支援。
第一个功能点谈下来了。领导发给你了要求。
你发现你半懂不懂。
里面提到的一些其他模块，你在每月组织的技术交流大会里听说过，但你写过的那点代码里从没调用过他们的API，你更没读过他们的代码。你有点不知所错，开始心虚。
不管了，先开始干。
你找到了一些相似的功能，翻出了一些发霉的陈年旧代码，注释里写着2004/06/18。你没有时间完全读懂，你开始复制粘贴，直接debug。当然，代码报错了，你开始挨个解决，就这样，一个通宵。
第二天早上，你总算把你熟悉的后台部分调通了，你发现了新的麻烦。
是前台。你对前台并不熟悉。你知道javascript的原名叫ECMAScript，你知道JQuery对象和dom对象的区别，但是你发现你还是看不懂你们的前台代码。
怎么办？
好吧，你决定拉下脸，问老李。老李看你的样子，说，“你去睡一会吧，我来帮你看”。你心里有些不甘，有些不好意思，也有些感激。你很想自己把它们做出来，但你不会，而且时间也来不及了。你想学学他是怎么做的，但是你的大脑已经停止工作了。于是你疲惫地笑了笑，“好，交给你了。你看一下这里这里还有这里...我就去睡半个小时，一会就回来找你。”
你这一觉睡到了下午。
你醒来一看表，震惊的弹起来，赶紧回办公室找老李。老李已经从你的座位回到自己的座位上了，正在慢悠悠地喝茶。你有些惊喜地问他，“怎么样？”他回头看见你回来了，说，“放心吧，已经给一线调试了，你去吃点饭吧。”
你哪里有心思吃饭。你惊讶地对老李说了声“好的！太好了！”然后回到你的座位上迫不及待得打开代码开始运行。正如老李所说的，功能已经实现了。你轻舒一口气，拿出一碗泡面泡上，开始啃代码，心里想的是“这次一定要准备好，防止下次再出乱子。”
啃着啃着，你有些不耐烦了，因为你发现代码越看越多，已经超出了你的大脑容量。你想了一下，决定先放在一边，查收一下邮件放松一下。
邮箱里又是塞满了新员工培训的资料，各个部门的联谊活动通知，当然最多的是服务器发来的build report和test report。没什么有趣的事。
你想了一下接下来要干嘛。算了，还是接着写新特性吧，测试们还等着你呢。但是你其实很忐忑，你的心早已飘去了前线，但是你知道你不能发邮件问状况，因为你领导可能几天没睡了，何况你也并没有什么特别紧急的事。你破天荒的把邮件客户端开着，留意每一个新收到的邮件。
就在这样的忐忑中，一天过去了。反正也没什么事，你回家好好洗了个澡，定了个早早的闹铃，安心的睡觉了。
第二天一大早你就跑去公司，果然邮箱里有了领导的邮件，上面写道“演示很成功，客户很满意，接下来是谈判阶段。家里的开发兄弟你们太棒了！”
当然，你很高兴。但是又有一点失落。你不太明白为什么，于是你想了一下。随后你似乎明白了，虽然这是一个好消息，但是好像跟你又没什么关系，跟任何人似乎都没什么关系，好像是一件自然而然的事情一样，并没有“holy shit”超神的声音。
过一会，你的大领导，项目总经理回复了你领导的邮件，说“干得好！同时也对家里的兄弟提出表扬！回来开庆功会！”你心里略有一些期待，“不错”，你想到，虽然主角不是你，但是你毕竟也是功臣。
你为庆功会暗自准备了很久，你在网上浏览跟领导吃饭该说些什么，你想好了很多概括性的有内涵的问题来证明你对项目的理解，你也想多了解一些项目的大方向。
几天之后，你领导回来了，大家开了庆功会。饭局上，大家聊聊家常，聊聊你领导在国外的见闻，大领导知道了你的名字，大家似乎很随意的打了一会牌，就这样平平淡淡的结束了。你略有一些失落。
生活回归正常。
但似乎又跟以前不那么一样。
你在开发工作以外，有了新的任务，其中包括学习推广新技术等等。你开始跟你领导彻夜长谈。他与你分享他的经验，你与他分享你的见闻。你开始接触他的工作，比如提高团队能力，完善自动化测试，提高代码质量，提高代码性能，增强功能可配置性等等。你开始淡定的接受新的工作，而不再幻想一朝成名的瞬间。毕竟，迎接挑战才是你真正感兴趣的事。
不过，这接下来的几个月里，除了改自己先前遗留下来的bug，你几乎没有提交任何代码。你每天的工作变成了看框架，读代码，看技术文档，学习试验新工具，浏览技术论坛等等。你开始觉得有一些缺乏成就感，也有点怀念绿绿的单元测试结果和噼里啪啦弹钢琴一般飞舞的手。
有一天晚上，只有你和你的领导在加班。你的问题困在心里很久了，于是你问道，“老大，为什么我的任务跟别人的不太一样了？” 老大说，“那当然了，你是当作未来的技术主管来培养的。”
突然的幸福让你不知所措，不过你克制地问道，“技术主管都是干什么的？” 老大并没有回答你，而是说，“以后你就知道了”。
生活还在继续。
跟你同一天入职的晓明是一个勤奋而又活泼开朗的人，但是你觉得他似乎入错了行。他总是挣扎着思考为什么他的代码中有逻辑错误。对你来说再简单直接不过的一段代码，他也很难读懂。领导也发现了这一点，所以安排他渐渐地向配置管理（CM）方向发展了。不过他似乎对这个很擅长，无论多么繁琐的任务，他总能按部就班的完成，各种纷杂的脚本他也一一了熟于胸，重要的是，他很有耐心，无论服务器出了什么奇葩问题，他都会跟它死磕到底。大家都很喜欢他，也很信赖他。
有一天，
晓明
像往常一样抓住你向你请教问题。是个bug。你已经习惯了从代码检视开始。你自信地叫他给你看代码。然而你并没有发现什么问题。于是你问什么现象。他说部署到服务器上就报错了。你看了一下日志。你没想通。于是你再仔细重新检查了一下是否各个环节都作对了。是的，没有什么问题。
好吧，你知道你遇到棘手的问题了。不过谁知道下一秒会不会就解决了呢？进公司这么久，各种奇葩问题对你来说早已是司空见惯。你打开搜索引擎，开始试图寻找相似的问题。你不断的做出假设，然后通过证据否定它们，然后再作出新假设……直到你突破了你的理智，你觉得可能是编译器出了问题。
真的假的？你从来没有想过编译器会出问题，就好像你从来没有想过你的肝脏有一天会报错一样。你觉得应该是自己错了，于是你仔细排查了一下其他的可能性，不，没有别的问题。于是你把服务器上编译过的字节码通过
反编译工具
打开，你发现了一件微妙的事情。于是你跟随着这个线索继续上网查找原因。终于，你发现是兼容性的问题。你发现了新大陆。
问题虽然复杂，但是你只需要简单调整一下代码就可以绕过这一问题，于是你三下五除二把代码改好了，测试，嗯，哈哈，果然没有问题。晓明在旁边看得发愣，问你，“咋回事啊？” 你心里有一丝淡淡的骄傲，你兴奋地把他拉过来看你搜到的网页，你把代码反编译之后跟源代码对比，你给他讲依赖加载的实现……你兴奋得讲了一大堆，他静静地听完之后，眨了眨眼，说，“大神啊！”
艹，他根本没听懂。你一下子泄了气。你也没什么可说的了，但也不知道该如何接茬，就谦虚道“没有没有，我不是大神”。
虽然如此，他依然天天跟着你“大神”“大神”得叫你，虽然你知道他很菜，但是当个伪“大神”也不错。你有点沾沾自喜，想说给你的同学听，又觉得太 low。要不发个状态“我不做大神好多年”？想想太蠢，只好作罢。
直到你发现还有好多人也被他称为“大神”。
失落？
有一点。
你都习惯这种失落了。自从意气风发地毕业之后，你再也没有那种强烈的胜利的感觉。你觉得生活似乎并不是你之前那样的一元化。大家都有各自完全不同的特长、兴趣、知识和经验，你也有你的，你并不是万能的。即使在上学的时候你从来都是班级里的佼佼者，但是你渐渐的发现世界还很大，你不会的还很多，山外有山，人外有人，路漫漫其修远兮，吾将上下而求索……
想到这，你的思绪突然中断了。你觉得自己实在是太优秀了，还懂得反思。你又开始了沾沾自喜，心想，自己如此优秀的人，总有一天会干出一番大事。于是你收拾收拾心情，继续工作。
最近项目没有那么紧张了，你渐渐的多出了不少时间。你领导也是。所以他又推荐给你了几本书叫你看，都是一些设计的书，什么《领域驱动设计》、《企业应用架构模式》、《
修改代码的艺术
》等等。你想起了刚来的时候他叫你读的《重构》，《
设计模式
》等书，你还记得刚翻开它们时的那种醍醐灌顶、豁然开朗的感觉。你微微一笑，说“好”。
这些书写的真好，你感叹道。
读着它们，你总是不自禁地想起你们的代码。你非常能理解书里描述的现象，你觉得你们的代码有着同样的问题。可是当书里介绍解决方案时，你却发现理解它们很困难。书里面的问题域跟你们的不太一样，你们有着不一样的需求和架构。书里说对于数据库的操作要做这样的一层封装，可是你们除了数据库还有web service；书里说对于UI和业务逻辑要做这样的隔离，可是你们的UI并没有直接调用后台，也是通过
web service
；书里面提到了好多技巧，你们并不需要……
你看得很无聊，渐渐的失去了耐心。简单翻完了书的后半部分，你觉得你差不多明白书里面说的方法了。一种
乾坤大挪移
练到第七层的感觉油然而生，你非常急切地想找点东西试试功力。
你踌躇满志地对你领导说，“我想对我们的代码 进 行 重 构 。”
出乎你意料的是，你领导一点都没有惊讶，而是笑眯眯的问你，“呦，好啊，你打算怎么搞啊？” 你没有想过这个问题，愣了一下，说，“就按照
领域驱动设计
的方法改啊，构造一个充血
领域模型
。” 领导继续笑眯眯，“好啊，那你打算怎么实施呢？”
怎么实施？什么叫怎么实施？改代码就是改代码咯，还怎么实施？你摆出了一个困惑的表情。
领导笑的更开心了，“你还记得《重构》里说过的，重构代码要保证单元测试全通过吗？但是现在你要重新设计，单元测试肯定都没用了，要重新改。你来看这个。” 他掏出一本书，指着某一章的标题说，“如果要对代码进行大型重构，只好退而求其次，使用高覆盖率的自动化测试来确保大部分功能的正确性。但是只是这样是远远不够的，我们还得保证原有功能没有被破坏，所以你还可以这样这样……”
你听的如痴如醉，如沐甘霖。你想起在学校里，如果你对代码不爽，你可以干脆删掉重写。你甚至都不需要一个版本控制工具。你从来没有想过在真正的工程中有这么多复杂的问题以及这么多聪明的前辈们发明了各种系统化的方法。你再一次发现了新大陆。
讨论之后的结论是，你负责监督并提高自动化测试的覆盖率，同时你可以先构造新的模型代码，也可以提交，但是在发布时并不把它们包含进去。当新的代码写好之后先内部测试，确保几乎没有问题了，再策略性的发布出去。
说干就干，你很兴奋。“终于可以写代码了！”你开心的对领导说。领导又笑了，“写代码并不是重点，重点是让它们正确的执行起来。” 你若有所思的点点头，心却早已飞到了你的新设计上。
你打开了看过改过无数遍的最核心的业务代码，心里想象着它们被你改好之后的样子，完美的领域模型、
高内聚低耦合
的类、优雅的代码、完备的注释、再加上同事们佩服的眼神……你觉得你快要像
樱木花道
一样笑出声来了。
但是细节之处有乾坤。
你发现你第一行就不知道怎么改。
是日志。
你想了半天，没有想到任何现成的解决方案。你问自己，日志算不算业务逻辑呢？算吧，它又对框架有很多依赖；不算吧，那把它放哪呢？你对着日志的代码看了整整一个下午，仍然毫无头绪。你觉得日志简直是破坏你优雅代码的杀手，你真恨不得把它们给删了……
算了，先不想了。你决定今天给自己放一天假，早早回家看个电影然后睡觉。
刚推开门，哇！外面下雪了。
漫天的雪花翩翩飞舞，一扫平日晚上萧条的景象。昏黄的路灯照射下，雪花反射出暖暖的光。你想起了你在北国的家乡。北方的小伙伴们都说江南的湿冷让人难以忍受，“屋里跟屋外一样冷”。你在此时此刻却有了另外的感悟，你觉得说成”屋外跟屋里一样暖和”也说得通。
也许生活就是这样吧，你想到，并不总是得意，也并不总是失望。你的期待总是狡猾得伪装成另外的样子悄悄的进入到你的生活中，而你的得意又总是在指缝中流走，想握也握不住。但是不管怎么样，你觉得你很快乐，也很幸福。你很庆幸自己成为了程序员。你对现在的自己感觉到骄傲。
意识到你已经在门口发呆了很久，你笑了，笑自己什么时候变的这么多愁善感。你走出门去，踩在雪上，发出咯吱咯吱的声音……
<全文完>
<程序员的故事还没有完>
/** 后记
真的没有想到大家对这篇小文章（我都不知道能不能称为文章）这么喜欢，我本意只是想通过一些真实的细节来描述工作和学校的不同的，谁知道写着写着就成故事了:-D
其实后面还有更多有意思的故事，不过已经扯得太远了，想听的话带上好酒来找我吧！
至于你们所关心的老李，他是真的，但是他并不是
扫地僧
，他是前端大神，后来他把我们前端的js代码完全重写了一遍，他三十多岁，头发浓密，有一个可爱的小女儿，说话不多，但是喜欢讲内涵段子。
故事经过了加工，亦真亦假，人物也不是完全还原，但是看到你们留言说很真实，我非常开心！
最后，作为一个工科男，我决定总结一下：
工作之后的代码量远没有学校时大作业那么多，但是要更严谨；
但是你要面对很多遗留代码，你要把它们弄懂，不像在学校里你基本都是从头造轮子；
同事们都是八仙过海，各有所长，无论你在学校里是当大腿还是抱大腿，在公司大家都对公司有着这样那样的贡献；
你不可能什么都会，工作才是学习的开始，大学生活只是让你准备好；
除了代码和技术，你还要考虑业务知识、测试、质量、生产效率和可持续性；
机会总是有的，你要做的只是准备好；
学校所学的非常有用，但是理论和实践有着巨大的鸿沟，这全靠你的经验和工程感 (engineering judgment)；
我暂时只能想到这么多，更多的就靠大家自己发掘啦。
最后祝喜欢编程的大家都成为
架构师
！
 */","第一名答案给的是一个在学校里诺难生，进去一家传统公司，然后看不上一切别人垃圾代码的视角。
我带来一个，毕业眼界也挺高，觉得自己技术不错，然后面试被真正的
大牛
虐成狗，然后还跪舔进入公司继续被虐的，游戏公司，第一视角。
给我一份爱，还你一夜情。第一视角，现在开始。
10年进入大学，无限憧憬大学，然后就傻逼了整个大一上学期，大一下学期买了电脑接触了dota，两年刀塔路，步步皆辛苦。大三下学期开始意识到，毕业总得赚钱吃饭，现在的节奏感觉会要饭，然后就开始敲代码。一开始无任何头绪，找到某培训机构视频开始看，我学java，据说ssh搞完，出去就有6k以上，我无耻的硬了。不对，我傻傻的信了。现在想想，多单纯啊，6k就感觉吊炸天了。大四下学期，独自一人去了广州，学校同学还在学校里接受培训机构培训。我觉得教的都会了。就先出来了。
2013年11月18号，到了广州。投了一圈，没反应。感觉人生挫败了。这时候，有时候不得不说可怜之人偶尔也有运气好的时候。在qq上碰到一个公司发招聘，我完全不抱希望的尝试下，居然给了面试机会。当天去面试信心满满，然而并没有什么卵用。老大直接从基础问到虚拟机，计算机原理，编译原理。当场直接跪了，我现在都还有心理阴影。整整差不多一个小时，我感觉像是一个世纪。印象比较深，老大问编译原理，我说我们没有开编译原理的课，事实是真的没有。老大原话，“你们他妈没有编译原理也敢叫软件工程专业！”，我完全无法接下去。最后老大问，你坚持最久的一件事是什么？大三一直都在跑步，我说，跑步，跑了一年多。老大说，那你感谢你的跑步吧。就这样我留了下来。得到了全公司最低的月薪，别问我怎么知道的，不可能有人比我更低就是了。忘说了，老大长发，那种中长发，飘逸的那种，第一眼真心就觉得大牛。至今无法忘记见老大的第一眼。好了，不能再说了，再说会有gay的即视感。
留下来后，下周二入职，周一我去看了牙齿，做根管治疗。
大学里面完全不知道游戏怎么做，游戏服务端是怎么做。一丝一毫的概念都没有。第一天几乎没啥事做，我自己配了下环境，上网看了看游戏相关的东西。还是完全都不了解游戏到底怎么做。我的座位靠着一个项目组老员工，我就看他和别人一句话过来一句话过去，然后看看代码什么的，后来才知道这叫连调。第二天，旁边的老员工问我是新来的么，然后让我去找xxx要学习视频，然后拿两本书，一本Java
并发编程实战
（JCP），一本Effective Java。然后就开始看视频，看书，看视频，看书。视频也是一个培训机构录的视频，后来才知道，那是我老大几年前在一个培训机构讲课录的。大概看了一周多视频，终于有了个小任务，写一个拉日志的小程序。暂时就叫那个老员工鸟哥吧，大家都那么叫，一直我也不知道为什么。鸟哥讲了需求，给了点思路。我第一次知道延迟队列，第一次知道Executor线程池，然后就自己去搜，搜了然后去用，然后去写，写完去找鸟哥，鸟哥直接在我电脑上看代码，分分钟把问题找出来，看了多少篇文章，都不如
鸟哥
直接指出来，来的印象深刻。写完之后大概有看了一周的书，等到了第二个入职的新人，终于有了个伴。然而后来我问了，人家工资都比我高。我就说我全公司最低啦。
第二个人进来后，我和他两人开始做第一个测试项目。SVN管理系统。在这之前，我对SVN真心都不太熟，只是知道这东西。第一个版本，鸟哥说写个命令行版本的，就直接在命令行能交互就行，我当时虽然被虐的很惨，但还是比较有信心的。毕竟当时我看培训视频，还写过一个OA的项目，当时我觉得OA就很牛逼了。没办法，眼界太低。开始做了才知道，这东西真心没那么简单，SVN写过代码的都知道，版本控制，有库什么的，原生版本好像是没有权限的，然后我们就是要在外面加一层控制，并把权限管理加进去，用一个RBAC模型，总之全都没听过，总之做的艰难前行。
忘了说，当时面试进来，HR的老大就强调过，说他们公司对新人的淘汰率很高，每做一个小项目，都会有代码review，会有几个老大一起看，如果说不过，给次机会回去改，改了还不能过，直接辞退走人。童话里真的都是骗人的，我之前从来没有过这样的心理准备。你们有待过这样的公司么，真的是直接走人，真真的！后来看到有人review完，会议室里出来，就收拾东西去办离职了。你们感受下。
在高压下前行，完成了第一个版本。第一次review，我不知道女孩子第一次是啥感觉，反正我进会议室内心是期待而又忐忑的。过去从来没有人这么正式的看过我的代码，一行一行的看。真的是一行一行的看！功能是最基础的，但是鸟哥真的不怎么在乎那些功能，他觉得那是必然要做到的。功能验证演示也就几分钟的事，功能看完就是看代码。在会议室，用个笔记本，远程桌面连接到自己的电脑上，然后直接投影到会议里，直接在eclipse里面看，从入口开始，一个一个方法，一行一行代码，那天整个人内心真的是被骂崩溃的。对的，就是被骂崩溃的。看到别人进入公司都会碰到一个和蔼的老李，我这边真没有老李，只有严厉的不能再严厉的鸟哥。代码中各种错误被鸟哥一处一处指出，包括各种编码规范错误，并发控制考虑，该抽出可配置文件的地方抽出配置文件去配，不能硬编码在代码中。印象很深的是不处理异常，直接就打印出来了。“你他妈打印出来给谁看，以后都是跑在服务器上的，以后不要让我看到syso在代码中出现”，然后还特意全局搜了下syso这句打印代码的数量，然后鸟哥一头黑线，因为我所有有异常的地方都是打印出来。当时加上设计错误，代码错误，反正记起来得有十几条，我写在笔记本上的，笔记本现在依然躺在我电脑边上。我是个恋旧的人。
经过第一次review，我和另外一个哥们总算是感受到什么叫代码review了。那哥们比我早一届，已经毕业，之前在一家公司做过，我问他这咋办，真的是被喷成狗了。他说实在不行就辞职了。我没说话。
/**
2015/10/5 2点更新
**/
经过第一次review，回去改第二版，基本知道了问题有哪些，虽然被打击的非常惨，但是还是有信心可以把这些代码改好的。当时其中一个主要大的问题，就是在做多任务处理时，对多线程的处理，以及多线程异常的处理。当时鸟哥说，上传功能有可能当时是因为网速或者其他因素没上传成功，但是可能稍微多尝试几次就能成功，所以出错后要加尝试处理。当时我是真的没经验，我就觉得尝试嘛，得嘞，那捕获到异常，我就循环，while（true）一直就尝试上传操作，直到上传成功才跳出这段代码。所以当我上次看到那个图，一个哥们写代码，失败之后再强制去试100次的代码的时候，我真的是笑尿的，因为我比他更牛我是试无限次。当然最后这里也是被鸟哥喷的狗血淋头，鸟哥说，你真牛逼。你这是在代码里面写了个死循环啊。我真的当时脸都绿了，因为我知道在服务器代码上写个死循环是什么后果，真的是一背都是汗。
哦，插一段，当时第一次还是第二次review的时候，鸟哥看完代码之后，发现太多问题，实在没法看下去了，说，“你们的代码真的让我感觉到恶心。”。不知道你们review的时候，听到这么一句是什么感觉，反正我是一辈子忘不掉了，和我同期那个同事也是，至今一起吃饭每次都会回忆这句。
当时经过了，几次改版，从基本命令行，到后来用bootstrap做个web版本，前前后后鬼门关走了得有7,8次，特别是当时做web版本，鸟哥要求使用restful风格，又是一个新名词，restful，好好休息么？我承认我当时真的是渣1的战力。不过鸟哥讲解东西真的是一绝，就三两下，真的可以把restful是个什么东西让你有个清晰的了解。restful当时还好说，springmvc本来就支持restful，真正让我差点挂掉的是js。JS我真的是学了一万年都没学好的一个东西，当时我和那个同事两人还是有点美术追求的，不想就写个特别简陋的界面出来，感觉至少也得让人能下的去眼吧，虽然鸟哥当时没有要求这个。后来我们两就想用bootstrap，一直都挺火的一个前端框架，但是也是完全没接触过，然后我还是9流的js程序，功能没花我太多时间，反而是界面真的是让我整个人都疯了。很难整体上做出一个比较好的效果出来。最后听说公司后台用的就是
bootstrap
，我们两就拿了公司的后台模板直接来改，但是中途发现公司有自己封装一层js，我的一个侧边栏点击，右边显示的效果死都出不来，但是这还是最重要的一个效果。搞得心好累，就是不出来。关键时刻，那个周末，我那个和我相依为命的同事，还去澳门玩了。我内心的怨念，你们可以感受下。因为他已经调出来了。没办法，我只能等他澳门回来，星期天晚上，12点多，我们语音，他跟我一起帮我调我的那个问题，最终解决。想想，那一段日子，没有他一起，还真的是很难坚持下来啊。相依为命的日子，一起深夜打车，冬天跑KFC买甜筒，一起感慨不知道哪次review完就要收拾东西走人。历历在目。
===更了一段。待续。大家来点赞。要不好多人看不到。被压在下面。
/**
看了一眼，上一次更新时2015年10月5号，差两天正好一年，时间真的好快
2016年10月3日更新
*/
感觉自己的记忆在一点点流失，趁着现在还能回忆起，我还是要坚持把我在那游戏公司的一年多写完。
好不容易熬过SVN权限管理系统的痛苦黑暗的一段时期，差不多改了3个还是4个版本，从命令行一直写到WEB版本，方才罢休，总算是过了。
不过忘记当时通过是什么感觉了，很后悔没有把但是最直接最真切的感受记录下，有可能这辈子都不会再有了。
据之前已经通过试用期的同事小道消息，过了SVN权限管理系统之后就能真是接触游戏代码了，当时还是很兴奋的。马上要接触自己从没接触过的东西，好奇心所带来的兴奋感冲淡了那段难熬的痛苦时光。当时公司扩招的很厉害，办公位置不够，都是各种找位置挤，到最后没法挤了，就弄了个会议室，所有试用期的同学全部搬到了会议室改成的办公区。他们取名叫小黑屋。就是一个没有窗户的小会议室，挤一挤坐了7,8个人。后来我们也是在小黑屋里，结下了深厚的战友情，这是后话了。
第二个测试项目开始涉及游戏，做一个黑市商店，也就是可以发布物品，然后玩家可以选择购买，然后扣费发放购买奖励什么的。但是听到需求的第一感觉是完全没概念的，没有任何整体的设计概念，知道像以前一样，定义个存储，设计一些接口啥的，对于实际游戏中的设计，或者说最佳实践完全木有概念。而且这次开始有了一个简单的公司框架给我们使用，我和我那个小伙伴简直如获至宝，感觉看公司的实际运行的东西是怎么写的，然而没想到木有源码，只是一个简单的架子，有些调用实例，底层的代码都是木有的。sigh.
就这样做了第二个测试项目，过程快进了，和之前类似，都是被骂，修改，继续被骂，再修改。还好反正抱着必死的决心，也就坚持过来了。我那个一起吃甜筒的小伙伴中途还提过一次辞职，不过后来又被鸟哥两句话给安定下来了。我还记得那天鸟哥突然把我俩叫到会议室去，我一脸懵逼，然后就说我们就这么玻璃心，然后说我那小伙伴提了离职，问我怎么想的。我还一脸傻逼的笑着说，哈哈，我没有啊，还好诶。但是我的内心独白其实是，其实我也想过。
经过了这个游戏项目，后面开始顺利很多，偶尔还会犯特别二的错误，但是已经可以整体理解真实游戏开发怎么做了。后面还继续做了两个测试项目，都是游戏中的真是模块，一个摇钱树，一个奴隶系统，我小伙伴抽到的是竞技场。反正就这么熬了下来。
进到项目组之后，开始负责开发一些小玩法模块，修复一些产品提过来的BUG。老大已经不是鸟哥，换了实际游戏开发组的老大。不过要求没有一点点的减弱，每次上线的代码要review，会扣一些很细节的内存使用，数据结构使用，边界的处理从这个老大那里也是学到很多。对待代码的那种认真的态度，和对实际review中的错误代码敏感度，真是我到现在都很敬佩的。总是能在review中快速看出错误点，或者可能有疑问的地方，提出质疑。人真的是在高压环境下成长比较快，我很庆幸能一开始进入到这样的团队接受锻炼，提高自己的眼界。
我一直觉得，代码眼界很重要，你要知道什么是好的代码。
除了老大，组里的一些同事也都非常的执着认真，说实话，我真心感觉自己有时候就是个渣。当时坐我旁边的是一个成都的哥们，操着一口四川普通话，川普，你晓得的撒，真心是逗的飞起。不过他写代码做东西的速度也是快的飞起。而且看问题的角度经常能转换的非常快。近水楼台嘛，所以我的很多问题都是找他讨论的，总能找到一些新的思路。关键是！！！天天炒股还能不耽误工作！！代码照样写的飞起！！我也是没话说了。像我这种，只要想着什么事的时候，基本工作效率就为0了。
还有个湖南的同事，工作经验比较丰富的，之前电信研究院做了4年还是5年，然后转行来做游戏。我们都叫他斌哥哥。我就记得当时印象最深的，我们在闲聊一个什么事情的时候，然后斌哥哥说他就是真心喜欢写代码的。从那以后这句话一直是我检验自己内心的标杆啊！
不过页游最终是走下衰亡的趋势，是无法逆的。技术人再怎么努力，你也没法反抗市场的选择。页游市场被37几乎全部霸占，手游开始崛起，最终呆了一年多之后，我也是不得不选择离开。我的第一家游戏公司，又爱又恨的公司。到现在，我午睡的靠枕和毯子都还是这家公司发的。我说过，我是个恋旧的人。嘻嘻。
好像写的越来越离题了，反正我其实也是在写给以后的自己看了。大家将就吧。","作为一个计算机相关专业毕业，毕业后一直从事编程相关工作10年多的大叔就这点上可以谈一些看法。
我在面试很多计算机本科甚至硕士毕业生时，他们很难向你展现实际的项目经验和工作能力，因此你只能考验他们对某门编程语言的熟悉程度，也就只能是语法和算法。因此也不可避免的让他们做些算法题。说实话，我觉得这种方式很傻，有谁会在纸上写程序呢？但你会有更好的选拨方法吗？
不夸张的说，一切学校学习的目的是为了通过考试。因此在学校学习编程无非是通过期末的考试。考试是在卷子上写程序，还是在机器上写程序并不重要，因为无论哪种考核方式，都和你将来是否成为一个合格的程序员没有什么卵关系，它仅仅就是纯粹的考试。但是，我想说编程的能力不在于你对这门计算机语言语法背诵以及几个算法的记忆。在实际工作中，更多在于你怎么组织你的代码。 语法是可以百度的，算法前人早已经给你写好了，你只需要知道怎么调用。但是新手和老手写出的程序是立马能闻出来的。
有些人面试的时候很厉害，但到后面，你会发现他/她并不适合也不想成为一个程序员。因为真正的编程工作是如何理清一大堆代码，而不是在几个烧脑的算法上玩智力游戏。如果你刚入行接手的是一堆糟糕的代码，那么我只能遗憾的告诉你，你的程序员生涯有了一个糟糕的开始。第一次糟糕的体验会是影响一生的。所以我希望你一开始接手到的是一堆高人留下的代码，这对你的发展以及培养你对编程兴趣是起到至关重要的作用的。当然，如果你天赋好，你最好有能力选择好的代码堆，或者自立门户。毕竟自己挖坑总比填别人的坑要来得爽。
我这里有点小小的人森经验要分享，就是你看一个人适不适合编程，就得看他是不是喜欢把事物整理得井井有条。在学校里你看他的床铺，看他的写字台，看他组织集体活动的能力，等等。不要以为程序猿都是胡子拉碴，脏里八稀的，那些都是电影小说杜撰的。就算有时候会出现这种情况，那也是为了短期的冲刺工作。程序猿就是艺术家，虽然很多人不这么看，就连很多程序员自己也并不这么认为。但实际上，程序员就是艺术家。语法和算法，还有程序组织能力，那些都只是基本功，就像画家的画功，都不需要提。厉害的程序员是要有对现实世界抽象的能力，是要用系统性的思维去理解世界，并有可能模仿上帝去创造自己世界的人。因此，你会看到许多高阶程序员写的书和文章都像哲学家写的一样。
看一段糟糕的代码就如同你走进一间脏乱的房间，你会闻到不好的味道，你会看到东西被放在不该放的位置上。新手写的代码就如同一间不知道整理的小孩的房间：被子团在床上，玩具乱扔，墙上乱画.....你暂时是不会指望他能把整个家都收拾好的。因此，很多情况下我带新人更多的是会告诉他们代码应该写在哪里，而不是i++和++i的区别。
实际的编程工作中，你做的事情往往是一个大系统中的一个组件。完成一个大系统的开发工作是一个团队的事情，因此你必须学会如何团队开发。而这点上和学校学习的编程是有本质区别的。学校的编程课教授的东西是点状的，它教你如何写出可以编译过去的一小段代码，它教你一些经典算法，但都没什么实际卵用。举个例子，比如排序算法，教科书上一大堆。有些同学硬是能将各种排序算法默写出来。然而他们永远不会想到关系型数据库是如何实现排序的，因此我一问他们如果内存装不下所有数据的情况下，怎么排序，就个个傻眼了。因为他们只知道在内存中排序数据，不知道多了硬盘后怎么处理；他们只知道
冯.诺依曼
这个名字，并不理解它在计算机架构中的本质。
这些点状的知识点对于一个不接触实际的学生来说是很难串起来的。团队开发是个很搞的课题，涉及组织理论。虽然很多人都能意识到这样一个事实：人多未必能办好事。但真正联系到实际，就是如何发挥一个团队的最高组织效率时，往往对自己的认识是估计不足的。很多想当然的事情是行不通的。编程工作是纯粹的脑力劳动，是很难量化的劳动。咨询公司乐此不疲的发明各种指标（如：代码行数）和各种团队编程模式（如：SCRUM），但也是基本没什么卵用的。永远记住程序员是艺术家，不要试图用管理指标来衡量艺术家的工作，这只能靠尽可能发挥程序员的主观能动性来提高效率和质量。
最近，考古学家发现，埃及金字塔不可能是由奴隶建造的，而是由拥有绝对信仰的大量工匠完成的。每个工匠切割每块石头的时候，都倾注了他的心血和虔诚，这并不需要由监工去督促。这些由不同工匠独立完成的石头最终能拼接成如此巨大完美的五面体，是人类工程史上的奇迹。真实程序员所做的大抵就是类似的事情。","百赞啦，又想到了一些，更新一波~
 文档：
            学校：口口相传
            工作：别人都用Markdown写文档，快把你的Word收起来……
    delay：
            学校：deadline之前搞定了就好，先休息半个月再说
            工作：每天都要发项目日报，你的老板和你老板的老板都盯着呢……
    联调：
            学校：自己和自己联调，左右互搏……
            工作：我：##￥￥%！……&*！！ 对方：没听懂……
    需求：
            学校：定期和老师汇报进度就行，需求一般不会发生变化
            工作：时常会碰到来求助的运营MM
    故障：
            学校：就算真的遇到了，顶多挨顿骂
            工作：这个季度的kpi又悬了……
    上级：
            学校：才不管你怎么实现的，也不会看你代码，能用就好
            工作：不但会问你怎么实现的，也会review你代码，还会强行让你用一些新技术……
    代码复用：
            学校：复用全靠写函数
            工作：就算跨项目也要强行复用……
    造轮子：
            学校：轮子是什么
            工作：这个季度造个什么轮子吹比呢……
    bugs：
            学校：以空指针居多
            工作：只有想不到，没有遇不到……
    吐槽：
            学校：好烦啊，做了这么多事情一点好处也没有
            工作：运营又说改版了，之前的代码可是PHP的啊，确定这样也能改版？
--------------------------------------------------------------------
    项目：
            学校：基于XXX的XXX系统的设计
            工作：商家处罚中心
    工作来源：
            学校：老师或者是自己
            工作：产品或者运营
    工作内容：
            学校：实现完整的项目
            工作：实现完整项目是少数情况，大部分是新增功能需求
    开发之前：
            学校：打游戏看电影刷知乎拖延一下
            工作：开会评审需求，分配工作
    开发人数：
            学校：前端后台产品设计全是自己
            工作：前端2两人，后台3人，产品一人
    代码：
            学校：所有代码自己搞定
            工作：只负责规则模块
    规范：
            学校：实现功能就好，代码写成什么样不重要，从来不写任何注释，代码之后自己刚写完的几天才能看得懂
            工作：每一个模块都需要完成相应的单测，并且保证测试通过。代码需要简洁美观，变量、类等命名严格遵守驼峰命名法，需要附加完备的注释
    框架：
            学校：框架是什么，实现功能就行
            工作：公司对各个功能（例如链接数据库等）进行了封装，必须要使用相应的框架
    封装：
            学校：为什么一定要面向对象，怎么简单粗暴怎么来
            工作：进行一定的封装是必须的，要考虑代码的复用性，尽可能避免代码冗余。差的封装是会被吐槽的
    debug：
            学校：肉眼，偶尔使用工具，一碰到蛋疼一下午
            工作：使用工具，流程化排查问题
    疑难杂症：
            学校：自己蛋疼摸索，直到放弃向研究生师兄请教
            工作：蛋疼摸索一会，请教大牛
    发布：
            学校：随意发
            工作：每次发布需要请示老板，你多发几次试试……
    review：
            学校：review是啥……
            工作：发布之前必须review，被挑到刺打回去再正常不过
    maven：
            学校：maven是啥……
            工作：每个模块的打包发布都有严格的流程，maven依赖必须要仔细，否则很容易遇到问题，有专门的工具对maven依赖进行检查
    git：
            学校：coder只有一个，用git干嘛……
            工作：git的命令牢记于心，stash,merge,checkout花式命令，键盘敲起来
    氛围：
            学校：开发累了，打会游戏休息一下
            工作：老板就在旁边，你打个游戏试试……
    设计模式：
            学校：闻所未闻
            工作：原来这种方法这么机制，赶快学一下，以后说不定能用上
先想到这么多，后面想到了再来更","我本科的专业是软件工程，大一的C++基础课学的还不错，后面数据结构与算法也学得挺认真的，
数据库结构学的时候搞不清那么多范式有什么用，UML直接睡过去了，软件生命周期搞不懂是怎么回事，测试这门课老师都没怎么好好讲。所以上面几门课直到毕业也没觉得有什么用，感觉C++的基础好，数据结构和算法好，就是编程好了。
到了工作中，才发现原来还有【需求】这种东西，不是课程作业那种胡搞瞎搞，差不多就行的了。而且做出来的程序不能只是自己演示正常就可以，要经受的住用户的各种胡搞瞎搞，被各种奇怪操作导致的BUG打回来，才知道什么叫程序的健壮性。
接手了一份胡搞瞎搞的数据库之后，才知道范式说的是什么，师傅说我司数据库每天要备份六次，我问为什么不多备份几次，他说，因为每次备份需要四个小时...
后来做了很多外包项目，才知道需求管理，或者说讨价还价其实也是个重要的编程技能。不是每个程序员都可以干干净净的只搞技术研究，做一个科学家。程序员应该是个工程师，工程师的话就要以实现为目标，很多时候，算法效率不是最重要的，有时候为了工程上的需要，还要牺牲程序效率换取工作流程上的效率或者框架的可维护性。
以前上学写的代码就像是高中物理中飞天遁地光滑无阻力无摩擦的小滑块，没有需求变更，没有雷劈机房，没有瞬发流量，没有兼容版本，没有很多奇怪的东西，完全是在理想状态下写代码。","小慕
决定先说一下比较直观的不同：
程序员A：在学校编程的时候，有着一头乌黑的秀发，现在发际线惨不忍睹；
程序员B：在学校的时候没钱觉得配不上女神，现在有钱了觉得好像并不是钱的问题？
程序员C：在学校起码能靠帮女同学修电脑和炫技装X，现在在公司连个可以装X的对象都没有；
程序员PHP：在学校的时候我不知道谁才是最好的语言，在工作中我终于明白……
言归正传，小慕认为在实际工作中的编程，跟在校期间相比，是
炮火纷飞的战场和与世隔绝的
象牙塔
之间的区别。
在学校里编程，不外乎三种情况：
一是课堂或课后作业；
二是期末考试或毕业设计；
三是课余时间参与维护的开源小项目。开发团队要么是学校社团成员，要么是同宿舍的几位室友，大多数情况下都是一个人同时身兼数职，承包了产品经理、开发工程师、测试工程师甚至还包括美工的所有工作。
在学校里编程，只要根据老师布置下来的课题，实现主要功能，经简单测试可以运行就算及格。你可以各种花式炫技，也可以随便应付了事，因为在学校里编程最主要的目的是：
能够将课堂上或者自学到的理论知识付诸实践，检验自身对于知识的掌握和运用程度。
在工作中的编程除了文首说的直观的不同当然还存在着许多深层次的不同，这些不同只有经历过的人才能明白。如果你正打算去做一名码农，小慕的总结会对你有一些作用的，具体有以下几点：
1. 工作中工具的使用呈现多样化
在工作中，需要使用公司专门要求的工具来完成编程，同时还有可能需要用到多种工具，这就需要程序员对于工具的熟练运用呈现多样性；而在学校编程因为实现的业务功能单一，所以使用的工具也较为单一，基本都是主流的IDE，相对要容易得多。生动一点地说就是在学校里，你可能只用一个电饭锅就能解决一顿饱饭，而在工作中，你可能还需要烤箱、打火灶、汤锅、炖锅等等更多的工具来完成。
2. 工作中，程序命名规范很重要
在工作中，代码需要遵循一套严格的编写规范，因为在工作中的代码不是属于某一个人的，它是需要大家共同维护的。阿里巴巴的开发团队就有专门的开发手册，每行代码都需要经过至少一次其他人的Code Review，因此，遵守命名规范利人利己。
在学校里写的代码可能没几个人会看，命名可以随意起int a、int b等等，最后只要实现功能就好，并且过后很少会被再拿出来看。而在工作中，从来不写注释或者简单注释几句的代码，一段时间之后可能自己都看不懂了，这种情况是不被允许的，因为这些代码可能会被持续使用很长的时间，需要不断地维护和更新。从某种程度上说，
你写出的代码就代表着你拥有的专业态度。
3. 工作中，测试的重视度高于开发
在工作中，相比开发的时间，写单元测试和接口测试的时间只多不少。一行代码可能需要好几行代码、好几个用例来测试，通常需要使用工具，按照规范的流程来进行调试。并且，在工作中，测试是重于开发的。就像生产一个玩具小汽车，设计出来，还要测试它能不能跑，跑得快不快，遇到撞击会怎样等等，在工作中的程序在投入使用前同样也是经历了无数次的测试，才最终与用户见面的。而在学校，大多数情况是这样的：代码写完运行一下、肉眼看一下，偶尔会使用工具，碰到bug可能会蛋疼一下午。
（举个栗子：项目上线发布后有个模块挂了）
4. 工作中代码量贵精不贵多
在工作中，解决同一个问题，能够用更少的代码的人水平更高，你写的每一行代码都必须保证是精华。因为在工作中代码写完并不代表结束，后期可能还要持续维护，就算你离开了，也要保证接手的人能读懂，所以写的代码贵在精而不在多。
在学校里编程，可能写的代码越多，会感觉自己越牛逼。有时候一天能撸上千行代码，感觉自己太牛X了，然而这在工作中并没有什么卵用。
5. 工作中，团队合作是常态
在工作中，你负责的往往会是一个大工程中的一个模块。完成一个大工程的开发工作是一个团队的事情，因此你必须学会团队合作，也就是说你的代码要让更多的人看懂，也能让更多的人拿来即用。
在学校，教的都是一些经典算法，解决些通用的问题，但是当面临实际的问题时，这些往往没有卵用。举个例子，比如排序算法，课本上有很多，有些同学甚至能将各种排序算法都默写出来。可他们永远不明白关系型数据库是如何实现排序的，因此当你问他们如果内存装不下所有数据该怎么排序时，他们只能一脸懵逼地望着你。
6. 工作中，性能要求更高
在工作中，可能一行代码面对的用户会达到上千万甚至上亿，所以就要求开发者在开发的时候要把很多可能会出现的问题考虑进去。也就是说如果你编写的是一个把猪肉放进去可以做成火腿的程序，你还要考虑到如果有人放进去的是一袋面粉，程序是否能够完成对它的加工。
以12306为例，在使用阿里的云计算平台之前，每年到春运的时候网站几乎都会因为访问量过大而瘫痪，铁道部受到铺天盖地的吐槽，这可能就是当时开发者没有考虑到或者是没有解决的问题。后来，随着阿里的云计算平台的支持，很好的解决了访问量过大的问题，还提升了网站的性能，极大的提高了网站的承载量及用户体验，口诛笔伐明显平息了很多。
而在学校里，我们写的代码充其量只是个小玩具，用户量一只手数得清，甚至在变成玩具之前就已经夭折了。在学校里如果你想实现苹果去皮的功能，只考虑这一个功能就好，很少需要再去考虑如果是一个橙子，该怎么办。
7. 工作中，时间分配多元化
在工作中，你的时间会被分配到多个环节，包括了解精准的业务目标，预研需要用到的技术手段、如何选型、详细设计、编码实现、配合测试、上线及上线后的维护等等。
每一步都都要评审，降低返工风险，具体到每一个项目时遇到的问题可能会更多，比如怎么测试，怎么部署，怎么更新，怎么监控和保证健壮性、效率以及规模。用户量多了怎么办，被攻击了怎么办，你依赖的东西挂了怎么办，你部署的环境变了怎么办。更深层的考虑是不是要开源？这个东西能维持几年？有啥竞争性的产品？他们都怎么样？下一步该做啥？等等等等……会多出来好多事情。所以工作中，coding所分配到的时间可能只是你的工作时间很少的一部分。
在学校里，所谓的编程更多的时间就真的只是coding,或者是通过算法解题，一个小的算法解决一个问题等等。这跟实际工作中的强度和时间分配相比，有很大差别。
8. 工作中，对代码质量要求更高
在工作中，代码要考虑可用性、易用性、安全性、健壮性等因素。假如你身处金融机构，哪怕一行代码出错，都有可能导致上百万、上千万甚至更多的资金损失。所以，对于你所撸的代码一定要常怀一颗敬畏之心，要经得起考量，质量比数量更为重要。
“
莫愁前路无知己，总有bug跟着你
”，说起来也是蛮心塞的！
而在学校里，只需要考虑指定的功能是否得以实现即可，即使存在问题也只是重新修改，或者请老师给予指正，不会带来实质性的影响，因此在Coding的时候也不需要非常的谨小慎微。
9. 工作中，代码会带来直接收益
在工作中，作为程序员的你，编程是你安身立命、养家糊口的基础，也是在职场彰显个人才华的根本，对于整个职业生涯的发展发挥着至关重要的作用。如果在IT公司或者互联网公司任职，技术太水的话是过不下去的，轻则拿不到理想的收入，重则与心仪的公司无缘。很多人都知道程序员的收入比其他工种普遍偏高，其实他们的投入成本也极大，可能每周工作996或者997。好在收入与所付出的努力能够成正比。
在学校里，完成作品带来的可能仅仅是精神上的愉悦，或者是得到老师的褒奖及奖励，与工作中的直接收益结构是完全不同的。也就是说：
在工作中，你在编程上的造诣越高，一般都会获得相应越多的收入。
但是，程序员的辛苦也是众所周知的。
所以，在回答的最后，请各位IT、互联网公司的产品经理大大，或者说，如果你身边有“程序猿”朋友，请千万记得一定要对他好一点，没事帮他捏捏肩捶捶背，没事多请他吃吃饭，多帮他买买单，编程的压力已经很大了，请理解他，帮助他，毕竟猿生已经如此的艰难，真要把天天加班又没有对象的他们惹急了，后果会是……
还有如果你是程序员的女朋友，想为程序员男朋友做点什么，那么请参考知乎用户 @韩食 的回答：
“我是一位程序员的女朋友。和他见面的时间不是很多，但是也不会有生疏感。他有时工作到很晚，压力也比较大，我尽量就是在他专注的时候不打扰，在他运行完一段程序后给他递上一杯热饮。没有工作的时候，我和他一起出去玩，去山林中休憩和在城市中探险。他之前也是一个焦虑的人，他现在是一个很开朗快乐的人。他生日的时候，我送了他一把机械键盘，本来我对这些外设也是一窍不通，也是慢慢查资料了解哪些更适合。把护眼灯调柔和一点，在座椅上摆上舒适和坐垫。我们一起的时候很快乐，真诚，信任。他抱着我睡觉的时候，我能感觉到他的疲惫，他的呼吸声也是我的安眠曲。 
然而，以上都是我编的。我是那个程序员，我没有女朋友（笑  ”
最后送大家一段程序员专用霸气代码注释：代码永无bug！！！
1. //                            _ooOoo_   
2. //                           o8888888o   
3. //                           88"" . ""88   
4. //                           (| -_- |)   
5. //                            O\ = /O   
6. //                        ____/`---'\____   
7. //                      .   ' \\| |// `.   
8. //                       / \\||| : |||// \   
9. //                     / _||||| -:- |||||- \   
10. //                       | | \\\ - /// | |   
11. //                     | \_| ''\---/'' | |   
12. //                      \ .-\__ `-` ___/-. /   
13. //                   ___`. .' /--.--\ `. . __   
14. //                ."""" '< `.___\_<|>_/___.' >'"""".   
15. //               | | : `- \`.;`\ _ /`;.`/ - ` : | |   
16. //                 \ \ `-. \_ __\ /__ _/ .-` / /   
17. //         ======`-.____`-.___\_____/___.-`____.-'======   
18. //                            `=---='   
19. //   
20. //         .............................................   
21. //                  佛祖保佑 永无BUG  
22. //          佛曰:   
23. //                  写字楼里写字间，写字间里程序员；  
24. //                  程序人员写程序，又拿程序换酒钱。  
25. //                  酒醒只在网上坐，酒醉还来网下眠；  
26. //                  酒醉酒醒日复日，网上网下年复年。  
27. //                  但愿老死电脑间，不愿鞠躬老板前；  
28. //                  奔驰宝马贵者趣，公交自行程序员。  
29. //                  别人笑我忒疯癫，我笑自己命太贱；  
30. //                  不见满街漂亮妹，哪个归得程序员？  
以上。
更多
慕课网
相关回答：
各个编程语言都有哪些「黑点」？
2017你觉得未来五年最具前景的一门编程语言是什么？
怎样成长为一个优秀的 Web 前端开发工程师？
程序员面试要准备哪些方面的内容？
2017 年你所在的行业和领域发生了哪些大事？","刚工作了三个月，简单谈一下我的感受。先说重点：最大的不同是
质量
。
质量是个很广的概念，涵盖方方面面。
1、规范性
在学校写的代码，除了你自己可能没有第二个人看，可以不写注释，命名随意起，int i、int a；在公司，代码需要遵循一套严格的规范，这样做利人利己。每行代码需要经过至少一次其他人的Code Review，我在学校自认为代码比较规范，结果到这里经常被师傅提很多Tala（修改建议）。
2、测试
在学校，代码写完运行起来跑一下、随便点一下就行了；在公司，相比较开发的时间，写单元测试和接口测试的时间只多不少，一行代码需要好几行代码、好几个用例来测试。我认为没有经过测试的代码等于没写。
3、性能（并发）
在学校，写的代码充其量只是个小玩具，用户量一只手数得清，甚至再变成玩具之前就已经夭折了；在公司，每一行代码要面对的用户上千万、甚至上亿，性能以及随之带来的并发问题不得不考虑。这就好比在公园盖一个厕所，装修华丽，环境很好，但是坑位只有五个，结果节假日几百号人同时上厕所，那场面自行脑补。
4、严谨
在学校写的代码，出错了最多被老师批一顿，改一下就完事了；在公司，尤其是我所在的支付宝，一行代码出错可能会带来几十万、几百万甚至更严重的资金损失，这种坑把我卖了都填不上。借用一位前辈的话：对你的每一行代码保持一颗敬畏之心。
最后回答题主另外一个问题：每天啪啪啪手敲成千上万行代码――我还没听说过每天啪啪啪就能敲成千上万行代码的人，不啪啪啪也敲不了这么多。
暂时想到的就这么多，后续有机会再补充。","刚开始工作的时候，还是个愣头青。那个时候最优秀的品质就是 速度。一天三千行代码啊………简直文思如尿崩。然后 一周之后 自己写的什么 回看起来就困难。好像是 乱扯的毛线团，虽然能用看着心烦。bug时不时的出来 撩拨你的神经。
大概过了两三年 经过几个项目之后，每天有个三百行 真是了不起了！不同是 写的少，错的少。功效倒是差不多。写的少 想的多了。代码结构从 过程化 到 对象化 到函数化了。建模从 点线面到立体 到 流，从描绘系统 变成了 描绘 用户体验流。
基本上经历了一个过程
比较语言哪个好，系统哪个好
到方法哪个好，思路哪个好
到代码范式，规范，美观，编程技巧
再到怎么样 最短时间 最低成本达到可用性要求，快速推进项目，不废话 不嗦。
到最后其实都是工具而已，脱离了情景环境单论好坏都是耍无赖。
代码外围的工作做的越来越多了，颈椎间盘突出越来越严重了。稍有不注意休息 就会有肢端麻痹和疼痛。
工作后很难和小伙伴打一局dota了，学校里 很难有认真严肃的项目。
诸位 注意保护颈椎，坐卧行 都是关键。","真实的工作中，一个合格的程序员并不是把所有时间都用来写代码。而是在脑袋里、电脑上，通过各种方式先把程序的结构、逻辑等等先想明白了，才开始动手写。
一个好的程序员不是产出代码量多，而是产出代码质量高。
牛逼的程序员一天写十行代码，可能比我一个礼拜写1000行代码还有用。","工作中的编程和学校里最大的不同在于：
在完整的流程规范下，同事间协同开发，按时按量交付，并不断测试迭代优化，最终能稳定的用于生产。
有人说这是软件开发，并不是编程啊。对这就是工作编程和学校编程的差异，工作编程不仅仅考虑代码，代码是为系统服务的，而系统中千丝万缕的结构都与编程息息相关。
比如作为程序员，你需要搞定设计文档、流程图、伪代码、接口、测试用例，冒烟回归测试等等，以及与产品经理、UI工程师、测试工程师、数据工程师等进行配合
所以你会注意到工作里的开发不仅仅是单纯地编程，它更像是修建一栋大楼，从规划、设计、审核、施工、装潢、再审核、交付等等，需要把设想中的建筑变成现实。而学校里的编程更像是设计图纸搭局部模型，今天做个浴室、明天做个厕所，而且用料标准也不固定，没法形成建筑。
因为我是做数据分析的。拿数据平台开发来说，一方面有任务流程、数仓设计、命名设计、调度管理等事项，另一方面SQL开发也有很多规范。
从需求调研规划、规范定义、模型设计、自动化开发，到测试验证、数据资产管理等都需要注意。
对于SQL开发，不是传统认知的写代码run成功了事。它有编码规范、注释规范、DQL规范、DDL规范、运算符规范、表别名命名规范、调度配置规范、数据同步规范、std清洗规范、分区规范、维表使用规范等等要求。
这是在企业数据开发中需要严格遵守的，可能在学校里写个SQL并不会考虑这么多。
除了开发流程规范的差异外，编程本身也有很大不同，就是刚刚提到的代码规范。
学校里编程基本都是书本上或者老师教的步骤，一二三四实现了就可以，很难用到实际开发里。
现在各大互联网公司都有自己的代码规范和code review，比如腾讯、谷歌。
腾讯员工发过一篇code review，简单列几个：
1. 对于代码格式规范，100%严格执行，严重容不得一点沙。
2. 文件绝不能超过 800 行，超过，一定要思考怎么拆文件。工程思维，就在于拆文件的时候积累。
3. 函数对决不能超过 80 行，超过，一定要思考怎么拆函数，思考函数分组，层次。工程思维，就在于拆文件的时候积累。
4. 代码嵌套层次不能超过 4 层，超过了就得改。多想想能不能 early return。工程思维，就在于拆文件的时候积累。
谷歌开源项目风格指南，对各种语言大型开源项目都给出了代码规范：
拿Python来说，它分别对风格规范和语言规范做了详细说明。
对于Python异常处理，有如下建议，异常必须遵守特定条件:
优先合理的使用内置异常类.比如 
ValueError
 指示了一个程序错误, 比如在方法需要正数的情况下传递了一个负数错误.不要使用 
assert
 语句来验证公共API的参数值. 
assert
 是用来保证内部正确性的,而不是用来强制纠正参数使用.若需要使用异常来指示某些意外情况,不要用 
assert
,用 
raise
 语句,
模块或包应该定义自己的特定域的异常基类, 这个基类应该从内建的
Exception类
继承. 模块的异常基类后缀应该叫做 
Error
.
永远不要使用 
except:
 语句来捕获所有异常, 也不要捕获 
Exception
 或者 
StandardError
 , 除非你打算重新触发该异常, 或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面, Python非常宽容, 
except:
 真的会捕获包括Python语法错误在内的任何错误. 使用 
except:
 很容易隐藏真正的bug.
尽量减少try/except块中的代码量. try块的体积越大, 期望之外的异常就越容易被触发. 这种情况下, try/except块将隐藏真正的错误.
使用finally子句来执行那些无论try块中有没有异常都应该被执行的代码. 这对于清理资源常常很有用, 例如关闭文件.
其他具体请看：
GitHub - google/styleguide: Style guides for Google-originated open-source projects
 
对Python而言是这样，其他语言有更多的规范，这个需要大家平时多练习、多思考。比如说多逛github、牛客网、leetcode等，持续保持对代码的敏感度。
牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网
综上，学校是学习编程基础建立认知的地方，很难把所学用到工程开发里。而工作是教会你怎么用编程创造有价值的产品，这其中有太多东西需要你去学习、运用、深化。","入行愉快。
首先，一言以蔽之，用两个字来概括，就是“残酷”，但是，好在是加引号的。让我慢慢说来――
下面这些都是看起来“残酷”的事实，有的不但残酷，还很无奈；有的则是在残酷的同时，还很有趣。搞工程和学校里的
象牙塔
大不相同，这也许老早就知道，但是绝对不是七八年前我想象的模样。你可以把它当成我没睡醒的呓语，也可以当成我喝多的胡话，或者是心情太差的时候写的吐槽檄文。反正，它们就在那里，事实就在那里。
总的来说，学校里面编程，或者在工作之余编程，是很有趣的，没有manager给你各种压力，也没有各种大神（比如TMP、PM、SE等等我都搞不清楚干嘛的职位）给你指点江山，你可以自己爱咋弄咋弄。当然，没有了这些“残酷”的痛苦，你没法进化，没法超脱，没法升华。
就从一毕业开始的荒唐的面试说起吧。国内的公司问的更杂一些，知识性的问题也问，有时我反而觉得更务实。而外企则很喜欢考察“能力”，我加引号是因为他们觉得他们在考察能力，实际却不见得。因为他们只是在考察80%的算法+数据结构，以及一点点系统设计，一点点扯淡能力，再顺道看看颜值如何啊，八字合不合啊，星座属相啥的而已。因此，这其中前80%东西都是可以准备的。而应试，恰恰是中国人最擅长的东西。我记得有朋友在我的blog里面回复道，特别鄙视刷算法题和面算法题这样的做法。我想，我可以和你“同鄙视”的，但可惜我没有那么崇高，而且他应该是没有很多去大的外企公司面试的经历，否则，应该去一边骂这个该死的面试方式，一边自己偷偷刷题去了。还有人说，FLAG又如何，某ACM拿奖的，某算法特别好的，某题刷特多的，但是工作却不出活儿啊。嘿，这样的人，我还真见过，也听人说过，但问题是，人家，钱，拿，得，多，啊？人家不爽了就可以跳槽啊？人家一跳就是不错的薪水啊？
既然聊到算法，那就继续下去。好吧，残酷的事实是，绝大多数软件工程师的日常工作，和算法的关系其实并不大。当然，和data analyst这样的职位比我们还是好很多，那个职位简直就是仅次于
产品工程师
的神级角色了，学经济学宇宙学物理学化工的，只要数学属性可以，只要会讲故事，就可以扯到伟大的数据分析上面，就可以表示“本人具备成为优质数据分析师的潜质”（好像也没有什么不对嘛，analyst们请不要打我）。好吧，话题再扯回来，面试考察的正是平时工作用不着的东西，换言之，原则是“什么用不着就考什么”，首当其冲的就是算法，而真正用得着的呢，以一句“Google得到的别考”搪塞过去了，于是这些自我感觉良好的公司中，工程师日常工作就是在和Google+StackOverflow战斗中度过的。尤其是MS，这家自我号称地球上最没有taste的公司，面试简直是为ACMer准备的，有的组简直是“来了就做题，做完就闪人”。Google问的算法题还算有新意的话，是那Facebook是对普通算法题要求
bug free
就让人和不解，bug free能说明什么问题，说明熟练，说明题目做得多，还是想说明一个人脑子这个
hash table
里面存放的题量大？
工作有多有趣？这是个好问题。其实，每当我们从一家公司跳到另一家公司的时候，也总会有这样那样的幻想，会对下一个让自己发挥的“舞台”有所憧憬。但是很多时候，我们面对的问题，都是“知识谜题”。说白了，就是那些“不知道的打死也不知道，知道的困难解决毫无难度”的问题。来来来，这样归纳一下，假设一个工程师每天的工作时间是100%的话，20%可能要吃饭喝水打望上厕所刷推刷微博吹牛逼闲聊，30%的时间要开各种傻里吧唧的会（这个估计够保守了吧），剩下50%的时间想干正事儿了，发现大部分都在干各种operation的工作，说白的就是编译构建部署安装搭环境改配置打补丁，余下总数的10%才是真正研究问题写代码的时间，发现各种乱七八糟奇形怪状的问题，各种在学习新技术的时候，看着那些玩具代码和hello world的时候，根本不可能想到的狗血问题全部冒出来了。就改了一行代码，居然这东西就不work了？就加了一个小小的feature，整个系统居然就挂掉了？于是，从外往里连蒙带猜，连分析带搜索，连Google带StackOverflow地试错，重要在某个人生中重要的时间点发现，又是一个知识谜题，又犯了一个二了吧唧的错。搞完这些东西，终于把自己写的那一点点小代码，像橡皮膏一样贴到项目组负责的这个庞然大物上了，嗯，it’s working it’s perfect。
别急，哪那么容易让你到达成功的彼岸？代码修改了要反复测试啊，测试的时候要考虑各种情形，调用一个API的时候说要接收一只老鼠作为参数，必须要考虑如果对方传过来一头大象怎么办。搞完这些东西，才可以去尝试code review这个苦难重重的关卡。发出去以后，等啊等，等啊等，居然没人review啊，那好吧我去催，挨个催。结果，幸福来得太突然，十行代码，二十条review comments，一度让自己对自己的人生观和价值观产生了怀疑。但是，仔细看了之后，发现其中19条是关于各种缩进符号命名大小写注释空格的，只有1条是具有实际的建设性意见的，终于松了口气，又是一轮改+催的流程……
更可恶的是，当你折腾完这些乱七八糟的东西以后，心里居然没有啥成就感，就那么点破事儿，居然整那么半天？于是你在第二天的sync up meeting上说，俺昨天做了xxx，yyy，发了个
code review
，里面代码修改其实只有10行。这就是一天又苦逼又繁忙的工作产出啊。更更可恶的是，有牛逼哄哄的同事A跳出来说，你这么搞是大错特错的，理由1理由2理由3，还有最核心的理由4，退一步说还有理由5，就在你心里想我擦妈蛋你这个马后炮为啥不早说的时候，又有一位牛逼哄哄的同事B跳出来说，如果用开源的/公司内部的/免费的/别的组做的/我曾经参与开发的，框架abc/库def/组件ghi/工具xyz，问题可以瞬间解决，言下之意，就是你眼瞎了，脑残了，活白干了，当初应该屁颠屁颠地跟在他后面求指导就好啦。
别高兴得太早，到了线上，还会有更多历练人生的有趣事情等着你。比如项目发布，比如on call（改线上问题）。有的问题紧急啊，就意味着你要拿着一个传呼机一样落伍的几千年前才用的东西睡觉。它也许早上响，也许晚上响，也许深夜你做美梦的时候响。总之，当它响了，你就得爬起来立即处理，看看是不是service又挂了？是不是你天天整的那个破玩意儿又不能访问了？还是哪个用户欠抽搞了个
false alarm
？说不定这个问题还真是由你提交的代码引发的呢，那就是bonus啦。所以不用怀念学校里那些美好的熬夜打游戏的美好时光，你会迎来新一轮的熬夜改问题的美好时光。
来回折腾若干次以后，环境终于搞定了，code review终于审过了，代码终于push了，集成测试终于跑过了，部署到线上终于没问题了……但是，淋漓畅快的成就感呢？在崇高和伟大之间对神一样的设计反复的斟酌呢？对代码像艺术品一样的华丽丽的无止境的追求呢？
以上，来自我的blog：
http://www.
raychase.net/","1.要学会在没有文档的情况下快速掌握一个轮子，这个轮子可能是某个大神的呕心沥血之作，也有可能是一堆傻逼拍脑门子想出来的东西。
2.要学会心平气和的改别人的bug，艹你@&%*&*&***&这种话要藏在心里。
3.规范！规范！规范！接口也好，命名也好，
也好，甚至是log，都请按照规范来。
4.如果不是大神，多听多看多想少BB，别以为还是开什么学习小组讨论会呢，不说话没人当你是哑巴，多说一句话就多暴露自己是一个菜B。实在要开口问问题，请先确保自己想过三遍，百度谷歌必应各一遍。
5.总结一下，热爱编程是一回事，正式工作的时候，请拿出应有的职业道德和职业素养。","看了一圈，貌似全是用语言敲代码的码农们在回答。我来说说数控编程吧。
数控编程是个什么样的概念？用通俗的语言来说就是用各种软件或者手工给一个需要数控机床加工的工件编写刀路。常见的编程软件有MASTERCAM，CIMATRON，Pro/E ，UG等。上述软件在算法和后处理方面各有特点和优势。初学者一般是根据自己最先接触的一个来进行编程。
我编程5年，从塑胶模，五金模，冲压模，汽车覆盖模还有各种零件产品和工装、检夹具都编。主要用的软件是UG。从4.0-10.0都用，带过的徒弟也不少，说实话。我不怕那种没有底子来工厂的学徒，相反我很怕那些从学校出来的学生。因为学校教的那一套往往在实际的操作中根本行不通。一个产品给你。首先你得想到这东西加工工艺怎么排，先铣哪后铣哪？先镗孔还是先铣型腔？图纸上没有公差的位置精度如何把控？这些都是从大量的实践中才能累积下来的经验。下面我会拿一个比较简单的辅助工装来举例。学校怎么教？我们怎么编？
通过CAD，我们可以看出这个工件的尺寸，公差，材料等一系列我们需要的信息。下一步是根据这个2D图在3D软件中画出3D图。得出以下的产品。
通过2D画出3D实体，这个也是基本功之一。可以看出我并没画出4颗螺丝孔的
沉头孔
。这个在实际中需要知道自己公司各部门的法则，或者和钳工师傅沟通。我们公司这些活儿都是给钳工做的，加工中心只需要点出中心孔即可。接下来我们要确定这个工件的加工工艺。
考虑到残料，刀路，和刀具的各方面因素之后得出加工工艺的顺序是先紫色铣型腔。再铣蓝色避空位，最后加工粉色凹槽。如果在学校，老师可能直接会教你一把刀开完。然而，在实际操作中，这是不可行的，原因是刀具磨损和加工时间太长，工艺不合理。建好每一步需要实体图，放入不同的的图层，开始加工第一步。
第一步：先开粗。要想刀路顺，刀路优化最好，先得改图。上图可以看出我将影响刀路的所有参数移除，只剩下我这步需要加工的6个型腔。考虑到不锈钢残料特质，我选择分出两个程序。各加工三个，这样能避免一次切削会造成的刀具磨损或者断刀。由于我们公司的钨钢铣刀最大只有D10的。所有没得选。用D10的平铣刀把6个型腔开粗。侧面余量为0.2mm，底部0.1mm
第二步：加工凹槽，这个很简单，移除所有参数。只留下3条凹槽，随便用个开粗或者走线的程序加工，侧面余量为0.2mm，底部0.1mm
第三部：加工避空位，先用抽取工具抽取出边缘线。这样加工的好处在于，2D刀路相对比3D刀路更好优化，刀路更顺。先用2D走线编写出其中一个或者两个，由于此工件是的加工坐标在中心，而且所有参数都是对称和镜像关系，所以剩下的避空位全部可以用点复制和程序镜像来完成，编1个得12个，省时省力。侧面余量为0.1mm，底部0.1mm。如果不能灵活变通用开粗或者等高的加工思路去加工，那会非常的耗费时间。
开完粗，开始中铣或者精铣，是否需要中铣取决于产品要求。我这个要求不高，所有直接精铣。
直接精铣，用2D走线选择打开的曲线。或者用开粗时抽取的闭合曲线都行，直接一刀过。余量为0。
一样的。
最后，点上中心钻，方便钳工打孔，齐活儿！！设置后切削参数后通过UG自带的模拟功能跑一次，如果没有问题，没有问题是指刀路没有干涉，没有过切等等。确认无误后进行后处理之后把编写好的程序发给操作工。程式单上注明家工坐标，单边还是分中，刀具规格，注意事项等。
数控编程讲究的并不是你能把程序编出来，它最难的地方在于你需要编写出最优化的程序。很多复杂的东西要考虑的远比这个负责得多。
老师可能会教你怎么编写程序，但是他教不了你经验，一整套塑胶模具扔给你，你要知道该从哪里下手。
如何下刀，如何抬刀，在什么时候该用哪种命令？遇到破面怎么办？每种材料的加工特性是什么？电极该怎么拆？火花位该怎么留？还有考虑避免伤到水路孔，分型面，胶位。斜顶，滑块这些该注意什么？
编程其实是一项很系统的工程。你需要的不止是会编写程序，还需要知道很多很多的知识。这就会促使我们更加努力的去学习跟数控有关的一切知识。学校的理论知识是远远不能达到的。前段时间公司招了个刚刚从学校出来的编程师傅，结果看他编出的一个小电极我就知道这孩子还是太嫩。编一个模仁上的镜像直角，还是没有异形的那种居然编了4个，粗精各两个。我给他说你这个直接一个解决，他很无解的看着我。我告诉他，首先这个地方加工中心是可以用铣刀加工到位的，只是会留下铣刀的R角。所以不需要粗公，只需要拆出一个电极然后镜像一个出来，合二为一放在同一个基准上面左右各打一次就行。这么点东西你拆除4个？老板不杀了你？这个例子也可以看出来，理论和实践真的相差很多。
最后，放点鸡汤，各位在机械行业的大坑里继续挣扎的朋友们，不要放弃希望。我们才是这个国家的基石！！哈哈哈哈哈哈哈哈哈啊哈哈。。","学校里，程序哪怕错了一百次，只要跑对一次，也算是及格了，也就是过了。
工作中，你跑对一百次是应该的，只要错一次，就是错了，就过不去。","以前老是幻想自己造轮子，造的多美多棒，上班之后慢慢的把技能点全加在快速学习别人轮子的使用方法上了
，实在找不到现成的才会自己造。
以前觉得代码才是王道，文档算个屁，现在觉得没有文档的代码算个屁，谁不写文档干死谁。
以前觉得码农主要工作是写代码，现在才知道主要工作是debug，包括自己和别人的bug
以前觉得程序要写的完美无缺才行，各种纠结怎么做，现在是在最短时间内拿个demo给甲方，demo多简陋都行，先看自己和甲方对需求的理解是否一致。
以前追求装B，现在追求简单高效
以前是输出错误到屏幕，现在是输出到日志
以前觉得注释是天经地义，后来看到个注释就欢天喜地","看图，
骚年悟到了么","最大的不同就是，学校里写的代码都是用完就扔，所以完全不管可维护性（这不是个好习惯）。
公司里写出来的代码大部分情况就要你一直维护它到离职了，写的时候就不可能不管可维护性了。
至于代码量，我在学校的时候经常一天上千行C艹，公司里我一天也就300行C艹左右。","学生正式走入社会进入工作岗位和在学校里还是有不少差别的，当然也不是说学校里学到的东西就没有用了，学校里学到的知识是帮助你巩固基础能更快的适应进入工作岗位上会发生的各种变量。
一、 版本管理
在大学里码的代码，往往只有你一人完成就可以了，可以说是一人吃饱全家不愁啦！所以版本管理的需求没有那么大。但是进入公司工作后，趋于多人协作，代码管理变得重要了很多。熟练运用 git，p4 等版本管理软件进行编程。版本管理的目标主要是为了使代码的开发流程更加清晰，当然，好的版本控制并不仅仅在于让代码更清晰。对于团队开发来讲，可以有效控制分工和权限。并且在协作的时候提供解决冲突的方法。
二、 代码规范，代码注释
在学校写的代码除了提交后老师批改以外，往往不用其他人阅读，但是在公司写的代码往往需要经受大规模的 review，你需要让阅读你代码的人迅速了解你代码的意义。
大驼峰、小驼峰：主要通过大小写来区分变量的用途，以及性质。
注释：注释主要集中在变量的用途和函数的用途上，注释言简意赅，让阅读者一眼扫过就知道这个函数的用处。
将代码按照功能抽到多个 scripts 中，不要聚集在一个 scripts 里。每一个 script 不要要超过 1000行最好。
三、长期维护、充分测试
上述两点的话，很多在校学生其实也会掌握对应技巧，在进行协作的时候往往也会接触到相关的需求。但长期维护和充分测试亮点往往就是实打实的需要在工作中学会了。
在学校的作业往往是有一个目标，实现对应的目标即可，其次提交作业时往往不会进行充分测试。
在工作开发的时候，无论是自己设计单元测试亦或是黑箱测试，都要进行充分的测试。
而且在之后迭代的时候往往需要针对一个线上版本进行短平快的开发，这是在学校完全没有过的体验。往往不允许你对项目进行重构，同时在开发时也要兼顾之前的内容。以及需要有快速的修复 bug 的能力，这种能力其实更多的依赖于你的代码，是否规范，有没有养成良好的习惯。
这里推荐力扣君另一篇回答，在日常的编程学习中注意培养良好的习惯会让将来踏入工作的你受益非浅。 
四、适当减少自我意识
学生时期是一个成长的阶段，你可以自由选择喜欢和谁在一起，不喜欢和谁在一起。而在工作中应减少个人情绪，融入整个团队，为了同一个目标而奋斗。
比如程序员与产品经理的沟通问题，力扣君作为一名程序员也曾体会过产品经理天马行空的需求，在处理这些问题时，力扣君总是告诫自己：避免冲突，增加沟通，共同解决。
初出茅庐的程序员有时会走向一个极端：将技术提升作为自己的最重要的目标，不愿意接收产品经理提出的没有技术含量的工作，或是不愿意破坏自己的现有代码结构去实现产品经理的奇怪需求等等。事实上，无论是程序员还是产品经理，我们都是给老板打工，为用户服务的。技术提升是自己的事，在工作中，产品体验才是我们最重要的目标。有时可以让你写一个超体现能力的算法或数据结构，但也无可避免的需要你写一下简单的静态页面实现数据检测。要知道，工作上安排的事情都属于业务需要，我们应当在工作时间减少自我意识。
四、抱怨--，方法++
学生时期，遇到不会的题目，总有学霸同学帮我们解决，或可以向师长请教。而工作中，交到自己手上的工作，解决的人只有自己。业内有句话说：老板招你进来不是希望你告诉他这个想法有多么难，而是希望你帮助他实践这个想法。
好的程序员
Never say no
，事在人为，方法总比困难多。当然这并不是说我们一味接受无理需求，沟通也是解决问题的办法。重要的是我们要勇于承担，对事情负责，这样才能得到更多的锻炼。
五、产品体验 > 自我提升
在学校，老师都会鼓励同学们创新，不断使用新技术、新知识提升自己，而在工作中却不能完全这样。不少职场新人都有一点标新立异，比较直接的体现在过度炫技，不爱用老技术，喜欢在工程中大量使用新技术，即使这门技术自己尚未完全掌握。诚然，我们不能否定创新的价值，然而将自己尚未了解透彻的技术用在实际项目中是可怕的。
工作多年的职场老手就明白，不要做第一个吃螃蟹的人，在公司项目中引进任何一项新技术都需要考虑再三。多数情况下，第一个吃螃蟹的人是踩着坑前进。在个人成长时，不断踩坑是好事，毕竟“失败乃成功之母”。而项目团队是经不起这样的折腾的，团队前进过程中不希望看到出错，我们走的每一步必须慎重再慎重。对此，力扣君有个建议：业余时间创建自己的练习项目，在个人项目中使用新技术不断试错，在公司项目中使用稳定的技术。如果自己感觉已经能够掌控这门新技术并足以应对其带来的风险时，再将其引入公司项目中。
认真看完力扣君所说的，你是不是也总结出来了，只要在大学时候拥有良好代码习惯，迭代周期优秀的人在工作时也能较快适应对应的变化。而大学时期的很多学习习惯是为了迎合老师和考试未必会在实际工作中被青睐，真正踏入工作岗位就应该随机应变，把公司的业务和目标放在首位。","打坐，修炼
洗髓经
，忘了学校，准备被喷
熟悉公司标准的桌面工具
熟悉版本管理系统及操作
熟悉业务基本逻辑，文档和业务书籍清单好长。不是所有的公司都是纯软件公司。就算是纯软件公司，商业逻辑你之前也基本没见过。一般这种文档要看3个月起步。在大公司？再加三个月都不止，越看越多。
一边看业务书，一边开始看代码，shit，这是多么古老的代码和语言！为啥都是java和C语言，卧槽还有汇编？卧槽这个语言是啥没见过，
pascal
？为什么不是ide的？为啥还在用
sourceinsight
这种古老的编辑器？
试着编译一下，卧槽这是个什么破编译器？编译器要用命令行调用，那些编译选项都是啥？工程文件里面的参数分别都是啥？
你带着代码语言和编译器问题愤愤不平地去找开发老大，老大翻了个白眼给你: 这系统20年了，这项目我们做了10年了。不服？啃完那边那堆带着卷边的语言书和编译器说明书去！
你一边啃着这些破烂古董书，一边继续看代码。卧槽这个调用接口是啥？书里面没有！卧槽卧槽卧槽，类似的接口好多，调用得还好频繁！
你满怀疑惑地找老大，老大说:哦，不好意思忘记给你内部接口手册了，服务器上有，注意有18个版本，你这个team用的是其中第6个版本的。 顺便设计文档也在上面，一起看看吧。
你上文件服务器一看，晕了，这个版本的内部接口手册563页，设计文档合计353兆，各种格式的文档都有，呃，这个文档最后一次编辑是在2004年4月。。。
开始琢磨代码和注释，与设计文档反复对比，搞清楚它们到底都在干什么，心中凛然。卧槽这里有个调用好奇怪，怎么直接读写地址的，绝逼严重违背软件编程常识啊！
跑去找老大，老大头都没回""地址多少啊？""
xxxx
去服务器上找""xxxx 芯片/传感器/执行器 手册""，顺便这个玩意在系统中的使用说明在""yyy子系统设计说明书""中有描述
尝试去修改代码，记得对照公司编程规范，否则交叉审视被默默鄙视。
信心满满地提交代码，编译还没通过，就被自动扫描工具喷得狗血淋头，然后你不甘心地将代码加长了10倍去预防低级错误。
编译通过了！功能测试失败！开始找bug，一定是自己改的代码出了问题。几个通宵下来，发现是隔壁组的修改了接口内部实现，shit！
。。。。。
被测试组头儿拿着性能度量报告喷得狗血淋头，抓狂地开始性能调优
。。。。。
老子不要被骂，自己测试！
师傅飞扑上来了一把拔掉插头，转头破口大骂""小混蛋你不做保护就要实际运行啊！""
。。。。。
这只是个纲要，而且还没写完。","差别很大。最近一直在洗数据，就拿 SQL 来说，学校里学到的大多都是一些常用的用法，事实上即使是公司里的开发，日常做业务需求的那种，用到的 SQL 技巧也是有限的。
我第一次有这种经历是因为在上一家公司，数据库是用 PostgreSQL，所以每一次改动都需要给 DBA 过 SQL，要求是必须每一条改动的 SQL 都需要用 explain 跑过之后对比改动前后的 rows 以及时间，保证改动后与之前差异不大，至少要保证所增加的压力在目前机器数量下，最高峰的压力可以保证服务可用性，才会允许上线。
我第二次有这种经历是因为目前所做的事情，虽然我应该是一个写业务的 RD，然而我现在却是日常洗数据，写 SQL 写到想吐。讲真，日常开发有多少机会会用到 case when，coalesce，if as，concat_ws，group_concat 这些东西的。当然并不是说不会用到，只是机会真的很少，所谓贫穷限制了我的想象，业务场景真的会限制你的发展，当你遇不到的时候你永远不会想到，窝草，还有这种情况？这大概就是所谓的，哪怕是最简单的排序，当数量级很大的时候，都是一个难题。
以上，只是简单举了一个 SQL 的例子，就更不要提，学校里写的东西大多不需要考虑什么并发，而公司里的东西由于流量大、并发高，除了加机器以外更需要提高自己的单机 QPS，即使是加机器，也要考虑各机房机器分布，流量分布，这中间可能会遇到的问题，所需要的解决方案就不是我们在学校所能遇到以及想到的了。
简而言之，刚毕业的我已经被虐的不要不要的了。不过，我觉得从学生到工作过渡的过程中，对我而言，最艰难的一件事是意识，很多东西第一次做，是没有意识的，这个比你没有见识过更可怕，可怕的就是你见识了，但是你却没有意识。"
,,,,,,,,,,,,,,,,,,,,,
你碰到过的最难调试的 Bug 是什么样的？,"在 Quora 上有一个和 Bug 相关的热门问答帖：《
What's the hardest bug you've debugged?
 | 你调试过的最难 Bug 是？》我大中国的程序员攻城师们遇到最难调试的bug是什么呢？欢迎吐槽！","写一个热乎的，刚发生的：
写JS，自己手机没电了，拿同事老张的安卓机调试，很简单的获取用户微信昵称，结果死活获取不到，一直显示为null。应该是跨平台问题，因为之前在自己iPhone上是没有bug的，拼命看api文档，但是都没提到这方面。急死我了。
―――――――8.21更新―――――――――
刚刚老张告诉我他的昵称就是null。
答主的其他回答：
有哪些听起来高大上实际上很普通的东西？ - 条件状语从句
在网吧写代码是怎样一种体验？ - 条件状语从句
PPAP 为什么突然之间就火了？ - 条件状语从句
哪个瞬间让你突然觉得读书真有用？ - 条件状语从句
为什么乔布斯和扎克伯格都有传记式个人电影，而盖茨没有？ - 条件状语从句
为什么总觉得日本的很多地名比中国的听起来有味道？ - 条件状语从句","实在忍不住了，第一次答题。
       08年的时候，我所在的公司调试三星的一款新的arm9 CPU，型号是S3C2416，是S3C2450的简配版。开发板刚入手的时候还是热乎的，因为三星的这个芯片刚刚出来，国内的代理商一共就几块开发板。各公司评估开发板都是分时使用的，只能预约几天。开发板入手的时候，三星那面连
BSP
都没有准备好，没有test code，没有u-boot，没有linux-kernel，甚至连
Spec
都是错误百出。还好我公司虽然小，研发能力在本地区还算不差，没有的东西可以自己移植。
       公司急着要出新品，在没有完全验证处理器的情况下，已经layout好了PCB，并且去打样了（当时竞争确实比较激烈，400M主频处理器而且这么低的价格绝对非常有诱惑力，所以公司决定冒这个险了）。在没黑没白的工作两周后，硬件和软件做的都差不多稳定了。这时候经理说，功能上问题不大了，我们来调一调休眠时的功耗吧（我们的产品一直以待机时极低功耗作为产品的卖点之一）。然而这却是噩梦的开始……
       公司的指标是待机时休眠电流500uA~800uA（电源电压4V）之间。以前所有的产品都在这个范围之内，三星方面的技术支持也明确表示，他们的解决方案达到这个指标。
       在我们调试过程中发现，整个系统休眠时的功耗在1800uA左右，一直降不下来。我们重新核对了所有的IO和外围电路的所有连接，以及IO口的电平配制，都没有问题。这时，我们决定测试每一个单元的功耗，用电流表分别串联进每一个外围电路，每个单元都很正常，就是系统总体偏大1000uA。
       我们连flash和ram的待机电流都测过了，仍然正常。好了，通过排除法已经确定了就是CPU的功耗过大。但是在开发板上调试休眠的时候，CPU功耗却是正常的。
       我们怀疑是开发板上CPU批号和我们自己拿到的CPU样品的批号之间有区别导致的，因为三星那面也在同步修正CPU的BUG，所以我们“大胆地”把开发板上的CPU用风枪吹下来，换到我们的PCB上，把我们的CPU贴到了开发板上进行交叉验证。结果是开发板仍然功耗正常，我们自己的板子上功耗偏大，还是大了1000uA。
       CPU周边的核心电路设计出现了问题！这是我们一致的判断！但是问题出在哪里，我们反复核对开发板的原理图和我们自己板子的原理图，简直就是一模一样！因为整个核心电路这部分就是从开发板上抄过来的，实在没有什么可比对的。我们转而又去怀疑PCB的问题了。
       我是做系统移植和软件的，纯电气的问题我就无能为力了。闲着没事，我就反复检查我在linux中对系统休眠的IO引脚配置。然后挂着电流表做反复测试。电流表也对的起我，每次都是那个数。在一次系统待机的时候，我实在忍无可忍，一把抓起了板子。突然之间，电流表的读数飞快下降，降到了300uA！我松开手电流表的读数就又爬回来了。我把我这个惊奇的发现告诉了同事――一个硬件工程师。同事说可能是哪儿摸短路了，让我试试还能不能唤醒系统。我给了一个外部中断，系统神奇的正常唤醒了！
        “难道这就是问题？”，我想重现一下。但是再次在待机的时候抓起电路板的时候，读数并没有显著发生变化。“可能是手法不好”，我这么想着，用手在板子上继续抚摸着。果然！当我的手指按到PCB中的某一个位置时，电流又降了下来！反复试了几次，都是这样，就是在我手指按压的这一片，只要是用手指按着，电流就正常！
        这回同事开始重视了，打开PCB图，拿着电路图和万用表，查查我摸的到底是那块电路。硬件工程师觉得不可思议，因为我摸的部分并没有连接任何的电路――焊盘是空的。他于是用万用表的表笔去检查是不是PCB制版的问题，测一下这些空焊盘到底哪一个有电压。但是万用表中没有读数，这块都没有电。但是当万用表的表笔落在一处空焊盘的时候，电流表的读数又降下来了！
        这可是重大发现，我们对照了一下电路图。这处空焊盘是CPU中USB-Host模块的D+信号。由于我们的产品不需要USB的主机功能，所以这一块儿没有做任何处理。多亏了画原理图和PCB的同事，多留了一手，把USB Host的引脚都在PCB上做了个引出。谁也没想到是这个引脚出现了问题，辛亏这个信号引出来了，要是没有引出来，一辈子也查不出问题。我们给D+信号加了一个下拉电阻后，系统的功耗瞬间正常了。
        事后分析，三星自己开发板上有USB-Host的功能，所以USB-Host的外围电路也是完备的，所以功耗不会有问题。但是我们自己的产品上不使用USB-Host功能，没有相关外围电路，所以出了问题。这是因为在CPU休眠的时候，D+信号内部被悬空了！一句话，是三星CPU自己的BUG。我们修改了我们的PCB，增加了一个
下拉电阻
，同时将问题反馈给了三星。
         一个月后，当我们的产品量产时，三星也及时的解决了这个问题。那个下拉电阻也不需要再贴上去了。
         最后用手指头找到了CPU的BUG，不知道这算不算是最难调的。
         反正这么多年了，这个经历留给我的印象是最深的。","评论里信誓旦旦要小护士的兄弟，你真觉得长着一张工程师脸的你能搞定么？ 木有高富帅的命，却得了高富帅的病……洗洗睡吧亲，一个成功的工程师是注孤生的……
XXXXXXXXXXXXXXXXXXX 
网络硬件相关
现象：
某医院部署的网络，不定期会有半夜断网或者不稳定情况，但天亮就会恢复，客户投诉抱怨。
调试过程：
现场查看全部网络硬件正常，查看log发现有一台汇聚交换机有反复重启动作，在重启前有高温告警。于是重点关注该机器。
该机器放在一个机柜中，机柜在一个小储藏间的角落里，储藏间不大，一边还摆着张破沙发，正好可以坐着用电脑调机器，但是实在查不出什么可疑情况会导致过热，因为投诉等级较高，于是连夜蹲守。
第一夜无事。
第二夜无事，到半夜，忽然进来个小护士，吓一跳，说，哟怎么有人啊，然后就走了。一夜无事。
第三夜无事，到半夜，又来个小护士，探头看一眼走了。一夜无事。
第四夜无事。
于是告诉院方，发现问题马上打电话，回家。
第五夜出事，赶到时已是早上，网络已经正常，查看log发现还是过热告警重启，时间在半夜3点多。联想到前几天的小护士，于是问院方半夜是否有人进入，答一些值夜班的护士会偶尔在里面休息。
于是找到进去的小护士，问是否动交换机，答没有，问进去后做了些什么动作，答只是睡觉。再追问，除此之外呢？答：就是那个排风扇太吵，睡觉的时候把电源拔了。
她把机柜的冷却排风扇电源拔了！
她把机柜的冷却排风扇电源拔了！
她把机柜的冷却排风扇电源拔了！
她以为就是个通气风扇！
居然睡醒走了还知道再插回去 _
你有胆拔插头你倒是别插回去啊…
EEEEEEEEEEE分EE割EEEEEEEEEEEEE
再说一个吧。
研发的一块新电路板，调试正常，往机箱里面装，装上螺丝拧好后不上电了，没有电压，确认是电源短路保护。
把板子拆下来，又能用了。
装上去，又不能用了。
跟白鹿原里
白孝文
在窑洞里穿裤子一样。
机箱是金属并且接地的，检查了全部连接，电源肯定木有碰到地，但是用万用表量的明明就是电源地短路，而且就是裸板能用，带机壳就短路，于是怀疑螺丝。
螺丝都拧上就短路，都拆下来就正常。
然后挨个拧螺丝，定位到某个螺丝。
那个螺丝一拧上就短路。
但是电路板正面反面都是地，螺丝本来拧上去就是为了接地用的，怎么会把电源短路了呢……
这tmd不科学啊。
仔细端详该螺丝孔，发现内壁有些黑，凑近闻略有焦味。心里大概有数了，一查pcb图，果然，6层电路板，内层电源层的铺铜几乎直接铺到了螺丝孔，安全距离只留了一点点。
其实本来也没什么，螺丝只是固定用的，不会和螺丝孔内侧有什么触碰，好死不死的那块板子那个螺丝孔公差偏大，螺丝拧上去是没有完全对齐的，直接卡到了螺丝孔内壁……使劲一拧，就像刀一样切了进去，碰到了内层电源。
所以，所有灾难，都是一连串小概率事件的巧合扎堆，搞科学，也得信命。
------------------------------------------------------------------
补充备注一下，这都是很多年前的事情了，以现在的技术而言，第一个case即使机柜风扇关几天都不会有问题，芯片的可靠性和工作温度范围已经有很大的改善。第二个case则是安规设计规则的低级错误问题，只要正常按照安规的规范审查，是不会有问题的。","2017年1月17更新
好像最近这个帖子又被翻出来了，又陆续有一些朋友点赞或者留下评论，谢谢大家！有一些大家共同关心的问题，我在这里做一些统一的回复，谢谢！
1. 那哥们后来怎么样了？
没怎么样，混的不错。去Intel继续祸害大众了，哈哈
2. 同行啊，请问答主目前哪里高就
现在混互联网。搞了家小公司。不写BIOS很多很多很多年了
3. 300万行代码如何编译成不足8m的rom?
这个问题问得很好。首先300万行的规模是整个项目的规模，里面包含有几乎所有硬件的platform code，事实上在每个特定的主板上，是要做一些裁剪的，把一些这个主板没有用到的硬件代码去掉；其次这300万行里面还包含所有的工具代码，makefile，配置文件等等等等，尤其是工具类的代码，除去编译以及连接工具，大概有几十个自行开发的工具要参与构建过程，整个BIOS的构建过程首先就是先构建这些工具，然后再用这些工具去处理配置文件，创建总的
makefile
，在一步步的逐渐的去创建各个模块的makefile，最后再根据最上一级的模块配置文件来逐步的构建每一个组件。当这些组件都生成了，再根据预先配置好的FLASH的存储结构，按照相关的规范来打包成ROM文件，压缩格式是略微调整过的LZMA，按照FFS规范来进行存储
我那个时候（2005年 - 2010年），编译工具用的是VS2003 + MASM；后来听说他们升级到了VS2010，貌似也可以用GCC了，好像也可以用Intel C Compiler
2015年8月23更新
评论里有几位朋友对于我提到的BIOS有上百万行源代码表示不可能，甚至有一位朋友提到BIOS就是个boot loader，要那么多代码干什么？我想我有必要在这里做一些简单的说明。
在说明之前，我首先要申明一下由于我2010年就已经离开BIOS行业了，并且之后的日子我并没有持续的去跟踪最新的技术趋势，所以我对于目前的最新情况并不了解，事实上这个行业的知识刷新速度看起来非常快。所以我这里说的其实还是基于我当年的知识构成。
首先，目前的BIOS都是基于UEFI的新一代BIOS。这类系统本身就具备十分强大的功能。完全可以视作一个小型的操作系统，有自己的shell，自己的drivers，自己的app，甚至自己的图形环境。这样的系统的代码量自然不会小。
其次是因为x86系统的历史包袱非常非常严重，而bios作为最核心的系统固件承担了太多的历史兼容性的责任。举个例子，就是对于usb键盘的支持，大家可能会简单的认为，支持一个usb键盘那不是太简单的事情么？的确是这样，但是个人电脑有一个非常非常重要的原则就是兼容性。具体到键盘上，如果你现在找一个古董级的PS/2接口的键盘，然后把它接到现代的主板上，假如你的主板已经没有PS/2接口了，那么买一个转换头，然后再接上去你会发现这个古董级的硬件仍然可以使用。是的！对于我们用户而言，这是完全符合逻辑的一件事情。但是对于bios开发者而言，这就是一个很要命的问题了。原因很简单，我们暂时穿越到几十年前，那个年代的电脑主板上都有一个叫做8042的芯片，用来控制诸如键盘这样的外设，那个时代的开发者通过读写60H以及64H端口来访问键盘，然后那个时代的汇编BIOS则提供了INT 9H中断来为应用程序提供键盘服务，在几十年前那个时代，这一切是很美好的。那个时代的操作系统DOS就是这样来访问键盘的。现在让我们回到更加美好的现代，由于历史兼容性原则，所以现在的每一台计算机还必须可以安装DOS，还必须让DOS或者运行在DOS之上的应用程序可以无差别的运行在现代的计算机之上 - 可是，大家是否知道，现代的计算机压根没有8042这块芯片！更要命的是，后来人们发明了一个叫做USB的新玩意儿，基于这个新玩意儿的键盘根本不会接到60/64端口上，而且这个新接口的键盘采用的编码与过去PS/2接口的编码完全不一样！那么如果不做任何处理的情况下，那些过去年代的软件压根不会认识新的键盘，所谓的历史兼容性根本无从谈起！所以我们伟大的bios这个时候就扮演了救世主的角色了，bios会做很多处理，以现在的角度看，现代bios模拟了一个PS/2键盘：现代bios一边读取来自USB键盘的信息，一边将其转换成那些古老软件能够识别的键盘编码，然后再中断系统，写入内部的60/64端口的缓冲区。大家也许会发现，所有的现代bios里会有一个设置项，一般叫做legacy USB Support，默认值就是Enable，打开这个选项你才可以在DOS下使用usb键盘。当然，具体的实现过程异常复杂，涉及x86处理器最神秘的SMM模式，我们就不展开讲了，这已经远远超出本文的初衷。所以一句话，bios的代码非常复杂，还要包含大量的历史兼容性代码，除了我们上面谈及的键盘问题，还包括比如INT 10H的屏幕服务，据说直到Windows 7的安装程序，还有一小部分使用INT 10H来写屏。那么我们的bios就必须包含这些可能有些用户一辈子也用不上的服务。代码量刷刷的就上去了。
--------------------------
每次想起这个bug，虽然很多很多年了，我仍然满脸都是泪水啊！
当年做x86 BIOS，客户是长城电脑。有一回我们的新版本发布给他们后进行系统重启测试，就是安装好操作系统后反复不停的重启机器，看看重启几百上千次后情况如何。原因是客户买了电脑每天用，至少得保障人家用个俩三年没事吧。
结果我们的新版本重启到一百多次的时候挂了，现象就是开机黑屏，没有任何输出，就和当年的CIH病毒发作一模一样，经验判断系统压根还没有boot OS就跑飞了，我们自己测试也是这样，而且一旦出现问题就只能重新刷BIOS
这个bug非常难调，因为当时我们的版本将近300万行源代码，大概2%的汇编与98%的C，几千个源文件，光是用来参与build过程的工具就有十几个。而且这些工具都是自己写的，构建项目的时候先编译这些工具，再去用这些工具加编译器来生成最后的ROM文件
并且更加恼人的是，我们当时没有source level的debug tool，甚至连汇编级别的单步调试工具也没有，压根没法对代码做step into/over，更没法加个断点。。。当时可以用来调试BIOS的工具有两个，一个是Intel自己内部用的ITP，这个是人家公司自己的，一般不给外面人用，当时我们公司与I公司的关系尚处蜜月期，给了我们两个，但是当时被Chipset team霸占着做porting用；另一个工具就是American Arium（这家鸟公司不知道现在还活着不），这个东西说白了就是商品化的ITP，因为目标客户少，所以价格巨贵巨贵！一套系统价格几万美金，而且每一代CPU都要换一个插座上的适配器，这个适配器又是一万美金好像，还不太稳定，用着用着就挂了。。。我们公司当时有俩，但是因为没有买新一代处理器的适配器，于是只能吃灰了
于是我们唯一的调试手段就是serial debug，就是系统启动的时候会通过port 80把一些重要信息打出来，然后我们根据这些信息判断执行到哪里了，系统的情况如何。这类似原始的printf打印。如果要看一个变量的值或者验证一下我们的判断，就得重新写代码，在需要的地方加入调试语句，然后花上半个小时rebuild bios，再重新烧录，再上电运行看看打出来的到底是啥。如果有疑问，或者发现这里没有问题，又或者有了新的思路，重复上述过程。记忆中整整一个礼拜，我们都在不停的看debug info，反复烧录bios 哭啊！简直不是人过的日子！
最后发现系统可以成功的跑过PEI，到了DXE阶段的某个环节，突然就像心脏骤停一样，跑飞了！去看疑似跑飞的DXE Driver，是个很普通的平台硬件初始化程序，没什么疑点，压根没有头绪。那段时间，几乎每时每刻都在想着这个bug，实在是茶饭不思，根本没心情做任何事！
就这样差不多过了俩礼拜，经过了无数次的重启与烧录bios，以及猜测，验证，被否定，再猜测，再验证，再否定。。。。。的过程后，我们终于发现了问题的原因：
大家可能还记得电脑主板上有个CMOS，传统上用来存bios设置，但是现代的系统已经逐渐弃用这个东西。我们现在的bios芯片都是可擦写的，也就是用程序可编程。bios大小是8MB，里面会规划好，哪里是code，哪里放设置等等，然后代码里有专门写flash的函数，让大家可以保存一些东西，比如你想用硬盘还是光驱启动等等。同时系统每次启动也都会自己写一点没什么鸟用的信息进来。
问题就出在这个写flash的函数上，我们后来发现，这哥们算错了存储区域的地址，导致写很多次后终于越界，误写到了人家代码区，把人家好端端的代码给写的乱七八糟，就如同当年CIH破坏系统的方法一模一样，照这样哪个机器能点亮才怪呢！又因为每次系统写的信息不一样，比如启动时间就不太一样，所以越界需要的次数不是恒定，更加重了我们排错的难度，泪啊！
第一次写这么长的回答，还是手机打的，累！","**************************************************************************************
2016.8.29 咋最近这么多赞，莫非来了很多考古学家？
既然这样，顺便发一个刚刚发生的真实案例，绝对真实，有血有肉！！（Debug 案例2发在原答案下方）
================================================================ 
原答案：(Debug 案例1)
======================================================================
    差不多10年前，我们做了一个ARM核的芯片，据说还是国内第一批用ARM7做的，还挺高端，带有很多安全功能，当然安全就意味着难以调试，整个系统全部打散，不能分块。俺负责前端设计，系统，硬件软件驱动等杂七杂八一堆工作。
    然后芯片流出来了，封装回来，几天几夜的调试，功能都正常了，那个高兴呀，第一个芯片就成功，奖金有了！
    不过做稳定性测试时候有一个问题一直困扰着，这系统总是莫名其妙的有时候启动不起来，概率有个百分之几左右。上电就是不LOAD。而一旦起来之后，就很容易了。
    反正功能设计，硬件，驱动都是俺的，那就调呗，软件，硬件，电路，仿真，研究了好几天，抓狂，无解。又整个系统不能分块，我都开始怀疑是不是ARM核的问题。。
     又做了一个不断重启的测试系统，不断啪啪响上电断电，针对上电的情况作了统计。得出结论就是，上午不启动的概率高，下午不启动的概率低，晚上不启动的概率高，深夜不启动的概率低。。。。。和饥饿程度快挂钩了。。。
      那时候那个抓狂啊，怀疑是什么干扰的，连屏蔽房，隔离电源啥都整出来了。就是没头绪，而公司给客户演示的时间快到了，要是现场挂掉就丢脸了，心里那个急啊。那段时间，每个深夜，公司里就是我座位上啪啪啪的声音------继电器的啪啪声。
      接下来一个周日测试，公司空调坏了，汗流浃背，脾气极坏，几乎就要摔板子了。不过发现这天运气非常好，成功概率很高。没头绪，直接抽上烟，看着板子发呆，不知那根神经搭错，直接把烟头对着芯片戳上去！咱第一个亲生芯片！！如果不行了就掐死它！！！结果发现怪了，戳了烟头，启动哗哗的，每次都OK。遂怀疑是
尼古丁过敏
或者是温度原因。拿着烙铁烫着它，每次必成。于是送进高低温箱，做温度曲线测试，发现环境温度40度以上，成功概率极高，刚好碰见今天加班没空调，平均温度高，所以表现良好。而启动起来因为系统一发热，所以后面启动就容易了，温度一凉下来表现惨不忍睹，敢情这芯片是非洲来的。
      有了方向就好说，先解决DEMO，给领导好看。遂做了一个电热丝发热电路，贴在芯片上，用单稳开关控制，一上电就加热，然后不断自动啪啪啪对芯片重启，一旦芯片重启成功了就断开发热电路和重启电路。进入正常运行情况。系统搭起来一测，效果杠杠的！！！基本都能保证几秒钟内就能启动，公司上下一片赞誉。 于是，领导拿着这套带着电炉丝的系统去做报告，销售拿着这个电炉丝Demo去给客户演示，取得极好成功，老板都在准备后续的销售计划了。俺心里急啊，总不能出货产品也带着电炉丝吧。。。。
       静下心好好分析，和温度有关，又是随机故障，应该很可能是哪个地方悬空，存在不定态的问题，外面的电路是不可能了，前端模拟加入随机量也不能重现，那很大可能是后端的人搞的鬼，遂拉来后端人员(暂且称为C公司)，检查扫描链和测试电路，果然发现有一个寄存器没有初始化复位。于是后面的情况就简单了，往扫描链中灌入一串数据，把未知量洗出来。成功！！！
       所以我们第一代的产品，主芯片旁有一个奇怪的芯片。据线人报告，有竞争对手和盗版者都认为这是安全反盗版电路，因为拆掉这一块，系统工作就时不时的异常，抓不到规律，可能包含短时间正版验证，长时间正版验证，随机正版验证等高精尖反盗版措施。反正无法破解。。。。
俺笑而不语。图样图森破。:)
---------------------------------------------------
至于说为什么寄存器没有初始化复位没检查出来，我也不知道，这是人家C公司做的后端，他们的软件自己加进去的电路。而据说这C公司虽然牛，但那时候后端服务还是新的，软件也是新的，刚进国内，给我们一个特惠价做白老鼠。。。
=====================================================--
=
=(Debug 案例2)
=
=====================================================--
最近把家里的台式机搬到了客厅，虽然台式机和电视机都很少用了，但本着发挥余热的原则，接了一根
HDMI
线到电视机，于是可以
双屏显示
了，用奇艺投放视频到电视机中，一家人一起看，效果杠杠的，俺还可以在边上显示器上一边刷知乎，各得其乐。
不过呢，原来用的是天威宽带，看大网站的视频速度还行，因为天威有CDN. 但看不热门的网站，或者720p的节目，就相当的卡顿了。于是说服老婆大人，改为电信光纤，在沙发的地方放光纤猫， 因不好拉网线跨过整个客厅，于是用了一个TPLINK的多频无线路由器，通过5G WIFI连接电脑。这下载速度相当的满意。看视频也是可以选择最高清晰度的。不过呢最近都是下载蓝光大片，不看在线了，原因无他，爽。
这两天，LP大人想看一些新片，于是俺用奇艺找到电影，然后打开电视机，拉到电视机中播放。LP大人很满意。 可是蹊跷的事情发生了。无论是什么电影，只要放上去几分钟，马上就卡住，然后就不能放了，网络全断，PING 路由器也出现大量的掉包率。。。。然后再也不行了，浏览器也上不了了，切换其他视频也不行了。 重启电脑偶尔能连上，也是断断续续。 但是平时上网或者在显示器看视频，又是从来不出问题。
又有一天，不死心，打开浏览器，开始播放，然后暂停，然后等LP回来了投到电视准备一起看，结果看几分钟后就断网。。。
又有一天，LP大人自己找了视频，看了一段，然后暂停，准备一起看，结果投到了电视，过几分钟又断网了。。。
不过只用显示器看视频貌似没问题。。。。
每次只要LP大人想要看视频就看不成，看着领导败兴的样子，亚历山大。。。
于是查硬件，查软件，挪天线位置，切换2.4G, 5G， 似乎都没有反应。
查了网络上的信息，据说这个INTEL AC-7260 无线网卡似乎确实有网络兼容性问题，貌似我还真的是MSI主板：
这下中彩了，按照网上的信息修改设置也没用！据说最好的方法是换个网卡。于是向LP申请了2万块换一台一体机，未遂。
于是作为一个技术宅，摆了一个亮骚的机器，却无法让LP舒服的坐在沙发上看电影，俺多年来修理水龙头遥控器电灯泡积攒的权威性日渐消失。地位一天不如一天。。。
今晚不死心，又折腾了好久，重启电脑，路由器，拔掉所有外设。故障照旧。。。
现象总结：
1.用网线没问题。
2.只用电脑上网看视频没问题。
3.上网的时候家人看电视没问题。
4.把电脑的视频投上电视机，刚开始几分钟没问题，接下来就几乎连不上网了。然后再怎么重启，也很难连上，连上也是断断续续的。
（感觉就像家里有个幽灵，一看到我献殷勤，或者看到电视机被电脑占用就耍脾气。。。。莫非是贞子？？）
突然，
灵犀
一动，仔细分析了
坐着沙发看视频和趴在电脑前看网页
的区别。发现这主要区别应该在于电视机的问题，于是开命令行一直PING路由器，同时切换电视机，发现只要电视机在显示PC内容，必然会断PING，关掉电视或者切换到别的源，就没有问题。看了应该是多屏或者输出的问题，试着修改HDMI分辨率，从720P60 改为1080P60，PING非常流畅！ 
问题顺利解决
！！！俺又可以在家里当大爷啦！！
问题分析：
HDMI线有干扰
，影响到了WIFI信道，加上这个AC7260无线网卡本身设计不良，容易串入干扰。由于HDMI工作频率是根据视频信号码率决定的，通过修改分辨率，改变HDMI工作频率，使干扰谐波信号跳开了2.4G和5G信道。另外通过HDMI传输信号会有一个接口协商初始化过程，只有电视机切换到这个HDMI源，完成初始化，才会在HDMI线上有数据，这点和VGA,YPBPR等模拟信号不同。
之前分析问题没有往HDMI方面想，主要是视频播放会有一个缓冲，因此，刚开电视切换到HDMI的时候，一切看起来是正常的(但此时后台网络已断)，过了几分钟缓冲读完了才停顿。因此分析问题时很难和HDMI线联系上。
此问题其实做音视频类产品的项目经常遇见，由于HDMI频率高，传输长，因此很多输出源有意加重输出信号，导致EMI干扰严重，又由于很多HDMI线材质低劣，偷工减料，缺少屏蔽措施，因此HDMI接口往往成为电磁干扰的重灾区，也导致大量HDMI接口的兼容性问题(我这个破电视就挑信号源，有些1080P不显示)。因此能用YPBPR模拟线，或者能用DP接口，我都是躲开HDMI的。
****************************************************************************************
****************************************************************************************
****************************************************************************************","也谈谈自己遇到的一个bug吧，我之前是做电商的，某较大的电商平台，突然有一天，C2C的店主反馈，看到的订单不是自己的，看到后台的商品列表也不是自己的
当时在睡午觉，看到这个问题，立马吓醒了，平时5个投诉就是一个故障单，那还都是一点体验上的小问题，这种订单混乱，商品混乱的错误，真是要紧急死了
于是，主管，总监都来看这个问题，一群大佬在后面看着，赶紧找最近几天的发布，测试情况，一个个回退，一个个检查，最后都无法解决问题，要知道时间一分一秒过去，半个小时还解决不了就要出大事了
后续又有用户来投诉，直接电话联系，远程控制电脑，发现操作起来巨慢，于是顺口问了一下用户的网络是什么网络。
结果他说是：“某城宽带”，一瞬间，有点感觉了，继续问其他几个投诉的客户都是“某城宽带”，然后我们打电话到那个宽带的运营商，得到的回复是“年底了，为了省流量，他们做了一部分缓存”
他们做了缓存
做了缓存
缓存
存
可是为毛TM的动态请求还做缓存啊，修改商品和订单的时候，随机返回成功或者失败 。。。。
＝＝＝＝＝＝＝＝＝回答下面的一些质疑＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
1.这个和时间戳也没关，我们都加了
token
的，他们也忽略了
2.你没猜错，他们把POST和GET动态请求也缓存了，就是说你提交了一个POST修改商品的请求，他从环缓存里面随便丢个回复给用户，用户感觉修改成功了，其实请求根本没到我们这边
是的，就是这么丧心病狂。","我印象里面最难调试的两个bugs，都和硬件有关，但最终都可以通过BIOS来打补丁。
悬丝诊脉
某著名公司还未上市的笔记本出了问题，在-10度的低温下经常莫名其妙死机。我作为BIOS专家，被千山万水召集到它的总部进行联合调试。在前台签署了一堆文档后，两个员工陪同我进入了一个大实验室。一进入实验室，画风突变，本来应该光洁明亮的房间，黑色的幕布从房顶垂下，将房间分割成十数个小间，像在进行敌特工作。在被引入需要工作的小间时，我要被气笑了。只见一根黑色的USB线从另一个小间连出，接在一台笔记本上。我被告知，只能在这台指定的笔记本上工作(我自己的不能用)，目标机因为机密，不能看，更不能碰！
都说BIOS调试和看病一样，讲究望闻问切，但这种只在传说中给闺中小姐，悬丝诊脉的情景，却在这个号称高科技公司中演绎地活灵活现。我心中暗自盘算，该公司不是中国公司啊，为什么是个中医粉呢？看我面色不善，他们以为我受到了冒犯，解释道：“no offense, it applies to everyone, include us.”其实我是被该公司著名的保密文化震撼了。后来才知道，在幕布后面，机器上还套个假壳子，他们自己人也看不到真容。
闲话休提，开始工作，于是发生了以下有趣的对话：
“死机死在哪了？”
“死在操作系统里。”
“你知道我不能看贵公司的操作系统源码，而我是个搞BIOS的吧！”
“操作系统没有变，一定是BIOS出问题了！”
好吧，我又要被气笑了。硬件一定变了吧？操作系统能支持新硬件码？为什么总是BIOS背锅？！没办法，调试手段有限，只有硬看了。经过两天两夜的调试，通过重建调用栈，寄存器对比等发现，原因是连接CPU和
PCH
的DMI总线太长，比Intel推荐的要求长了一点点，相信是主板布线时受到些硬约束，硬件工程师觉得长一点点不碍事。就是这长的一点点，导致在低温下，信号完整性不佳，而出现错误，最终操作系统读取硬盘时报错。
解决的办法是BIOS先给DMI降频，继续验证。产品版不得不再做一次
FAB
，多一次验证。成本增加了，上市也延迟了一点。
令出多门
某次主持开发一款E3主板。进度顺利，接近尾声。产品beta过后要进行压力测试，需要通过5000次soft reset，5000次
hard reset
，5000次Linux关机/启动，5000次Windows关机/启动，5000次
UEFI Shell
关机/启动。而在这个时候出了问题，在2000次左右关机/启动后，经常死在BIOS的内存初始化阶段，而且只有Windows/Linux会出现，重启和shell都是好的。
事关BIOS，我当然责无旁贷，组织了个攻坚团队，包括BIOS、硬件、操作系统、
BMC
和ME工程师。于是每天开会，每天跟踪进度，联合诊断。事情的难点在于每次关机/启动要3到5分钟，2000次需要3天多的时间。一次改正后，反馈周期太长。我不得不安排了6台机器进行迭代测试，安排不同部分的人分别盯守。
初步几天过后，分析下来是BIOS在读取spd信息时出错了。但为什么是关机/启动才出错？为什么开始不出错2000次后才出错？smbus读取代码十分简单，用过了很多代，为什么现在才出错？我仔细检查电路图，发现这代主板硬件工程师为了省事，将smbus的线都连在了一起，让BIOS、ME和BMC都可以访问内存信息，BIOS可以读取spd，ME和BMC可以读取内存温度，多方便！
smbus支持多host，硬件工程师这样做，也未尝不可。但ME、BMC和BIOS的祖传代码却缺乏相应支持，于是开会内容变成了各种争吵，事关谁该让一让的问题。最后决定大家都加上退避算法，解决总线冲突问题。
由于每次尝试都要等待好几天，加上牵扯方面太多，整个问题解决下来耗时一个多月，终于在产品发布之前，软件解决了问题。为此所有人出去大肆庆贺了一番。这个bug是我职业生涯中耗时最久的bug。
欢迎大家关注我的专栏和用微信扫描下方二维码加入微信公众号""UEFIBlog""，在那里有最新的文章。同时欢迎大家给本专栏和公众号投稿！
用微信扫描二维码加入UEFIBlog公众号","刚看其他人的回答，又想起来一个。
现象：
很简单，有段时间学校宿舍电信的网络，经常大面积集体掉线，时间不固定，但发现最常掉线的时间是晚上10点多，各种投诉抱怨，问候学校网管家人的。（心塞呀，学校其实真的维护设备的都是我们这帮兼职的学生，那帮老师就管收钱和发钱，工资那么低，累成汪还被骂。。。）
调试：
白
天去看了下机房设备硬件一切正常，当时以为是认证服务器配置太low，晚上上线人太多就卡死，导致心跳包中断，集体被下线，后来发现发现虽然到5000多
人后会有部分
心跳包
没回应，但是客户端允许部分掉包，人再多也不至于丢包到集体下线，最后查log发现这台机架上的所有交换机到那个时候都会重启一下，于
是重点关注。
机房是5号宿舍楼1楼的一间宿舍改造的，加了空调，另外从配电箱里接了不限电的电源（宿舍的电嘛，晚上会断电，还有功率限制），联通电信移动每家一个宿舍做机房，于是我在机房里蹲守。
第一晚是周六，一晚无事。
第二晚，到10点多一点，咔嚓一下机架上所有交换机的灯一下全灭了，过了几秒后通电，重启。诶，我什么都没做呀，我就在机柜前坐着，也没人碰机柜呀！肿么就断电重启了，
然后又看了log，发现其他机柜切换到UPS电源供电了一小段时间，交换机的机柜是没UPS的，明显是断电了，但是我人在机房，没人碰设备呀
怀疑是插头接触不良，换了机柜里的排插。（其实想想就不太可能，接触不了还能定时发生？）
第三晚还这样，
第四夜还这样，
诶~神奇了，这是什么超自然现象？
难道是进户线有问题了？想起电线是从隔壁联通机房进来的。
于是跑联通的机房看看他们到点会有问题没？发现这边也是每到那个点，就自动切换到UPS供电。（联通给交换机也配置UPS了）怀疑是电路有问题，时不时断电。
于是，第五晚守在隔壁了。。。一夜无事！！！
诶？？！！！这是神马情况？
然后就再也没事了，断电情况再也不出现了。。
足足好了1个月。直到下个月的运行商派人来例行检查了以下设备后，又出现上述问题了。
额，这是神马情况嘛！！
我去两个机房看了一下，诶，又好了，电信不掉线了！
抓狂了都！！完全是玄学呀这。
只要我进过联通的机房一次，电信的掉线问题就能解决。。
我居然还有防掉线的功能？
最后只好挨个问机房隔壁的几个宿舍有没有发现在那个点机房有没有奇怪的现象。
他们有人说感觉会掉线的日子里，机房不是那么吵！！
然后在我努力研究调查下，终于知道事情的真相：
========真相的分隔线==========
机房的供电是这样的，红色的是电线，紫色的是一排插座
电线是后改造的从室外的桥架上引入的明线，隔壁是电信的机房，因为进门的墙是承重墙巨厚还有钢筋，布线的时候为了省力，就只从联通这屋进了线，电线到插座高度后，打洞到隔壁。
联通机房隔壁宿舍的嫌睡觉时机架散热风扇太吵，就用偷偷用卡把门捅开（那种A级锁，很好撬的），睡前就偷偷把机柜的风扇电源拔了，早上再偷偷插上。。因为机
房有空调，拔了也没导致设备过热。但是。。。插机柜风扇的那个插座是进户第一个插座，就是那个孔的位置，他拔插时插头会带动插座，导致里边没接好的电线在
连接处断开一下。
为什么周五周六有时没事，因为他们可能周末集体出去了，晚上不在宿舍没人拔插头！
为什么是10点多，因为快睡觉了，才去拔插头。
为什么其他时间不定时，因为他们不一定什么时候想起来插回去。
为什么我进去一次就没事，因为我出机房后，会用钥匙反锁门，他们捅不开了，而其他人出来不反锁，只是关门，他们能捅开。
其实现在回想，最诡异的就是，我第一次蹲在联通机房的那一晚（第五晚）他没来撬门拔插头，不然也不至于追查这么久。
又想起来一个：
【关于锐捷和交换机的事】
学校某一天开始，大量用户正常上网情况下突然掉线，再次拨号时认证停顿在“寻找认证服务器”，之后提示框显示“认证失败”。但是有人发现锐捷认证失败后，“禁用”、“启用”网卡后，多次尝试锐捷拨号能够成功认证，但是在上网几分钟后会再次掉线。
锐捷的认证过程就不写了，看这个个问题的估计都大概知道。
先考虑，锐捷认证服务器故障，看了下，CPU占用率60%左右波动，内存占用2G左右。（这渣渣服务器啊。。占用这么高也是醉了）ＲＧ－ＳＭＰ正常，加密狗也没问题。看来服务器没事。
那估计就是网络环境故障，看了下核心交换机到认证服务器之间的网，物理连接没问题，流量看起来也挺正常。
那估计就是核心交换机和用户终端交换机的问题。
然后发现，核心交换机到物理选课平台的服务器间最高峰时一秒快3万的封包。。。这肿么可能嘛，结果联系了那边，到服务器上一看，恩，服务器被人拿下了，被放了好几个成人和赌博网站在上边，还发现有挖流量矿的代码，还被拿来D别人，还被放了个SMTP服务器在发垃圾邮件。里边的学生个人信息被下载都不算事了。
断开与他们的链接后，CPU负载降低，但是认证还是失败。
继续查，发现另一个到行政楼的接口流量也很高，大约每秒1.5W的封包
show arp一下查看，发现一堆arp未完成报文，在Incomplete状态在ＩＰ地址无法找到其对应的ＭＡＣ地址时进行转发，占用了交换机内缓存表。于是猜，要么中毒，要么出现环线，然后就查呀查，发现基础交换机上WLAN102、103流量异常，那就继续查呗，最后发现，某逗比做了这么一件事。
这个基础交换机是直接给这层供网的，大办公室留两个口，小办公室一个口，他们自己用交换机再分。
学校机构调整，部分办公室从新分配了，本来有个大办公室是，两个部门同时用的，他们每个部门自己各占用了一个接口用。后来换给另一个大部门了，他们搬家时，看到有两个接口，于是把这两个同时插到自己的集线器（居然连交换机都不是）上。
始作俑者还特肯定的和我说，这样可以加快网速，可以有双倍的带宽。
我和他说这样不行，他还不行，非说我不懂电脑了，他是在XX之家看到的，还说之前办公室里就这么接，就没事，网速还快了。（后来发现，他原来办公室其中一个接口，交换机端的插头松了，插了等于没插，网速什么的，只能说是心理作用了）
什么时候集线器能当路由器用了。。
什么时候，带负载均衡的双WAN口路由器，只卖20块钱了。。
想多玩多播起码你也要设置下吧，直接插有个毛用。。
不怕遇到小白用户，就怕遇到半懂不懂还装懂的。。","分享刚看到的一则新闻――
思科交换机复位键设计问题成了网络工程师最可怕的噩梦
2013年，思科针对旗下价格昂贵的3650和3850系列交换机发布了“问题通报”。世界各地的许多数据中心正在使用这2个系列的交换机。通报当中详述了这2个系列交换机当中复位键存在设计错误，导致用户插入网线之后，可能在短短几秒内让整个网络瘫痪。
如果有人在这个端口插上一根网线，在不知情的情况下就会按下复位键，他们甚至没有意识到整个网络已经因此瘫痪。","以前做windows技术支持，一直调试
crash dump
。就我个人的体验，有关线程安全的dump是最难调试的，来无影去无踪，看到的就是一坨已经被破坏的现场（dump），然后你需要在大脑中还原案发经过。
有一天香港某大公司（名字不透露了）上了一个case，他们自己的一个应用在生产环境中会莫名奇妙地crash。当时我就想：你自己应用crash找我们干什么，肯定是你自己代码问题，而你还不给我看你的代码！
所以几个难点：
第一，没有客户代码。
第二：客户用的系统是NT4！NT4什么概念？就是没有pdb文件的，符号文件只能对应到函数入口，对应不到具体的源代码行号。你只能把整个函数的汇编都读懂才能知道crash的地点是在做什么事。
第三：只有dump，不可能设断点调式，因为根本不知道如何重现。
反正就这么读了几百上千行的汇编（此处省略两千字），最后定位crash的地点，能看到进到EnterCriticalSection的api之后发现这个CRITICAL_SECTION结构其实已经坏了，然后就挂了。从heap结构可以看出似乎那个heap block已经被用作它用了，所以有可能那个CRITICAL_SECTION已经被delete了。
然后看谁管理这个CRITICAL_SECTION的， 发现是
msvcrt
，还是VC5的。好吧去找代码，还好那个代码是找得到的。然后就把所以处理这个CRITICAL_SECTION的代码全部找出来，把所有代码在不同线程中的不同执行顺序都排列出来，最后发现在某一个特殊的执行次序下会有一个
race condition
，导致这个CRITICAL_SECTION会被过早delete掉。还好一开始就怀疑是线程安全问题，入手方向没错。
好吧，最后居然是vc runtime的bug。当初错怪客户了。
调完这个bug的副作用就是之后看到汇编就想吐。看看现在c#的调试那根本不是事。","最难调的是在
菊花厂
做分布式数据库Taurus，遇到的数据不一致的bug.
为什么说难调呢？
1.从发现bug 到最终解决耗时一个月，当时项目已经马上要发版本，所以期间每天搞到12点。
2.耗人力，累计投入1个专职测试，最高峰时期有一个10人的攻关小组，这很菊花厂:-)，其中一半以上的都是senior developer，一个价值上百万的bug。
从技术上来说难度主要体现在
1. 系统复杂，涉及到上百万行代码，系统分布式部署
2. Bug 难重现，并且没有规律
3. 系统代码复杂度较高，涉及数据库事物核心代码。
吹水结束，下面是技术干货
1，什么是数据不一致，怎么测试出来的？
测数据库一致性的用例一般用转账的例子，例如A给B转10块钱，那就需要把A的账户余额减10，再给B的账户余额+10，然后再判断一下A和B总的账户余额不变。当然你也可以扩展到多个表，但是基本原理类似。我们的测试是用
TPCC
，所以一致性使用的是TPCC的业务模型，模拟往TPCC的
warehouse
之间出货，然后查库存是否一致。
为了尽量模拟用户的真实使用场景，当然得导入大量的数据，加大并发，中间还会故意模拟各种故障。 所谓的各种故障，说白了也无非是杀进程，下电，模拟磁盘故障，因为Taurus又是一个分布式的数据库，网络故障必不可少，模拟网络抖动，丢包，网络割裂。
不过，出现数据不一致的场景反而没那么复杂，就是导入300G基础数据，然后起大量并发在上面跑TPCC测试用例，跑个3，4个小时，一致性检查语句就能发现数据不一致。（想想挺后怕，要是这个bug是由各种故障的注入导致的，定位的工作量估计又要翻倍）
2，怎么定位和解决的？
最开始接手这个问题的时候，首先当然是看测试测的对不对了，因为之前也乌龙过几次，测试一开始导入的数据就有部分不成功，导致一致性检查一开始就没通过 :(。确认问题后，就开始定位。
首先我们想的是找到重现条件，好吧，那就开测吧，搭个环境，导个数据，1天下来也是能够重现一次的。
那不一致的日志有没有什么特征呢？插入的数据有上千万条，每次测试出来的不一样的记录，连不一样的表都不重样。
那日志里有没有啥异常？日志全开，还好跑几个小时也就几G的日志，大菊花厂的硬件还是舍得花钱的，都是300G内存的机器，mount一块来放日志，grep查出来的warning，error看的眼睛疼。
那只能从读写流程来定位了。这里需要首先交代一下Taurus的背景。
Taurus是一个基于MySQL改的计算和存储分裂的分布式数据库，计算层支持1写多读，存储层通过raft协议来同步
redo log
。
那写入的流程就涉及到：
计算层的读写节点解析执行SQL语句，最终执行引擎会生出redo日志，
redo日志发送给存储层的leader节点，
存储层的leader节点再通过raft，把redo日志同步给其他的存储节点（副本）
存储副本再解析redo，重放redo
存储副本的数据是需要做checkpoint的，把脏页写入磁盘
计算层的读节点读的时候首先在自己的缓存里面找需要的页面，如果对应版本的page在内存中，直接返回，否则是需要去存储节点拿的
存储节点接收到请求的页面，会根据页面号，页面版本信息，返回对应的页面。
说了这么多，最想说的其实就是，这个流程中任何一个步骤出差都可能会导致数据不一致，我们的想法是，首先要定位到在上面的整个流程中，是哪一个处理流程出错了。
我们的办法是按流程倒着排查。
首先第7步请求的页面和磁盘上的页面是否一致？
我们根据出错的记录，找到记录所在的page，把都出来的page dump出来，然后和磁盘上的数据做对比。除了page头的数据，其他一样，ok，那可以排除计算节点读到的数据和写入的数据不一致。
然后再排查第3步，同步的
redo日志
有丢数据？
我们对raft同步的数据做了很多优化，其中之一就是raft同步的数据做了batch，然后我们开发了一个raft日志的解析工具，把raft日志解开，打印成可读的文本方便分析。
然后还真通过这个工具发现raft日志里面的redo日志不连续，我们很开心，觉得问题已经定位的差不多了，但是raft那块代码是相当稳定的，因为我们团队在
raft算法
积累了好几年的经验，在cockroach db和
etcd
社区有5，6个committer，并且，raft出错好歹也会在leader频繁切换，磁盘故障或者网络丢包严重的情况下，测试场景一切都正常，当我们回过头再来看我们的raft日志分析工具，发现对应的分析工具正好有几个我们添加的redo日志类型没有解析到，并且没解析到日志也没报错。。。这个时候，时间已经过去了2周。无奈之下我们只好去北京，找当初写块代码的兄弟一起来攻关。这里顺便吐槽一下菊花厂的开发模式，经常是一群人做了一个原型，然后丢给另一群人做产品，然后可能最后会丢给其它的团队来做维护，同一个项目团队成员流动太大。
读上来了一个老版本的页面，然后在老版本的页面上再做修改，导致把中间做的修改的数据覆盖？
果然还是亲爹靠谱，直接就说了一个他觉得可能性最大的地方，然后这哥们就回去啃代码去了。。。
这里交代一下背景，MySQL本身有一个mvcc机制来实现多版本管理，在我们的实现中计算层的只读节点是按页面来请求数据的，为了满足不同的事务请求请求同一个页面在不同时刻的数据，我们在存储层实现了一个多版本的page管理机制，会根据读page请求的版本号，来返回一个特定版本的page给用户。
问题就在“请求特定版本的page”这里，如果计算层请求的page版本是一个老版本的page，那后面的update是会基于这个老版本的page来做修改的，举个例子：比如存储层的page版本是10，上面有2条记录，记录了插入的2条数据，但是计算层读到的是版本为9的page，版本为9的page没有在事务10插入的2条数据，这个时候事务11为page插入另外2条数据，生成的redo刚好就覆盖了事务10增加的那2条数据，这个和
innodb
的page机制有关，插入数据的时候会从空闲空间那个offset往后写数据。对应到我们的一致性检查就会看到转账的时候，只看到A扣钱，B的余额没有增加。
那我们的想法是先通过测试来验证是这个问题。但是重现一次需要半天时间，我们想到的是尽量构建重现的条件：
缩小导入数据的规模，把导入300G数据改成100M。
把
buffer pool
设置的很小，这样计算层就需要频繁的去存储层读page，读的越多就越有可能会读错老版本页面。
加大客户端的并发度，构建尽量多的读写请求。
把存储节点的buffer pool设置的很小，启动另外一个写磁盘的线程，不停的抢占磁盘IO，这样的好处可以让存储节点读磁盘慢，返回页面慢，增加读写页面的冲突程度。
结果20分钟就重现了这个问题，一下子把定位的问题从上百万行代码缩小到我们写的1w行代码。
这个时候时间已经过去了3周，后面我们花了1周时间改了2行代码，修复了bug，并通过验证。导致出现bug的原因很简单，计算层在把redo日志提交给存储层做持久化的时候使用了异步和pipeline的方式通讯，在异步处理里面，我们保护redo日志提交的锁释放晚了，导致读线程还是拿老的事务号去读page，从而读到了老的page，从而导致修改的时候基于老的page修改。
3，怎么保证后续的开发不会再引入同样的问题
首先想到的肯定是把重现的用例增加到自动化的测试用例集中，在每次发布代码前都需要校验。
增加测试用例，模拟各种极端情况，例如基于jepson模拟各种网络和节点故障。
除此之外，我们还在代码中增加了几个检查点，例如在每次替换页面的时候保存页面的checksum来校验读上来的页面是否是写下去的页面。当然这个开关只在内部测试版本中才会打开。","怒答！！
答主不如楼上这些硬件大牛，乃软件狗一只，去年做 Android 开发的时候遇到一个极其搞笑的 BUG ，自我感觉有必要说出来让大家开心开心。
当时我们在做 Egret Runtime 的第一个版本，可以理解为他就是一个 Android GLSurfaceView 渲染器。
当我从开发工程师手中拿到第一个新鲜出炉热乎的开发版的时候，我发现一个现象，就是游戏整个 App 会不时崩溃掉，crash日志大概描述的是 C++ 挂掉了，当时我由于经验不足，还不会根据 C++ 的 dumpstack 去检查是哪个模块的问题。所以我决定先尝试重现一下这个问题。
重现步骤：
1、把手机放在桌子上，打开 App，观察5分钟，未崩溃
2、5分钟的时候接了个电话，接完后 App 崩溃
3、意识到可能是 Android 生命周期问题导致的，于是重新打开 App，反复在前台 / 后台切换，未崩溃
4、由于长时间弯腰盯着桌子上的手机，有些不舒服，于是把手机拿起来，想舒服的后仰坐在工位上继续重现，然后在把手机拿起来的一瞬间，崩溃。
5、吓一跳之后，小心翼翼的重新打开 App，思索自己刚才到底做了什么，同时紧握着手中的手机继续盯着屏幕，观察5分钟，未崩溃
6、心情暴躁，把手机扔到桌子上，崩溃
7、惊愕......
8、重新把手机拿起来，再次扔到桌子上，崩溃
9、给开发的同事讲，我重现出了这个BUG，只要用力把手机往桌子上砸一下，就会崩溃
10、开发同事匪夷所思的表示没有调用过陀螺仪之类的 API，只是个简单的渲染。
11、现场演示狠狠的砸了一下我的手机，崩溃重现
12、开发同事狠狠的砸了一下他自己的测试机，未重现，于是拿过来我的手机，进行真机调试（ 每次调试就要砸一下我的手机....请自行脑补我的表情）
13、最后发现，原来是当手机被狠狠砸一下的时候，屏幕旋转方向发生了改变，然后触发了 OpenGL 底层渲染的问题没有 Handle 住 ...... 
14、用3分钟修复了此问题，然后对着被砸了20多次的手机泪流满面.....","如果有（内行的）人故意和工程师做对的话，他弄出来的BUG或许会是最难调的BUG……
以下全文转载EtherDream的博客的一篇文章
【趣事】一根网线发起的攻击
（感谢评论区指出原出处，原作者若认为侵权可私信我删除），虽然是以破坏分子的视角来写的，不过各位可以脑补一下维修人员的心情是怎么样的……
刚上大学没多久，就遇到件头疼事。
富二代们刚来就带着笔记本电脑，这让咱们只能玩手机的潘勘裁窍勰郊刀屎蕖Ｒ命的事来了，晚上断电不断网，于是熄灯后笔记本仍然可以玩。
不巧的是，我们寝室也有个。常常熄灯后，非得把电池用干净才罢休。边游戏边语音，还放着音乐，备受煎熬。虽经劝说有所好改，但过不了几天又会复原。
为了迫切改变这个状况，但又不想和新认识的同学扯，于是决定用技术方案解决。
可当时的家当只有一部
诺基亚滑盖手机
，没有装备一切都是空谈。唯一可行的，只有偷偷在他电脑里设置个计划任务，晚上自动关机。但那样万一发现了更不好，根本没有技术含量。
无奈，只能把目光转移到电脑之外，网络上。如果不能上网，就算电脑能用，也不至于熬夜玩单机游戏吧。
既然刚来时他的网线插口就能用，想必我这儿的也有信号。上一届的肯定都开通过，总不至于走了以后还封掉。趁着有天寝室没人，我把那笔记本的网线拖到我这边一试，果然，信号！顿时来了精神，感觉有希望了！
也许你会说，总不可能把网线连到诺基亚上，然后用什么恶搞软件吧~ 当然不可能，那时的手机哪有这么先进。
事实上，我们不用任何软！件！，甚至可以不用硬！件！ ―― 除了一根网线之外。
要说如何玩转网线，还能从之前安装机顶盒的那天说起。
曾有段时间，很多城市开始流行起数字电视。我们这也不例外，挨家挨户的赠送机顶盒，还免费上门安装。华数电视本来就和网通是一家，数字电视当然就是共享网通的宽带了。由于之前已开通了网通，这次又要给机顶盒连网，我想至少得送个交换机才行吧。然而，安装的师傅一进来，既没掏出交换机、甚至连集线器也没有，反而一剪刀把网线给割了！
当时就惊呆了，这究竟是搞哪门子鬼。尽管那时对网络链路协议玩的挺嗨的，但物理层上的却是一窍不通。那师傅不慌不忙的说，网线只要四个就够了，还有些就是备用的。于是从之前的线里，拆了四根给机顶盒。
这大出之前所料，居然没用任何设备就把机顶盒接上了！于是，又开始异想天开了。。。
这分出来的两股，在交换机来看是不是两个独立用户？如果把他们接在一起，效果和一线插两口相同吗？能一样短路局域网吗？
怀着兴奋的心情一测，果然可以！真把整个小区的网络搞挂了！
在恢复之后很长段时间里，一直拨不上号。在嗅探器里发现好多邻居们的也在不断的拨号。显然，刚刚那接通两个4股线，把外部的STP包也转发了，导致小区网络被外部隔离了。
这一天，改变了之前的看法。原来只需一根网线，就可以来一次VLAN风暴！
为什么一根网线插交换机的两个口会产生风暴？因为交换机会把发往广播地址的包，转发到所有接口上。如果有两个接口回路了，一旦出现
广播包
，就会彼此不断循环发送，耗尽整个设备的带宽。别小看交换机，它天生就是为发包设计的，风暴能把每个接口都占满，打出背板带宽的流量。STP协议就是为了解决这个问题，进行回路检测。
尽管了解了这个新技能，但物理层的知识基本派不上用场，也就淡忘了 ―― 直到发现寝室座位下有信号的那天。
根据回忆，寝室之间还打过局域网游戏，显然这不是独立的网段，于是更加信心满满了！
立即找来一根网线，减掉一边的水晶头，刮掉外皮，然后把对应的四股两两粘上。果然，附近的寝室开始传来 ―― 不，先是寂静了几秒，接着陆续传来的尖叫声，吼声。“卡了！”，“谁掉了？“，什么情况？”，“靠，断网了~~~”。。。
跑出走廊一看，整栋楼都暴动了！原来这寝室楼根本就没划VLAN，所有几百号寝室都是连在一起的！！！
这时既兴奋又担心。兴奋的是，以后有了电脑可以抓上千人的流量了。担心的是，现在只想恶搞自己寝室，不想牵扯所有人。
不管怎样，行动还是继续。熄灯后本该休息，断了所有的也没什么不好。
这时技术上已无大碍，就差实施了。如何从容而又隐蔽的操作呢？
为了不暴露没电脑还插着根网线那么荒唐，于是尽量沿着有遮挡的柜子布线，从衣柜后一直拖到床铺。剩下的水平部分就埋在床边的缝隙里，并用席子盖着。
整个布局不凑近仔细看，根本发现不了~
当晚熄灯后，夜猫子们又开始蠢蠢欲动了，我也迫不及待的开始试验。和其他几个同学一样，假装在玩手机，实际已开始悄悄的接线，颇有地下情报员的感觉。
当搭上最后一股时，流畅的游戏声立即出现了卡顿。毕竟整栋楼都在这个LAN里，广播包的数量是相当多的。
只听得游戏剩背景音乐，却没有音效了！
想着100Mbps的流量从手中捏着的网线穿过，仿佛看见密密麻麻的ARP、NetBIOS广播在黑暗中闪过 ―― 还有那少得可怜的、被挤掉的游戏数据包。
下午的骚动又一次爆发了。尽管熄灯后少得多，但在夜晚的环境里，显然越发清晰。
被断开的大多不甘心，还想继续玩。这一次，不打算这么暴力了，万一触发了回路检测，说不定整楼就被封了。
于是，改成搭上几秒，断开。再搭上、断开。。。游戏虽能运行，但不断陷于卡顿之中。没多久，传来一阵阵温馨的关机声，纷纷洗洗睡了。
首战告捷！终于睡了个好觉。
改良 v1
刚开始的几天里，效果非常理想，大家都乖乖的提前睡觉了。
不过没多久他们就发现，网络过会就会恢复的。原因很简单，哥睡着前就把线放开了，于是他们又开始了疯狂。
在迷迷糊糊睡梦中，要把网线重新搭上会困难的多。经常把不相干的也缠在了一起，结果就没效果了。
于是，需要一次用户体验上的改进。
事实上，其中三股线都是事先粘好的，实际就控制一股而已。不如把那三股都提前隐藏起来，只留一股在身旁，这样就不会搭错了。
换了根网线重新制作。这次，直接把其中 3 股用胶布粘好，藏在衣柜后面，只留一股拖上来。线路也细了不少。
这样，就和电路开关一样了。总共就两根线，搭上或分开就行。
即使在睡梦中，也只需动动手指，就能轻松自如的控制整楼的网络了！
改良 v2
不过这么简陋的设备，总会有操作失误的时候。
在一个周末的半夜，被通宵的吵醒后，狠狠的搭上了网线，然后继续睡。没想到这一次太困，直接沉睡了过去。直到早上10点多，才被敲门声惊醒。
原以为是隔壁同学，但敲门不断，打开后发现进来一个背着工具包的大叔。这时，才猛然意识到，搭着的网线忘了断开了！！！整整断了一晚，都查上门来了！
这时也来不及收拾了，心想这回终于要露陷了。不过那师傅一眼扫去，发现我们桌子上都是干干净净的，啥也没有。唯独敞着个笔记本，而且还没关机。于是上前拔掉了网线，然后走了。
侥幸躲过了这一劫，迫切需要改进了。
如果能睡前开启，睡着后自动关闭，那就十分理想了。再也不用睡梦中用意念去断开了。
于是打算做一个有弹性的开关，必须按着才会开启，松开就关闭。这样睡着后身体放松就自动断开了。
经过一番改进，把开关做得无比隐蔽：把两根线塞到一个袜子里，里面塞了棉布等等有弹性的东西。正常情况线路是分开的，但轻轻往下压就会搭住，放开后又恢复正常。
不过袜子捏手里也怪怪的，于是就藏到脚后头。至此，每当夜晚吵闹时，只要脚趾头稍稍踮一下，周围的气氛就立即变得格外安静。
到此，总共花了两块钱打造的装备，能让脚趾来控制上千人的网络状态，简直太有成就感了：）
没多久，大家似乎发现了规律，只要声音太响网就会卡，但无奈又找不到原因。于是都变得乖乖的安静上网了。（每次回想起就特别搞笑）
当然，这装置只投入使用了半年。第二个学期大家都装了电脑，于是一起愉快的通宵上网了。","歪个楼，说个SCADA工程投产的关键时刻突发的bug，论技术含量，它无疑是最low的，但绝对够刺激。
N年前的一天，晚10点，甘肃戈壁滩上的某处工艺站场，现场一片忙碌，根据工艺人员的测算，工艺介质还有半个小时就要进站了，介质进站就表示站场正式投入运行。我和我们部门经理，作为站场核心控制系统――SCADA系统的集成商，2人蹲守在站控室的主控电脑前，做好了72小时保投产的准备。
随着时间一点点逼近，控制室的气氛越来越凝重，对讲机里丝丝拉拉的呼叫声、调度电话的铃声，此起彼伏，我和经理也一脸严肃地坐在站控台旁，内心既轻松又紧张，经过一个多月的紧张安装与调试，站控SCADA系统早已准备就位，该忙活的都忙活完了，剩下的就看它的了！
10点05分，报警器突然传出沉闷的报警声，三条报警出现在SCADA软件的监控屏幕上，三条报警都指向同一个设备，我快速浏览了一下控制流程图，其它设备一切正常，单只这台设备的状态出现了变化，我的第一反应是，又是哪个傻逼在现场乱动设备了。
这套站控SCADA系统是由我亲手组态安装的，每一个信号回路、每一个信号、每一个控制命令，我都亲自测量调试过，我敢保证系统里显示的所有数据，一定是对现场工况的真实反映，所有的数据和操作，一定是准确可靠的。
我猜测，这台状态发生扭转的设备，肯定是现场人员手动操作的结果，没有调度令瞎特么动，找骂呢，也不看看现在是什么时候，我还幸灾乐祸呢。
10秒钟不到，几千公里之外的控制中心的调度电话就打过来了，什么情况？报告原因？
离设备最近的工作人员迅速赶过去，用对讲机汇报了检查结果：设备一切正常，没人动它，现场指示一切正常！
现场指示一切正常，我心里咯噔一下，不会吧，设备没问题，那就是SCADA系统有问题呀，数据错误那可是重大失责，极有可能导致生产事故的，这可不是闹着玩的。
腾的一下我就站起来了，抓起防爆对讲机就向200米开外的工艺区冲去，我必须亲自确认一遍设备状态，果然，机械指示没问题，电子指示也没问题，各种装置也在原来的位置上，没错，设备没问题，完了完了，回去查系统吧。
我以最快速度飞奔回站控室，一头扎进机房，迅速检查了一遍上、下位机的数据，PLC、实时数据库、HMI三者数据一致，数据流正确，系统没问题呀，我在脑子里头快速过了一遍数据流程，究竟是哪个环节出问题了呢？
PLC程序中设备的控制逻辑是按模块封装的，要出错早就该出错了，不会拖到现在，即使真出错了，也得是现场几十个同类设备一块出错呀，单是一台设备出问题，肯定不是PLC程序的问题，排除。
实时数据库出错的可能性也不大，数据点在数据库中是哈希分布的，不存在逻辑关联，同一设备的所有数据点同时出现错误的概率太小了，我还不至于点背到这个程度，再者说，实时库中的数值与PLC是一致的，说明数据采集程序运转也是正常的，排除。
HMI显示的都是实时库发布的数据，我手动修改了几个故障数据点，HMI立马跟着变化，数据发布和显示功能也正常，排除。
上位机和下位机都排除了，剩下的就是PLC IO模板及其之后的环节了，先排除IO模板吧，短接测试最简单有效，半分钟之后得出结论，IO模板也没问题，排除。
问题肯定出在现场设备与机柜之间的信号回路上，没得跑了。
我咽了口唾沫，转身抄起了万用表，在PLC机柜缜密排列、密密匝匝的电缆与信号线中，找到该设备的所有输入回路，逐一量过，果然，信号回路的电流电压与现场设备的状态严重不符，与HMI显示的错误结果一致，问题找到了，电缆传过来的信号乱套了。
不会是信号电缆断了吧，这是我脑子里闪过的第一个念头，现场设备与机柜之间的所有线路我都亲手调校过，每一台设备我都开盖测试确保接线规范牢固，单体调试和逻辑联动也是反复做了很多次，这些基本功课我做的一丝不苟，完全可以排除掉接线错误、接线自动脱落等低级错误，出问题的是台进口设备，这类设备之前的表现一直很稳定，信号源出错的可能性貌似不大，现在摆在面前的唯一的可能就是，这条电缆现在断了，或者它曾经断过，后被施工人员只是草草地焊接上了，现在脱焊了。
按照施工规范，信号电缆是不允许出现断点的，然而，献礼赶进度，难免出现加班施工、违规操作的情况，哪个土方施工队开着推土机，冷不丁来上一铲子，干断几根电缆的事情也是不可避免的，毕竟从控制室与设备之间有好几百米的距离，中间隔着很多地面施工点。（电信机房的光缆都会被人挖断，更何况繁忙的施工现场敷设的电缆，每次想到献礼我就蛋疼）
一种不详的预感向我袭来，要真是焊接的电缆，哪我就太TM倒霉了，电缆敷设和仪表安装的活也是我们公司干的呀，尽管不是我的工作，但他们挖的坑埋的雷，最后都得由我们来拆包填坑，而且还特么是在这种关键的时刻，一万头草泥马从我耳边呼啸而过，我不敢往下细想了，一股凉气从后脊梁一路串到头顶。
经理赶过来了，见我正举着万用表，看着机柜发呆，还以为我吓傻了呢，一把抢过万用表就要亲自上阵，他是赶过来保投产的，未参与前期调试，他以为是我的信号回路接线有问题呢，我拦住他，把情况跟他一说，他也傻了，这种狗血的事情，他之前遇到过。
经理赶紧把在站控室外待命的仪表安装负责人叫了进来，瞪红了眼，指着电缆问道，老张（化名），这根缆被人弄断过，你们给偷摸焊上了，是不是，你跟我说实话。
老张憋红了脸，拍着胸脯保证，这根缆绝对是一条完整的电缆，没出过任何问题，无论我们怎么逼问，老张都一口咬定，电缆绝对没问题。
我和经理看老张说的这么决绝，姑且相信了他，这种时候，谅他也不敢死扛。
可是电缆没问题，设备也没问题，那会是什么问题呢，我抬头看了一眼时间，10点19。
冷静，冷静，我擦了擦鼻子上的冷汗，走到机房的小窗口，漫无目的地扫射了一遍厂区，夜色中，几十台相同型号的设备散布在工艺区的各个角落，深蓝色的电子屏如群兽的眼睛，透着幽兰的光芒，死死地盯着我，那台故障的设备就蹲在巨大厂房的阴影之中，眼睛忽明忽暗地眨巴着，仿佛在嘲笑着试图驯服它的主人。
我突然一个机灵，不对劲，亮度不对劲，其它设备电子屏的亮度是固定不变的，很少出现闪烁，只有这台故障设备的电子屏，如鬼火般轻微跳动，在夜晚黑色的背景下，越来越刺眼。
电压波动，肯定是380伏动力电网的电压波动，导致设备的主电路版出现了故障，我拆过这种设备，它采用的是独立的显示模块，尽管显示模块与IO模块是隔离的，但电子屏都出现了画面抖动，IO模块也不会好到哪里去。
我转身正要往控制室跑，这才发现，站场的主要负责人已经把经理给围住了，经理憋红了脸，应对着各种质询与责难，我赶紧上前，把我的发现与想法告诉了他们，他们半信半疑，这种进口设备，项目上用了这么多，从未出现过这种问题，你确定是设备的问题不是你们的问题，信与不信已经不重要了，不试怎么知道，时间不等人，赶紧请示控制中心，要求重启设备，控制中心回复：现场自行决定。
还决定个屁呀，我抹头就往厂区跑，把这帮人甩在了身后，开闸，断电，等待10秒，合闸，上电，报警自动恢复，数据显示正常。
10点28，故障终于解除了，憋在胸口的一口闷气，终于可以吐出来了。
控制工程和软件工程一样，都是系统工程，一环扣一环，一层叠一层，系统越复杂风险越大，系统工程出现的问题，绝大部分都是多米诺骨牌效应造成的，小故障导致大事故。
多米诺骨牌的触发和传导过程是外显的，小牌推大牌，傻子都能一眼看出问题的端倪，但系统工程是隐蔽性工程，系统内部的结构不是显现的，问题的发生与传导也是不可见的，当故障发生时，大家看到的是倒下去的最后一张牌，看不见故障的源头，也看不清坍塌的全过程，这也是为什么工程师爱说「不是我的问题」的原因，很多错可能真的不是他们造成的。
愚蠢的管理者，会责怪倒下去的最后一张牌，聪明的管理者，认为每一张牌都有作案的嫌疑。
当你被怀疑时，能做的就是自证清白，往下深挖，如果你自己的功课一团糟糕，又没本事找出推倒你的上一张牌，那么很不幸，你就成了那口黑锅，only you。
很多时候，工程师什么都爱学一点，并不一定是求知欲太强烈，或许他只是想看清楚，站在我身后的，究竟是些什么鬼。
----------------------------------------------
相关话题：
石油，天然气的管道运输程序是怎样的？ - SCADA 的回答
不同行业的真实工作是怎样的？ - SCADA 的回答
现代工业的存在是依赖于工业软件的支持吗？我国有世界级的工业工程、控制软件企业吗？ - SCADA 的回答
为什么自动化专业后来转成 CS 的这么多？ - SCADA 的回答","远远算不上最难，但是很有意思。来自我的知乎专栏文章。
背景，我给饥荒游戏写了一个LuaJIT PATCH，替换掉了原有的LUA引擎以解决卡顿的问题。在编写过程中解决了很多BUG，全文很长长长长长长，下面这个是比较有意思的，就节选出来了。完整的部分请点击下面的文章链接。
此PATCH源码及下载在GITHUB有：
GitHub - paintdream/DontStarveLuaJIT: LuaJIT bridge for Don't Starve (compatible with DS, RoG, SW, DST [only for test] )
===================================================
作者：paintsnow
链接：
https://
zhuanlan.zhihu.com/p/24
570361
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
0x0F 人间蒸发的海盗鹦鹉
新的版本持续用了很久，新的BUG反馈与很少了，而且基本上都是已经使用了旧的patch或者自己不会按要求改代码导致的。
安逸的日子一直持续到有用户开始报告说：陷阱类物品使用鼠标点击后捕捉到的动物消失，并且物品的耐久没有减少。
这看起来很难理解，这个bug是如此的精致，精致到不像是脚本引擎更换时引起的bug，反而更像是lua代码本身的bug。若是PATCH引起的bug，为什么游戏中的其他逻辑能精确地运行，唯独陷阱不行呢？这是怎么做到的呢？
（前方高能提醒：这个是制作此Patch时遇到的最诡异，逻辑链最长，但同时也最好玩的一个）
为此我打开游戏（启用PATCH），建了个新档，用控制台刷出一个捕鸟器和一只海盗鹦鹉。拾取后果然鹦鹉没了，捕鸟器耐久也没掉。
那么，问题出在哪里呢？通过仔细比对启用PATCH前后的画面，发现一件怪事：
（启用前）
（启用后）
所以问题应该是出在原本应该是Check的操作变成了Pick up，导致玩家捡起了捕鸟器而不是收获捕到的鸟。但是如果使用空格捡的话，则会正确地执行Check操作。
接下来目标就很明确了：这个Pick up是哪里来的？
通过检索lua源码中""Pick up""，可以发现在strings.lua中有其定义：
STRINGS
 
=
 
{
    
--ACTION MOUSEOVER TEXT

    
ACTIONS
 
=

    
{

        
REPAIR
 
=
 
""Repair""
,

        
REPAIRBOAT
 
=
 
""Repair""
,

        
PICKUP
 
=
 
""Pick up""
,

        
CHOP
 
=
 
""Chop""
,

        
FERTILIZE
 
=
 
""Fertilize""
,

        
SMOTHER
 
=
 
""Extinguish""
,


...


}


}
再看看哪些地方引用了STRINGS.ACTIONS.PICKUP这个值，并没有找到，再找ACTIONS.PICKUP，发现一处有价值的线索：
也就是说，所有操作都是通过构造一个BufferedAction来封装的，从名字上来看既然是Buffered，应该会有一个队列之类的来存储Actions，继续找""BufferedAction""可以发现在scripts/components/playeractionpicker.lua里有些奇怪的东西：
function
 
PlayerActionPicker
:
SortActionList
(
actions
,
 
target
,
 
useitem
)

    
if
 
#
actions
 
>
 
0
 
then

        
table.sort
(
actions
,
 
function
(
l
,
 
r
)
 
return
 
l.priority
 
>
 
r.priority
 
end
)

        
local
 
ret
 
=
 
{}

        
for
 
k
,
v
 
in
 
ipairs
(
actions
)
 
do

            
if
 
not
 
target
 
then

                
table.insert
(
ret
,
 
BufferedAction
(
self.inst
,
 
nil
,
 
v
,
 
useitem
))

            
elseif
 
target
:
is_a
(
EntityScript
)
 
then

                
table.insert
(
ret
,
 
BufferedAction
(
self.inst
,
 
target
,
 
v
,
 
useitem
))

            
elseif
 
target
:
is_a
(
Vector3
)
 
then

                
local
 
quantizedTarget
 
=
 
target
 
                
local
 
distance
 
=
 
nil
 

                
--If we're deploying something it might snap to a grid, if so we want to use the quantized position as the target pos 

                
if
 
v
 
==
 
ACTIONS.DEPLOY
 
and
 
useitem.components
.
deployable
 
then
 
                    
distance
 
=
 
useitem.components
.
deployable.deploydistance

                    
quantizedTarget
 
=
 
useitem.components
.
deployable
:
GetQuantizedPosition
(
target
)

                
end


                
local
 
ba
 
=
 
BufferedAction
(
self.inst
,
 
nil
,
 
v
,
 
useitem
,
 
quantizedTarget
)

                
if
 
distance
 
then
 
                    
ba.action
.
distance
 
=
 
distance
 
                
end
 
                
table.insert
(
ret
,
 
ba
)

            
end

        
end

        
return
 
ret

    
end


end



function
 
PlayerActionPicker
:
GetSceneActions
(
targetobject
,
 
right
)

    
local
 
actions
 
=
 
{}


    
for
 
k
,
v
 
in
 
pairs
(
targetobject.components
)
 
do

        
if
 
v.CollectSceneActions
 
then

            
v
:
CollectSceneActions
(
self.inst
,
 
actions
,
 
right
)

        
end

    
end


	
if
 
targetobject.inherentsceneaction
 
and
 
not
 
right
 
then

		
table.insert
(
actions
,
 
targetobject.inherentsceneaction
)

	
end


	
if
 
targetobject.inherentscenealtaction
 
and
 
right
 
then

		
table.insert
(
actions
,
 
targetobject.inherentscenealtaction
)

	
end


    
if
 
#
actions
 
==
 
0
 
and
 
targetobject.components
.
inspectable
 
then

        
table.insert
(
actions
,
 
ACTIONS.WALKTO
)

    
end


    
return
 
self
:
SortActionList
(
actions
,
 
targetobject
)


end
仔细看了半天，这里似乎是一个比较关键的地方。所有的BufferedAction在这里通过table.sort按priority排了个序。我猜想游戏逻辑应该是先收集各种可选的操作选项，然后把操作们按优先级排个序，顶端的即为优胜者，将会被选作默认的操作（亲，你直接选个最大值不就得了吗）。
因此，要么是排序前的actions有已经有问题了，要么是排序本身出的问题。通过这里我们应该可以缩小检查的范围。
0x10 不稳定天平
为了验证我的想法，在SortSceneActions里写点LOG。看看好不好玩：
local
 
mapActionToName
 
=
 
{}


for
 
k
,
 
v
 
in
 
pairs
(
STRINGS.ACTIONS
)
 
do

    
local
 
m
 
=
 
ACTIONS
[
k
]

    
if
 
(
m
)
 
then

        
mapActionToName
[
m
]
 
=
 
k

    
end


end



local
 
function
 
PrintList
(
actions
)

    
for
 
i
,
 
v
 
in
 
ipairs
(
actions
)
 
do

        
print
(
""ACTION [""
 
..
 
i
 
..
 
""] = ""
 
..
 
(
mapActionToName
[
v
]
 
or
 
""NULL""
))

    
end


end



function
 
PlayerActionPicker
:
SortActionList
(
actions
,
 
target
,
 
useitem
)

    
if
 
#
actions
 
>
 
0
 
then

        
print
(
""-----------------------""
)

        
print
(
""Before sorting ... ""
)

        
PrintList
(
actions
)

        
table.sort
(
actions
,
 
function
(
l
,
 
r
)
 
return
 
l.priority
 
>
 
r.priority
 
end
)

        
print
(
""After sorting ... ""
)

        
PrintList
(
actions
)

        
        
local
 
ret
 
=
 
{}

        
for
 
k
,
v
 
in
 
ipairs
(
actions
)
 
do

            
if
 
not
 
target
 
then

                
table.insert
(
ret
,
 
BufferedAction
(
self.inst
,
 
nil
,
 
v
,
 
useitem
))

            
elseif
 
target
:
is_a
(
EntityScript
)
 
then

                
table.insert
(
ret
,
 
BufferedAction
(
self.inst
,
 
target
,
 
v
,
 
useitem
))

            
elseif
 
target
:
is_a
(
Vector3
)
 
then

                
local
 
quantizedTarget
 
=
 
target
 
                
local
 
distance
 
=
 
nil
 

                
--If we're deploying something it might snap to a grid, if so we want to use the quantized position as the target pos 

                
if
 
v
 
==
 
ACTIONS.DEPLOY
 
and
 
useitem.components
.
deployable
 
then
 
                    
distance
 
=
 
useitem.components
.
deployable.deploydistance

                    
quantizedTarget
 
=
 
useitem.components
.
deployable
:
GetQuantizedPosition
(
target
)

                
end


                
local
 
ba
 
=
 
BufferedAction
(
self.inst
,
 
nil
,
 
v
,
 
useitem
,
 
quantizedTarget
)

                
if
 
distance
 
then
 
                    
ba.action
.
distance
 
=
 
distance
 
                
end
 
                
table.insert
(
ret
,
 
ba
)

            
end

        
end

        
return
 
ret

    
end


end
在排序前后我都把actions数组中的值打印出来，看看这个排序做了什么：
（启用PATCH前）
（启用PATCH后）
注意看图中蓝框的部分，排序后的结果果然变成PICKUP第一了。于是一个直接的想法就是，饥荒作者并不知道table.sort排序是不稳定的，LuaJIT中的快排算法很可能和原版的不一样，在最大元素不唯一的情况下，二者的结果就会有差异！！
于是我打开actions.lua，一切都似乎明白了：
Action
 
=
 
Class
(
function
(
self
,
 
priority
,
 
instant
,
 
rmb
,
 
distance
,
 
crosseswaterboundary
)
 
	
self.priority
 
=
 
priority
 
or
 
0

	
self.fn
 
=
 
function
()
 
return
 
false
 
end

	
self.strfn
 
=
 
nil

	
self.testfn
 
=
 
nil

	
self.instant
 
=
 
instant
 
or
 
false

	
self.rmb
 
=
 
rmb
 
or
 
nil

	
self.distance
 
=
 
distance
 
or
 
nil

	
self.crosseswaterboundary
 
=
 
crosseswaterboundary
 
or
 
false


end
)



ACTIONS
=


{

	
REPAIR
 
=
 
Action
(),

	
...

	
PICKUP
 
=
 
Action
(
2
),

	
...

	
CHECKTRAP
 
=
 
Action
(
2
),

	
BUILD
 
=
 
Action
(),

	
PLANT
 
=
 
Action
(),

	
...


}
非常明显，PICKUP和CHECKTRAP的优先级都是2，那么排序就有可能出现PICKUP在CHECKTRAP前面的情况。
想要解决也很容易，把CHECKTRAP的优先级调大些（如2.5），就好了。事实证明调整后，bug也确实消失了。
然而问题就到这里完结了吗？
0x11 依赖于错误的正确
这个bug的神奇之处在于，并不仅仅如此。
在发布了修补办法之后，吧友表示问题解决了，但是还有其他的类似问题，比如船只不能Inspect，MOD人物翼语的莲花台不能右键拾取，烤箱MOD异常等等。
确实，这些都是原版饥荒Actions优先级设置导致的，那么有两种可能：
1. 作者们修改了排序算法，使之变成稳定的（如冒泡排序），所以在优先级相同的时候，原序列中排前面的排序后也排前面。
2. 作者们压根就不知道快排还有不稳定一说，出现结果异常的时候就调调优先级，结果要是符合预期，就不管了。lua5.1.4中快排实现和LuaJIT中不一样导致了这个问题。
最初我以为是1的问题，于是手写了个稳定排序，挂入后果然解决了陷阱的问题（即使优先级都是2）。但是其余的bug不能都解决，此路不通。
那么如果按2来说，快排实现不一样，那么我换一个lua5.1.4原版的DLL试试呢？
于是我把lua51.dll改名成luajit.dll，运行游戏，果然一切正常。看来就是排序算法的问题了。
于是我打开lua5.1.4的源码，对比luajit的源码，却发现了神奇的事情：排序算法除了报错部分有点区别以外，竟然是一模一样！！
那这个就奇怪了，排序算法也是一样的，为什么结果不一样呢？我漏掉了什么东西吗？
再仔细检查这两张图，终于发现了问题所在：
（启用PATCH前）
（启用PATCH后）
之前我一直关注排序后的结果，却没发现排序前的数据顺序也是不一样的（红框所示）。也就是说，问题本身与排序算法没有关系，与错误的priority虽有关系，但不是致命的。
致命的是排序前数据的顺序是为何不同的！
沿着SortActionList往上找，果然，刚刚就在眼皮底下错过了：
function
 
PlayerActionPicker
:
GetSceneActions
(
targetobject
,
 
right
)

    
local
 
actions
 
=
 
{}


    
for
 
k
,
v
 
in
 
pairs
(
targetobject.components
)
 
do

        
if
 
v.CollectSceneActions
 
then

            
v
:
CollectSceneActions
(
self.inst
,
 
actions
,
 
right
)

        
end

    
end


	
if
 
targetobject.inherentsceneaction
 
and
 
not
 
right
 
then

		
table.insert
(
actions
,
 
targetobject.inherentsceneaction
)

	
end


	
if
 
targetobject.inherentscenealtaction
 
and
 
right
 
then

		
table.insert
(
actions
,
 
targetobject.inherentscenealtaction
)

	
end


    
if
 
#
actions
 
==
 
0
 
and
 
targetobject.components
.
inspectable
 
then

        
table.insert
(
actions
,
 
ACTIONS.WALKTO
)

    
end


    
return
 
self
:
SortActionList
(
actions
,
 
targetobject
)


end
不管你信不信，问题就出在这个函数里的for循环上。
如果您看过前文的话，就能明白我的意思――for循环的枚举顺序是与string HASH算法有关的！而v:CollectSceneActions是顺序往actions中添加ACTION的，那么，不同的枚举顺序就会导致ACTION在actions里的顺序不一致。
而LuaJIT的string HASH算法和原版lua的并不一样，这也是前文联机版RPC出bug的原因。
那么，我们把逻辑整理一下，完整的bug触发流程是：
string HASH算法不一致 => table里key的遍历顺序不一致 => actions里的ACTION顺序不一致 + 排序算法不稳定且待排序数组中存在键相等(priority相等)的问题 => 排序结果不一致 => 选中的操作不一致。
事已至此，所有的谜团都已经解开了。回头来看，如果饥荒作者在发现actions排序后顺序奇怪的时候能想到这是排序算法的稳定性，那么就绝不会只调整个别ACTION的priority来解决，而是会重新为所有的ACTION明确不同的priority。如果他们这么做了，整个问题就完全不会出现。
而现在，程序能够正确运行完全依赖于特定排序算法对特定数据的排序结果。试想如果有一个mod手工添加了一个ACTION；或者随着版本更新，作者又在targetobject.components里添加了一个默认components，都会导致排序的结果与预期的不一致，而且这种不一致会导致大面积的逻辑错误，极难排除。
更麻烦的在于，已经有不少第三方MOD使用了ACTION。如果随便改掉默认ACTION的priority值可能会导致这些MOD出错。
因此这个bug就慢慢地变成了feature，且无人敢动。
那么怎么解决呢？我没办法，只能把lua5.1.4的string HASH算法复制出来，替换掉luajit的那份实现了。这个同时也解决了之前RPC的问题，不用再修改代码了。我其实不想这么改，因为这样的设计将会面临更高的安全风险。但是没办法，将错就错吧。
==================================
中间省略一些章节，下面这个话题是这个bug的延续。问题的表现比较相似，但是解决起来更加棘手。
==================================
0x20 暗号
当我刚开始制作DST版本的饥荒LuaJIT补丁时，为了保证最大限度的兼容，要求用户在服务器和客户端上都启用补丁。但是实际的情况往往是，很多服务器并不在玩家的控制之中（如一些联机平台提供的服务器），而且大量服务器使用了linux版的饥荒。因此为了扩宽补丁的适用范围，需要对原版饥荒进行兼容，使得服务器不使用LuaJIT补丁时，使用了补丁的客户端也能够正常和服务器通讯。
按照之前文章的描述，Lua和LuaJIT不兼容的地方已经被修复了很多，然而在这些修复都完成之后，带有LuaJIT补丁的客户端仍然不能正确和服务器通讯，具体的表现是，非服务器的一方将不能正确通过鼠标拾取物品或者采集资源（键盘可以）、吃食物、调整物品栏物品的顺序、扔下物品、将物品给予他人等。
之前我曾经在前文提到过因为对象成员遍历顺序不一致导致RPC code不一致的问题。然而当我再次查看RPC列表时，却发现即使我把string hash的算法改成一样的，LuaJIT和Lua所生成的RPC列表也是有一点点不同的：
启用了LuaJIT补丁后的饥荒：  
原版饥荒：  
全部49个RPC调用中，绝大多数都是匹配的，惟独第1和第48号所对应的服务函数在LuaJIT和Lua中正好对调了一下。是不是就因为这两个函数导致了如前所述的问题呢？
答案是否定的，即使我用硬编码把两者的顺序强行指定一下，上面的问题一个也不会少。仔细研究了下出问题的这两个函数恰好是不重要的两个函数，和问题中所提到的那些操作都是没有关系的。难道传递这些操作还需要核对什么隐藏的暗号吗？
0x21 表象
那么，既然连相同的string hash算法都没有办法得到相同的表，那么很可能有其他地方也用到了类似的ID分配策略。研究了一阵，发现两处问题所在：
一个是在scripts\actions.lua中：
ACTIONS =
{
    REPAIR = Action({ encumbered_valid=true }),
    READ = Action({ mount_valid=true }),
    DROP = Action({ priority=-1, mount_valid=true, encumbered_valid=true }),
    TRAVEL = Action(),
    ... 中间省略
    SADDLE = Action({ priority=1 }),
    UNSADDLE = Action({ priority=3, rmb=false }),
    BRUSH = Action({ priority=3, rmb=false }),
}

ACTION_IDS = {}
for k, v in pairs(ACTIONS) do
    v.str = STRINGS.ACTIONS[k] or ""ACTION""
    v.id = k
    table.insert(ACTION_IDS, k)
    v.code = #ACTION_IDS
end
另一处在scripts\componentactions.lua
local COMPONENT_ACTIONS =
{
    ... 省略
    POINT = --args: inst, doer, pos, actions, right
    {
        blinkstaff = function(inst, doer, pos, actions, right)
            if right and TheWorld.Map:IsAboveGroundAtPoint(pos:Get()) then
                table.insert(actions, ACTIONS.BLINK)
            end
        end,

        complexprojectile = function(inst, doer, target, actions, right)
            if right then
                table.insert(actions, ACTIONS.TOSS)
            end
        end,

    },

    EQUIPPED = --args: inst, doer, target, actions, right
    {
        brush = function(inst, doer, target, actions, right)
            if not right and target:HasTag(""brushable"") then
                table.insert(actions, ACTIONS.BRUSH)
            end
        end,

    },

    INVENTORY = --args: inst, doer, actions, right
    {
        balloonmaker = function(inst, doer, actions)
            if doer:HasTag(""balloonomancer"") then
                table.insert(actions, ACTIONS.MAKEBALLOON)
            end
        end,

        book = function(inst, doer, actions)
            if doer:HasTag(""reader"") then
                table.insert(actions, ACTIONS.READ)
            end
        end,
    },

    ISVALID = --args: inst, action, right
    {
        workable = function(inst, action, right)
            return (right or action ~= ACTIONS.HAMMER) and
                inst:HasTag(action.id..""_workable"")
        end,
    },
}

local ACTION_COMPONENT_NAMES = {}
local ACTION_COMPONENT_IDS = {}

local function RemapComponentActions()
    for k, v in pairs(COMPONENT_ACTIONS) do
        for cmp, fn in pairs(v) do
            if ACTION_COMPONENT_IDS[cmp] == nil then
                table.insert(ACTION_COMPONENT_NAMES, cmp)
                ACTION_COMPONENT_IDS[cmp] = #ACTION_COMPONENT_NAMES
            end
        end
    end
end
RemapComponentActions()


RPC ID不是唯一的区分不同操作的ID，有些RPC请求中会有部分数据要依赖于刚才这两个表中的动作ID。而经过测试这两个表里面ID乱得是比较严重的――LuaJIT和Lua的遍历结果差得十万八千里。而且从其内容来看，也与有问题的操作相关。看到这里心里差不多就能肯定它就是我们要找的目标了。
那么怎么改呢？硬编码这些数据并且在
luajit
加载对应模块时作替换吗？全局表或许可以，但是local定义的局部表是比较麻烦的。一方面，局部表只作为upvalue被函数引用，从加载后的模块中找到这个表比较困难。另一方面，lua/luajit的parser在加载代码的时候不会把整个文件读进来，而是由On Demand方式的loader进行加载的，这样试图从中截取到local xxxx = {}这样的定义并修改是很难做得比较健壮的。
还有一个问题，我们即使能够通过hack的办法让这两个表拥有正确的哈希顺序，也不能根本性地解决这个问题。毕竟其他现有代码也有可能触发这个问题，而随着游戏更新和MOD的加入，也不保证新的代码能绕过这些坑。
看来只有从源头上解决这个问题了。
0x22 根源
那么排除了string hash算法的影响之后，还有哪些因素会影响到遍历表的顺序呢？
1. 对hash取的模/掩码
由于hash值通常是一个较大的整数，那么往哈希表中放的时候需要先对一个数（通常是表大小）取模。Lua和LuaJIT取的模都是2^n，实现完全一样。
2. 初始表的哈希部分大小
某些情况下初始表LuaJIT要大一些（256），但是改成相同的值并不能解决问题
3. 哈希表的冲突解决方案
两者采用的方案都是维护一个从尾开始的“空余项指针”，在冲突之后优先从这里分配。所有HASH相同的项都会通过链表串起来。
4. 重哈希的策略
重哈希都是扩展为原来两倍大小，并且按hash顺序装填原有元素。所不同的是Lua是hash逆序遍历原有元素，而LuaJIT是顺序遍历的。但是把LuaJIT也改成逆序之后，LuaJIT的结果和上次不同了，但是和Lua的结果还是不一样。
5. 删除键值的策略
出现问题的表是直接用初始化列表构造的，不存在删除的问题。因而也不会是这个原因。
6. 用初始化列表构造时的策略
在排除了以上5种可能之后，我终于发现了线索。线索的发现过程非常漫长（花了一天多），也走了很多弯路，为了节约笔墨就不写是怎么发现的了。为了便于说明这种情况，我举个例子，这样的代码：
local
 
RPC_HANDLERS
 
=


{

    
LeftClick
 
=
 
function
()

    
end
,


    
RightClick
 
=
 
function
()

    
end
,


    
ActionButton
 
=
 
function
()

    
end
,


    
AttackButton
 
=
 
function
()

    
end
,


    
InspectButton
 
=
 
function
()

    
end
,


    
ResurrectButton
 
=
 
function
()

    
end
,


    
ControllerActionButton
 
=
 
function
()

    
end
,


    
ControllerActionButtonDeploy
 
=
 
function
()

    
end
,


    
ControllerAltActionButton
 
=
 
function
()

    
end
,



}



local
 
i
 
=
 
1


for
 
k
,
 
v
 
in
 
pairs
(
RPC_HANDLERS
)
 
do

    
print
(
""RPC [""
 
..
 
i
 
..
 
""] = ""
 
..
 
k
)

    
i
 
=
 
i
 
+
 
1


end


i
 
=
 
nil



print
(
""-----------------------------------""
)




local
 
RPC_HANDLERS2
 
=


{


}



RPC_HANDLERS2.LeftClick
 
=
 
function
()


end



RPC_HANDLERS2.RightClick
 
=
 
function
()


end



RPC_HANDLERS2.ActionButton
 
=
 
function
()


end



RPC_HANDLERS2.AttackButton
 
=
 
function
()


end



RPC_HANDLERS2.InspectButton
 
=
 
function
()


end



RPC_HANDLERS2.ResurrectButton
 
=
 
function
()


end



RPC_HANDLERS2.ControllerActionButton
 
=
 
function
()


end



RPC_HANDLERS2.ControllerActionButtonDeploy
 
=
 
function
()


end



RPC_HANDLERS2.ControllerAltActionButton
 
=
 
function
()


end



local
 
i
 
=
 
1


for
 
k
,
 
v
 
in
 
pairs
(
RPC_HANDLERS2
)
 
do

    
print
(
""RPC [""
 
..
 
i
 
..
 
""] = ""
 
..
 
k
)

    
i
 
=
 
i
 
+
 
1


end


i
 
=
 
nil




在lua5.1.4下的输出为：
RPC
 
[
1
]
 
=
 
AttackButton


RPC
 
[
2
]
 
=
 
ControllerActionButtonDeploy


RPC
 
[
3
]
 
=
 
ControllerActionButton


RPC
 
[
4
]
 
=
 
ResurrectButton


RPC
 
[
5
]
 
=
 
RightClick


RPC
 
[
6
]
 
=
 
ControllerAltActionButton


RPC
 
[
7
]
 
=
 
LeftClick


RPC
 
[
8
]
 
=
 
InspectButton


RPC
 
[
9
]
 
=
 
ActionButton


-----------------------------------


RPC
 
[
1
]
 
=
 
AttackButton


RPC
 
[
2
]
 
=
 
ControllerActionButtonDeploy


RPC
 
[
3
]
 
=
 
ControllerActionButton


RPC
 
[
4
]
 
=
 
ResurrectButton


RPC
 
[
5
]
 
=
 
ActionButton


RPC
 
[
6
]
 
=
 
ControllerAltActionButton


RPC
 
[
7
]
 
=
 
LeftClick


RPC
 
[
8
]
 
=
 
RightClick


RPC
 
[
9
]
 
=
 
InspectButton




而LuaJIT 2.0的输出为：
RPC [1] = ControllerAltActionButton
RPC [2] = ActionButton
RPC [3] = ControllerActionButtonDeploy
RPC [4] = RightClick
RPC [5] = InspectButton
RPC [6] = AttackButton
RPC [7] = LeftClick
RPC [8] = ResurrectButton
RPC [9] = ControllerActionButton
-----------------------------------
RPC [1] = ControllerAltActionButton
RPC [2] = ActionButton
RPC [3] = ControllerActionButtonDeploy
RPC [4] = RightClick
RPC [5] = InspectButton
RPC [6] = AttackButton
RPC [7] = LeftClick
RPC [8] = ResurrectButton
RPC [9] = ControllerActionButton


可以看出，除了lua 5.1.4在面对初始化列表构造以外，其余的三个结果都是相同的。这说明lua 5.1.4在面对初始化列表构造时的策略和先构造一张表，再一个个添加项目时的处理是不一样的。而LuaJIT无论是哪种构造，都是先构造一张表，再一个个添加项目的。
lua 5.1.4作了什么处理呢？我们来看代码：
lparser.c:
static
 
void
 
constructor
 
(
LexState
 
*
ls
,
 
expdesc
 
*
t
)
 
{

  
/* constructor -> ?? */

  
FuncState
 
*
fs
 
=
 
ls
->
fs
;

  
int
 
line
 
=
 
ls
->
linenumber
;

  
int
 
pc
 
=
 
luaK_codeABC
(
fs
,
 
OP_NEWTABLE
,
 
0
,
 
0
,
 
0
);

  
struct
 
ConsControl
 
cc
;

  
cc
.
na
 
=
 
cc
.
nh
 
=
 
cc
.
tostore
 
=
 
0
;

  
cc
.
t
 
=
 
t
;

  
init_exp
(
t
,
 
VRELOCABLE
,
 
pc
);

  
init_exp
(
&
cc
.
v
,
 
VVOID
,
 
0
);
  
/* no value (yet) */

  
luaK_exp2nextreg
(
ls
->
fs
,
 
t
);
  
/* fix it at stack top (for gc) */

  
checknext
(
ls
,
 
'{'
);

  
do
 
{

    
lua_assert
(
cc
.
v
.
k
 
==
 
VVOID
 
||
 
cc
.
tostore
 
>
 
0
);

    
if
 
(
ls
->
t
.
token
 
==
 
'}'
)
 
break
;

    
closelistfield
(
fs
,
 
&
cc
);

    
switch
(
ls
->
t
.
token
)
 
{

      
case
 
TK_NAME
:
 
{
  
/* may be listfields or recfields */

        
luaX_lookahead
(
ls
);

        
if
 
(
ls
->
lookahead
.
token
 
!=
 
'='
)
  
/* expression? */

          
listfield
(
ls
,
 
&
cc
);

        
else

          
recfield
(
ls
,
 
&
cc
);

        
break
;

      
}

      
case
 
'['
:
 
{
  
/* constructor_item -> recfield */

        
recfield
(
ls
,
 
&
cc
);

        
break
;

      
}

      
default
:
 
{
  
/* constructor_part -> listfield */

        
listfield
(
ls
,
 
&
cc
);

        
break
;

      
}

    
}

  
}
 
while
 
(
testnext
(
ls
,
 
','
)
 
||
 
testnext
(
ls
,
 
';'
));

  
check_match
(
ls
,
 
'}'
,
 
'{'
,
 
line
);

  
lastlistfield
(
fs
,
 
&
cc
);

  
SETARG_B
(
fs
->
f
->
code
[
pc
],
 
luaO_int2fb
(
cc
.
na
));
 
/* set initial array size */

  
SETARG_C
(
fs
->
f
->
code
[
pc
],
 
luaO_int2fb
(
cc
.
nh
));
  
/* set initial table size */


}




注意cc.na和cc.nh这两个变量，它分别记录了表在构造过程中数组部分和哈希部分的数量。并在所有数据都读入后才去构造最终的表。也就是说，这个表的构造只经过了一次一步到位的哈希空间的分配。而如果先构造一个表，再一条条加的话，会经历多次重哈希。由于后者重哈希时重插入的顺序与最初的构造顺序不一致（重插入是按当时的哈希值取模后的顺序来排的，和最初的构造顺序不一样），因此最终的哈希表的构造并不相同！
0x04 药方
与此同时，让我们来看看LuaJIT中的处理是怎么样的：
static
 
void
 
expr_table
(
LexState
 
*
ls
,
 
ExpDesc
 
*
e
)


{

  
FuncState
 
*
fs
 
=
 
ls
->
fs
;

  
BCLine
 
line
 
=
 
ls
->
linenumber
;

  
GCtab
 
*
t
 
=
 
NULL
;

  
int
 
vcall
 
=
 
0
,
 
needarr
 
=
 
0
,
 
fixt
 
=
 
0
;

  
uint32_t
 
narr
 
=
 
1
;
  
/* First array index. */

  
uint32_t
 
nhash
 
=
 
0
;
  
/* Number of hash entries. */

  
BCReg
 
freg
 
=
 
fs
->
freereg
;

  
BCPos
 
pc
 
=
 
bcemit_AD
(
fs
,
 
BC_TNEW
,
 
freg
,
 
0
);

  
expr_init
(
e
,
 
VNONRELOC
,
 
freg
);

  
bcreg_reserve
(
fs
,
 
1
);

  
freg
++
;

  
lex_check
(
ls
,
 
'{'
);

  
while
 
(
ls
->
tok
 
!=
 
'}'
)
 
{

    
ExpDesc
 
key
,
 
val
;

    
vcall
 
=
 
0
;

    
if
 
(
ls
->
tok
 
==
 
'['
)
 
{

      
expr_bracket
(
ls
,
 
&
key
);
  
/* Already calls expr_toval. */

      
if
 
(
!
expr_isk
(
&
key
))
 
expr_index
(
fs
,
 
e
,
 
&
key
);

      
if
 
(
expr_isnumk
(
&
key
)
 
&&
 
expr_numiszero
(
&
key
))
 
needarr
 
=
 
1
;
 
else
 
nhash
++
;

      
lex_check
(
ls
,
 
'='
);

    
}
 
else
 
if
 
((
ls
->
tok
 
==
 
TK_name
 
||
 
(
!
LJ_52
 
&&
 
ls
->
tok
 
==
 
TK_goto
))
 
&&

	       
lj_lex_lookahead
(
ls
)
 
==
 
'='
)
 
{

      
expr_str
(
ls
,
 
&
key
);

      
lex_check
(
ls
,
 
'='
);

      
nhash
++
;

    
}
 
else
 
{

      
expr_init
(
&
key
,
 
VKNUM
,
 
0
);

      
setintV
(
&
key
.
u
.
nval
,
 
(
int
)
narr
);

      
narr
++
;

      
needarr
 
=
 
vcall
 
=
 
1
;

    
}

    
expr
(
ls
,
 
&
val
);

    
if
 
(
expr_isk
(
&
key
)
 
&&
 
key
.
k
 
!=
 
VKNIL
 
&&

	
(
key
.
k
 
==
 
VKSTR
 
||
 
expr_isk_nojump
(
&
val
)))
 
{

      
TValue
 
k
,
 
*
v
;

      
if
 
(
!
t
)
 
{
  
/* Create template table on demand. */

	
BCReg
 
kidx
;

	
t
 
=
 
lj_tab_new
(
fs
->
L
,
 
needarr
 
?
 
narr
 
:
 
0
,
 
hsize2hbits
(
nhash
));

	
kidx
 
=
 
const_gc
(
fs
,
 
obj2gco
(
t
),
 
LJ_TTAB
);

	
fs
->
bcbase
[
pc
].
ins
 
=
 
BCINS_AD
(
BC_TDUP
,
 
freg
-
1
,
 
kidx
);

      
}

      
vcall
 
=
 
0
;

      
expr_kvalue
(
&
k
,
 
&
key
);

      
v
 
=
 
lj_tab_set
(
fs
->
L
,
 
t
,
 
&
k
);

      
lj_gc_anybarriert
(
fs
->
L
,
 
t
);

      
if
 
(
expr_isk_nojump
(
&
val
))
 
{
  
/* Add const key/value to template table. */

	
expr_kvalue
(
v
,
 
&
val
);

      
}
 
else
 
{
  
/* Otherwise create dummy string key (avoids lj_tab_newkey). */

	
settabV
(
fs
->
L
,
 
v
,
 
t
);
  
/* Preserve key with table itself as value. */

	
fixt
 
=
 
1
;
   
/* Fix this later, after all resizes. */

	
goto
 
nonconst
;

      
}

    
}
 
else
 
{

    
nonconst
:

      
if
 
(
val
.
k
 
!=
 
VCALL
)
 
{
 
expr_toanyreg
(
fs
,
 
&
val
);
 
vcall
 
=
 
0
;
 
}

      
if
 
(
expr_isk
(
&
key
))
 
expr_index
(
fs
,
 
e
,
 
&
key
);

      
bcemit_store
(
fs
,
 
e
,
 
&
val
);

    
}

    
fs
->
freereg
 
=
 
freg
;

    
if
 
(
!
lex_opt
(
ls
,
 
','
)
 
&&
 
!
lex_opt
(
ls
,
 
';'
))
 
break
;

  
}


  
lex_match
(
ls
,
 
'}'
,
 
'{'
,
 
line
);

  
...
nhash虽然也是记录哈希项的数量的，但是由于t在第一条key-value时就已经被构造出来了，因此这时nhash并不是最终哈希项的数量，这个表在构造过程中将不可避免地面临重哈希。从而产生不同于lua的结果。
那么怎么改呢？比较麻烦。由于整个parser是one-pass的，LexState和FuncState是同步向下走的，所以想到推迟表的构造时间并不是那么现实。我起初想把LexState的值缓存出来，在整个表解析完后再构造t（这时已经有正确的nhash了）。然而试了好久都没有成功，原因是中间那个expr调用还可能再遇到一张初始化列表，一些依赖于LexState的值的缓存会失效，从而造成子表的值出错。
最后我想到一个简单的办法：表呢，按要求构造，expr_table也按要求执行，但是把所有插入值的操作在低层拦下来，然后统一commit的时候进行重哈希，就不会干扰到LexState，也解决了问题。
具体了方案如下：
修改table结构(lj_obj.h)：
typedef
 
struct
 
{

	
Node
 
head
;

	
MRef
 
current
;

	
uint32_t
 
size
;


}
 
Cache
;



typedef
 
struct
 
GCtab
 
{

  
GCHeader
;

  
uint8_t
 
nomm
;
		
/* Negative cache for fast metamethods. */

  
int8_t
 
colo
;
		
/* Array colocation. */

  
MRef
 
array
;
		
/* Array part. */

  
GCRef
 
gclist
;

  
GCRef
 
metatable
;
	
/* Must be at same offset in GCudata. */

  
Cache
*
 
cache
;

  
MRef
 
node
;
		
/* Hash part. */

  
uint32_t
 
asize
;
	
/* Size of array part (keys [0, asize-1]). */

  
uint32_t
 
hmask
;
	
/* Hash part mask (size of hash part - 1). */


#if LJ_GC64

  
MRef
 
freetop
;
		
/* Top of free elements. */


#endif

}
 
GCtab
;



添加了一个用于缓存的结构Cache指针。
再写两个函数(lj_tab.c)：
void
 
lj_tab_prepare_cache
(
lua_State
*
 
L
,
 
GCtab
*
 
t
)
 
{

	
Cache
*
 
cache
 
=
 
(
Cache
*
)
malloc
(
sizeof
(
Cache
));

	
cache
->
size
 
=
 
0
;

	
setmref
(
cache
->
head
.
next
,
 
NULL
);

	
setmref
(
cache
->
current
,
 
&
cache
->
head
);


	
lua_assert
(
t
->
cache
 
==
 
NULL
);

	
lua_assert
(
t
->
cacheHead
 
==
 
NULL
);

	
t
->
cache
 
=
 
cache
;


}



#define maxval(a, b) ((a) > (b) ? (a) : (b))



void
 
lj_tab_commit_cache
(
lua_State
*
 
L
,
 
GCtab
*
 
t
)
 
{

	
Cache
*
 
cache
 
=
 
t
->
cache
;

	
Node
*
 
head
;

	
lua_assert
(
cache
 
!=
 
NULL
);

	
t
->
cache
 
=
 
NULL
;

	
lj_tab_resize
(
L
,
 
t
,
 
t
->
asize
,
 
hsize2hbits
(
maxval
(
cache
->
size
,
 
t
->
hmask
 
+
 
1
)));

	
head
 
=
 
noderef
(
cache
->
head
.
next
);

	
/*

		printf(""START COMMIT!!\n"");

		*/

	
while
 
(
head
 
!=
 
NULL
)
 
{

		
Node
*
 
p
 
=
 
noderef
(
head
->
next
);

		
TValue
*
 
v
 
=
 
lj_tab_newkey
(
L
,
 
t
,
 
&
head
->
key
);

		
/*

		printf(""COMMIT!!\n"");

		if (tvisstr(&head->key)) {

			printf(""COMMIT VALUE: %s\n"", strdata(strV(&head->key)));

		}*/

		
		
*
v
 
=
 
head
->
val
;

		
free
(
head
);

		
head
 
=
 
p
;

	
}


	
free
(
cache
);


}



配合lj_tab_newkey前加一些语句用于拦截：
/* Insert new key. Use Brent's variation to optimize the chain length. */


TValue
 
*
lj_tab_newkey
(
lua_State
 
*
L
,
 
GCtab
 
*
t
,
 
cTValue
 
*
key
)


{

	
Node
*
 
n
;

	
if
 
(
t
->
cache
 
!=
 
NULL
)
 
{

		
Node
*
 
p
 
=
 
(
Node
*
)
malloc
(
sizeof
(
Node
));

		
setmref
(
p
->
next
,
 
NULL
);

		
setmref
(
noderef
(
t
->
cache
->
current
)
->
next
,
 
p
);

		
setmref
(
t
->
cache
->
current
,
 
p
);

		
setnilV
(
&
p
->
val
);

		
p
->
key
 
=
 
*
key
;

		
t
->
cache
->
size
++
;

		
/*

		if (tvisstr(key)) {

			printf(""CACHED VALUE: %s\n"", strdata(strV(key)));

		}*/

		
return
 
&
p
->
val
;

	
}

        
...


}
最后，修改expr_table，使得在解析表时启用我们的缓存：
/* Parse table constructor expression. */


static
 
void
 
expr_table
(
LexState
 
*
ls
,
 
ExpDesc
 
*
e
)


{

  
FuncState
 
*
fs
 
=
 
ls
->
fs
;

  
BCLine
 
line
 
=
 
ls
->
linenumber
;

  
GCtab
 
*
t
 
=
 
NULL
;

  
int
 
vcall
 
=
 
0
,
 
needarr
 
=
 
0
,
 
fixt
 
=
 
0
;

  
uint32_t
 
narr
 
=
 
1
;
  
/* First array index. */

  
uint32_t
 
nhash
 
=
 
0
;
  
/* Number of hash entries. */

  
BCReg
 
freg
 
=
 
fs
->
freereg
;

  
BCPos
 
pc
 
=
 
bcemit_AD
(
fs
,
 
BC_TNEW
,
 
freg
,
 
0
);

  
expr_init
(
e
,
 
VNONRELOC
,
 
freg
);

  
bcreg_reserve
(
fs
,
 
1
);

  
freg
++
;

  
lex_check
(
ls
,
 
'{'
);

  
while
 
(
ls
->
tok
 
!=
 
'}'
)
 
{

    
ExpDesc
 
key
,
 
val
;

    
vcall
 
=
 
0
;

    
if
 
(
ls
->
tok
 
==
 
'['
)
 
{

      
expr_bracket
(
ls
,
 
&
key
);
  
/* Already calls expr_toval. */

      
if
 
(
!
expr_isk
(
&
key
))
 
expr_index
(
fs
,
 
e
,
 
&
key
);

      
if
 
(
expr_isnumk
(
&
key
)
 
&&
 
expr_numiszero
(
&
key
))
 
needarr
 
=
 
1
;
 
else
 
nhash
++
;

      
lex_check
(
ls
,
 
'='
);

    
}
 
else
 
if
 
((
ls
->
tok
 
==
 
TK_name
 
||
 
(
!
LJ_52
 
&&
 
ls
->
tok
 
==
 
TK_goto
))
 
&&

	       
lj_lex_lookahead
(
ls
)
 
==
 
'='
)
 
{

      
expr_str
(
ls
,
 
&
key
);

      
lex_check
(
ls
,
 
'='
);

      
nhash
++
;

    
}
 
else
 
{

      
expr_init
(
&
key
,
 
VKNUM
,
 
0
);

      
setintV
(
&
key
.
u
.
nval
,
 
(
int
)
narr
);

      
narr
++
;

      
needarr
 
=
 
vcall
 
=
 
1
;

    
}

    
expr
(
ls
,
 
&
val
);

    
if
 
(
expr_isk
(
&
key
)
 
&&
 
key
.
k
 
!=
 
VKNIL
 
&&

	
(
key
.
k
 
==
 
VKSTR
 
||
 
expr_isk_nojump
(
&
val
)))
 
{

      
TValue
 
k
,
 
*
v
;

      
if
 
(
!
t
)
 
{
  
/* Create template table on demand. */

	
BCReg
 
kidx
;

	
t
 
=
 
lj_tab_new
(
fs
->
L
,
 
needarr
 
?
 
narr
 
:
 
0
,
 
hsize2hbits
(
nhash
));

	
kidx
 
=
 
const_gc
(
fs
,
 
obj2gco
(
t
),
 
LJ_TTAB
);

	
fs
->
bcbase
[
pc
].
ins
 
=
 
BCINS_AD
(
BC_TDUP
,
 
freg
-
1
,
 
kidx
);

	
lj_tab_prepare_cache
(
fs
->
L
,
 
t
);

      
}

      
vcall
 
=
 
0
;

      
expr_kvalue
(
&
k
,
 
&
key
);

      
v
 
=
 
lj_tab_set
(
fs
->
L
,
 
t
,
 
&
k
);

      
lj_gc_anybarriert
(
fs
->
L
,
 
t
);

      
if
 
(
expr_isk_nojump
(
&
val
))
 
{
  
/* Add const key/value to template table. */

	
expr_kvalue
(
v
,
 
&
val
);

      
}
 
else
 
{
  
/* Otherwise create dummy string key (avoids lj_tab_newkey). */

	
settabV
(
fs
->
L
,
 
v
,
 
t
);
  
/* Preserve key with table itself as value. */

	
fixt
 
=
 
1
;
   
/* Fix this later, after all resizes. */

	
goto
 
nonconst
;

      
}

    
}
 
else
 
{

    
nonconst
:

      
if
 
(
val
.
k
 
!=
 
VCALL
)
 
{
 
expr_toanyreg
(
fs
,
 
&
val
);
 
vcall
 
=
 
0
;
 
}

      
if
 
(
expr_isk
(
&
key
))
 
expr_index
(
fs
,
 
e
,
 
&
key
);

      
bcemit_store
(
fs
,
 
e
,
 
&
val
);

    
}

    
fs
->
freereg
 
=
 
freg
;

    
if
 
(
!
lex_opt
(
ls
,
 
','
)
 
&&
 
!
lex_opt
(
ls
,
 
';'
))
 
break
;

  
}


  
if
 
(
t
)
 
{

	  
lj_tab_commit_cache
(
fs
->
L
,
 
t
);

  
}


  
lex_match
(
ls
,
 
'}'
,
 
'{'
,
 
line
);

  
if
 
(
vcall
)
 
{

    
BCInsLine
 
*
ilp
 
=
 
&
fs
->
bcbase
[
fs
->
pc
-
1
];

    
ExpDesc
 
en
;

    
lua_assert
(
bc_a
(
ilp
->
ins
)
 
==
 
freg
 
&&

	       
bc_op
(
ilp
->
ins
)
 
==
 
(
narr
 
>
 
256
 
?
 
BC_TSETV
 
:
 
BC_TSETB
));

    
expr_init
(
&
en
,
 
VKNUM
,
 
0
);

    
en
.
u
.
nval
.
u32
.
lo
 
=
 
narr
-
1
;

    
en
.
u
.
nval
.
u32
.
hi
 
=
 
0x43300000
;
  
/* Biased integer to avoid denormals. */

    
if
 
(
narr
 
>
 
256
)
 
{
 
fs
->
pc
--
;
 
ilp
--
;
 
}

    
ilp
->
ins
 
=
 
BCINS_AD
(
BC_TSETM
,
 
freg
,
 
const_num
(
fs
,
 
&
en
));

    
setbc_b
(
&
ilp
[
-
1
].
ins
,
 
0
);

  
}

  
if
 
(
pc
 
==
 
fs
->
pc
-
1
)
 
{
  
/* Make expr relocable if possible. */

    
e
->
u
.
s
.
info
 
=
 
pc
;

    
fs
->
freereg
--
;

    
e
->
k
 
=
 
VRELOCABLE
;

  
}
 
else
 
{

    
e
->
k
 
=
 
VNONRELOC
;
  
/* May have been changed by expr_index. */

  
}

  
if
 
(
!
t
)
 
{
  
/* Construct TNEW RD: hhhhhaaaaaaaaaaa. */

    
BCIns
 
*
ip
 
=
 
&
fs
->
bcbase
[
pc
].
ins
;

    
if
 
(
!
needarr
)
 
narr
 
=
 
0
;

    
else
 
if
 
(
narr
 
<
 
3
)
 
narr
 
=
 
3
;

    
else
 
if
 
(
narr
 
>
 
0x7ff
)
 
narr
 
=
 
0x7ff
;

    
setbc_d
(
ip
,
 
narr
|
(
hsize2hbits
(
nhash
)
<<
11
));

  
}
 
else
 
{

    
if
 
(
needarr
 
&&
 
t
->
asize
 
<
 
narr
)

      
lj_tab_reasize
(
fs
->
L
,
 
t
,
 
narr
-
1
);

    
if
 
(
fixt
)
 
{
  
/* Fix value for dummy keys in template table. */

      
Node
 
*
node
 
=
 
noderef
(
t
->
node
);

      
uint32_t
 
i
,
 
hmask
 
=
 
t
->
hmask
;

      
for
 
(
i
 
=
 
0
;
 
i
 
<=
 
hmask
;
 
i
++
)
 
{

	
Node
 
*
n
 
=
 
&
node
[
i
];

	
if
 
(
tvistab
(
&
n
->
val
))
 
{

	  
lua_assert
(
tabV
(
&
n
->
val
)
 
==
 
t
);

	  
setnilV
(
&
n
->
val
);
  
/* Turn value into nil. */

	
}

      
}

    
}

    
lj_gc_check
(
fs
->
L
);

  
}


}



在表构造时调用lj_tab_prepare_cache以启用缓存，在构造结束时使用lj_tab_commit_cache将缓存中的结果刷入表中即可。
（不过其实这样的写法有个问题：就是如果异常发生了，分配的内存有可能会释放不掉。标准的做法是使用lua源码里的内存分配函数，分配出可gc的内存块放在lua state上。可惜写代码时太懒了。。）","全国电子设计大赛
，比赛做逆变器相关，做出来效率大于100%，找不出原因，评委也找了半天找不出原因。然后就给了一等奖。","答个前段时间刚发生的，不是最难调的bug，但是确实比较虐心。
之前用xilinx一块比较高端的开发板验证一个高速信号的功能，发现有一路输出幅度是其他的1/10，感觉很诧异，于是和师弟翻了一天手册文档，难不成这货还有配置幅度的功能。最后无解，用万用表在BGA焊盘和走线上一点一点地量，过了一个小时，发现....
（Bug微距图）
尼玛一万多的板子 表贴SMA接头漏焊！中间大概有0.5mm的距离，高速信号空间耦合过去10%。
于是默默用热风枪吹上，一切正常了。
这个bug的恐怖之处在于，高速信号可以从断点发射出去，然后让人误以为卧槽这有输出啊，不会想到根本就是个直流的断路，直到你用了万用表。","9月21日增加说明
谢谢各位程序员捧场……
我要讲的这个bug一点都不难，可能大家也都遇到过，但是当时卡了我一上午，所以印象极为深刻
在这跟大家分享一下
--------------------分割线-------------------------
我来讲一个吧，也是我亲身经历的
在传输数据的时候，需要对字符串a做判断，如果a为空，则不下发配置，非空下发配置
在我获取到a之后，我把它打印出来发现是""""
嗯，什么都没有，为空，应该不下发，但当我去检查配置的时候，很奇怪的下发了
我当然认为是我的判断问题，去检查，发现没问题，判断条件和逻辑都是正确的
我觉得应该是字符串类型的问题，我又把所有判断项都转换成了unicode编码，问题仍然存在
我又更改了判断条件为a的长度为零，则不下发，问题仍然存在
当时我的心情大约是这样的
为什么
为什么明明a的内容什么都没有，代码却一直认为a非空呢
a你为什么如此任性的表现你的存在感呢！
我觉得下发的配置在嘲笑我，虽然是一个bug，但是他却表露出一股王霸哥之气
我愤怒了，身为测试转研发的我一定要解决这个bug，人定胜天……额，bug
我又重新写了一个程序，专门测试这段代码，代码逻辑仍然没问题，但是只要传输数据，他就认为a是非空的
我逐行print各种东西，数据全对，问题存在
我查了一下字符串那部分的python源代码，代码全对，问题存在
我更换别人的机器执行这段代码，全都正常，问题存在……
最后胡乱尝试，甚至期盼掌控代码的神明或者
魔法少女
代码子能够出现帮我解决这个问题，
毕竟这个简单的不能再简单的问题已经卡了我将近4个小时了
直到我在一次瞎试的时候
print len(a)
屏幕结果是：2
我才恍然大悟，原来字符串a的内容，就是""""
当时我大概是保持这样的动作持续了十分钟吧
而且，发生这一切的时候，我才刚刚看了@条件状语从句的回答，还在跟同时调侃哈哈哈怎么会有传输名字为null这种事发生
人生真奇妙","没想到有一天我也要来回答这个问题！！
我是如何排查一个让我气哭的 BUG 的
事情要从半年前说起。在当时发布
那篇文章
中，我在
评论区
提到“邮件配置一直不成功”，是的，当时我开启了防火墙的所有和邮件有关的端口，但就是发不出去邮件，
甚至连转发也不能
。当时调了好几天，都没有解决。最后，我只好放弃，选择了用别人设置好的虚拟主机。
时间到了二零一九年年末。由于有记笔记的好习惯，我很快搭建好了 LAMP 环境。但是却发现，博客的附件无法上传。博客的附件，通过
cosUploadV5
插件，应该被上传到我的腾讯云储存桶。但是试了几次，一直无限转圈圈。等等，现在还在转：
自然，应该是哪里出了问题。我想到了看错误信息。打开 Chrome 自带的控制台，果不其然有报错：
Uncaught SyntaxError: Unexpected token < in JSON at position 0
    at JSON.parse (<anonymous>)
    at Function.jQuery.parseJSON (jquery.js?v=18.10.23:7490)
    at plupload.Uploader.FileUploaded (write-post.php:1070)
    at plupload.Uploader.dispatchEvent (plupload.js?v=18.10.23:2205)
    at plupload.Uploader.trigger (moxie.js?v=18.10.23:2240)
    at XMLHttpRequest.xhr.onload (plupload.js?v=18.10.23:1585)
    at XMLHttpRequest.<anonymous> (moxie.js?v=18.10.23:2256)
    at Array.<anonymous> (moxie.js?v=18.10.23:2172)
    at callNext (moxie.js?v=18.10.23:374)
    at Object.inSeries (moxie.js?v=18.10.23:380)
通过一系列追踪，我定位到了插件源代码 201 行：
/usr/plugins/cosUploadV5/src/Guzzle/Http/Curl/CurlHandle.php
这里通过 curl 发起了请求。然而遇到错误：
curl (6) couldn't resolve host
第一反应，是 DNS 服务器设置有误。执行 
sudo vi /etc/resolv.conf
，可以发现是谷歌的 Public DNS，谷歌基本不可能出错，而且我服务器在魔法触及不到的地方，不存在墙的问题，但是以防万一，我把首选 DNS 改成了 CloudFlare 家的 
1.1.1.1
。
然后再次尝试上传：
没用。一直无限转圈圈：
这就奇怪了。是不是 DNS 没生效呢？我执行：
sudo service network restart
sudo service httpd restart
然后再次尝试上传：
没用。还是一直无限转圈圈：
难道要重启不成？
sudo reboot
然后再次尝试上传：
没用。还是一直无限转圈圈：
那么，我直接 ping 会怎样？
$ ping www.google.com
PING www.google.com (172.217.31.228) 56(84) bytes of data.
64 bytes from hkg07s28-in-f4.1e100.net (172.217.31.228): icmp_seq=1 ttl=54 time=1.68 ms
64 bytes from hkg07s28-in-f4.1e100.net (172.217.31.228): icmp_seq=2 ttl=54 time=1.77 ms
64 bytes from hkg07s28-in-f4.1e100.net (172.217.31.228): icmp_seq=3 ttl=54 time=1.73 ms
64 bytes from hkg07s28-in-f4.1e100.net (172.217.31.228): icmp_seq=4 ttl=54 time=1.69 ms
64 bytes from hkg07s28-in-f4.1e100.net (172.217.31.228): icmp_seq=5 ttl=54 time=1.95 ms
64 bytes from hkg07s28-in-f4.1e100.net (172.217.31.228): icmp_seq=6 ttl=54 time=1.72 ms
64 bytes from hkg07s28-in-f4.1e100.net (172.217.31.228): icmp_seq=7 ttl=54 time=1.75 ms
64 bytes from hkg07s28-in-f4.1e100.net (172.217.31.228): icmp_seq=8 ttl=54 time=1.67 ms
^C
--- www.google.com ping statistics ---
8 packets transmitted, 8 received, 0% packet loss, time 7012ms
rtt min/avg/max/mdev = 1.677/1.750/1.957/0.094 ms
显然，十分正常，并且说明我的 DNS 服务器运转良好。
在 Stackoverflow 某帖子的启发下，我写了一个文件
<?php
$ch = curl_init('www.google.com');
curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);
curl_setopt($ch, CURLOPT_HEADER, true);
curl_exec($ch);
通过浏览器访问其 url，自然，发生了域名解析错误。
然后我通过 php 的交互模式执行：
$ php
<?php
$ch = curl_init('www.google.com');
curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, false);
curl_setopt($ch, CURLOPT_HEADER, true);
curl_exec($ch);
HTTP/1.1 200 OK
Date: Fri, 06 Dec 2019 15:09:45 GMT
Expires: -1
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
P3P: CP=""This is not a P3P policy! See g.co/p3phelp for more info.""
Server: gws
X-XSS-Protection: 0
X-Frame-Options: SAMEORIGIN
Set-Cookie: 1P_JAR=2019-12-06-15; expires=Sun, 05-Jan-2020 15:09:45 GMT; path=/; domain=.google.com
Set-Cookie: NID=193=Dma_WfgEDig7HlMLDpRAFZa7y7GIQlqC_SwBhfMnJausKKGw45c4TMPACIXitQU_rRoCk-AQfVH_4wK57B5ano3hQPU8fezAhO_Ou5qgpa8nw8fqG8P3hMLdwLaacmN8NB8HT-FFI3r3NKOwu-POo0V29j5F08UNXYLaA4obQ94; expires=Sat, 06-Jun-2020 15:09:45 GMT; path=/; domain=.google.com; HttpOnly
Accept-Ranges: none
Vary: Accept-Encoding
Transfer-Encoding: chunked
这没问题呀。所以奇怪之处就是：在网站脚本中写这些代码，Not Working。但是在 shell 中以交互模式执行，就没毛病。同时，也排除了防火墙的问题。
这时候首先想到的就是权限问题。
我通过 
chown
 更改文件权限，无效。
我通过 
sudo
 切换到 
apache
 用户视角，交互模式执行，没毛病。
这说明不是用户权限的问题。
但是知道和权限有关之后，大概有了 Google 的方向。然而在国内网站搜到的，清一色是关闭防火墙或者关闭 SELINUX 这样的不负责任的操作。
一时间解决不了，我向
网友提问
。不过没有人回答。
在
PHP curl 无法解析域名
这个问题下，说是关闭 chroot 解决的。于是我仔细研读了 chroot 的相关资料，得出结论是这个方法对我们 Apache 服务器不适用。同时，关闭 chroot 和关闭 SELinux 一样，都是不负责任的行为，会给服务器带来很大的危险。
我一时间真的不知道该怎么办了。
一番思索后，我考虑：会不会是 CURL 的问题呢？
于是我编写了这个文件：
<?php
$ip = gethostbyname('www.example.com');
echo $ip;
结果，在交互模式执行，返回的是 ip，在浏览器打开，返回的是域名。
怎么回事？查询
php文档
得知：
Returns the IPv4 address or a string containing the unmodified hostname on failure.
当失败的时候，返回的是不经修改的原域名。
这排除了 CURL 的问题。并且更加确定是权限的问题。我把 
CURL
 
GETHOSTBYNAME
 
SELINUX
 
CHROOT
 
APACHE
 
CENTOS
 这些关键词变着花样地搜索，都没有找到满意的答案。
不过，倒是有很多人建议这么做：
setsebool -P httpd_can_network_connect 1
这里是允许 Apache 连接网络。言外之意，SELinux 开启的状态下，默认的设置下，Apache 无法接触到外部网络。我照此执行。然而结果毫无变化。但是考虑到 SELinux 让我吃过那么多苦头，我觉得和 SELinux 关系很大。
不情愿地，我尝试性地执行：
setenforce 0
这里的作用，根据 Manuel，是将 SELinux 设为被动模式。
问题消失了。
可是，这并不是我想要的答案，这么做和关闭 SELinux 没有区别，都是不负责任的行为。
不过，可以肯定，问题必然和 SELinux 有关。我开始大量搜集和 SELinux 有关的资料。其中，比较重要的是“
SELinux User's and Administrator's Guide
”。
我觉得和 httpd 有关的那些 bool 值很可能是罪魁祸首。
根据：
https://
wiki.centos.org/TipsAnd
Tricks/SelinuxBooleans
https://
access.redhat.com/docum
entation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/sect-managing_confined_services-the_apache_http_server-booleans
我试着开启了几个，但是无用。
然后我遇到了这篇文章 
How To Enable Or Disable SELinux In CentOS/RHEL 7
他提到，安装 
setroubleshoot-server
 可以帮忙排查问题。
However when I try to view the index file in Firefox, the index.html page content does not display and I get the below error in the /var/log/messages file.
我 
cat /var/log/messages
，没有找到任何线索。
从头仔细阅读这篇文章后，我注意到他说：
Permissive:
This mode will not actually block or deny anything from happening, however it will log anything that would have normally been blocked in enforcing mode.
于是，我暂时性地设为被动模式：
sudo setenforce 0
然后刷新那个测试页面。
然后
less /var/log/messages
果然找到了问题。
不要被这令人作呕的日志吓跑。我们慢慢读。
tmp_t, man2html_content_t, man2html_htaccess_t, man2html_ra_content_t, man2html_rw_content_t, man2html_script_exec_t, man_cache_t, man_t, mandb_cache_t, mcelog_exec_t, mdadm_tmp_t, mediawiki_content_t, mediawiki_htaccess_t, mediawiki_ra_content_t, mediawiki_rw_content_t, mediawiki_script_exec_t, mediawiki_tmp_t, mencoder_exe
c_t, mirrormanager_exec_t, mirrormanager_log_t, mirrormanager_var_lib_t, mirrormanager_var_run_t, mock_build_exec_t, mock_exec_t, mock_tmp_t, modemman             Dec  6 22:45:42 Yecaoyun-2019126515 /usr/bin/sealert: LogfileAnalyzer.open(): Permission denied                                                                    Dec  6 22:45:49 Yecaoyun-2019126515 /bin/sealert: failed to retrieve rpm info for /etc/sysconfig/network-scripts/ifcfg-eth0                                        Dec  6 22:46:50 Yecaoyun-2019126515 dbus[489]: [system] Activating service name='org.fedoraproject.Setroubleshootd' (using servicehelper)                          Dec  6 22:46:51 Yecaoyun-2019126515 dbus[489]: [system] Successfully activated service 'org.fedoraproject.Setroubleshootd'                                         Dec  6 22:46:51 Yecaoyun-2019126515 setroubleshoot: failed to retrieve rpm info for /etc/resolv.conf                                                               Dec  6 22:46:52 Yecaoyun-2019126515 setroubleshoot: SELinux is preventing /usr/sbin/httpd from getattr access on the file /etc/resolv.conf. For complete SELinux me
ssages run: sealert -l f11038bf-3fc9-4611-9d21-0b38b6dd63e5                                                                                                        Dec  6 22:46:52 Yecaoyun-2019126515 python: SELinux is preventing /usr/sbin/httpd from getattr access on the file /etc/resolv.conf.#012#012*****  Plugin restorecon (82.4 confidence) suggests   ************************#012#012If you want to fix the label. #012/etc/resolv.conf default label should be net_conf_t.#012Then you can run restorecon. The access attempt may have been stopped due to insufficient permissions to access a parent directory in which case try to change the following command accordingly.#012Do#012# /sbin/restorecon -v /etc/resolv.conf#012#012*****  Plugin file (7.05 confidence) suggests   ******************************#012#012If you think this is caused by a badly mislabeled machine.#012Then you need to fully relabel.#012Do#012touch /.autorelabel; reboot#012#012*****  Plugin file (7.05 confidence) suggests   ******************************#012#012If you think this is caused by a badly mislabeled machine.#012Then you need to fully relabel.#012Do#012touch /.autorelabel; reboot#012#012*****  Plugin catchall_labels (4.59 confidence) suggests   *******************#012#012If you want to allow httpd to have getattr access on the resolv.conf file#012Then you need to change the label on /etc/resolv.conf#012Do#012# semanage fcontext -a -t FILE_TYPE '/etc/resolv.conf'#012where FILE_TYPE is one of the following: NetworkManager_exec_t, NetworkManager_log_t, NetworkManager_tmp_t, abrt_dump_oops_exec_t, abrt_etc_t, abrt_exec_t, abrt_handle_event_exec_t, abrt_helper_exec_t, abrt_retrace_coredump_exec_t, abrt_retrace_spool_t, abrt_retrace_worker_exec_t, abrt_tmp_t, abrt_upload_watch_tmp_t, abrt_var_cache_t, abrt_var_log_t, abrt_var_run_t, accountsd_exec_t, acct_data_t, acct_exec_t, admin_crontab_tmp_t, admin_passwd_exec_t, afs_logfile_t, aide_exec_t, aide_log_t, alsa_exec_t, alsa_tmp_t, amanda_exec_t, amanda_log_t, amanda_recover_exec_t, amanda_tmp_t, amtu_exec_t, anacron_exec_t, anon_inodefs_t, antivirus_exec_t, antivirus_log_t, antivirus_tmp_t, apcupsd_cgi_content_t, apcupsd_cgi_htaccess_t, apcupsd_cgi_ra_content_t, apcupsd_cgi_rw_content_t, apcupsd_cgi_script_exec_t, apcupsd_log_t, apcupsd_tmp_t, apm_exec_t, apmd_log_t, apmd_tmp_t, arpwatch_tmp_t, asterisk_log_t, asterisk_tmp_t, audisp_exec_t, auditadm_sudo_tmp_t, auditctl_exec_t, auth_cache_t, authconfig_exec_t, automount_tmp_t, avahi_exec_t, awstats_content_t, awstats_htaccess_t, awstats_ra_content_t, awstats_rw_content_t, awstats_script_exec_t, awstats_tmp_t, bacula_admin_exec_t, bacula_log_t, bacula_tmp_t, bacula_unconfined_script_exec_t, bin_t, bitlbee_log_t, bitlbee_tmp_t, blueman_exec_t, bluetooth_helper_exec_t, bluetooth_helper_tmp_t, bluetooth_helper_tmpfs_t, bluetooth_tmp_t, boinc_log_t, boinc_project_tmp_t, boinc_tmp_t, boot_t, bootloader_exec_t, bootloader_tmp_t, brctl_exec_t, brltty_log_t, bugzilla_content_t, bugzilla_htaccess_t, bugzilla_ra_content_t, bugzilla_rw_content_t, bugzilla_script_exec_t, bugzilla_tmp_t, calamaris_exec_t, calamaris_log_t, calamaris_www_t, callweaver_log_t, canna_log_t, cardctl_exec_t, cardmgr_dev_t, ccs_tmp_t, ccs_var_lib_t, ccs_var_log_t, cdcc_exec_t
, cdcc_tmp_t, cdrecord_exec_t, cert_t, certmaster_var_log_t, certmonger_unconfined_exec_t, certwatch_exec_t, cfengine_log_t, cgred_log_t, checkpc_exec_t, checkpc_log_t, checkpolicy_exec_t, chfn_exec_t, chkpwd_exec_t, chrome_sandbox_exec_t, chrome_sandbox_nacl_exec_t, chrome_sandbox_tmp_t, chronyc_exec_t, chronyd_tmp_t, chronyd_var_log_t, cinder_api_tmp_t, cinder_backup_tmp_t, cinder_log_t, cinder_scheduler_tmp_t, cinder_volume_tmp_t, cloud_init_tmp_t, cloud_log_t, cluster_conf_t, cluster_tmp_t, cluster_var_lib_t, cluster_var_log_t, cluster_var_run_t, cobbler_etc_t, cobbler_tmp_t, cobbler_var_lib_t, cobbler_var_log_t, cockpit_tmp_t, collectd_con
tent_t, collectd_htaccess_t, collectd_ra_content_t, collectd_rw_content_t, collectd_script_exec_t, collectd_script_tmp_t, colord_exec_t, colord_tmp_t, comsat_tmp_t, condor_log_t, condor_master_tmp_t, condor_schedd_tmp_t, condor_startd_tmp_t, conman_log_t, conman_tmp_t, conman_unconfined_script_exec_t, consolehelper_exec_t, consolekit_exec_t, consolekit_log_t, container_log_t, container_runtime_tmp_t, couchdb_log_t, couchdb_tmp_t, courier_exec_t, cpu_online_t, cpucontrol_exec_t, cpufreqselector_exec_t, cpuspeed_exec_t, crack_exec_t, crack_tmp_t, cron_log_t, crond_tmp_t, crontab_exec_t, crontab_tmp_t, ctdbd_log_t, ctdbd_tmp_t, cups_pdf_tmp_t, cupsd_config_exec_t, cupsd_log_t, cupsd_lpd_tmp_t, cupsd_tmp_t, cvs_content_t, cvs_data_t, cvs_exec_t, cvs_htaccess_t, cvs_ra_content_t, cvs_rw_content_t, cvs_script_exec_t, cvs_tmp_t, cyphesis_exec_t, cyphesis_log_t, cyphesis_tmp_t, cyrus_tmp_t, dbadm_sudo_tmp_t, dbskkd_tmp_t, dbusd_etc_t, dbusd_exec_t, dcc_client_exec_t, dcc_client_tmp_t, dcc_dbclean_exec_t, dcc_dbclean_tmp_t, dccd_tmp_t, dccifd_tmp_t, dccm_tmp_t, ddclient_log_t, ddclient_tmp_t, debuginfo_exec_t, deltacloudd_log_t, del
:
我们可以看到几个关键：
failed to retrieve rpm info for 
/etc/resolv.conf
For complete SELinux messages run: 
sealert -l f11038bf-3fc9-4611-9d21-0b38b6dd63e5
If you think this is caused by a badly mislabeled machine. Then you need to fully relabel.
Do 
touch /.autorelabel; reboot
我执行 
sealert -l f11038bf-3fc9-4611-9d21-0b38b6dd63e5
结果：
前面还有好几页。
其中，最为关键的是：
allow this access for now by executing:
ausearch -c 'httpd' --raw | audit2allow -M my-httpd
执行
sudo ausearch -c 'httpd' --raw | less
结果中好像还是一团乱。容易发现：
type=AVC msg=audit(1575613783.791:925): avc:  denied  { getattr } for  pid=12038 comm=""httpd"" path=""/etc/resolv.conf"" dev=""vda1"" ino=4086 scontext=system_u:system_r:httpd_t:s0 tcontext=system_u:object_r:unlabeled_t:s0 tclass=file permissive=0
通过这些文字，我找到了红帽的一个 
BUG 汇报
。顺着读下去可以看到：
Ok,
/etc/resolv.conf has definitely bad labeling.
If you execute
restorecon -R -v /etc/resolv.con
does it happen again? We need to find a reason why is mislabeled.
他的意思是，文件被错误地标记了。
我执行：
ls -laZ /etc/resolv.conf 
-rw-r--r--. root root system_u:object_r:unlabeled_t:s0 /etc/resolv.conf
查询 restorecon 的 Manuel：
restorecon(8)
NAME
    restorecon - restore file(s) default SELinux security contexts
执行：
sudo restorecon -R -v /etc/resolv.conf
貌似什么也没有发生。不过此时 
ls -laZ
 的话可以发现它的标签变了。
怎么样了？来试试吧。
最后开启 SElinux 为完全状态：
sudo setenforce 1
重新访问测试地址
重新上传图片
成功了(☆-ｖ-)
同样解决的还有半年前的那个问题。
悬 案 就 此 告 破。
谁能想到，博客的图片附件不能上传，通知邮件发不出去，竟是因为一个系统文件被打上了错误的标签。
而解决这个问题，只需一句短短的
：
sudo restorecon -R -v /etc/resolv.conf
而你永远不知道获得这一最终答案的路途，会是多么的艰辛。
结语
做这样的工作，需要极大的耐心，而且，英语还要好（你以为我读长篇英语技术文章不会头大吗::>_<::）。
哎，我竟然这么有耐心（崩溃）。我没有疯，我没有！！！！","上大学的时候带的拉杆箱自带三位数密码，000到999共1000个数
很久没用后有一天想用它的时候发现是锁住的！
回忆了一下好像是学期初设的密码。
然而怎么也想不起来密码是啥了……没法子反正就1000个密码，一个个试嘛。试之前还去网上搜了怎样靠耳朵听着就能确认试到正确密码了，有一种特工破解密码的豪迈！（I'm 棒的，真是・棒的）
000――001――002……101――102――103……801卧槽怎么800多了还没有，硬着头皮继续上……996――997――998――Click！擦成功了！！！
然而一共也就1000个密码我试了999次！！WTF！！！
回忆当初……原本给箱子设密码，我是拒绝的，然而有天突然被害妄想，必须设一个！设密码要有策略……那么就逆向思维：别人猜密码肯定先猜000 111 666 888 999 123 321这些最简单的，都错的情况下可能就开始从头试密码了，哼哼机智如我肯定让你试也没那么容易试出来，既然破译的人会从000开始试，那我就设置998吧，最大限度延缓你破译密码的时间！！！就这么愉快地决定了。
――――――――――――――分割―――――――――――――――――――――――――
自己给自己下套，果然套得最准，这个大脑自带bug我看是debug不了了。"
,,,,,,,,,,,,,,,,,,,,,
PHP、Java、Python、C、C++ 这几种编程语言都各有什么特点或优点？,None,"相信每一个计算机科班出身的同学或许都有这样的经历：在大三的某一天，仿佛打通了全身筋脉一般把三年的所学：“数电里的与非门――计算机体系结构――汇编语言――C语言――C＋＋语言――Java语言”。所有知识全部串联了起来。所有这些语言的出现都仿佛都有了必然性和追根溯源的历史感。
**阅读指引**
读懂此文，需要以下基础:
1. 至少写过50000行的代码;
2. 汇编基础（静态数据段，代码段，堆栈段）。
有以下或者类似知识就更好了：
1. C语言编译，C++对象模型，MFC反射的实现
2. JAVA的解释器运行原理
3. 使用过javascript，Python，PHP：感受过代码和类型系统在运行时的自由程度的不同
4. 计算机组成原理
**序 ―― 一些问题**
1. 程序设计语言的目的是什么？
2. 为什么大多数语言有控制流？逐行执行+跳转。这与我们的需求差很远（例如一个教务管理系统、一个自动打车APP）
3. 为什么类型申明在C语言中要与控制流隔离开来?
4. 现在主流语言最基本的元素是？
5. 有没有语言它的类型结构，在运行时也可以改变？
动态性？
什么是动态性？
1. 编译后确定了什么信息，之后不再改变；
2. 运行时可以改变、添加什么；
3. 运行时是否保存着类型信息。
程序中的信息分为几类？
1. 数据信息
a) 编译时Meta-Data元数据（类型框架、空间占用）
b) 运行时Meta-Data元数据（继承体系、用于new或者反射）（特别区别编译与运行的Meta-Data的不同。）
c) 堆栈段中地址偏移（C++的switch case中不能声明变量、共享内存）
d) 静态段中地址
2. 指令信息
a) 代码段（动态性需要操作系统或者虚拟机支持，例如动态链接库，动态类加载，lisp语言自生成代码）
**语言举例**
**汇编语言**
汇编语言没有动态性吗？
没有。首先，寄存器、数据段、堆栈、代码段完全由程序员控制。完完全全是写死了的。然后，根据
冯诺伊曼机
的规则；取指令，执行，取指令，执行……
既然都有数据段了，还要堆栈段来做什么？这不是多余？
一开始本没有堆栈，直到60年代出现了module模块化，才有了堆栈。汇编中的模块叫子程序，不过仍旧靠程序员全权控制。
堆栈和模块化的优点有？
1. 递归
2. 功能分离到模块，可复用
3. 封装作用域
堆栈和模块化的缺点有？
1. 时间上：保存现场、还原现场的代价（另，高级语言编译“消除
尾递归
”节约部分成本）
2. 空间上：爆栈的危险
**C语言**
C语言比起汇编多了什么东西？
1. 编译器
2. 表达式（相比汇编，可以处理多个操作数了。）
3. 函数与模块｛｝（真・模块化，栈操作无需程序员完成）
4. 类型（原子类型、结构类型、数组、指针）
5. 头文件，库
总之，C语言并没有比汇编多了新的特性，它只是把汇编的繁琐操作抽象出来，让编译器完成，减轻程序员负担。
编译器的作用是？
（减少程序员负担）
1. 解析表达式，控制流（汇编中指令只有1-3个操作数，而表达式可以多个操作数）
2. 模块和函数的抽象（完成堆栈中保存恢复现场的工作）
3. 类型变量的管理（所有变量被替换成直接访问的地址，最快的访问速率）
4. 代码优化
变量是替换成可以直接访问地址的？
a) 编译时的Meta-Data（struct的成员，数组的长度，以便替换到指令流；只在编译器中维护，编译结束后丢弃）
b) 计算出每个变量相对于该模块的偏移（一旦算出该偏移地址，将固定在执行码中，无法改变；就是说编译完成后，所有变量的偏移地址都固定下来了。）
c) 对变量的存储进行管理（所有的变量/内存地址的布置，都是在编译时确定的；也就是说，可执行码中没有类型信息，只有地址，任何数据都是地址来操作，完全和汇编类似。至于寄存器的安排，那是更下一层的类似缓存策略算法的结果。）
编译出来的执行码与汇编的执行码有特征的区别吗？
没有。特别是在编译器优化之后。
无法通过执行码，区分汇编和C程序。
打个比方，一只“程序猫”在黑笼子里，在里面喵喵的叫，无法通过它的叫声来判断它是“汇编猫”还是“C语言猫”。
从效率上来讲，C的多余代价在哪里？
1. 编译的时间
2. 模块的堆栈操作
总之，经过优化的C程序执行码与汇编效率几乎相同。
因为从理论上来说，C并没有引入运行时的新机制。
我理解的C语言只是一种汇编的宏而已。
**C++语言**
（推荐《深度探索C++对象模型》）
C++语言比C语言多了什么？
1. 成员函数
2. 类型继承体系
3. 虚函数、虚继承
4. 模板
5. 涉及到了多种编程范式
（开始更抽象，语言逐渐开始脱离冯氏结构。）
其中，面向对象的思想，让程序与现实事物的关系更加紧密。
程序设计的负担，也因为OO与设计模式的流行，而变得轻松。
编程范式是什么？
就是一套指导思想行为准则。
（例如，C是过程式，Haskell是函数式，JAVA是面向对象，Python是简单的大杂烩，shell是调用命令的，lua是调用c程序的，PHP是写页面的，ProLog是线性逻辑推理的。
再例如，UML是描述规格specification的，XML是存储数据的。
再再例如，CSS是描述网页表现的，HTML是描述网页内容的。
javascript比较神奇，不敢说。）
C++有什么编程范式？
1. 过程式（使用STL的类C语言编程）
2. ADT式（自定义抽象数据类型，继承；但是不用new，不用virtual；拷贝构造；为了防止资源泄漏，也发明了RAII的方式进行资源的初始化和释放）
3. 面向对象式（使用new，使用virtual，需要指针或引用；实现多态。）
4. 泛型编程（《Modern C++ Design》各种奇淫技巧，业务层代码比较少遇到）
C++编译器是怎样实现的？
C++开始有一个叫做cfront的编译器，即把C++语言先翻译成C语言。
然后再用C编译器来编译，C的编译器并不知道此段代码是来自C++还是C。
C++语言特性分别是怎样实现？简单说。
1. 成员变量：和C语言的struct 类似，最后也会被直接替换成地址，便于高效访问。
2. 成员函数：使用特殊函数名编码方案，翻译成C函数，并添加this指针作参数。（如___clsA12345func001(...,clsA *this)）
3. 类型继承体系：通过C++编译时的Meta-Data来实现。即在编译时，编译器是知道类型信息与继承体系的，但是编译成C语言后就丧失了此类型信息。
4. 虚函数、
虚继承
：为了支持多态，这也是“面向对象”最重要的特性，使用了虚函数表和虚基类表。注意，运行时多态是通过运行时查表实现的。稍后详细说。
5. 模板：通过代码复制的方式实现。每次编译都需要重新编译，不能编成库文件直接使用。
C++编译器的准则与virtual机制？
1. 首先，C++的编译准则，希望做到与C一样的效率。希望做到以下：
――a) 没有运行时调用间接性。任何数据在运行时都是一个地址直接就访问到。
――b) 没有运行时的Meta-Data。无需通过Meta-Data来访问某个复杂的类层次。
――c) 所有的数据都希望用C中struct来实现，即在编译时就确定好对象及其成员地址。
2. 以上，在过程式范式，与ADT范式中都是成立的。
3. 但是，在面向对象范式中，渴望做到：
**需要维系着同一个继承体系成员结构的一致性，只有这样，才能保证运行时的多态性。即希望通过同一个入口，访问到父类或者子类的相同数据成员、函数成员，而不在乎具体对象的是父类还是子类。**
C++的virtual机制如何实现的？
a) 虚函数
i. 虚函数，运行时，每个有虚函数的类型（哪怕是子类）都维持着一个
虚函数表
，这已经是运行时的Meta-Data，通过查表，即可找到对象自己的虚函数。
ii. 例如clone肯定是object.__vptr__Base->#3()，无论具体的对象。
b) 多重继承
――如何处理后继的base基类？由编译器判断指针类型并加上相应的偏移。
c) 虚继承
――添加一个虚基类指针，指向共享部分。
这样的缺点有两个：
1. 虚基类的子类都要背负一个基类指针指向共享部分。如果继承了多个虚基类，还需要多个这样的指针。（Microsoft的解决方法是增加一个虚基类表，类似于虚函数表。）
2. 虚继承链条的增加，会导致间接访问的层次增加。例如两个
菱形继承
的串联。
跨平台的级别有哪些级别？――头文件，库，源代码
1. C++确实在源代码的层次是可能跨平台的（例如《POSA2》中加了针对不同平台的各种宏的代码）。
2. 也可以通过相同的头文件去访问不同平台的库。
3. 但是，不同操作系统中的不同的API大大增加了跨平台的难度。
4. 跨平台的责任留给了程序员（充斥着大量宏的C++跨平台代码确实让人头疼。）
5. 编译器面对不同的系统也不敢作为，它只是负责编译源代码，链接。
如何使用C++才能保证其高效性能？
1. 有额外负担的机制：虚函数，虚继承，拷贝构造。
2. 用一次虚函数，多了一次指针寻址的效率损失，并且相对于inline内联（另，inline是编译器优化的重头），还损失了保存和恢复现场的效率。
3. 用一次虚继承，也多一次指针寻址的效率损失。（另，虚基类没有成员变量没有虚函数的时候会被优化。这也是JAVA可以多重继承接口interface的原因。）
4. 不要使用virtual在复杂的多继承，深层次继承中。
5. 编译速度会较慢：virtual机制会使编译器处理更多的Meta-Data。
**JAVA语言**
（推荐《本地Java代码的静态编译和动态编译问题》）
JAVA语言比C++语言多了什么？
1. 虚拟机
a) 跨平台
b) 动态编译
c) 动态特性
2. 没有指针
3. 没有类的多继承，有接口的多继承。
4. 统一的库
从编译来说，JAVA比C++迈出了一大步。
它的跨平台特性和运行时的灵活性，为JAVA自己以及未来语言都提供了很多可能性。
虚拟机的好处有什么？
1. 跨平台：在OS与字节码间隔了一层。实现了程序员无负担的跨平台。
2. 动态编译：许多信息不必在编译后确定，为动态特性提供可能，稍后详细说。
3. 运行时维护着类型信息，甚至可以加载新的类型。（CORBRA依赖这个实现）
JAVA编译执行的过程是怎样的？
1. 编译后产生一个基于堆栈的字节码。
2. JRE在不同的OS上提供支持。
3. 起初的JRE是解释执行的，效率低下。
a) 获取待执行的下一个字节码。
b) 解码。
c) 从操作数堆栈获取所需的操作数。
d) 按照 JVM 规范执行操作。
e) 将结果写回堆栈。
JAVA是如何解决执行效率低下的问题呢？
使用JIT（Just-in-time）编译器进行动态编译。
JIT（Just-in-time）是怎样运行的呢？如何解决了效率的问题？ 
如上图：
1. 每次按照一个function来编译。转成中间表示，并优化其效率，再生成可执行码。
2. 编译器的编译线程和执行线程是分开的，应用程序不会等待编译的执行。
3. 分析框架Profiler会观察程序行为，对频繁执行的function进一步优化。（例如function内部对象维持一个池不必每次生成。）
动态编译的优点有什么？
可以根据程序的行为，优化其代码
1. 例如频繁执行的function――热方法
2. 例如arrayCopy方法，如果每次都拷贝大段内存，在指令集中有特别指令可以加速。
3. 例如类层次结构，多态的优化。（大多数虚调用都有其固定的一个目标，JIT因此生成的直接调用代码比虚表调用代码的效率会更高。）
动态编译的缺点有什么？
1. 大量的初始编译会影响程序启动时间。
2. 运行时候的编译，行为分析都需要花费时间。
3. 运行效率达到稳定需要时间。
4. 实时GUI型的程序不能忍受“动态编译”和“GC”带来的延迟。
JAVA如何解决实时的需求？
使用AOT（Ahead-of-time）编译器：预先编译成为可执行码。
AOT（Ahead-of-time）的缺点:
对于一些动态特性的支持效率低下
1. 反射机制
2. 运行时类加载
JIT与AOT的对比
总体来说，JAVA适合怎样的应用呢？
JAVA比较时候需要长期运行的应用，例如Web服务器，Daemon服务。
**函数式语言**
函数式语言通常有哪些呢？
1. 函数式语言
a) Lisp
b) Scheme
c) Haskell（纯函数式）
d) F#？
2. 包含了函数式特性的语言
a) Python
b) Javascript
c) JAVA
d) C?
函数式语言有哪些特性？
1. 函数无副作用，只对输入输出有作用
2. 高阶函数，lamda演算。(这个像C函数指针，但是它是高阶的，即返回值可能也是函数)
3. 没有过程，类似规格说明的语法，更容易理解，自解释。
4. 基于list的编程，函数更通用。
5. 惰性计算（这个很像“树形DP”）
6. 有对应的数学形式化表达，有可能证明其正确性。（最终目标可能是保证程序没有bug。）
7. 其模型适合多核或者分布式的计算。
a) 不变性（immutable）
b) 惰性计算/按需计算（lazy evaluation）
c) **最重要的是，由于函数式语言不可在同一数据上做修改，每一次运用一个函数都会在新的位置产生新的数据，这与过程式语言在同一位置对数据做多次操作不同：函数式语言的函数依赖于前一次函数产生的结果数据，过程式语言依赖于数据的位置。这里函数式语言就暗含了计算的依赖顺序，如果没有前后顺序关系，就可以并发。而过程式语言没有指定这个顺序，就需要通过加锁、Actor、Channel等模式来指定这个顺序**
总的来说，函数式语言，向着更抽象迈了一大步，更像是数学上的表达，几乎与
冯诺伊曼体系
断绝了关系。
函数式语言的劣势？
1. 效率不高（因为其抽象，远离了冯诺伊曼体系）
2. 平台以及开发环境都比较简单。
3. 缺少推广，应用不广泛
**逻辑程序设计**
ProLog语言，线性逻辑。人工智能语言。没有接触过。
**总结**
动态性有哪些呢？
1. 多态性：运行时根据具体对象来访问属于它的方法。（而不理会指针的类型。）
2. 反射：运行时维系着类型结构的Meta-Data。
3. 运行时类加载：运行后再次加载新的数据类型和指令流。
4. 动态链接：OS根据按需链接库文件。
编译语言 和 解释语言 的分界在哪里？
语言本身并没有编译类型或者解释类型。（例如：JAVA也可以静态编译后成可执行码。）只有少数运行时特性是依赖于解释型的。（可能需要运行环境的支持。）
为什么解释语言都需要虚拟机或者运行环境支持？
动态编译，运行时Meta-Data的保存，这些功能对于每个程序都是一致的。
所以把它们分离开来，不必每个程序植入这些代码
非脚本语言 和 脚本语言
脚本语言，我理解是负责调度其他代码的语言。
例如shell脚本（调用命令），lua（调用C）。
跨平台分为哪些层次？
1. 源码跨平台（C，C++，但是因为系统调用接口不同，程序员负担太大，但是汇编却不是。）
2. 执行码跨平台（JAVA，有些语言直接从源码解释执行，例如Javascript，PHP）
发展历史（推荐《近看图灵碗 (一. 从苏黎世到巴黎)》）
学术上有哪些实验性语言？
1. Fortran
2. ALGOL58
3. ALGOL60
4. Lisp
5. smalltalk
常用语言
过程式：C，ALGOL，Pascal，
面向对象式：C++，smalltalk，JAVA，Delphi
函数式：Lisp，Scheme，Haskell，
逻辑式：Prolog
脚本？PHP，Python，Ruby
存储描述信息：XML，CSS，HTML
**回答问题**
程序设计语言的目的是什么？
1. 控制数据
2. 控制指令流
为什么大多数语言有控制流？逐行执行+跳转。这与我们的需求差很远（例如一个教务管理系统。）
逐行执行，很大程度是起源于冯诺依曼体系结构。
为什么类型申明在C语言中要与控制流隔离开来?
因为在编译时，具体的类型信息，要转化成地址偏移，然后替换控制流中的类型变量。
现在主流语言最基本的元素是？
控制流 与 类型系统。
有没有语言它的类型结构，在运行时也可以改变？
Javascript只有对象没有类，使用prototype的方式继承，运行时给某个对象添加新的数据成员。没有类型体系。
许多后来的语言在运行时都保存着类型信息的，例如Python，JAVA。
**综上所述**
控制流――指令流
类型系统――为了计算出变量地址信息
区分运行时的Meta-Data与编译时的Meta-Data","PHP：没有优点
Java：库多，库多，库多
Python：语法清楚，语法清楚，语法清楚
C：能操纵底层，能细粒度优化性能
C++：啥都有，啥都有，啥都有
――――――――――――――――――――――――――――――――――――――――――――
汇编：
C：
Java：
C#：
PHP：
Python：
Go：
Haskell：
Lisp：
最后是 C++：
（图部分为自制，部分来自网络）","有个笑话，让程序员打架的一个最有效的方式是去讨论区问大家那种编程语言最好，这就会没完没了的讨论。大致分成C++派，Java派，Python等脚本派。
C/C++: 可能很多人入门都是啃着
谭浩强
的C程序设计，这种语言很强大，既高性能，又灵活（指针，地址，二维指针，指针数组），名词特别多（多态，重载，重用，范型，模板类，
元编程
），坑也特别多，容易造成内存泄露，
野指针
，在大学里面吃了不少苦头，疯狂看各种C++经典，秘籍，后来去了创业公司和百度都是大量使用，里面也很多人玩的炉火纯青，面试时候经常出个写个线程安全的C++
单例模式
，析构能否多态或者什么写个调用顺序，让面试者骚手挠腮，欲罢不能，想想自己也折磨过这些面试者，真是罪过啊。这几年视野广了，不接触C++了，回过头来看还是觉得当年有些走火入魔，没必要自己折磨自己。
Java
: 估计是目前用的最广的项目语言，容易上手，概念简单，无数的库，大量的代码。我就不多介绍了，我自己也是大半的项目用Java写的。缺点时配置比较烦，很多什么XML，Config，适合写服务端。
LUA
：大量应用在大型游戏的脚本语言，主要是高性能，语言规范精简、运行时库小，与C/C++交互方便，我在百度做云计算平台时候也是用它作为嵌入式脚本。
Python
：跟Perl, PHP,合成3P语言，都是脚本:) 非常方便实用，初学编程就可以拿它练习，有很多方便的库，比如urlib, 
beautifulsoup
。有句话说：人生苦短 我用Python。做数据分析的有个超好的工具叫
iPython
，它是结合在线notebook，可以交互式编程，非常爽。据说Python的创始人在Dropbox，当年他简历就一句话，说I wrote Python. 在面试Google时候还被一些人误会，想会python算个啥，但人家是作者。有一本书 
集体智慧编程 (豆瓣)
 用Python作为实践做机器学习，推荐给大家。
GO
：Google开源的语言，比C++容易上手，却有相似的性能，很多从Google出来的人喜欢，据说Square, Pinterest就在用。Go语言有哪些好处，谁用谁知道，
为什么要使用 Go 语言，Go 语言的优势在哪里？
Scala
：各种集大成，面向对象，
函数式编程
，面向过程。我目前也在学习，东西实在太多，Coursera上面有Scala作者的一门课，
Coursera - Free Online Courses From Top Universities
 公司技术部也主推这种语言，这也是为啥我们墙上员工证书中最多就是Scala这门课的。另外著名的Spark，Kafka也是Scala写的，确实在高性能，高并发上面表现不错，又保持了优雅精炼的写法。值得玩味。
Javascript
: 本来这是个前端客户端的动态语言，做一些页面特效，主要特点是天然支持异步，又跨平台，弱类型，比较安全 （有sandbox），有人把它拓展到后台，随着V8，Node.js, Angular出现也显得越来越厉害了。
还有一些语言，Ruby，R，Object-C, Swift，Matlab, Perl, SQL, D, Lisp就是偶尔用了，有个
TIOBE
编程语言排名
。","PS：应大家要求重新编辑了！
千万别惹程序员
下图一张昨天我公司内部被传递的图片。经典的SQL注入式攻击。千万别惹程序员
这是一个有技术含量的号牌遮挡。我们先不说其是不是能奏效，不过，这个创意相当的NB啊。当你驾车通过某些路口时，被摄像头捕捉到你的车牌，通过OCR变成文本，然后插入数据库，于是，上图的这个车牌就成了SQL注入。（不要以为车牌的OCR技术还不行，这项目技术已经非常成熟了，无论是国内还是国外）。这张图片就如同“
Web开发中应该知道的事
”中说的一样――永远不要相信用户的输入。
如果编程语言是一种刀
下面这个图是把编程语言看做是一种刀，那么会是什么样的。这个图我个人感觉很有意思。
对于这个图，最好不要解释，意会就好。不过，我却有点想不解风情，忍不住想解释一下。
C++，C，Pascal 都是瑞士军刀，说明是用来做细活的工具。C语言的刀上有个USB，说明是可以做硬件操作的。C++的刀是什么都有，说明C++是一种功能繁多的语言。（图中C++的那把瑞士军刀很强大，不要以为其是虚构的，这把刀是真实存在的，叫Wenger巨人刀，
Select | International
 (这个网页上有个Youtube视频，可以爬墙去看)，淘宝上有卖的，价格在1万4左右。）
Java/C#是一把塑料餐刀，这说明，Java和C#语言是带虚拟机的，而且其语法和使用并不像C++那么复杂，其泛型编程可以有很多种玩法，而Java和C#的泛型编程是比较单一的。
Python是把电锯，人挡杀人，佛招杀佛，威力很大，面对大型的物体的修整，比C++/C/Java什么的得心应手得多得多，但是对于一些精细的调优工作，明显不行。这和Ruby很像。
PHP没有MySQL，明显是被幽默了一把。不过最近对PHP的批评越来越多，不过，facebook的PHP的引擎HiPo已经很牛B了。
Perl是一本日本武士刀，是忍者玩的语言。
VB，就是一个玩具。你见过用塑料玩具勺当刀的吗？Haskell感觉是外星来的。呵呵
详细移步：
http://www.
oschina.net
Java
犹如
宫泽贤治
的《不畏风雨》中出现的、性格木讷的女孩子。从小就由于迟钝和大食量等特征被别人当作笨蛋，从小学入学开始进入田径部、坚持跑步，在中长跑中经常取得好成绩，给人以活泼的印象。是十分努力的女孩子。
她的家境并不算好。父亲Sun是有才能的艺术家，但不擅长理财，在她14岁的时候因为苦于借债积劳成疾而去世。她被Oracle叔叔收养，那时还与Google叔叔之间因为对她的扶养权问题而引起争端并闹上法庭。
在周围的人都担心，正值青春期时她在这样的处境下会不会一蹶不振的时候，她却处变不惊、继续着每天练习跑步的生活。
朴素的、认真的、难说是聪明的她，进入高中后不知是不是稍稍开始对异情在意，被人看到她偷偷地学着别的女孩子的时尚穿着在街上行走。虽然会受到“虽然很努力，也许稍微有点过时”、“那衣服与Java的印象不合”之类的否定评价，但感到“意外地很萌？”的好意的人也很多。
喜欢喝咖啡，只喝印度尼西亚产的。其本人曾说过“喜欢咖啡胜过三顿饭”，不禁让人稍稍担心“这样对健康没问题吗？”
C++
苗条的双腿和协调的五官。被许多人称作“IT界首屈一指的美女”的她，也因为拥有插花、茶道、钢琴和小提琴、柔道、剑道、合气道等等才能而出名。
她的粉丝大多很狂热，还存在着“黑暗军团”这样的粉丝俱乐部。黑暗军团的是规模仅次于共济会（Freemason）的巨型团体，一般人无法入会。据说如果能回答出对她非常狂热的问题，就会有察觉到的军团成员来询问“你愿意进入黑暗军团吗？”
与她同父异母的姐妹Objective-C一心专注于弹钢琴，她的专注被IT界的天才史蒂夫乔布斯（也被一部分人称为紫色蔷薇）相中，而一跃成为明星，而C++则是由于其美貌和才能被人关注，长年坐稳业界明星的宝座。姐妹二人真可谓是对比鲜明。
她根据心情不同频繁地变换发型和服装这一点也很出名。昨天还是和服配黑发，今天却是红发哥特系登场之类的，因为她的变身而使轻度的粉丝惊奇道“啊嘞？今天是C++小姐吗？”的事也常有发生。远离业界时私下经常穿HYSTERIC GLAMOUR的服装。
关于她的出身年月日其事务所并不公开。虽然也有出身于1983年一说，本文采用的是在一部分粉丝中流传甚广的1985年10月14日说。其间也流传 有“她自己也许也记不清自己的生日……”这样煞有介事的传言。与其说“C++小姐的话记不清自己的生日也不是什么不可思议的事情”，倒不如看作是她天真烂 漫的性格的表现。
Python
由Guido父上养大的深闺中的大小姐。她出身于荷兰的阿姆斯特丹，但在小时候就搬到了美国，父亲也在家里使用英语，所以不怎么会说荷兰语。
她个性随和。最出名的是她听C++宣布“想出去旅行一趟改变一下形象。200x年回来哦”出门旅行后（结果回来的时候已经2011年了……），放言说“我也稍稍出门旅行一下，公元3000年再回来哦”后出门数年未归。
虽然有着这样冒失的行动，但多亏抱着“养成大家都喜爱的孩子”的心愿的Guido父上大人的教育，实际上和她接触后会觉得她非常容易亲近。
前些天，她来到作者的朋友的公司打工（她现在似乎在边上大学边打工），被人们评价为“能充分融入工作、八面玲珑、给我们帮了大忙”。她不怎么说多余的话，彬彬有礼的样子，被评价为是在“天真烂漫、自由第一”的人众多的业界中与众不同的存在。
据说她擅长的科目是数学，经常看到她轻松地解决各种统计相关的难题。喜欢穿白色的连衣裙或浅粉色的开衫这样清新的服装。
实际上她还喜欢爬行动物，据说在家里还有养蛇。粉丝们经常讨论“她会给宠物们起什么样的名字呢？”这样的话题。大多得出的都是“肯定是Monty 吧”这样的结论。会不会飞就不得而知了。（估计指的是英国的六人喜剧团体Monty Python的作品The Flying Circus，译者注）
Ruby
由松本爸爸养大的日本的女孩子。因为生日在圣诞节，人生最大的烦恼是生日礼物和圣诞节礼物变成一份了。出生地是岛根县松江市，除了旅游和工作以外没有到过其它的县。
由于受的教育是自由奔放式的，她性格好动、好奇心旺盛。平时是一个率真的好孩子，但偶尔也会看到她喜欢恶作剧的一面，这让周围的人十分困扰。看到她的身影时经常会想起IT业的“Just For Fun !”这句话。
小时候过着一个人在荒山野岭到处跑的生活，10岁的时候与一个叫Rails的女孩成为朋友，生活开始变化。两个人玩耍时停在了演艺事务所门前，谈起 可以两个人结对进行演艺活动。以“Ruby与Rails”的艺名出道、主要从事杂志模特，也有拍过电视广告，所以很多人都听过她们名字。
人们想着她在这多愁善感的年龄段体验各种演艺活动、性格多少会产生一些变化吧，但在前些天与她久违的谈话中，却惊讶地发现她仍是与从事演艺活动之前一样行动自由奔放。虽然行为举止多多少少显得更加稳重，其喜欢恶作剧、活泼的本性却和以前一样没有变化。
想着已经是高中生了差不多也要开始穿一些成熟一点的服装的她，对于洋装却和小时候一样穿着Mickey Mouse。虽然她个子小又是娃娃脸与这样的衣服很配，不过这样真像一个女高中生吗？
她的粉丝也分为想要她一直保持现在的样子，和想要看到她更成熟的样子的两派。
PHP
以强化Web世界为目的制作出来的女性机器人。竖着的头发是用作天线来随时接收主人的命令的。
为了有与人类相近的触感，使用了硅树脂来制作其皮肤。内部是类似于刀片服务器的构造，常常使用多台服务器进行复用。因此体重比人类更重一些。
在她最初登场的时候，还能看到她关节可动部分的骨架，行动也很僵硬，与人类的形象差别很大。然而经过了18年间6次的大版本升级之后，其行为和言语已经渐渐变得像人了。最近更是达到了像初音未来这样（比起人类仍然有少许违和感但已经十分自然了）的级别。
虽然笨笨的、工作时也磕磕绊绊的，但由于她遵循
机器人三原则
、服从主人的命令，也有很多人成为她的粉丝。她的粉丝俱乐部官网“PHPer！”无需入会费便可简单入会，是会员数在IT界首屈一指的大团体。
对于她持拒绝态度的人也很多，常有“她的行为在生理上有些难以接受”、“如果再聪明点就好了”、“与她稍有过接触但觉得还是与人类差别很大”这样的评论。
平常穿从Forever12和志村买来的衣服。想着穿便宜的快速时尚（fast fashion）衣服便可以将省下的钱花在机器开销上。可以说是标准的机器人的效率优先的花钱方式。或许会有她也在意流行、为样子烦恼的那一天吧？
C#
在著名的微软公司接受精英教育、11岁时便跳级进入大学学习、倍受人们关注的少女。也被称为“IT界的最强幼女”。
因为与C++的名字很像，一段时间内盛传“难道是私生子吗？”的流言，实际上两人没有直接的血缘关系。也有报道称两人是远房亲戚，但实际情况如何则不得而知。
似乎喜欢成熟的行为、讨厌像小孩子一样玩耍。有生日的时候收到父母送的名为安迪的毛绒玩具时说道“这是啥。没sense。不要”的传闻。
然而对于食物的兴趣却仍停留在小孩的阶段，多次目击到她在学校食堂点儿童套餐的样子。不喜欢喝咖啡，就算是甜味的罐装咖啡也会令她皱眉头。
虽然偶尔会见到她意外地孩子气的一面，多数情况下见到的还是她说话、待人接物彬彬有礼的样子。是一个既有成熟的一面又有稚气的一面的孩子。由于还在成长期，见到她时常有“又长高了啊”、“有些像大人的样子了”这样的感慨。一直会期待着下见到她时会长成什么样子。
常穿
秀兰邓波
的洋装。据说都是她本人挑选的，与她自己非常相配。她的可爱让人们无论男女都会成为她的粉丝。
她的志向是在大学毕业后不仅在养育她生长的微软公司的旗下工作、还要活跃于整个IT界。虽然没有问到更详细的计划，但据说是要做出能让苹果和企鹅等也能和睦相处的东西。到底会做出怎样的东西来呢？
JavaScript
在争议地区长大的17岁的女孩子。常常面无表情、谈话时总给人以一定的距离感。
虽然与Java的名字很像，两个人之间却没有血缘关系。在当时Java这样的名字很流行，所以父母也给她起了类似的名字。她本人似乎对自己的名字并不在意，有时也以“ECMA”的笔名进行活动。偶尔也会被叫“JS”的外号，对此则更不在意，甚至对这种称法公然无视。
她的生涯非常不幸。刚一出生祖国便爆发战争。懂事之前便母亲去世、离开了父亲。在大人们任性的争斗中，她学会了将自己藏在壳中、保护自己周围的生存 之术。同年龄的女孩子随着年龄的变化都在挑战各种风格的时候，她却不顾周围的话语、一个人继续闭锁在壳中。当时就是非得这样才能生存的艰难环境。
由于有了这样的儿童时期，她的说话、思考、待人接物的方式与其它的孩子都稍显不同。有很多人在与她说话时都会烦恼该怎样说才好。不过，也有人对她持有简单的一根筋的思考方式“容易接触”、“某种程度上来说，很好理解”的印象。
现在，她的国家正向努力解决纷争、开拓新的居住土地的方向前进着。大人们虽然仍旧任性地互相斗争，至少在这几年里，已经没有发生像以前那样互相憎恨、互相残杀的战争了。
在开始复兴的祖国里，她如今应该能幸福地生活着吧？什么时候才能看到她像同龄的女孩一样欢笑呢？","你遇到了一群敌人！
你要怎么办呢？问问你的大将吧！
C：拿出一根棍子，一个一个把敌人砸死。
C++：用机关枪。
java：我打电话叫十万个基佬！
perl
：我会功夫！
ruby大喊着拿着武士刀冲上去了。
python：用氢弹。
lisp
：我先把敌人分组一下吧！
haskell：我们可以用
歼星舰
啊！
PHP：让我们把敌人老死吧！","我的简单理解是：
C++ 是为又聪明又努力的人设计的
Java 是为不聪明但努力的人设计的
Lisp 是为聪明但不努力的人设计的
Python 是为像我这样的人设计的。。。","这个问题已经有不少很详细的资料了
Let me google that for you
//============
口胡,PHP明明是这个:
Lisp
Fortran
Perl 
JavaScript
VB
Scala
最后是Python:","一图胜前言：
img
下面的图对比了最流行的9种编程语言，来帮初学者选择最适合自己的。
img
img
img
img
img
img
img
img
img
 图片来源： 
Should You Learn Python, C, or Ruby to Be a Top Coder? (Infographic)-Medium
Which Programming Language Should I Learn First?
 翻译：麻瓜编程
我是 
@程序员吴师兄
，持续分享校招经验、CS学习、面试、算法等内容，在计算机、程序员领域相关的问题下，
有几个收藏过万的回答，
点击下方链接了解更多。","转一篇包含全系列武器对比的文章――《如果编程语言是种武器》
对程序员来说，编程语言就是武器，但有的武器好用，有的武器不好用，有的武器甚至会杀了自己。
▲C语言是
M1式加兰德步枪
，很老但可靠
▲C++是双截棍，挥舞起来很强悍，很吸引人，但需要你多年的磨练来掌握，很多人希望改用别的武器
▲Perl语言是燃烧弹，曾经在战场上很有用，但现在很少人使用它
▲Java是M240通用弹夹式自动机枪，有时它的弹夹是圆的，但有时候不是，如果不是，当你开火时，会遇到NullPointerException问题，枪就会爆炸，你被炸死
▲Scala是
M240通用机枪
的变种，但它的使用手册是用一种看不懂的方言写的，很多人怀疑那只是一些梦话
▲JavaScript是一把宝剑，但没有剑柄
▲Go语言是一种自制的“if err != nil”发令枪，每一次发射后，你都必须要检查它是否真的发射了
▲Rust语言是一种3D打印出的枪。将来也许真的能派上用场
▲
bash
是一个十分碍手的锤子，你抡起它时会发现所有东西看起来都像钉子，尤其是你的指头
▲Python是一种“v2/v3”双管枪，每次只能用一个管子发射，你永远不知道该用哪个管子发射好
▲Ruby是一把外嵌红宝石的宝刀，人们使用它通常是因为看起来很炫
▲PHP是水管子，你通常会把它的一段接到汽车的排气管，另一端插进车窗里，然后你坐进车里，开动引擎
▲Mathematica是一种地球低轨道粒子大炮，它也许能够干出很神奇的事情，但只有付得起费用的人才能使用它
▲C#是一种强悍的激光大炮，架子一头驴子上，如果从驴子上卸下来，它好像就发不出激光
▲Prolog语言是一种人工智能武器，你告诉它要做什么，它会照做不误，但之后，它会弄几个
终结者
出来，烧掉你的房子
▲Lisp语言是一把剃须刀，有很多款式。只有寻求刺激和危险的人才会使用它","PHP、Java、python、C、C++，编程语言都各有什么特点或优点？
C、C++属于编译语言，源码先编译成机器语言，然后直接使用编译结果运行，效率高。
PHP、python属于解释性语言，不需要编译，使用时由解释器解释执行，效率低。
java源码会先编译成字节码，然后JVM解释执行，半编译半解释。由于JVM的优化，执行时不用逐行解释，效率上更偏向
编译型语言
。
不过，随着硬件效率的不断提高，程序员开发效率比程序运行效率要重要得多。
C作为通用的基础编程语言，编程开发入门必备，特点在于偏向计算机底层操作，多用于性能要求严格的领域，如驱动，内核。
优点：编译效率高，底层开发时相对于汇编而言移植性好，能直接访问物理地址。
C++以C为基础发展而来，可认为是C的扩展。相对C增加了类、继承、重载、类模板、C++标准库、模板库等。C面向过程，C++面向对象。
优点：继承了C，在保持高效的前提下又有所发展。
JAVA的特点在于跨平台，“一次编译、到处执行”。语法上相对于C++，有自己的内存回收机制，不用指针，不用考虑内存分配和回收，程序可靠性高。框架和库都非常多，应用广泛，从桌面应用、web、企业级应用到移动端的Android开发都有使用。容易找工作。
优点：简单、面向对象、分布式、解释执行、鲁棒、安全、体系结构中立、可移植、高性能、多线程以及动态性。
PHP属于脚本语言，主要应用于 web端，发展成熟、网络上很多的模板和框架，学习资料也多，快速建站网络开发必备。简单概括为：入门简单，广泛流行，总是被黑。PHP在语法上和C相似，两者相互学习容易。
优点：使用变量前无需定义类型简单，跨平台，支持多，框架成熟，拥有众多库函数，可以直接实现Key-Value存储。
Python同样简单易学，相对PHP专注web，Python的应用领域更广泛。语言上更简洁，接近自然语言。
优点：开发快，功能强大，程序易读。","Java
厚重，不易携带，每一样工具都经历了考验，无数人使用，各种场合，各种工作得心应手。
Python
工具不少，便于携带，但是每项工具都是缩微版本，适合随身应急使用，也适合收藏。但是不适合正经八本的干活。
C系语言
生产工具的工具。
PHP
按惯例黑一下。
$$$$$$$$$$$","把编程语言类比到王者荣耀里的英雄。
Java就是吕布，没钱就没伤害也没坦度，前中期都要发育，先出防装再堆输出装，装备起来了，砍谁都是几刀的事，但前提是附魔，没有附魔还是打不出伤害。Java就这样，你必须按照框架和
设计模式
的条条框框（附魔）来做，否则你就发挥不出Java的作用。Java项目需要投入更多的财力人力（发育），没有好的服务器和足够的开发时长，也发挥不出Java的作用。
PHP则是
亚瑟
，新手英雄，很容易上手。不需要什么操作和装备，开局就能打出不俗的伤害，而且没有蓝条，自带回复。发育起来后，伤害不算高，但也不低，双沉默一套带走脆皮没问题，身板不算肉但也不脆。玩家意识和操作够强的话，打进巅峰赛前十（比如斗鱼
亚瑟王
）也不是不可能，所以上限也不算低。这也是为什么很多公司起步时选择PHP，开发和运维成本低，见效快，试错成本低。发展起来后，也不是不能用，好比
英雄池
多了，根据阵容掏一手亚瑟也不是不行。
Python是
夏侯
，也算一个新手英雄，机制很全，减速、击飞、护盾、真伤、位移、霸体都有，但大多数机制单独拿出来跟其他英雄对比，都很一般，并不是一个能带飞全场的英雄。
C++是韩信，机制全、位移多、伤害高，但身板脆，依赖暴击，容错率低。玩得好，可以带飞全场。
C是赵云，比韩信容错率高，操作也更简单，伤害和控制也更稳定。也是一个能带飞的英雄。要练习打野盘活全场，赵云是一个不错的入门选择。",各语言的魔戒之旅。上老图，大概能看个方向。,"如果把编程语言比作国家的话：
PHP：巴西。
拥有很多美好的事物，经常炫耀自己，但私底下其实非常保守。
Java：美国。
乐观，强大，喜欢把麻烦事掩盖起来。
Python：荷兰。
时髦，富有，平易近人，有吸引力，但并不是表现最佳的。
C：挪威。
强势，动态，但无法令人感到激动。
C++：英国。
强大，严谨，但并不擅长于干实事，逐渐被Java取代。
如果把编程语言比作车的话：
PHP：Oscar Mayer Wienermobile。
外形奇特，难以驾驭，但每个人都想驾驭它。
Java：家庭旅行车。
驾驶起来很容易，速度不会太快，不容易车毁人亡。
Python：适合初学者使用的车。
可以无照驾驶，适合在路况好、车速<30码的地方行驶。
C：赛车。
跑得很快，但它可能每50公里就抛锚一次。
C＋＋：C赛车的升级版。
它除了拥有C赛车的功能，还增加了许多新功能。例如它每250公里只抛锚一次，但是一旦它抛锚，基本上没人能找出是什么地方出了错。
--------------------------------以下是几种语言的特点-----------------
PHP
优点：
1. 跨平台，性能优越
跟Linux/Unix结合比跟Windows结合性能强45%，并且和很多免费的平台结合非常省钱。
2. 语法简单，容易上手
PHP有成熟的开发工具，比如NuPHPed，在Linux平台下可以使用Eclipse等等。
3. 技术支持性好
很多技术工具，比如WebService、Ajax、XML等等，足够应用；还能够使用多种数据抽象层，模板层，方法。
4.框架多且成熟
比如支持MVC的框架：phpMVC，支持类似
http://
ASP.net
的事件驱动的框架：Prado，支持类似Ruby On Rails的快速开发的框架：Cake等等，足够满足你的应用需求。
5.面向对象体系，能够适应基本的面向对象要求。适合开发大型项目。
6..开源性
比如比较知名的开源框架有Zend Framework、CakePHP、CodeIgniter、
symfony
等，开源论坛有Discuz!、Phpwind等，开源博客 WordPress，开源网店系统如Ecshop、ShopEx等，开源的SNS系统如UCHome、ThinkSNS等。
缺点：
1.对多线程支持不太好，大多数时候我们只能简单的模拟去实现的。
2.语法不太严谨，比如变量不需要定义就可以使用，在c,Java,c++中变量是必须先定义以后才可以使用的。
3. PHP的解释运行机制繁琐。
Python
优点
1.易于学习
python虽然是用c语言写的，但是它摈弃了c中非常复杂的指针，简化了python的语法，它使你能够专注于解决问题而不是去搞明白语言本身。
2.开源性
Python是FLOSS（自由/开放源码软件）之一，Python希望看到一个更加优秀的人创造并经常改进。
3.可移植性
Python经过改动，已经被移植在许多平台上了。另外，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行，因而，你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。
4.面向对象面向过程同时支持。
5.可扩展性和可嵌入性
你可以将Python嵌入到C/C++程序，让你的程序的用户获得""脚本化""的能力。
6.标准库以及第三方库资源丰富
Python标准库确实很庞大。python有可定义的第三方库可以使用。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）等等。
缺点
1.运行速度慢，相比于C++/C运行速度偏慢，不过对于用户而言，机器上运行速度是可以忽略的。
2.构架选择太繁杂，没有像C#这样的官方.net构架，也没有像ruby由于历史较短，构架开发的相对集中，所以人人都有不同的方案。
Java
优点：
1. 跨平台性
Java语言中， Java自带的虚拟机很好地实现了跨平台性。 Java虚拟机提供了一个字节码到底层硬件平台及操作系统的屏障，使得Java语言具备跨平台性。
2. 面向对象
Java是一种面向对象的语言，也继承了面向对象的诸多好处，如代码扩展、代码复用等。
3. 安全性
运行时Java类需要类加载器载入，并经由字节码校验器校验之后才可以运行。 Java类在网络上使用时，对它的权限进行了设置，保证了被访问用户的安全性。
4. 多线程
Java除了内置的多线程技术之外，还定义了一些类、方法等来建立和管理用户定义的多线程。
5. 简单易用
Java源代码的书写不拘泥于特定的环境，可以用记事本、文本编辑器等编辑软件来实现，然后将源文件进行编译，编译通过后可直接运行，通过调试则可得到想要的结果。
缺点：
运行速度相比于C/C++有些缓慢了，这是机制原因导致的。
C
优点：
1. 简洁紧凑、灵活方便
C语言一共只有32个关键字,9种控制语句，程序书写自由，主要用小写字母表示。它把高级语言的基本结构和语句与低级语言的实用性结合起来。 C 语言可以象汇编语言一样对位、字节和地址进行操作, 而这三者是计算机最基本的工作单元。
2. 运算符丰富
C的运算符包含的范围很广泛，共有种34个运算符。C语言把括号、赋值、强制类型转换等都作为运算符处理。从而使C的运算类型极其丰富表达式类型多样化，灵活使用各种运算符可以实现在其它高级语言中难以实现的运算。
3. 数据结构丰富
C的数据类型有：整型、实型、字符型、数组类型、指针类型、结构体类型、共用体类型等。能用来实现各种复杂的数据类型的运算。并引入了指针概念,使程序效率更高。另外C语言具有强大的图形功能, 支持多种显示器和驱动器。且计算功能、逻辑判断功能强大。
4.C是结构式语言
结构式语言的显著特点是代码及数据的分隔化,即程序的各个部分除了必要的信息交流外彼此独立。这种结构化方式可使程序层次清晰, 便于使用、维护以及调试。C语言是以函数形式提供给用户的,这些函数可方便的调用,并具有多种循环、条件语句控制程序流向,从而使程序完全结构化。
5. C语法限制不太严格、程序设计自由度大
一般的高级语言语法检查比较严，能够检查出几乎所有的语法错误。而C语言允许程序编写者有较大的自由度。
6. C能直接访问物理地址和操作硬件
因此既具有高级语言的功能，又具有低级语言的许多功能，能够象汇编语言一样对位、字节和地址进行操作,而这三者是计算机最基本的工作单元，可以用来写系统软件。
7. C语言程序生成代码质量高
程序执行效率高一般只比汇编程序生成的目标代码效率低10へ20%。
8. C语言适用范围大，可移植性好
C语言有一个突出的优点就是适合于多种操作系统, 如DOS、UNIX,也适用于多种机型。
另外
C语言具有绘图能力强，可移植性，并具备很强的数据处理能力，因此适于编写系统软件，三维，二维图形和动画它是数值计算的高级语言。
缺点：
运算符和运算优先级过多，不便于记忆，语法定义不严格，编程自由度大，对新手不友好。
C++ 
C++除了兼具了C语言的优势之外，还有一下特点：
C++语言的主要特点表现在两个方面，一是尽量兼容C,二是支持面向对象的方法。
它操持了C的简洁、高效的接近汇编语言等特点，对C的类型系统进行了改革的扩充，因此C++比C更安全，C++的编译系统能检查出更多的类型错误。
另外，由于C语言的广泛使用，因而极大的促进了C++的普及和推广。C++语言最有意义的方面是支持面向对象的特征。虽然与C的兼容使得C++具有双重特点，但他在概念上完全与C不同，更具面向对象的特征。
出于保证语言的简洁和运行高效等方面的考虑，C++的很多特性都是以库（如STL）或其他的形式提供的，而没有直接添加到语言本身里。C++引入了面向对象的概念，使得开发人机交互类型的应用程序更为简单、快捷。很多优秀的程序框架包括Boost、Qt、MFC、OWL、wxWidgets、WTL就是使用的C++。
欢迎关注我的微信公众号：
九章算法
（ninechapter）,帮助你了解IT技术前沿，通过面试、拿到offer、找到好工作
！","来个车版的：
ref : 
If programming languages were vehicles
C:
C was the great all-arounder: compact, powerful, goes everywhere, and reliable in 
situations where your life depends on it
C++
C++ is the new C ― twice the power, twice the size, works in hostile environments, and if you try to use it without care and special training you will probably crash.
C#
C? is C++ with more safety features so that ordinary civilians can use it. It looks kind of silly but it has most of the same power so long as you stay near gas pumps and auto shops and the comforts of civilization. A well-known heavily muscular intimidator keeps touting it.
JAVA
Java is another attempt to improve on C. It sort of gets the job done, but it's way slower, bulkier, spews pollution everywhere, and people will think you're a redneck
Python
Python is great for everyday tasks: easy to drive, versatile, comes with all the conveniences built in. It isn't fast or sexy, but neither are your errands.
Perl
Perl used to serve the same purpose as Python, but now only bearded ex-hippies use it.
LISP
LISP is programming stripped down to the bare essence. It's been around since forever. Using it makes you stronger, but only an athlete or a maniac can make a living with with it.
Haskell
Haskell is like a hipster version of LISP.
PHP
PHP is this hand-me-down deathtrap that you only use because you're stuck with it, and when you hit a speed bump the wrong way it sets you and your passengers on fire.
Javascript
This is Javascript. If you put big wheels and a racing stripe on a golf cart, it's still a fucking golf cart.
Matlab
MATLAB is what scientists use to do special scientist things.
R
R is what scientists use when they can't afford MATLAB.
Go
Go is a shiny new toy that tech nerds say will be the way of the future, but it's only practical if you limit everything you want to do to stay within its range.","PHP、Java、Python、C、C++这些编程语言，计算机专业的同学基本在大学都学过，而在工作以后基本就偏重1-2门语言，对于Java程序员来说，基本就可以沉溺于Java而无法自拔了，但也偶尔会用PHP写写网站后台；对于学霸级的同学来讲，Python、C、C++有可能会样样精通，因为简单地调用一些库已经无法满足他们的需求，一探究竟才真正的过瘾。其实，各种编程语言没有简单的优缺点，在什么情况下或在哪些方面使用，是由它自身特点决定的。
-------------------------前方美图预警---------------------------
PHP
应用指数：★★
性格特点：清新淡雅
卡通形象：
特点简析：
有人说“PHP是世界上最好的语言”，也有人说“PHP最大的优点就是没有优点”。可以说，她是编程语言中的一股清流，
专注于Web开发，是写中小型网站后台的首选
。正因为其
架构简洁明快，开发效率高
，所以对PHP程序员仍然有大量的需求。目前，PHP主流框架依然基于MVC模式，但也在不断地创新，比如Codelgniter框架，性能高、速度快，适用于共享主机；Seagull则功能更加强大，代码库的标准化和模块化更高，同时也有较多的文档提供支持。虽然PHP有着清新的外表，但也有着丰富的内心，等待你去探索。
Java
应用指数：★★★★
性格特点：“社会”姐
卡通形象：
特点简析：
说起Java，很多人第一个想到的词就是“
跨平台
”。凡是有Java虚拟机的地方，Java语言都可以大显身手。
从安卓APP的开发，到各种互联网信息系统的开发，再到大数据、云计算、物联网的应用，可以说Java无处不在，无时不有
。在各种编程语言当中，Java是真正见过“大世面”的，所以她也有着世界上最广泛的开发者群体。Java有着easy-going的外表，但当你深入其中时，她会教你如何成为一名真正的“程序猿”。
Python
应用指数：★★★
性格特点：知性十足、学霸范
卡通形象：
特点简析：
Python给人的印象是“学姐范”十足，她有着
丰富的库
，根据开发需要可直接调用。她最初应用于科学计算，任何复杂的数学问题她都能迎刃而解；同时随着AI的兴起，Python也成为了
人工智能开发的主流语言
。对于初学者而言，语法简单、功能强大是Python最大的亮点。当你深入其中，图像处理、网络开发等功能也能让你大呼过瘾！如果你同样是学霸，便能轻松和她“配对成功”。
C
应用指数：★★★★
性格特点：内涵深、御姐风
卡通形象：
特点简析：
作为计算机相关专业的第一门专业课，C语言在实际应用场景中已很难再看到她的容颜。但她却无时无刻不陪伴着我们，Linux就是用C开发的，很多
底层设计、工业领域的机器程序开发都会用到C
。编程语言的本质是算法，而作为
面向过程的语言
，C将各种算法演绎得淋漓尽致。如果你致力于
嵌入式开发
等领域，这位御姐将会给你战友般的陪伴！
C++
应用指数：★★
性格特点：娇羞而善解人意
卡通形象：
特点简析：
C++可以说是C的“姊妹篇”，但和C相比，C++要温婉许多。从功能上看，
C++比C扩展了很多
，
并且增加了面向对象的特性
。C++开发简洁，运行高效，但因其娇羞的特点，如果没有扎实的C语言功底，你很难读懂她的心思。但她的功能扩展，也使得她一度成为主流的IOS开发语言。","别的我不知道，但是PHP和Python明显优于Java和C++，因为不伤头发！
题主还问了C，那就补一下C语言之父――
C语言也不错，优点明显。","PHP:面向Web服务器编程
JAVA:面向各种框架编程
PYTHON:面向人类语言编程
C/C++:面向内存和数据结构编程
附赠几个
C#:面向微软产品编程
汇编:面向CPU指令编程
JavaScript:面向DOM编程","如果编程语言也来玩《权力的游戏》，怎么按照它们各自的特点安排角色？
Java――龙妈
理由
：Java是使用程度最为广泛、同时也是目前使用人数最多的编程语言，鉴于龙妈的真命天女身份，同时身边聚集了越来越多的力量，更为重要的一点是，任何人在跟龙妈交手之前，先要了解她的N种头衔――而用Java写的项目，在你了解到核心部分之前，可能先要阅读很长很长的非核心代码……
龙妈（Daenerys Targaryen，丹尼莉丝・坦格利安）
坦格利安龙族风暴降生、不焚者、弥林女王、
安达尔人
和先民的女王、草原上的
卡丽熙
、破镣者、龙之母，龙妈女主光环加身，不光有三条神龙护体，还有大军跟随；当然更重要的，还有好几位智商超群的仰慕者辅佐，就连掐架失手杀爹的小恶魔也投奔龙妈了……
技能修炼手册
1. Java 8实战
2. Tomcat架构解析
更多：
https://
mp.weixin.qq.com/s/ZyG6
3kJcCWx8DoJCQ32jjA
C语言――泰温
理由
：C语言容易编译，贴近底层，多年占据编程语言排行榜前列，虽然近期份额有一定数量下降……
凯岩城
领主泰温虽然已经领便当了，但是他是少数几位对君临整体情况、不同家族的人物背景及未来趋势有深入洞察力的老前辈。
Tywin Lannister（泰温・兰尼斯特）
凯岩城公爵、西境守护，兰尼斯特狮族掌门人，詹姆、瑟曦和提利昂之父。手握重权、心思缜密、行事老辣，具有极高的军事和政治才能。被自己嫌弃的侏儒儿子提利昂在父子冲突中失手弄死......如若没有，在权游中，老前辈的筹码很高啊。
技能修炼手册
1. 明解C语言（入门篇，中级篇）
2. C语言程序设计：现代方法（第2版）
更多：
https://
mp.weixin.qq.com/s/IcXi
H56dav1PVyP7vwjXBA
C++――色后
理由
：C++是功能更为强大的C语言，且直接提供面向对象编程和
泛型编程
的特性。瑟曦虽然不如老爹泰温那样老谋深算，但是傲娇任性、野心勃勃，处处效仿老爹。
色后（Cersei Lannister，瑟曦・兰尼斯特）
泰温之女，君临城鹿族劳勃国王之妻，乔弗里、弥塞、托曼的母亲，与孪生弟弟詹姆关系亲密，痛恨侏儒弟弟小恶魔。从小被巫魔女预言了一生，比如嫁给国王，母仪天下，三个孩子都会死去……
技能修炼手册
1. C++权威教程（第6版）
2. C++程序设计实践与技巧
Python――迮
理由
：在人工智能和机器学习领域，Python炙手可热，作为未来之星的迮邓坪蹩梢杂Python一比。
迮 （Jon Snow，琼恩・雪诺）
临冬城公爵、北境守护、史塔克狼族掌门人
艾德・史塔克
的私生子（额，应该说是表面上的私生子，实际身份成迷，广为流传的推测是：龙族疯王长子雷加（龙妈的大哥）与艾德的妹妹绝世美女
莱安娜
之子），绰号“
雪诺大人
”、“临冬城的私生子“、“长城上的私生子”等。同时他也是一个易形者（狼灵），他的冰原狼为白毛红眼的“白灵”。
技能修炼手册
1. Python编程：从入门到实践
2. 流畅的Python
更多：
https://
mp.weixin.qq.com/s/uRqs
DGDJCFYFHVRj1dGORQ
C#――小玫瑰
理由
：借鉴了Java的设计思想，好学，易用，同时兼顾运行效率。小玫瑰聪明机智、处事圆滑，能屈能伸。
小玫瑰（Margaery Tyrell ，玛格丽・提利尔）
隶属高庭金玫瑰
提利尔家族
，师从祖母
荆棘女王
（老谋深算的奥莲娜・雷德温夫人），年轻貌美，处事圆滑周到。先后嫁给鹿族的
蓝礼
（劳勃的弟弟）、乔弗里和托曼（劳勃和色后的两个儿子）。她对权利同样具有勃勃野心，但她的手段比较高明，进入君临不久就受到了城内百姓的爱戴。当观众爱上这个心机貌美的皇后，并期待她跟色后和大麻雀有更多较量时，她就因为色后的一锅端复仇法领便当了……
技能修炼手册
1. C#图解教程(第4版)
2. 深入理解C#(第3版)
更多：
https://
mp.weixin.qq.com/s/tFXE
zu9ZzhVvqrHG0V2oBg
JavaScript――小恶魔
理由
：黑白两道通吃（前后端都能搞定），三观正，洞察世事，偶尔做点小坏事儿，但总体非常受欢迎。
小恶魔（Tyrion Lannister，提利昂・兰尼斯特）
泰温次子，因出生时母亲难产死亡，深受父亲厌恶。他喜欢美女、今朝有酒今朝醉，随性洒脱，虽身为侏儒，但智商超群，被迫弑父后投奔龙妈。
技能修炼手册
1. JavaScript DOM编程艺术（第2版）
2. JavaScript高级程序设计（第3版）
更多：
https://
mp.weixin.qq.com/s/zojx
GPMUBmTfEOO5scN6MQ
PHP――三傻
理由
：PHP是最好的语言……三傻是最乖的宝宝……
三傻（Sansa Stark，珊莎・史塔克）
狼族艾德・史塔克的大女儿，先后因为政治联姻和宫斗牺牲品嫁给君临国王“乔大帝”（劳勃死后继位）、小恶魔、小剥皮，又被小指头觊觎。在前几季里是让观众恨铁不成钢的傻白甜（外号三傻为英文谐音，同时表达了中国观众为她智商捉急的情绪）。但是，经历一系列命运的捉弄之后，三傻终于在第6季开始长心了……
技能修炼手册
PHP与MySQL程序设计(第4版)
2. 深入PHP：面向对象、模式与实践(第3版)
Go语言――Bran Stark
理由
：出身名门，年轻，潜力无限，兼备特殊技能（并发高性能）……
布兰（Brandon Stark，布兰登・史塔克）
狼族艾德・史塔克次子，理性聪明，因喜攀爬城墙撞见色后和詹姆的关系，被詹姆推下城墙失去双腿。狼灵，具备特殊技能，可短时间控制其他动物的意识。临冬城被攻占后，远离权力纷争，带几位随从寻找
三眼乌鸦
，对抗异鬼。
技能修炼手册
1. Go语言编程
2. Go并发编程实战（第2版）
Swift――二丫
理由
：机敏好学，稳扎稳打逐步完善自身。Swift代码少、性能优，二丫话少、行动快。
二丫  （Arya Stark，艾丽娅・史塔克） 
狼族艾德・史塔克次女，从小是个假小子，随身佩戴一枚绣花针型利剑“缝衣针”，性格倔强，出手利落。二丫（艾丽娅谐音，同时是家里的二女儿）亲眼目睹父亲艾德被“乔大帝”处死，之后独身一人流亡在外，复仇的信念支撑她顽强地生长，并习得绝技。
技能修炼手册
1. 从零开始学Swift（第2版）
2. Swift编程权威指南（第2版）
更多：
http://
mp.weixin.qq.com/s/KGWr
dUkHVDvNawt2rbDIow
SQL――小指头
理由
：SQL是其他关系型数据库的基础，是后台必备技能。而小指头隐藏在幕后，精于计算，事事都跟他有牵扯。
小指头（Petyr Baelish，培提尔・贝里席）
君临前御前财政大臣，《权力的游戏》中各种战争的直接和间接引发者，藏于幕后，精于计算，阴险狡诈，纵横捭阖。
技能修炼手册
1. 
SQL必知必会
（第4版）
2. SQL基础教程（第2版）
更多：
https://
mp.weixin.qq.com/s/68Yu
jKqVtojRhUiS8hc0Gw
Objective-C――弑君者
理由
：OC是一种通用、高级、面向对象的编程语言。詹姆作为名门望族之后，气质出众，但他拥有其他角色不具备的凡人之痛，错爱、忠孝难两全...
弑君者（Jaime Lannister，詹姆・兰尼斯特）
狮族泰温长子，色后孪生弟弟，痴爱色后。高大英俊美男、武艺超群，表面上冷酷无情，实际是一位具有骑士精神的男士。在断臂之前更英勇无双，断臂之后虽然失去了武力优势，但是开始从多维度思考问题。最让人唏嘘的是，一路走来，我们越来越能体会詹姆是一位悲情的角色。
技能修炼手册
1. Objective-C基础教程（第2版）
2. Objective-C高级编程：iOS与OS X多线程和内存管理
更多：
https://
mp.weixin.qq.com/s/Le-i
OJVicd2sObjNY9Jfew
Ruby――红袍女
理由
：Ruby虽然入门难度略高，但是一旦搞定，用Ruby on Rails框架很快就可以搭建一个复杂的网站。梅姨有红宝石，还有巫术和预言能力……
红袍女（Melisandre，梅丽珊卓）
梅丽珊卓，光之王
拉赫洛
的女祭司，据说已经几百岁，但是外表貌美。她的有一条红宝石项链，可以协助施展巫术。她能通过火焰看到未来的部分景象或者暗示（但需要解读，所以有可能出现错误），刚开始为鹿族劳勃国王的另一个弟弟
史坦尼斯
服务（她误认为史坦尼斯是曾经打败异鬼的
亚梭尔・亚亥
重生）。
技能修炼手册
1. Ruby基础教程（第4版）
2. Ruby on Rails 教程（原书第4版）
本文转自
图灵教育
，作者英子（部分内容参考“
If programming languages were ""Game of Thrones"" characters
”）。
以上图片均来自《权力的游戏》剧照。
========
点赞、收藏、关注@人民邮电出版社，一键三连，感恩有你~",你去用这几门语言各自实现一遍某个同样功能的项目，比如web framwork、template、orm，然后就会有体会了，比别人在这里说要印象深刻。
,,,,,,,,,,,,,,,,,,,,,
新手该如何使用 GitHub？,"我是一个编程新手，刚刚接触GitHub，目前仅仅是把它作为自己的代码仓库。但我知道GitHub的魅力在于共同完成项目，但我现在对GitHub有以下几个困惑：
1.比如我看到一个有趣的项目，那么我该如何为这个项目做贡献呢？我是指，这个项目本身已经完整了，核心的一些架构我暂时是力不从心的，那我还能为这个项目做什么呢？
2.我看到很多刚学编程的人说用GitHub来学习编程，但我觉得大多数的项目即便你fork下来也是看不懂的吧？那么初学者如何找到适合自己的项目来学习呢？
谢谢。","实名反对前排所有答案，一个个都没回答题主的问题！新手看了能有什么收获？？！！
作为一名在 GitHub 上收获 60k star 的程序员来说，我觉得有必要认认真真的来回答一下。
我的 GitHub ： 
在这里给大家推荐一些计算机必看的经典书籍，同时提供下载方式：
很好，对于编程新手而言，如果一开始就知道利用 GitHub 来提高自己的技术水平，
那一定会进步很快。
题主问了两个问题，我依次来回答，希望对题主有帮助。
一、如何参与项目
如果你想参与某个
开源项目
，你首先要做的是先了解这个项目，最好的方式是先仔细阅读它的 
README
。
一个标准的 README 应该包含以下内容：
项目背景
安装
使用
Badge
相关项目（可选）
主要项目负责人
参与贡献方式
开源协议
通过
项目背景
可以了解这个项目动机和背景是什么，是为了优化什么问题还是因为市面上其它的项目太渣渣。
然后通过 
安装
 和 
使用
 知道项目如何运行起来，方便查看细节。
最后就需要查看它的 
参与贡献方式 ，有的是
希望你提交 issue，有的是直接 push，有的是加群一起协作。
题主还问到 「核心的一些架构我暂时是力不从心的，那我还能为这个项目做什么呢」，这一点你不用担心，哪怕你只是修改里面的一个错误单词，一句错误的语法对于整个项目来说也是很有作用的。
这不是开玩笑。
一个 4 岁小女孩就给 Linux 内核贡献提交。
链接：
https://www.
reddit.com/r/linux/comm
ents/2pqqla/kernel_commit_4_year_old_girl_fixes_formatting_to/cmzfvpl/
我们看看她修改了什么
https://
git.kernel.org/pub/scm/
linux/kernel/git/torvalds/linux.git/commit/?id=690b0543a813b0ecfc51b0374c0ce6c8275435f0
在里面可以看到
就是改了一个 「 
-
 」字符而已。
没有用过 git 的同学可能看不懂这个修改，即使用过的同学刚开始也觉得一脸懵逼，git 的 diff 修改会在前面显示 - 和 + 符号，这样看就知道了，实际上就增加了一个字符 - 。
为什么要修改这个字符？
我们看到，正常情况下「--------」和上面的字符串是对齐的，但是刚好修改的那行是没有对齐的，所以是有问题的，是不严谨的。
虽然是一个很小的修改，但是这个修改的意思非常大。
1、Linux 内核可以让所有人参与进来。
2、Linux 内核非常严谨，只要有错误，任何人都可以修改它。
说说这个修改的由来
在修改的提交记录里面，是这样写
他的侄女发现那个 「 
s
 」字母很孤单，用她的话说是不开心，加上「 
-
 」后就显得开心了。
非常细心的一个举动，这个修改在 riddit 上，很多人在激烈的讨论，有人认为这个修改没有什么作用，不就是一个字符而已，但是很多人对这个小女孩产生钦佩，觉得他是一个非常认真仔细的人。
希望这个小女孩的故事能够帮题主解惑。
原文链接：
4岁小女孩给Linux内核贡献提交_嵌入式Linux-CSDN博客
原文出处：CSDN博客
原文作者：
写代码的篮球球痴
二、编程初学者如何在 GitHub 寻找适合自己的小项目
GitHub 成立于 2008 年，截止到 2015 年，GitHub 已经有超过两千八百万注册用户和5700万代码库。
对于新手而言，要从这浩瀚的代码库中找到适合自己小项目无异于大海捞针，如果有个类似于 hao123 那样的导航网站就好了！
登登登，还真有，一个国人建立的开源项目：
HelloGitHub，致力于分享 GitHub 上有趣，入门级的开源项目，对于编程新手而言十分友好。
地址：
https://
github.com/521xueweihan
/HelloGitHub
在项目中，内容每月 28 号以月刊的形式更新发布，主要是面向编程新手、热爱编程、对
开源社区
感兴趣人群的项目。更新的内容主要包括：各种语言的流行项目、入门级项目、让生活变得更美好的工具、书籍、学习心得笔记、企业级项目等。
这些开源项目大多都是非常容易上手、很 Cool，能够让你用很短时间感受到编程的魅力和便捷。从而让大家感受到编程的乐趣，动手开始编程。
这些项目都有一些共同的特征，那就是很酷，非常容易上手的项目，编程的魅力和便捷体验起来就是这么简单。
对于编程新手而言，不管你是学 Java，还是学 Python，哪怕你是编程小白，不懂代码，也总能在里面找到适合你的项目。
这个新手项目还不够？那在推荐一个类似但更有趣的开源项目：GitHubDaily。
链接：
https://
github.com/GitHubDaily/
GitHubDaily
GitHubDaily 每日不定时推送一批 GitHub 上优秀的开源项目给开发者, 帮助开发者们发现当下最火的开源项目, 令开发者们得以掌控技术脉搏, 扩大自己的技术视野, 并从开源项目的学习中获得技术能力的提升。
它分门别类的整理了好多有趣的项目，适合新手在零碎时间去阅读学习，了解 GitHub 的生态。
以上就是我的回答，希望新手都能通过合理的使用 GitHub 来提高自己的技术水平，如果你觉得这个回答能够解决题主的问题，
不妨支持一下，
同时根据知乎的算法机制，会有越来越多的优质答案出现在你的时间线上。
最后，如果你是程序员，
可以查看个人简介，一起交流学习成长。
我的专栏：
我的其它相关回答：
最后，在这里也送大家一本帮助我拿到BAT 等一线大厂 offer 的算法笔记，是一位阿里大神写的，对于算法薄弱或者需要提高的同学都十分受用，算法一定是计算机学习的重中之重：","借用作者 
@珊姗是个小太阳
    的一篇文章来说   原文链接：
如何使用 GitHub？
 
什么是 Github ？
必须要放这张图了！！！
（图片来源
GitHub 是怎样的一个存在？ - Deep Reader 的回答
）
Git 是由 Linux 之父 Linus Tovalds 为了更好地管理linux内核开发而创立的分布式版本控制／软件配置管理软件。
好吧，我相信看到这里你已经晕了，写这些教程的人都是几年以上的程序员呀，他们往往直接就告诉你所有命令的含义或者整个体系。
专家盲点（expert blind spot）就是对一个事物知道的越多，就越发不记得“不知道这个事”的情形。
简单来说，Git 是一个管理你的「代码的历史记录」的工具。
我不是程序员为什么要学这个啊啊啊！又不要管理代码们！
别急，虽然 github 学习门槛高，一会你就知道为什么人人都应该会这个啦！
学习步骤
注册安装
去官网注册一个账号（这个你应该会，恩就不放链接了）
然后，下载一个
GitHub Desktop
 mac客户端是最方便的啦！（命令行什么的真的是会越来越晕！先别管他们！）
step1:创建新项目
我们三个人在不同的城市要远程共同写一本书，要有一个漂亮的笔记本吧？
「
repositories
」就是你的笔记本们。你只需知道 Repository 是个放项目的地方就行。有时候会出现 Repositories，是多个 Repository 的意思。
**fork**
如果你不想新建一个笔记本，看到小四之前写过一个好到炸裂的文章，想把他的直接全部偷过来，修改修改就成你自己的文章了，这应该怎么办呢？
github 还提供了一个很赞的功能叫做 fork ，你只需要点击这个神奇的按钮，就可以把他的「笔记本」变成你自己的啦！任意修改都可以哦~
step2：把「笔记本」克隆到本地
「笔记本」在云端，你要把它摘下来放到自己的电脑上写小说才方便呀，在这里我们叫「clone」是不是很形象？步骤如图：
或者是直接去我们的客户端
step3：可以开始写作啦！
你的笔记本里已经自动有一个文档了，这个时候让我们回到网页版[微笑脸]
你只需要在 web 端点开这个README.md可以开始在里面写你的小说了。
或者直接点开刚刚 clone 到电脑上的文件夹直接在里面写。
ps:需要注意的是，文本支持 markdown 格式，可以先参考这个
献给写作者的 Markdown 新手指南
。
step4:上传你写的小说
在本地写完之后你要上传到云端让我和小四都能看见你写出什么幺蛾子了吧？
回到客户端，你发现有变化！！！
没错，在你头像旁边给你这次提交内容起一个名字，以后如果再次寻找的时候会很方便。然后点下面的 Commit to master，还有右上角的 Sync 就好啦！
step5：回退到之前的版本
夜深人静的时候，我趁着你们都在睡觉把小说的结局偷偷地改成女主死掉了！
你醒来觉得我这结局改的也太悲伤了，完全不能接受！结局必须要和之前那样王子公主幸福的生活在一起的 happy ending！
问题又来了，怎么退回到我修改结局之前的 happy ending？
还是刚刚那个客户端，选择History 然后点击小齿轮，选择潇洒地点 roll back to this commit！
你又回到happy ending的状态啦！！
step6：
小四写了一章华丽无比的番外，你要更新本地的小说和他写的保持一致怎么办？
git pull
知道这些基本操作入门应该够了，我们来回顾一下！
入门初期迅速得到一些正反馈对于学习一门新技能来说实在是太重要了！尤其是编程这么炫酷的事情！
所以先不要管什么复杂的 issue 呀 wiki 呀乱七八糟的操作，按照上面的一步一步来，如果遇到什么问题 google 之，一般都会解决的。
有一个段子不就是说，当你遇到问题去找最高级的工程师，他们一般都会直接 google 吗？而且自带的帮助手册也是解决问题的好办法，比如你要新建一个 branch=》
Create a new branch with git and manage branches ・ Kunena/Kunena-Forum Wiki ・ GitHub
这种遇到问题先自己尝试解决的小技巧，也是我自从学编程以来最大的收获。
除了写代码你还可以用 github 做什么？
回到文章开头，我又不是程序猿不用写代码玩这个干啥？
你有没有碰到过团队里几个人共同协作写一个文档的时候？或者说需要反复修改的东西？比如最简单的写论文，用 word 保存一个一个版本 e-mail 给 boss？下次再找上次修改了什么地方简直要死啊有木有！！！
github 说白了就是一个「版本控制工具」。我们所谓的「回退」到历史记录，随时查看更改了什么地方，利用这个功能可以做的事情简直太多啦！
就像 github 其中一位创始人[Chris](
defunkt (Chris Wanstrath) ・ GitHub
)也详细描述了[GitHub初创的前因后果](
Startup Riot 2009 Keynote 路 GitHub
)，他说道：
Do whatever you want.
所以不是程序猿可以用这个来做什么呢？
1、写书
和 33 一起写小说的例子，还记得吧？几个人你一章我一章共同修改一本书，或是几个出版社的编辑对新书进行校对，利用这个神器就可以随时看到哪里出现了问题和更改。如果想自己写书的话 
gitbook
 也是不错的选择（又是一个坑。。）
2、写文档神器
身为科研狗、产品狗、射鸡湿的你，是不是经常写文档？一个成熟的文档可能会有好几个版本，需要不断地迭代，然后不断提交给老板看哪里需要修改。在不同版本间自如切换就要用到git branch和
git rebase
了。
想想看，用 git 的分支管理不比拷贝粘贴更方便吗？
3、健身
有个哥们为了激励自己健身把每日计划都放上去了，还可以邀请其他人一起来相互监督！
hoosin/EveryDaySport ・ GitHub
4、找男/女票
没错，看这个项目！利用众包的形式一起罗列男/女友条件的 list 然后试图自己开发出一个男/女票233333
YixuanFranco/YourBoyfriend ・ GitHub
5、用GitHub搭建博客、个人网站或者公司官网
一个有自己域名的独立博客，是不是很帅？！
GitHub本身提供免费的托管服务，又提供了贴心的 Pages 功能，可以绑定你自己的域名，免费、高效、不限流量，做一个个人页面绰绰有余。
Jekyll 的教程和我自己的博客会稍后放出。。（先给自己挖个坑）
6、用GitHub协作翻译
苹果官方发布的各种官方手册，比如最近开源的 Swift
numbbbbb/the-swift-programming-language-in-chinese ・ GitHub
 就是国内一个自发组织起来的团队，30多个人用9天时间即将翻译和校对工作全部完成，他们每人都还有自己的事情，上班、上线、创业，这么大的工作量在以往简直是不可能完成的任务！
7、项目管理
GitHub最初是为了开发的管理而生，当然也就具备了项目管理的潜质，特别是与开发密切联系的项目中，它的优势尽显。比如这篇文章介绍了如何使用GitHub结合 Trello 等其它工具进行项目管理：
使用GitHub进行团队合作
。当然，GitHub还是很偏重开发的管理，一般的项目管理还是适合使用 wortile 之类的产品。
8、科研项目及数据
较早的
arXiv
、
PLoS
之外，较有气象的可以推荐
mendeley
、
开放期刊目录
教育方面：
OpenStudy
：一个社会性学习网络，通过互助来更好地学习，主题涉及到计算机、数学、写作等。
openhatch
: 通过练习、任务等帮助新手更好地进入
开源社区
9、个人简历
GitHub上的代码无法造假，也容易通过你关注的项目来了解你的知识面的宽度与深度。现在越来越多知名公司活跃在GitHub，发布开源库并招募各类人才，例如：
Facebook
、
Twitter
、
Yahoo
 ...
开始有了第三方网站提供基于GitHub的人才招聘服务，例如：
GitHire
:通过它，可以找出你所在地区的程序员。
Gitalytics.com
：通过它，能评估某位程序员在GitHub、LinkedIn、StackOverflow、hackernews等多个网站的影响力。
甚至专门有一个项目就是自动根据你的 GtiHub 公开项目创建个人简历：
我们可以使用 Git 以及 GitHub 做哪些事情？ - Kane Blueriver 的回答
10、设计资源库
做 ppt 不知道到哪里去找高质量美图？
最近半年初入设计圈，收集了不少 bookmark 想在年底来一个总结。 于是自己创建了这个Design- Resource List 项目，旨在让更多的设计师找资源变得有章可循。
timmy3131/design-resource ・ GitHub
11、
Explore ・ GitHub
 更多好玩的内容等你自己发现哦
你在 GitHub 上看到过的最有意思的项目是什么？ - 调查类问题
更多高阶教程：
如果你已经不满足于上面的基础知识了，欢迎探索更高级的玩法！
1、
GitCafe
 /
Help
2、[git简明指南](
git - the simple guide
)墙裂推荐！漫画的形式很形象（恩我承认比我画的好看多了）
3、在线交互学习 github 的网站
Learn Git Branching
 这个也很好玩~
4、[GitHub自身的官方博客](
The GitHub Blog ・ GitHub
)
5、
git-flow 备忘清单
入门书籍推荐：
GitHub入门与实践 (豆瓣)
比较基础
Pro Git (豆瓣)
 更高级的教程，很全面！
对了对了，还有阳志平老师的两篇非常全面的旧文（这么称呼好生疏啊2333）
如何高效利用GitHub
（本文转载已经过作者授权）
看完这篇内容后，相信以下三件事，也会给你带来帮助：
1、点赞，让更多小伙伴能看到这篇内容，你的点赞是我持续创作的动力
2、提升自己，CSDN放出了大量免费课送给正在阅读的你，包含Python、Java、人工智能、算法、机器学习等热门领域，只要你想学，这里都有！
戳下方链接查看：
https://
edu.csdn.net/course/ind
ex?is_member=1&is_free=2?utm_source=eduxy_zhihuyl_mfk_0608
3、关注【程序员知识圈】，更多面试题、面试技巧等优质内容等你来撩！","这里推荐下，实验楼的《Git 与 Github 入门实践》课程。本着实用的原则，针对零基础同学，以图文的形式详细介绍了 Git & GitHub 结合使用的基本操作。
以下节选部分内容先睹为快！
一、在 Github 上创建仓库
1.首先，打开 
GitHub
 注册个人账户并登录。登录后，在个人主页的右上角点击 
New repository
 创建新的仓库：
2.打开页面如下图所示，填入相关信息。注意下图紫色框中有两个下拉按钮，左边的用来选择忽略文件，右边的用来选择所属协议，这两项可以不选，后面的课程会讲到。
3.点击绿色按钮创建新的仓库，成功后自动跳转到新建仓库的主页面，如下图所示：
二、克隆 GitHub 上的仓库到本地
现在克隆前面我们在 GitHub 上创建的仓库，使用 
git clone + [仓库地址]
 命令即可，这是标准的克隆仓库命令。
1.点击下图绿色按钮，再点击紫色框中的按钮即可复制仓库地址，当然复制上面地址栏中的内容也是一样的。
2.
克隆仓库
到本地：
3.进入仓库主目录，如下图所示，仓库主目录中有个 
.git
 隐藏目录，它里面包含了仓库的全部信息，删掉这个目录，仓库就变成普通的目录了。进入到仓库目录中，命令行前缀发生了一些变化，出现了红色的 master ，它就是当前所在的分支名：
4.当我们在 GitHub 上创建一个仓库时，同时生成了仓库的默认主机名 origin，并创建了默认分支 master。GitHub 可以看成是免费的 Git 服务器，在 GitHub 上创建仓库，会自动生成一个仓库地址，主机就是指代这个仓库，主机名就等于这个仓库地址。克隆一个 GitHub 仓库（也叫远程仓库）到本地，本地仓库则会自动关联到这个远程仓库，执行 
git remote -v
 命令可以查看本地仓库所关联的远程仓库信息：
Git 要求对本地仓库关联的每个远程主机都必须指定一个主机名（默认为 origin），用于本地仓库识别自己关联的主机，
git remote
 命令就用于管理本地仓库所关联的主机，一个本地仓库可以关联任意多个主机（即远程仓库）。
5.克隆远程仓库到本地时，还可以使用 
-o
 选项修改主机名，在地址后面加上一个字段作为本地仓库的主目录名，举例如下：
6. 另一个在其它 Git 教程中常见的命令 
git init
 ，它会把当前所在目录变成一个本地仓库，因为有 GitHub 的存在，这个命令在我们的生产生活中用到的次数应该是零，除非你想费时费力自己搭建服务器。操作截图如下：
三、创建新的本地分支
1.首先，克隆远程仓库到本地，进入仓库主目录，执行 
git br
 查看分支信息：
2.执行 
git branch [分支名]
 可以创建新的分支：
3.此命令创建新分支后并未切换到新分支，还是在 master 分支上，执行 
git checkout [分支名]
 切换分支，
checkout
 也是常用命令，先给它设置别名，然后切换分支：
4.创建新分支还要手动切换太麻烦，介绍另一个常用的命令 
git checkout -b [分支名]
 创建分支并切换到新分支：
如上图所示的分支信息，前两行是新建的本地分支信息，它们的版本号与主分支 master 一致，这是因为在哪个分支上创建新分支，新分支的提交记录就与哪个分支一致。新建分支并无跟踪任何远程分支，所以没有 master 分支中的中括号和括号内的蓝色远程分支名。
5.假设我们要在当前分支 dev1 上开发一个新的功能，需要增加一个文件 new_func1，然后生成一个新的提交：
四、将新分支中的提交推送至远程仓库
1.执行 
git push [主机名] [本地分支名]:[远程分支名]
 即可将本地分支推送到远程仓库的分支中，通常冒号前后的分支名是相同的，如果是相同的，可以省略 
:[远程分支名]
，如果远程分支不存在，会自动创建：
2.上图命令可以简写为 
git push origin dev1
 。注意哦，这是我们创建 SSH 关联后第一次执行 
push
 命令，可以看到传输速度有明显的提高，更重要的是，不再需要重复输入用户名和密码了，另外打印信息的第一行是警告信息，因为是这个分支的第一次推送嘛，下次执行推送就不会再出现了。现在执行 
git br
 查看一下分支情况：
可以看到，远程分支 origin/dev1 的信息已经在本地存在，且与本地同名分支一致。再看下 GitHub 页面的情况：
五、本地分支跟踪远程分支
执行这个命令 
git branch -u [主机名/远程分支名] [本地分支名]
 将本地分支与远程分支关联，或者说使本地分支跟踪远程分支。如果是设置当前所在分支跟踪远程分支，最后一个参数本地分支名可以省略不写：
这个命令的 
-u
 选项是 
--set-upstream
 的缩写。可不可以让本地分支跟踪远程非同名分支呢？可以的，尽管几乎遇不到这种自找麻烦的需求。可不可以撤销本地分支对远程分支的跟踪呢？也是可以的，执行 
git branch --unset-upstream [分支名]
 即可撤销该分支对远程分支的跟踪，同样地，如果撤销当前所在的分支的跟踪，分支名可以省略不写：
问题又来了，前面的操作是先将本地分支推送到远程仓库，使远程仓库创建新分支，然后再执行命令使本地分支跟踪远程分支，有没有办法在推送时就自动跟踪远程分支呢？有的，在推送的时候，加个 
--set-
upstream
 或其简写 
-u
 选项即可，现在切换到 dev 分支试一下这个命令：
六、删除远程分支
1.首先，删除远程分支，使用 
git push [主机名] :[远程分支名]
 ，如果一次性删除多个，可以这样：
git push [主机名] :[远程分支名] :[远程分支名] :[远程分支名]
 。此命令的原理是将空分支推送到远程分支，结果自然就是远程分支被删除。另一个删除远程分支的命令：
git push [主机名] --delete [远程分支名]
。删除远程分支的命令可以在任意本地分支中执行。两个命令分别试一下：
2.可以看到本地仓库已经没有远程分支 dev 和 dev1 的分支信息。查看 GitHub 仓库页面：
也只剩 master 一个分支。操作成功。
感兴趣的同学，可以直接前往《
Git 与 GitHub 入门实践
》，直接使用实验楼提供的在线环境动手练习。
最后再送上10条给编程新手的 Github 秘籍：
实验楼在线教育：10条送给编程新手的 GitHub 秘籍
25 赞同 ・ 1 评论
文章","不 多BB，直接上干货！
大学就泡在
Github
 上了，当初学了几个月就找到腾讯后台开发的工作，我练手的项目都来自这里！！
GitHub 标星 1.6w+，这个神级宝藏项目，作为编程新手有福了！！
 
让走在开源路上的开发者不再孤单，让想进入
开源世界
的人不再畏惧。
 
以下是正文：
 虽然我很早就知道 GitHub，但是学会逛 GitHub 的时间特别晚。当时一方面是因为菜，看着这种全是英文的东西难受，不知道该怎么去玩，另一方面是一直在搞 ACM，没有做一些工程类的项目，所以想当然的以为和 GitHub 也没什么关系（当然这种想法是错误的）。  后来自己花了一个星期看完了 Python 的基础知识，就想着找点项目看一看，学一学，练一练，这个时候我才真正的去了解 GitHub，开始了在 GitHub 的瞎逛之旅，在开始之初，随之而来的问题是我不知道哪些项目当时还是新手的我，哪些项目是好项目，哪些项目好玩有价值。  虽然现在我已经在 GitHub 上逛的相当流畅，但我还是想如果有一个东西可以收集这些对新手友好的东西，那么我当时可以少走更多的弯路，节省更多的时间吧。
首先，推荐一个开源电子书仓库，收录数百本经典计算机书籍，可以 star 一下，下次找书直接搜：
在这，顺便分享一份大学期间自己整理的电子书库，绝不是在网上那种打包下载的，而是自己需要学到某个方向知识的时候，去网上挨个找的，最后汇总而成。
汇集了编程语言(Java、C++、C、Python等等)、操作系统、计算机网络、系统架构、设计模式、程序员数学、测试、中间件 、前端开发、后台开发、网络编程、
Linux使用及内核
、数据库、Redis....等主流的编程学习书籍。
我整理的这些书大家可以在这里获取，对于学习计算机的同学帮助非常大，且十分系统
：
书单：
编程指北：计算机必读的书单（含下载方式）
  那么有这么一个东西么？  有的，而且已经做了三年多，这就是
HelloGitHub
，一个分享 GitHub 上有趣，入门级的
开源项目
。  
imarvinle/awesome-cs-books
  那么有这么一个东西么？  有的，而且已经做了三年多，这就是
HelloGitHub
，一个分享 GitHub 上有趣，入门级的开源项目。   
 GitHub 网址：
https://
github.com/521xueweihan
/HelloGitHub
  在项目中，内容每月 28 号以月刊的形式更新发布，主要是面向编程新手、热爱编程、对
开源社区
感兴趣人群的项目。更新的内容主要包括：各种语言的流行项目、入门级项目、让生活变得更美好的工具、书籍、学习心得笔记、企业级项目等。   
 这些项目都有一些共同的特征，那就是很酷，非常容易上手的项目，编程的魅力和便捷体验起来就是这么简单。   
 再次给出 GitHub 地址: 
https://
github.com/521xueweihan
/HelloGitHub
 下面我们就来看看，这个项目具体包括啥，我们以最新的月刊（43 期）为例。   
0x00 简介
 
0x01 目录
 
0x02 内容
  每个类型的项目我们挑一个来看。  
C 项目
  
tmux
：一个终端复用工具，可极大的提高工作效率。  
提供了强劲的、易于使用的命令行界面；
可横向和纵向分割窗口；
窗格可以自由移动和调整大小，或直接利用四个预设布局之一；
可在多个缓冲区进行复制和粘贴；
可通过交互式菜单来选择窗口、会话及客户端；
等等。
C# 项目
  BenchmarkDotNet：功能强大的用于基准测试 .NET 库。   
C++ 项目
  dbg-macro：打日志是 C++ 开发中必不可少的一种 debug 方式，
dbg-macro
 受 
rust-lang
 中 的 dbg 启发，提供比 
printf
 和 std::cout 更好的宏函数。主要有如下特点：  
美观的彩色输出（当输出不是交互式终端时，颜色将自动禁用）；
兼容 C++11，并且是 header-only；
支持基础类型和 STL 容器类型的输出；
除了基本信息外，还输出变量名和类型；
启用 DBG_MACRO_DISABLE 生成 release 版。
 #include <vector> #include <dbg.h>  // You can use ""dbg(..)"" in expressions: int factorial(int n) {   if (dbg(n <= 1)) {     return dbg(1);   } else {     return dbg(n * factorial(n - 1));   } }  int main() {   std::string message = ""hello"";   dbg(message);  // [example.cpp:15 (main)] message = ""hello"" (std::string)   const int a = 2;   const int b = dbg(3 * a) + 1;  // [example.cpp:18 (main)] 3 * a = 6 (int)   std::
vector
<int> numbers{b, 13, 42};   dbg(numbers);  // [example.cpp:21 (main)] numbers = {7, 13, 42} (size: 3) (std::vector<int>)   dbg(""this line is executed"");  // [example.cpp:23 (main)] this line is executed   factorial(4);   return 0; }   
Go 项目
  go-admin：基于 Golang 语言的数据可视化与管理平台。特性如下：  
 高生产效率：10 分钟内做一个好看的管理后台；
 主题：默认为 adminlte，更多好看的主题正在制作中，欢迎给我们留言；
 插件化：提供插件使用，真正实现一个插件解决不了问题，那就两个；
?认证：开箱即用的 rbac 认证系统；
??框架支持：支持大部分框架接入，让你更容易去上手和扩展。
Java 项目
  eladmin：基于 Spring Boot 2.1.0、
Vue
 的前后端分离的后台管理系统，支持数据字典与数据权限管理、一键生成前后端代码、前端菜单动态路由等。基于 Spring Boot2.1.0 框架，涉及的技术栈：非关系数据库 redis、接口测试工具 swagger、druid 数据源驱动、邮件依赖（javax.mail）、三方支付和云存储 SDK、页面模板引擎 freemarker。技术栈丰富，初学者可以作为实战项目学习和使用。   
JavaScript
  
chart-race-react
：一个简单易用的 Bar Chart Race（长条图赛跑动画） 
React
 组件。示例代码：  import ReactDOM from '
react-dom
'; import BarChart from 'chart-race-react';  ReactDOM.render(<BarChart />, document.getElementById('root'));   
Python 项目
  TagUI-Python：一个 Python 自动化操作的库。比如：自动打开网页并截图，示例代码：  t.init() t.url('
https://www.
google.com
') t.type('q', 'decentralization[enter]') t.snap('page', 'results.png') t.close()  
Ruby
 项目
  shift：一个 Ruby 语言写的在线 MySQL 数据库迁移工具。   
Swift 项目
  Percent：让 Swift 语言支持百分比类型，消除精度缺失的烦恼。示例代码：  import Percent  10% + 5.5% //=> 15.5% -10% / 2 //=> -5%  
其他
  cascadia-code：微软开源的一套
等宽字体
，有趣的是可以组合字符创建新的字形。组合效果如下：   
开源书籍
  python_ebook：Python 编程相关的电子书资源集合项目。  book：（英文）《Cosmic Python》讲述如何管理复杂性的 Pythonic 应用程序结构的书籍。  
教程
  BigData-Notes：大数据入门教程，该教程介绍了大数据常用技术栈的基础和核心知识。内容涵盖：Hadoop、Spark、Storm、HBase、Hive、
ZooKeeper
、Kafka 等。  
机器学习
  dimensionality_reduction_alo_codes：该项目使用 Python 实现了 11 种经典的数据抽取（数据降维）算法。同时附有相关资料、展示效果，适用于机器学习初学者和刚刚入坑数据挖掘的小伙伴。   
0x03 写在之后
  以上，就是今天分享的内容，希望更多的人能够知道 HelloGitHub 这个项目，内容已经在这了，万事俱备，差的就是你学习的驱动力和对作者 Star 的支持了。
原文：
编程初学者如何在GitHub寻找适合自己的小项目？
  作者：
Rocky0429
，来源：知乎
  ?? 看完有所收获？希望爱学习的你不要吝啬三连击哟[点赞 + 收藏 + 评论]","非常给力的 GitHub 从 0 开始系列，对新手友好~
从0开始学习 GitHub 系列之「初识 GitHub」
我是从小白一路过来的，很能理解你们内心的感受与困惑，因为这些阶段都是我自己亲身经历过的，所以我写的文章都会从你们的角度去出发，并且我对文章高要求，除了排版、配图很用心外，文章的内容每次写完我都会亲自看三四遍，确保不会出现误导以及你们理解不了的情况，你们看的很轻松易懂的文章其实因为我背后做了很多的功课。
从0开始学习 GitHub 系列之「加入 GitHub」
注册 GitHub
认识 GitHub
GitHub 主页
设置你的 GitHub
GitHub 基本概念
创建自己的项目
从0开始学习 GitHub 系列之「Git 速成」
GitHub 是基于 Git 的，所以也就意味着 Git 是基础，如果你不会 Git ，那么接下来你完全继续不下去，所以今天的教程就来说说 Git ，当然关于 Git 的知识单凭一篇文章肯定说不完的，我这篇文章先介绍一些最基本的、最常用的一些 Git 知识，争取让你们 Git 速成。
从0开始学习 GitHub 系列之「向GitHub 提交代码」
上一篇文章只介绍了对本地 Git 仓库的基本操作，今天我就来介绍下如何跟远程仓库一起协作，教你们向 GitHub 上提交你们的
第一行代码
！
SSH
生成SSH key
GitHub 上添加 SSH key
Push & Pull
提交代码
从0开始学习 GitHub 系列之「Git 进阶」
关于 Git 相信大家看了之前一系列的文章已经初步会使用了， 但是关于Git还有很多知识与技巧是你不知道的，今天就来给大家介绍下一些 Git 进阶的知识。
用户名和邮箱
alias
其他配置
diff
checkout
stash
merge & rebase
解决冲突
内容节选自：
SegmentFault 技术周刊 Vol.28 - GitHub ―― 你不得不上的交友网站","8本电子书免费送给大家，见文末！
今天给大家推荐几个GIthub上新手也可以很快掌握的项目，甚至有不需要任何技术的学习教程！
项目：
from_coder_to_expert
作者：
wangbojing
介绍：wangbojing整理了上百份的企业大牛内部pdf和PPT，包括不仅限于
新浪微博
redis优化历程、京东分布式K-V存储设计与挑战、阿里万亿级数据洪峰下的消息引擎、滴滴统一资源调度平台建设实践、百度基于Druid的大数据采集即计算实践、爱奇艺广告大数据实践、
腾讯优图
深度学习在图像审核的应用..........
等等等等尽在其中
把技术大牛作为自己职业生涯规划目标的你一定不能错过！！ 别忘
点赞、收藏
哦！
项目：
Student-resources
作者：ivmm
介绍：学生可以用其特殊身份享受到许多的福利，本项目作者汇总了各类学生身份可以享受到的优惠，包括GIthub学生包、Microsoft imgine学生包、AWS学生包、阿里云校园计划、
华为云
校园计划、百度云校园计划、购买苹果、微软大疆等产品也可以享受到优惠。
项目：
you-get
作者：soimort
介绍：身为一名自媒体运营或者电影、电视剧爱好者，这个项目就是一个神器，它可以帮助你下载并保存喜欢的视频，可以随时浏览的同时避免了广告的打扰。
项目：
getAwayBSG
：
作者：Jinnrry
介绍：以下为作者的自述：项目起因，大约2年前，我大学毕业时，初入社会，完全不知道要到哪里去。于是当时抓取了各个城市的招聘、租房数据，分享了各个城市哪里工作机会多，哪里租房便宜，哪里大企业多...大约半年前，又到毕业季，看见很多人跟我当初一样讨论薪资，租房相关的东西，于是我想起了当时的这个项目，然后翻出当时的项目，改了改，最终开源出来，希望给大家一些参考。爬虫抓取了目前抓到了18W+全国各个城市的招聘数据与200W+全国各地的房屋数据。租房和二手房数据，我使用了Colly框架，抓的链接租房和二手房页面。
总的来说对于刚毕业的小白这个项目时非常有用的！！！！
项目：
CS-Notes
作者：CyC2018
介绍
:技术面试必备基础知识、Leetcode题解、后端面试、Java面试、春招、秋招、操作系统、计算机网络、系统设计。
本文作者：yzn
配图来自GitHub相关项目、相关新闻报道、视频来源见文中、部分图片基于CC0协议，如有争议可联系。
↓ ↓ ↓以下8本书电子版免费领，直接送 ，想要哪本评论区说声，我小窗给你↓ ↓ ↓","即使作为编程新手，刚刚接触GitHub，也建议你从最简单的项目入手，而不是单纯研究大量理论。 
这个3000+ starts的优（宅）秀（男）项目：
komeiji-satori
/
Dress
就非常适合初学者
Pick
。
作为全球最大同性交友平台，这个项目里集结了大量的女装大佬。
而且，这应该是 
GitHub 最低准入门槛项目
了，就算不会写代码也都可以参加。你可以在这里学习 GitHub 的用法，从克隆项目、创建分支、提交和同步修改，到合并分支请求的整套流程，只需一次即可熟悉 Git/GitHub 的使用。 
当然，你还要事先准备至少一张你的女装照。
 好了，接下来分享一些正经的。
 基于这个项目，你就可以马上开始你的实践了。
第一步：打开官网
：
https://github.com
 注册一个帐户。
第二步：创建仓库
 填写仓库的名字和描述。
创建好了之后，点击“Branch master”，创建分支――在文本框中输入分支名称和描述，然后点击蓝色部分确认。
第三步：点击创建一个新文件
输入想要提交的代码以及下方的文件名和描述后，点击最下方的Commit new file即可。
第四步：修改&保存修改
在github上，提交&保存修改的操作是
commits
。每一次的commit都会被记录，可以被其他用户查看。
点击铅笔图案即可修改，修改后点击Commit changes即可。
第五步：提交Pull request
点击New pull request，选择你所做的分支，编辑你想修改的内容，经过与原来内容的对比，确认后提交请求。然后@特定的人或者团队，请求他们review，并反馈给你（还可以请求把你的代码加入他们的分支）。
第六步：合并修改历史
点击绿色按钮，将自述编辑合并到Branch master。
合并成功后可以删除该分支。
应用：
1、查看别人的代码or项目，给其点赞评论或关注
点击“gist""
然后选择“All gists”，可以查看别人写的代码。
蓝色框“commonts”、“stars”，可以评论或跟踪关注别人的代码。
2、clone别人的代码，修修改改，然后变成自己的代码
点击别人代码右上方的”forks”，然后点击“Embed”，选择Clone，即可克隆保存别人的代码。点击Download，可以下载他人代码到本地。
3、查看别人代码的修改历史
点击“Revisions”即可查看修改历史，以及修改前和修改后的对比。
当然，除了这些基础的功能之外，
GitHub
 更是一个强大的宝库，怎么发现宝藏，是有诀窍的。
寻找 Demo 节省时间
当我们在工作中需要快速掌握和使用新的技术，又没有太多精力从头开始学习，我们就可以在 GitHub 上寻找相应的 Demo，在简单了解原理、稍作尝试之后，引入到项目中。
你可以按照
技术栈的关键字搜索，并根据更新时间进行排序
，以查找是否有合适的 Demo。
寻找脚手架：加快前期开发
有时候，我们需要寻找一个合适的脚手架来帮助我们做出想要的东西，
这时候我们可以，直接使用技术栈 + boilerplate 或者 starter 等关键词进行搜索，如 
react boilerplate
。如果其中找到的组合技术栈不大符合自己的要求，那么再加上相应技术栈的关键字，如 
react redux boilerplate
 即可。
寻找 awesome-xxx：探索可能性
在Github上，有一些前人总结整理好的宝库，比如Awesome-xxx 系列。
只要有一定知识广度的领域、语言、框架等，都有自己的 awesome-xxx 系列的项目，如 
awesome-python
, awesome-iot, awesome-react 等等。在这样的项目里，都以一定的知识体系整理出来的，从索引和查阅上也相应的更为方便。如果你想学习一些新的东西，进入一个新的领域，那就搜索 awesome xxx 吧。
学习资源
GitHub 上拥有大量的学习资源，从各类文章到各种笔记，还有各式各样的电子书。如：
搜索： 类型 + 笔记，如 操作系统 笔记 就能找到一些操作系统相关的笔记。
搜索： 书名 就能找到一些和这本书相关的资源，如 重构 
改善既有代码的设计
。
GitHub 上还可以搜索到各种 
未经授权 
的英文书籍的翻译，或是各种电子书的 PDF 版。还有一些库，可以提供相应的学习资源，如 free-programming-books-zh_CN，即免费的编程中文书籍索引。
与此同时，Github上不乏简单的新手项目，实践练手再好不过
令狐老师的算法小抄
：刷题超过3000+的FB大佬令狐老师，在Github仓库里分享了一套自己爆肝整理的算法模板（Java+Python两种模板），新手都可以直接套用！近期还有更新新手编程必刷100题，非常适合入门级，但刷题又没头绪的同学。
ZKEACMS
：一个可视化设计的CMS系统（
内容管理系统
）。页面布局是可以直接在线设计，页面也是可以在线设计，编辑的，模板是可以直接在线编辑的，样式还可以可视化直接编辑，内容板块可以直接从现有板块中快速添加。是一个非常适合新手跟进的优质项目。
 textgenrnn
：一款基于 
Keras
/TensorFlow 的 Python 3 模块，可以用来创建字符级的
循环神经网络
。
JEESNS
：一款基于JAVA企业级平台研发的社交管理系统，依托企业级JAVA的高效、安全、稳定等优势，开创国内JAVA版开源SNS先河。数据库使用MYSQL，全部
源代码
开放。
 最后，祝你寻宝愉快~~
以上部分内容来源 
@phodal
 经作者授权发布
看完这个回答后，有两件小事，能帮助你快速提升自己哟：
免费试听
九章算法班
，前
FB高级架构师
、资深面试官
令狐冲
老师讲授。覆盖90%国内外一线大厂算法面试高频考点，帮助你1个月内搞定算法面试，横扫大厂offer。","1. Fork一份你想要做贡献的代码，修改后 Pull Request，等待主人审核通过。 
2. 用 Github写一个技术博客吧，这个没有什么难的，用git写博客很有 Geek范，不知不觉中，你就能熟练掌握git了。","咦，这题我会！
不多 BB，直接上干货！当初学了三个月就找到后台开发的工作，我练手的项目都来自这里！！
GitHub 标星 1.6w+，这个神级宝藏项目，作为编程新手有福了！！
以下是正文：
虽然我很早就知道 GitHub，但是学会逛 GitHub 的时间特别晚。当时一方面是因为菜，看着这种全是英文的东西难受，不知道该怎么去玩，另一方面是一直在搞 ACM，没有做一些工程类的项目，所以想当然的以为和 GitHub 也没什么关系（当然这种想法是错误的）。
后来自己花了一个星期看完了 Python 的基础知识，就想着找点项目看一看，学一学，练一练，这个时候我才真正的去了解 GitHub，开始了在 GitHub 的瞎逛之旅，在开始之初，随之而来的问题是我不知道哪些项目当时还是新手的我，哪些项目是好项目，哪些项目好玩有价值。
虽然现在我已经在 GitHub 上逛的相当流畅，但我还是想如果有一个东西可以收集这些对新手友好的东西，那么我当时可以少走更多的弯路，节省更多的时间吧。
那么有这么一个东西么？
有的，而且已经做了三年多，这就是
HelloGitHub
，一个分享 GitHub 上有趣，入门级的
开源项目
。
GitHub 网址：
https://
github.com/521xueweihan
/HelloGitHub
在项目中，内容每月 28 号以月刊的形式更新发布，主要是面向编程新手、热爱编程、对
开源社区
感兴趣人群的项目。更新的内容主要包括：各种语言的流行项目、入门级项目、让生活变得更美好的工具、书籍、学习心得笔记、企业级项目等。
这些项目都有一些共同的特征，那就是很酷，非常容易上手的项目，编程的魅力和便捷体验起来就是这么简单。
再次给出 GitHub 地址: 
https://
github.com/521xueweihan
/HelloGitHub
下面我们就来看看，这个项目具体包括啥，我们以最新的月刊（43 期）为例。
0x00 简介
0x01 目录
0x02 内容
每个类型的项目我们挑一个来看。
C 项目
tmux
：一个终端复用工具，可极大的提高工作效率。
提供了强劲的、易于使用的命令行界面；
可横向和纵向分割窗口；
窗格可以自由移动和调整大小，或直接利用四个预设布局之一；
可在多个缓冲区进行复制和粘贴；
可通过交互式菜单来选择窗口、会话及客户端；
等等。
C# 项目
BenchmarkDotNet：功能强大的用于基准测试 .NET 库。
C++ 项目
dbg-macro：打日志是 C++ 开发中必不可少的一种 debug 方式，
dbg-macro
 受 
rust-lang
 中 的 dbg 启发，提供比 printf 和 std::cout 更好的宏函数。主要有如下特点：
美观的彩色输出（当输出不是交互式终端时，颜色将自动禁用）；
兼容 C++11，并且是 header-only；
支持基础类型和 STL 容器类型的输出；
除了基本信息外，还输出变量名和类型；
启用 DBG_MACRO_DISABLE 生成 release 版。
#include <vector> #include <dbg.h>  // You can use ""dbg(..)"" in expressions: int factorial(int n) {   if (dbg(n <= 1)) {     return dbg(1);   } else {     return dbg(n * factorial(n - 1));   } }  int main() {   std::string message = ""hello"";   dbg(message);  // [example.cpp:15 (main)] message = ""hello"" (std::string)   const int a = 2;   const int b = dbg(3 * a) + 1;  // [example.cpp:18 (main)] 3 * a = 6 (int)   std::vector<int> numbers{b, 13, 42};   dbg(numbers);  // [example.cpp:21 (main)] numbers = {7, 13, 42} (size: 3) (std::vector<int>)   dbg(""this line is executed"");  // [example.cpp:23 (main)] this line is executed   factorial(4);   return 0; }
Go 项目
go-admin：基于 Golang 语言的数据可视化与管理平台。特性如下：
高生产效率：10 分钟内做一个好看的管理后台；
主题：默认为 adminlte，更多好看的主题正在制作中，欢迎给我们留言；
插件化：提供插件使用，真正实现一个插件解决不了问题，那就两个；
?认证：开箱即用的 rbac 认证系统；
??框架支持：支持大部分框架接入，让你更容易去上手和扩展。
Java 项目
eladmin：基于 Spring Boot 2.1.0、Vue 的前后端分离的后台管理系统，支持数据字典与数据权限管理、一键生成前后端代码、前端菜单动态路由等。基于 Spring Boot2.1.0 框架，涉及的技术栈：非关系数据库 redis、接口测试工具 swagger、
druid
 数据源驱动、邮件依赖（javax.mail）、三方支付和云存储 SDK、页面模板引擎 freemarker。技术栈丰富，初学者可以作为实战项目学习和使用。
JavaScript
chart-race-react：一个简单易用的 Bar Chart Race（长条图赛跑动画） React 组件。示例代码：
import ReactDOM from 'react-dom'; import BarChart from 'chart-race-react';  ReactDOM.render(<BarChart />, document.getElementById('root'));
Python 项目
TagUI-Python：一个 Python 自动化操作的库。比如：自动打开网页并截图，示例代码：
t.init() t.url('
https://www.
google.com
') t.type('q', 'decentralization[enter]') t.snap('page', 'results.png') t.close()
Ruby 项目
shift：一个 Ruby 语言写的在线 MySQL 数据库迁移工具。
Swift 项目
Percent：让 Swift 语言支持百分比类型，消除精度缺失的烦恼。示例代码：
import Percent  10% + 5.5% //=> 15.5% -10% / 2 //=> -5%
其他
cascadia-code：微软开源的一套等宽字体，有趣的是可以组合字符创建新的字形。组合效果如下：
开源书籍
python_ebook：Python 编程相关的电子书资源集合项目。
book：（英文）《Cosmic Python》讲述如何管理复杂性的 Pythonic 应用程序结构的书籍。
教程
BigData-Notes：大数据入门教程，该教程介绍了大数据常用技术栈的基础和核心知识。内容涵盖：Hadoop、Spark、Storm、
HBase
、Hive、ZooKeeper、Kafka 等。
机器学习
dimensionality_reduction_alo_codes：该项目使用 Python 实现了 11 种经典的数据抽取（数据降维）算法。同时附有相关资料、展示效果，适用于机器学习初学者和刚刚入坑数据挖掘的小伙伴。
0x03 写在之后
以上，就是今天分享的内容，希望更多的人能够知道 HelloGitHub 这个项目，内容已经在这了，万事俱备，差的就是你学习的驱动力和对作者 Star 的支持了。
作者：Rocky0429 
链接：
https://www.
zhihu.com/question/2161
2257/answer/928278410
 
再补充一下计算机的学习资源。
所以，如果是在校大学生的话，强烈建议在校期间好好学习计算机基础知识。
目前互联网公司技术岗招聘的时候主要考察两方面：
1、
计算机基础，即计算机原理、网络、算法、数据结构这些
2、
专业技能知识
在校招和社招中，这两者的比例会有所调整，大致上可以这么说，校招寻找的是那些基础好的同学，他们具备更强的可塑性，方便培养成为公司的骨干中坚力量，所以关于计算机基础的考察是重点；而社招寻找的是那些能快速干活的同学，他们能尽快的熟悉项目，能给公司带来收益，所以关于专业技能知识的考察是重点。
简单来说：
校招：
计算机基础（90%）+专业知识（10%）
社招：
计算机基础（20%）+专业知识（80%）
可以看出，无论是校招还是社招，计算机基础都是必考的内容，因为对于程序员来说，计算机基础就相当于是内功心法，而专业知识相当于外功，如果内功修炼的不扎实，那么很可能走火入魔，也就是
基础不牢，地动山摇
。
所以互联网公司在招聘的时候，往往在一轮二轮面试中重点考察计算机基础，比如笔试考察算法、计算机网络，面试问一下操作系统的知识点，如果说计算机基础掌握的不够扎实，那么基本上就一轮游，除非你的简历和专业知识能力十分的出众，让面试官觉得你很优秀，否则后面的面试环节和你无缘，也就拿不到 Offer。
并且，计算机基础这个能力是伴随着程序员的整个职业生涯的，它并非像高考时学的化学、物理、地理知识，高考结束后迅速忘掉，在程序员的工作中，计算机基础内容时刻出现。
比如设计一个简单的用户接口，需要实现以下的功能：
1) 获取用户基本信息接口   2) 获取用户列表接口   3) 用户分组管理接口  。。。
如果让你设计数据库，应该怎么设计信息存储权限？
如何你熟练掌握了各种数据结构的特点的话，那自然而然想到使用 
bitmap
 来存储权限，相反，如果你计算机基础知识不扎实，可能需要花一周时间却写十几个糟糕的接口。
我们把权限划分成最小粒度之后，每一个 bit 都它的含义， 例如我们把权限划分为以下几种：
获取你的头像、性别、昵称等基本用户信息
以你的身份发布微博
获取你的好友列表
获取你的朋友圈信息
每勾选一个选项，就代表着这个权限被授权，为了保证可扩展性，我们使用一个 uint64 来保存这些 bit ，也就是说，我们一共可以划分 64 种细分权限，然后对这些权限进行组合。
例如，第一个 bit 如果设置了，那么就代表可以获取你的昵称、头像、地区、性别等基本用户信息， 第二个 bit 如果设置了，就可以用你的身份发状态。
再者很多互联网大厂不喜欢培训出来的程序员，除了因为一些培训出身的程序员喜欢简历造假（一年工作经验伪造成三年工作经验），还有一个重要的原因就是他们的计算机基础几乎为零，只具备简单的 CURD 干活的能力，那么一旦业务中出现一些问题，他们很难站在更高的维度去发现问题、思考问题。
如果科班出身的计算机专业的大学生计算机基础都不扎实的话，那么是远远不如培训出身的程序员，最起码他们还具备干活的能力。
所以，在大学期间把绝大部分时间花在打好计算机基础上是很明确的一个选择。
但计算机基础的的确确比较难学，如何学习呢？
我这里强烈推荐一种学习方式：视频课程 + 看书。
初学者可以先通过视频入门，知道你学的那些东西是什么、怎么用，细节和进阶通过书籍、源码、文章、项目去完成，并且第一遍视频快速过完，后面的视频边看边思考，不要抄代码，作业可以隔天再写；同时多去尝试，减少路径依赖，时不时和视频里面的正确方案对着干，看看会发生什么，以及怎么处理。
零、开始
如果是对计算机一无所知或者不确定自己是否能走编程这条道路，那么我推荐你花 10 个小时看看《
计算机科学速成课
》，这套课程是 Crash Course 旗下的计算机科学相关的视频，早期发布在 Youtube 上，整个系列课程高达 12 亿的播放量，令人开心的是，你可以在 B 站上免费观看，有汉化！
Crash Course 的这套计算机科学视频一共 40 集，基本上每集控制在 10 分钟左右，所以，只要不到 10 小时就可以粗略了解计算机科学这门学科，如果你是一个门外汉，相信我，通过这个短短的 10 个小时足以帮你打开计算机的大门。
你可能会不禁疑惑，十几分钟能学到啥？而事实上，Crash Course 的视频信息量很大，每一秒的时间都是精华，视频里面不仅有图像、视频资料、图表等，更有老师面授，老师的语速也是很快的，如果跟不上，建议 0.75 的速度进行观看。
如果你是小白，想了解一门学科，不妨通过该系列视频作为切入点；如果你是某学科学生，可以用该视频梳理总结课程的框架结构；如果你想拓宽知识，这个系列视频作为下饭菜也是十分合适的。
Crash Course 的 Youtube 官方频道地址如下：
https://www.
youtube.com/user/crashc
ourse
B 站频道地址如下：
https://www.
bilibili.com/video/av21
376839
一、计算机组成原理
计算机组成原理介绍了计算机的基础知识，包括计算机的各子系统（运算器、存储器、控制器、外部设备和输入输出子系统等）的基本组成原理、设计方法、相互关系以及各子系统互相连接构成整机系统的技术。
1、书籍
《计算机是怎样跑起来的》
 
《程序是怎样跑起来的》 
《网络是怎样连接的》
这三本书是一套书，把构成当前社会基本组成单元的计算机、程序和网络，用最通俗易懂的语言，讲的清清楚楚。
对于编程来说，兴趣最重要，没兴趣，给你推荐再多的经典书都是白搭，所以学习计算机组成原理最好从这套书入门。
然后就是下面这些经典书了。
《Computer Organization》
《计算机组成与设计：硬件 / 软件接口》
 
《深入理解计算机系统》
 
《
计算机组成：结构化方法
》 
《计算机体系结构：量化研究方法》
我一直认为读书是世界上性价比最高的成长方式，书很便宜但分量很重，是让我们摆脱平庸走向卓越的方式之一。
对于计算机专业的学生而言，读计算机经典书籍不光能让你快速提升知识和能力，更会让你在校招之际如虎添翼。
书籍下载：
计算机必看经典书籍（含下载方式）
2、视频课程
1) 国外视频
视频则推荐伯克利大学 Brian Harvey 的 SICP 课程，
CS61A
。建议至少学完 SICP 的前三章，并把练习题做完。
CS 61A: Structure and Interpretation of Computer Programs
如果你觉得 SICP 的课程太难，可以选择 How to Design Programs。
How to Design Programs
还有两门课也很经典：
Harvard的CS50：
CS50: Introduction to Computer Science
 MIT的6.001：
mit-6.001
2) 国内视频
清华大学
刘卫东
老师的课程：
https://www.bilibili.com/video/BV1c4411w7nd
哈工大刘宏伟（135讲）
https://www.
bilibili.com/video/BV1t
4411e7LH
二、 计算机操作系统
无论你学习什么编程语言，和都避免不了和操作系统打交道，比如你学习 Java，用到多线程技术，实际上操作系统才是负责管理进程和线程的；比如你学习到内存分配的知识，c++里可以直接分配一段内存，此时实际上是调用操作系统提供的API进行内存分配。
如果不懂操作系统，你在未来学习编程语言的高级特效，涉及到线程进程调度，内存分配，或者是学习Linux相关的知识时，都会一头雾水，所以，只有学会了操作系统，那么才能够更好地学习其他语言和技术。
基于此，
计算机操作系统的知识点
频繁出现在笔试环节。 
1、书籍推荐
《现代操作系统》 
《操作系统导论》
《深入理解计算机系统》 
《
自己动手写操作系统
》 
《操作系统真象还原》
我一直认为读书是世界上性价比最高的成长方式，书很便宜但分量很重，是让我们摆脱平庸走向卓越的方式之一。
对于计算机专业的学生而言，读计算机经典书籍不光能让你快速提升知识和能力，更会让你在校招之际如虎添翼。
书籍下载：
计算机必看经典书籍（含下载方式）
2、视频教程推荐
1) 国外视频
MIT的操作系统公开课（
http://
pdos.csail.mit.edu/6.82
8
）。MIT自己基于Unix v6开发的xv6类Unix系统。除了没有视频，课表，作业，考试等都有。youtube上有第四讲以后的所有视频
https://www.
youtube.com/watch?
v=kDRHsNauoxk&list=PLfciLKR3SgqNJKKIKUliWoNBBH1VHL3AP
Udacity的Advanced OS公开课：
Advanced Operating Systems from Udacity
Coursera
上北大操作系统原理公开课（15年3月17日开课）：
Advanced Operating Systems from Udacity
2) 国内视频
《操作系统原理》，清华大学老师的课程，讲得很浅显易懂。
https://www.
bilibili.com/video/BV1u
W411f72n
《操作系统》，哈工大李治军老师，32讲
https://www.
bilibili.com/video/BV1d
4411v7u7
三、
计算机编译原理
首先正视一个问题：
编译原理并非随随便便就能入门的
！
换言之，需要准备一些基础知识在学习。
编译原理的学习和实践通常基于对计算机编译过程、
计算机基本工作原理
、甚至一定的数学知识有一定积累，这些知识分别分布并应用在了编译原理的不同阶段。没有这些基本知识的积累，很快就会在某个阶段由于功底不够而无法再继续后面的学习。
编译原理非常难，而且非常枯燥，需要要很强的功底才可以入门学习，所以，先认认真真的积累上述的一和二在入门学习吧。 
1、书籍推荐
《编译器设计-第二版》 
《编译原理》
书籍下载：
计算机必看经典书籍（含下载方式）
2、视频教程推荐
1) 国外视频
CS143: Introduction to Compilers
CS243 - Program Analysis and Optimizations
CS 343
https://www.
cs.cmu.edu/~410/
15-411: Compiler Design (Fa'12)
15-440/640, Spring 2015: Distributed Systems
2) 国内视频
《编译原理》，哈工大，81集
https://www.
bilibili.com/video/BV1z
W411t7YE
《编译原理》，东南大学，廖力老师主讲，全64讲
https://www.
bilibili.com/video/BV1c
W411B7DW
四、计算机网络
计算机网络的相关知识在工作时使用的频率还是挺多的，毕竟，所谓的CURD工程师总是在处理 API 相关的业务。
学习计算机网络，你需要懂得Socket编程，知道TCP/IP网络模型，了解OSI七层网络架构，知道一个数据包是如何层层包装，再层层拆包，从客户端发送到服务端。
计算机网络应该是除操作系统与算法之外，另一个面试常考的方向。
如果你短时间想学好计网八股文准备面试，那么可以看一下这份资料。
1、书籍推荐
 
《网络是怎么连接的》
 
《计算机网络-自顶向下方法》 
《图解HTTP》
书籍下载：
计算机必看经典书籍（含下载方式）
视频教程推荐
1) 国外视频
http://
www-net.cs.umass.edu/wi
reshark-labs/
https://
lagunita.stanford.edu/c
Stanford的CS144
2) 国内视频
《计算机网络》（
谢希仁
第七版）-方老师
https://www.
bilibili.com/video/BV1y
E411G7Ma
《计算机网络》，哈尔滨工业大学，李全龙老师
https://www.
bilibili.com/video/BV1U
p411Z7hC
 五、数据结构与算法
相信无论是已经毕业的同学还是正在学校学习的同学，都或多或少地被数据结构与算法这门课给折磨过。数据结构与算法这门课开篇就讲了一个非常重要的概念：
程序 = 数据结构 + 算法
，对于初学者可能还不能完全地理解这句话，不过对于已经工作两三年的同学相信对这句话是深信不疑的。
对于数据结构与算法的学习，我个人认为应该分层三个步骤：
1、首先先大致了解什么是算法，可以通过一些科普读物来入门，这个过程我称之为
入门阶段
；
2、接着可以尝试实现一些比较容易的数据结构和算法，这样可以更加深对数据结构和算法的了解，这个过程我称之为
实践阶段
；
3、最后去了解数据结构与算法背后的相关数学原理等，这个过程我称之为
原理阶段。
具体的学习过程可以阅读我之前的一篇收藏破 8w 的回答：
1、书籍推荐
入门系列
入门的同学，我建议你不要过度追求上去就看经典书。
不要一来就拿着
《算法导论》
开始啃，初学就去啃这些书肯定会很费劲。你一旦啃不下来，挫败感就会很强。
然后就放弃学算法了。
所以，入门的同学，我建议你找一些比较容易看的书来看，比如《大话数据结构》和
《算法图解》
。
不要太在意书写得深浅，重要的是能不能坚持看完。
《大话数据结构》 这本书最大的特点是，它把理论讲得很有趣，不枯燥。而且每个数据结构和算法，作者都结合生活中的例子进行了讲解， 能让你有非常直观的感受。
虽然这本书有 400 多页，但是花两天时间读完，应该是没问题的。
如果你之前完全不懂数据结构和算法，可以先从这本书看起。
《算法图解》 跟《大话数据结构》走的是同样的路线，就像这本书副标题写的那样，“像小说一样有趣的算法入门书”，主打“图解”，通俗易懂。它只有不到 200 页，所以内容比较少。
作为入门，看看这本书，能让你对数据结构和算法有个大概的认识。
当然，这些入门书共同的问题是，缺少细节，不够系统，也不够严谨。
所以，如果你想要系统地学数据结构和算法，看这两本书肯定是不够的。
基础系列
通过基本入门算法书的调教，你已经逐渐体会到了算法的魅力，现在正是时候踏入基础系列算法的领域！！！
这些书籍需要你费点心思去阅读。
很多同学在学习的过程中，看到一篇算法科普文章经常会有这样的想法。
哎呀，要是文章的代码是 Java 语言就好了呀。
哎呀，要是文章的代码是 Python 语言就好了呀。
虽然代码并不会很严重影响阅读，但还是有很多强迫症的同学喜欢看到文章的解释代码是自己擅长的。
我这里推荐《数据结构和算法分析》，这本书非常系统、全面、严谨，而且又不是特别难，适合对数据结构和算法有些了解，并且掌握了至少一门编程语言的同学。而且，这个作者也很用心。
他用了三种语言，写了三个版本，分别是：《数据结构与算法分析 ：C 语言描述》《数据结构与算法分析：C++ 描述》《数据结构与算法分析：Java 语言描述》。
面试实战系列
大家都知道，对于程序员来说很大程度上算法就是为了应付面试的。
所以，推荐三本有益于面试的书籍，分别是：《
剑指 offer
》
《编程珠玑》
《编程之美》。
《剑指 offer》这本书的目的非常明确，就是为了面试。
这本书几乎包含了所有常见的、经典的面试题。如果能搞懂这本书里的内容，应付一般公司的面试应该不成问题。
另外，我每天都在 B 站录制《
看动画图解剑指 Offer 系列
》，到今天已经坚持了半个月，目的也是为了能够帮助到校招和社招的同学，
让他们学会算法，进入心仪的大厂
。
我的 B 站地址：
https://
space.bilibili.com/2861
0170
相信我，基本上你看一遍就会觉得这道题目没什么难，觉得《剑指 Offer》也就那样，能坚持下去学习。
能坚持就能有好结果。
同时，我把《看动画刷剑指 Offer》整理成了 PDF 与视频版，大家可以免费领取，一起学好算法，进大厂。
《编程珠玑》这本书的豆瓣评分非常高，有 9 分。
这本书最大的特色就是讲了很多针对海量数据的处理技巧。这个可能是其他算法书籍很少涉及的。面试的时候，海量数据处理的问题也是经常会问的，特别是校招面试。不管是开拓眼界，还是应付面试，这本书都很值得一看。
《编程之美》这本书有多位作者，其中绝大部分是微软的工程师，所以书的质量很有保证。不过，这里面的算法题目稍微有点难，也不是很系统，这也是我把它归到面试这一部分的原因。如果你有一定基础，也喜欢钻研些算法问题，或者要面试 Google、Facebook 这样的公司，可以拿这本书里的题，先来自测一下。
书籍下载地址：
书籍下载：
计算机必看经典书籍（含下载方式）
（PS：感谢大家耐心的阅读，算法是程序员的重中之重，必须攻克，大厂面试必考，顺便送一份阿里大佬刷Leetcode总结的算法笔记，如果你能吃透，那我相信80%的技术面试都会不在话下：
BAT大佬写的Leetcode刷题笔记，看完秒杀80%的算法题！
 这本书的目录，非常经典：
视频教程推荐
 
1) 国外视频
Stanford: Algorithms
这门课由斯坦福大学计算机科学系教授Tim Roughgarden授课，适合至少掌握一种编程语言的编程学习者。斯坦福的课强调理论和概念上的理解。学完这门课后，对你今后面对技术面试时将会非常有利。
UCSD：数据结构与算法
Daniel M Kane、Pavel Pevzner等五位老师共同授课，这门课程的最大特点是理论和实践的结合，你将学习到解决各种计算问题的算法技巧，并实现大约100个算法编码问题。
Prin:Algorithms, Part I
Kevin Wayne和
Robert Sedgewick
共同授课，涵盖了有关算法和数据结构的基本信息，重点是Java实现的应用程序和科学性能分析。第一部分包括基本数据结构、排序和搜索算法。第二部分重点讨论了图形和字符串处理算法。
2) 国内视频
《数据结构》，浙江大学陈越和何钦铭教授联合授课，其大名在计算机领域可谓耳熟能详了。
https://www.
bilibili.com/video/BV1J
W411i731
《数据结构与算法C++版》，由由北京大学
张铭
教授等七位授课老师全力打造，国家
精品公开课
。
https://www.
bilibili.com/video/BV1R
741117bK
《数据结构》，武汉大学
李春葆
教授
https://www.
bilibili.com/video/BV1g
b411C71L
同时再推荐清华计算机系
邓工
的课：
算法面试的话可以提前看看这一份刷题笔记：
如果你还是感觉学习算法很吃力，可以借助这几个网站来辅助学习。
1、
https://
visualgo.net/en
目前网站支持中文，印尼文，日文等多语言版本。
2、
Data Structure Visualization
目前已经有很多常用的数据结构与算法的可视化，如：常见的数组、链表、队列、二叉搜索树、
红黑树
、各种排序等，如下图所示：
最后，再给大家送上点干货！
下面这是一个
高赞回答合集
，建议大家
点赞&收藏
，Mark住别丢了，
大学期间绝对用得上
。
1、怎么学好数据结构，看下面这个回答，已经获得了 
21000+ 的赞和 50000+的收藏。
2、如何系统地学习算法，看下面这个回答，已经获得了
 11000+ 的赞和 26000+的收藏。
3、新手该如何使用 GitHub，看下面这个回答，如果在大学期间就知道使用 GitHub ，那么能力远超同龄人。
4、想成为一名优秀的程序员，那么这些程序员平时都喜欢逛的论坛怎么说你也得收藏一些吧。
5、无论别人怎么说，我都是坚定不移的选择计算机专业。
6、如何系统地学习 C++ ，这个回答能帮你找到路线。
7、想要准备 Java 面试，那么这些面试题必须掌握。
赶紧点赞和收藏吧~","首先呢，非常感谢小伙伴的邀请。另外，下面这条留言确实也激起了我很大的写作兴趣，如下：
点赞人数还不少，这说明还真有不少工科生不会用 GitHub，你看大小写都没有区分（手动狗头）。所以我就很想借这个答题的机会，按照我自己的方式给广大的 GitHub 新手科普下，“
到底该如何使用 GitHub？
”
插个楼，
我这里有一份 GitHub 上星标 115k+ 的 Java 教程，里面涵盖了 Java 所有的知识点，包括 Java 语法、Java 集合框架、Java IO、Java 并发编程和 Java 虚拟机，内容不多，只讲重点。
01、GitHub 是什么
维基百科是这样定义的：
 GitHub 是通过 Git 进行版本控制的软件
源代码
托管服务平台，由 GitHub 公司的开发者 Chris Wanstrath、PJ Hyett 和 Tom Preston-Werner 使用 Ruby on Rails 编写而成。 
 
那 Git 又是什么呢？
再来看维基百科的定义：
 Git 是一个分布式
版本控制软件
，最初由
林纳斯・托瓦兹
创作，于 2005 年以 GPL 协议的形式发布，最初目的是为更好地管理 Linux 内核开发。
 
简单点说就是，Git 是一个命令行工具，一个分布式的版本控制系统。它可以在背后默默地帮你管理和跟踪代码的历史版本，就好比一个时光机，让你在代码出错时不至于手足无措，快速回退到之前的历史版本。 
想了解更多 Git 方面的知识，可以点击这个链接跳转：
https://
git-scm.com/book/zh/v2/
%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F
 
很多初学者误认为 Git 就是 GitHub，但其实不是的。GitHub 是一个代码托管网站，只不过背后使用了 Git 作为版本管理工具。主要服务就是将你的项目代码托管到云服务器上，而非本地硬盘上。类似的网站还有 
http://
gitlab.com
 和 
http://
gitee.com
（国内版，中文名叫码云）。
02、GitHub 可以做什么
 Do whatever you want.
 
上面这个答案是创始人之一 Chris Wanstrath 说的，我表示无法反驳。
1）托管代码
GitHub 会自动帮你记录代码的修改，在必要的时候，能够帮助你快速回退到之前的历史版本。
2）搜索
开源项目
GitHub 是世界顶级开发者的聚集地，在这里你几乎可以找到任何你想要的东西。上面分享有许多优秀、著名的开源项目，在遵守其 License 的前提下，你可以免费使用、下载这些开源项目。这也是 GitHub 最为吸引人的地方。
通过下面这个网址可以查看 GitHub 上 TOP 200 的优质开源项目：
https://www.
githubs.cn/top
 
其中就包含了我前段时间给大家推荐的 
GitHub 上最励志的计算机自学教程
：
中文版离线 PDF 下载地址如下所示：
https://
pan.baidu.com/s/1tOyMq3
sGa2-xuajGJJYwOQ
，提取码:om0i 
 
关于优质项目的搜索，你可能需要一些技巧：
https://
juejin.im/post/68910564
15440535565
 
你可能还需要一些方法：
https://www.
zhihu.com/question/2008
4458/answer/1368411995
 
3）使用 GitHub Pages 搭建一个免费的博客网站
GitHub Pages 提供静态网页托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，然后构建并发布网站。
配合 Jekyll、Hexo、Hugo、Pelican、Gridea 等第三方静态模板系统可以快速搭建一个漂亮的博客网站。比如说我的个人博客用的就是 Jekyll，访问地址如下：
http://www.itwanger.com
 
4）学习，提升能力
GitHub 有太多太多优质的教程资源，只要你肯去挖掘。下面这个网址列出来的资源都不错。
https://www.
githubs.cn/awesome
 
比如说面试和刷题：
下面这个网址列举了一些非常不错的书单：
https://
github.com/itwanger/Jav
aBooks
 
5）提升影响力
你可以将自己的开源项目发布到 GitHub 网站上，项目越受欢迎获得的 Star 越高，说明业界对你的能力越认可。一份优秀的 GitHub 主页，能为自己的简历润色不少。
我最喜欢的两个实战项目（推荐过无数次了），来自我的好朋友
江南一点雨
和 macrozheng。
微人事（19.2k star）的地址：
https://
github.com/lenve/vhr
 
电商系统（43.1k star）的地址：
https://
github.com/macrozheng/m
all
 
当你看到这么多 star 的项目，并且真的是名副其实的好项目，是不是就特别佩服它们的作者，实话实说，我既是他们的朋友也是他们的粉丝。
6）其他
图床，单纯地把 GitHub 做一个网盘。
BBS，单纯地交友互动聊天吹逼。
翻译，之前有阿里的朋友就利用 GitHub 重写了一本《
Java 并发编程
》，在线访问地址：
https://
github.com/RedSpider1/c
oncurrent
 
离线版的 PDF 下载地址：
https://
pan.baidu.com/s/11Z-IfA
PEZNFWp_mAtqDIKw
，提取码:drjx
 
03、注册 GitHub 账号
说了这么多 GitHub 的好处，还等什么，赶紧去注册一个 GitHub 账号吧！
https://
github.com/join
 
一个 GitHub 账号除了可以作为交友的名片，当然也可以用来登录一些英文的学习网站，比如说 
GeeksforGeeks
：
04、下载 GitHub 桌面版
当然可以直接在 GitHub 网页上操作，不过，对于新手来说，一个 GitHub 桌面版更方便、更直白、更傻瓜式一些。
https://
desktop.github.com/
 
05、创建新项目
我现在要写一个《教妹学Java》的专栏，需要一个仓库来存储代码，怎么做呢？
打开 GitHub 桌面版，选择「File」→「New Repository」。然后填写仓库名、简介，选择仓库存放的本地路径，就可以点击「Create Repository」 创建新项目了。
创建完成后，可以在网页端看到该仓库。
（咦，怎么刚创建就有 star 了？）
06、fork 项目
如果你在逛 GitHub 的时候，发现了一些不错的项目，想占为己有，那太方便了，只需要一个 
fork
 就能搞定。
前几天，我发现了一个很有意思的项目：
state-of-the-art
-shitcode，中文译作
垃圾代码书写准则
。不过，代码示例是用 JavaScript 编写的，并且中文翻译得很烂。
怎么办呢？fork 它，然后就可以重制成 Java 版，并且按照我的风格进行翻译。
07、克隆项目到本地
GitHub 的一个好处就是，它把项目存放在云端，当你需要的时候，只需要克隆到本地就可以了。
打开 GitHub 桌面版，选择「File」→「Clone Repository」。 可以直接克隆你账号下的项目，包括你创建的、fork 的、star 的。
也可以通过 URL 的形式进行克隆，这时候，还可以指定
码云上的项目
进行克隆。
08、编辑项目
建议你在电脑上安装 
Sublime Text
，一款颜值非常高的文本编辑器，安装成功后，GitHub 桌面版默认自动使用它来关联项目。
打开后，是这样的（见下图），不得不说，颜值真的高。
编辑一段文字后保存，可以在 GitHub 桌面版看到发生变化后的文件。
填写文件更改后的描述就可以点击「Commit to master」（GitHub 从 10 月份起将 master 更名为 main）按钮提交了。
点击「Push origin」 可以同步到 GitHub 云端仓库。
09、回退到历史版本
如果一不小心提交错了，怎么办呢？
点击「History」 面板，找到你要回退的历史版本，右键选择「Revert this Commit」。
再次点击「Push origin」就可以了。
10、同步云端
GitHub 可以多人协作，如果本地想和云端保持同步，可以在 GitHub 桌面版上点击「Fetch origin」
如果发现本地和云端有不一样的地方，就可以点击「Pull origin」 从云端拉取了。
11、还想进阶
通过以上这些基本操作，我想你一定会用 GitHub 了。
反正入门嘛，先不要去管 issue 啊、pr 啊、wiki 啊，能够迅速地通过实战得到反馈对于学习一门新的技能来说实在是太重要了。只要入了门，有了信心，你会爱上 GitHub 的。
如果你不满足于现状，还想更进一步，可以到 GitHub 官方按照课程进行学习。
https://
lab.github.com/
 
除此之外，我再推荐给你一本不错的入门书籍《
GitHub入门与实践
》：
我是 
@沉默王二
 ，码字不易，希望你们能够喜欢，如果能够对你起到一点点帮助，那就太好不过了！温馨提醒一点，记得让它躲进收藏夹吃灰哦，顺带点个赞就更好了，你最美你最帅！","相信很多人都和我一样，第一次接触GitHub，可能是因为某个大佬将软件安装包放在了GitHub上，我们想从上边下载软件。
但单下载还不够，我们还是希望把下载的地址收藏起来，这就要用到GitHub的关注或收藏功能，使用这两个功能之前，需要先注册一个Github账号。
Github账号注册分为三步，分别是设置账户、选择订阅和定制体验。
设置账户中，设置用户名需要比较慎重，因为如果你以后使用Github来搭建个人博客，用户名也会成为博客地址的一部分。
选择订阅这一步，你可以根据自己的需要，选择是否添加订阅，但对于大多数人来说，选择免费账户就可以了。
最后一步的定制体验，可能是Github想通过了解你的个人经历，为你推荐合适的项目或内容。如果你不想填写这些信息，可以直接底部的跳过此步骤。
Github注册地址：
https://
github.com/join?
source=header
注册完Github账号，第一次接触Github的朋友，可能会囿于网站使用的英文，折腾了半天，都不知道Github该如何使用，于是就把它关掉了。
但别急，不妨看看我第一次使用Github后，认为使用Github时，需要了解的5个基本概念。
这些Github基本概念，你要知道
① Repository
Repository译为仓库，你可以将它理解为文件夹，可以用来存放项目相关的文件。如下图，这里有两个仓库，分别是weblife和ecma6-adventures。
点击网页右上角的加号，可以新建或导入仓库。
新建仓库时，你需要设置仓库的名称、仓库的可见性，而对仓库的描述则不是必填项。勾选下方的使用README初始化仓库，则会在新建的仓库中生成一个README文件。
创建好仓库后，你可以点击Create new file按钮来书写代码，也可以点击README.md右边的编辑按钮，来对仓库的说明文档进行编辑。
仓库说明文档README，可以用来说明仓库的用途、代码运行环境等，编辑说明文档需要用到Markdown标记语言。
Markdown虽然被称为标记语言，但它不能算是一种编程语言。它可以通过简单的语法标记，使普通文本内容具有一定的格式。
由于Markdown的的轻量化、易上手等特点，许多人用它来写博客。
对Markdown有兴趣的朋友，可以查看Github给出的Markdown指引：
https://
guides.github.com/featu
res/mastering-markdown/
说完仓库相关的内容，我们再来看一下每个Github项目右上角都会有的三个按钮，Watch、Star和Fork。
② Watch
这里的Watch，就可以用来关注你感兴趣的仓库或资源，类似于各种App中的关注功能。
点击Watch按钮，里面有4个选项，对应4种不同的通知权限。
默认情况下，Watch是处于Not Watching状态的，如果你在Github上看到一个不错的仓库，想长期关注它的动态，那你可以选择切换到第二或第三种状态。
打开通知后，当仓库或资源更新后，你可以在账户的个人中心收到通知，如果你绑定了邮箱，那么你也可以通过邮件收到更新提醒。
③ Star
Star直译是星星，但这里理解为点赞或收藏更合适，它可以说是每个Github项目最重要的一个指标，因为Star数值越高，说明这个项目更有价值。
Star按钮只有两个状态，第一次点击即成功收藏，这时它会切换到Unstar状态，再次点击则取消收藏。
你收藏过的所有Github项目，可以通过账号头像的Your stars菜单进行查看。
除了查看自己Star的项目，你还可以查看大佬Star的项目，比如查看
阮一峰
老师Star的项目，因为大佬Star的项目，本身就经过了一次筛选，可以更方便地为我们找到优秀的项目。
④ fork
fork，原意是叉子，但在IT领域，它被译为复刻/派生。
当你看到一个不错的Github项目，除了可以将它收藏，还可以使用fork，将它拷贝到自己的仓库中。
这个功能，是为了方便你在他人分享的源码基础上，进行二次开发，创建不同的软件。
当你使用
fork
拷贝了他人的项目，你可以在仓库名称下方的小字，看到fork的来源。
⑤ Issue
在每个Github项目下，都会有一个Issue板块，你可以将它看成是一个讨论区或留言区。
点击右边绿色的New issue按钮，你可以提交软件漏洞、对项目提出自己的疑问等，而对于项目作者来说，可以通过Issue来收集用户的反馈等。
这里仅介绍5个我觉得刚使用Github时，需要了解的基础知识，关于Github的更多帮助，可以查看官方的帮助文。
它也有对应的中文版本：
https://
help.github.com/cn
 
以上，希望有帮助。
更多精彩内容，欢迎移步我的个人 blog：","其实挺不喜欢回答这类问题的，但是大概看了一下前排，上来就罗列了十几个图和步骤，实在觉得手痒痒。那人家都知道拿GitHub做代码库了，为什么还要告诉他到底怎么注册和创建仓库？要是这种问题，直接详情见
GitHub官方使用指南
不就好了！
不说自己编程多厉害，但好歹有个7年前端开发经验，我也可以罗列十几个高大上的项目给你，但我明知对你没什么用，我还是希望我的建议和总结能帮到更多的人。
首先，不得不实话实说，对新手来说，还是先不要一上来就为GitHub上的项目贡献，这堵南墙撞不好，只会撞碎自己的信心。
题主的疑问也代表了大多数新手在使用 GitHub的困境，本来满怀信心的在Github上搜索，结果找到的项目要么太复杂，要么就是死了，到最后一无所获。而我想告诉你一些新手使用GitHub应该知道的事，以及你该怎么做：
1、GitHub上的
大多都已经有了一套完整的结构，没有为新手量身打造的。
GitHub上的项目，本身就是为了解决某个特定的问题而存在。当你能碰到它的时候，他就已经是一副安全灵活的模样，背后有着无数代码和复杂的结构做支撑，如果你想要为他贡献一个特性，就意味着你需要去了解它整个是如何运行的，甚至要一些其他人贡献的关键点。如果你只是冒然的看见一个小问题解决，很可能会引出更大的问题。这对初学者来说，光是去了解的部分难度就很大。
2、多数项目的维护者并不乐意接受新人的代码
项目是完整的，但不是完善的，一个项目很可能有成千上万个未处理的pull requests。但这个问题就像家长教育孩子，它虽然是开放式的邀请大家来围观，可家长总不喜欢那些没什么权威的人来指手画脚。所以如果你发现了一个问题，还非常精心的贡献出一个修复方案，很可能被淹没在人潮之中。
我并不是说反对新手为项目做贡献，凡事都有第1次，只要你决定要从这个平台开始，那这些这些都是你必须要经历的。
相比于你参与完整的开源项目，我更建议新手在刚接触时先自己创建的项目。
这样你才能在一开始就把握住这个项目的生命周期，从想法到设计再到实现，真正的自己去走一遍这个流程，我刚开始就是自己敲了几个小游戏入门的。比起盲目的在别人的代码里迷失，不如在自己的项目里寻求突破，渐渐的你就会发现自己不再只是个新手。
那么你该如何创建自己的项目呢？
第1步：确定一个简单的问题
这个问题最好有普遍性，越多人的问题，代表着你的项目越容易成功。它并不需要是一个非常完整的程序，哪怕只是一个简单的小补丁，小游戏，都能让你体验到自己创建项目的乐趣。就像学习编程一样，你也需要花时间去熟悉Git的工作流程
第2步：
开始编写代码并推送到GitHub
你不仅是在学习编程，你也是在学习如何使用GitHub以及如何为开源项目做共享。诸如创建分支、了解push、pull、 rollback等，具体可以见：
创建一个公共存储库，并编写Readme.md文件，它是指描述你的项目内容，项目背景等信息，另外最关键的一点是，你必须要有一份能向人清晰的阐述项目路线的计划，因为没有人关注你。如果你在乎自己的时间和精力，你就该知道你在做什么
第3步：不断的完善突破自己的项目
记住一点，你写项目永远都在未完成的路上。你的项目究竟怎么样？都是用户来评判的可是github有成千上万的项目。所以你需要思考怎么样把自己的项目送到用户眼前，吸引更多的人来为你测评。然后你就会发现自己写的全是Bug，怎么办呢？当然是请其他人和你一起为这个项目贡献代码，一开始，这可能很困难，但是这一步一旦迈过去，你也可以成为一个成熟项目的维护者。
那个时候， 你就已经有了相当的经验，不再是被边缘化的新手，那么我完全鼓励你积极大胆的去为别人的项目做贡献。
最后，给题主推荐一篇关于自学的文章：
以及一个接有偿开发项目的平台――程序员客栈。
商务合作可私聊。","作为全球最大同性交友网站 gayhub 的资深用户，必须先吹一波，这里人才超多，讲话也很好听，就想混在这里生活这样子，里面有很多很棒的项目。有多棒呢，我拽着一个没用过GitHub 的同学就像他安利，连我11岁的弟弟都没放过，
scratch
做的游戏？给我传上来！
如果有看到这篇回答的乖乖还没开始用github的，请收下我暴躁又粗鲁的爱-github超全新手入门技巧
http://www.
runoob.com/w3cnote/git-
guide.html
接下来回答一下题主的2个问题
第一个问题：
“比如我看到一个有趣的项目，那么我该如何为这个项目做贡献呢？我是指，这个项目本身已经完整了，核心的一些架构我暂时是力不从心的，那我还能为这个项目做什么呢？”
有三个方法
1.你可以克隆别人的代码，自己改
点击别人代码右上方的 forks-Embed-Clone，即可克隆保存别人的代码。点击Download还可以下载他人代码到本地。
2.你可以评论、点赞别人代码，给出意见
3.你可以上传自己的代码，@你先要review的人，请求他们把你的代码加入分支
再回答题主下一个问题
“我看到很多刚学编程的人说用GitHub来学习编程，但我觉得大多数的项目即便你fork下来也是看不懂的吧？那么初学者如何找到适合自己的项目来学习呢？”
ok，在这里可以传授给题主一个小技巧。
awesome + xx
awesome这个单词表示的棒极了一类意思，如果你在Github中搜索awesome + xxxg关键词，你就能搜索这个关键词的资源大全，比方说：
awesome python
awesome go
awesome linux
你就会发现关于这些东西的学习资料真的是一大堆一大堆的。无论是书籍资源，库资源，还是学习视频、学习笔记，应有尽有。会了这个技能你再也不用到处求学习资源了。
比如说如果你还不够了解github如何使用，你可以搜索awesome github
还有一些小窍门！
比方说当你想采集某个网站的时候，你可以在Github里面搜「网站名称 +Scrapy」，如果搜不到可以搜「网站名称+采集」，还可以搜「网站名称+Python」等等。
如果你想做一个仿大众点评的App，那么你在Github上搜「仿大众点评」，你就能快速找到别人做的一个大众点评项目，拿来几乎可以直接用了，想一想这节省了你多少时间？
有时候你找不到，可能仅仅是你关键词弄得不对，记得换一换关键词，比如说英文搜索，拼音搜索，大多时候就能搜到了
整理不易 需要点赞来鼓励！～","如果你是一枚Coder，但是你不知道Github，那么我觉的你就不是一个菜鸟级别的Coder，因为你压根不是真正Coder，你只是一个Code搬运工。
但是你如果已经在读这篇文章了，我觉的你已经知道Github了。
正是Github，让社会化编程成为现实。
什么是 Github?
github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。
Github 由Chris Wanstrath, PJ Hyett 与Tom Preston-Werner三位开发者在2008年4月创办。迄今拥有59名全职员工，主要提供基于git的版本托管服务。
目前看来，GitHub这场冒险已经胜出。根据来自维基百科关于GitHub的描述，我们可以形象地看出GitHub的增长速度：
今天，GitHub已是：
一个拥有143万开发者的社区。其中不乏Linux发明者
Torvalds
这样的顶级黑客，以及Rails创始人
DHH
这样的年轻极客。
这个星球上最流行的开源托管服务。目前已托管431万git项目，不仅越来越多知名
开源项目
迁入GitHub，比如Ruby on Rails、jQuery、Ruby、Erlang/OTP；近三年流行的开源库往往在GitHub首发，例如：
BootStrap
、
Node.js
、
CoffeScript
等。
alexa全球排名414的网站。
注册账户以及创建仓库
要想使用github第一步当然是注册github账号了， github官网地址：
https://
github.com/
。 之后就可以创建仓库了（免费用户只能建公共仓库），Create a New Repository，填好名称后Create，之后会出现一些仓库的配置信息，这也是一个git的简单教程。
Github 安装
下载 git OSX 版
下载 git Windows 版
下载 git Linux 版
配置Git
首先在本地创建
ssh key；
$ ssh-keygen -t rsa -C ""your_email@youremail.com""
后面的
your_email@youremail.com
改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在
~/
下生成
.ssh
文件夹，进去，打开
id_rsa.pub
，复制里面的
key
。
回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便填，粘贴在你电脑上生成的key。
为了验证是否成功，在git bash下输入：
$ ssh -T git@github.com
如果是第一次的会提示是否continue，输入yes就会看到：You've successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。
接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。
$ git config --global user.name ""your name""
$ git config --global user.email ""your_email@youremail.com""
进入要上传的仓库，右键git bash，添加远程地址：
$ git remote add origin git@github.com:yourName/yourRepo.git
后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote ""origin""内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。
创建新文件夹，打开，然后执行 
git init
 以创建新的 git 仓库。
检出仓库
执行如下命令以创建一个本地仓库的克隆版本：
git clone /path/to/repository 
如果是远端服务器上的仓库，你的命令会是这个样子：
git clone username@host:/path/to/repository
工作流
你的本地仓库由 git 维护的三棵""树""组成。第一个是你的 
工作目录
，它持有实际文件；第二个是 
暂存区（Index）
，它像个缓存区域，临时保存你的改动；最后是 
HEAD
，它指向你最后一次提交的结果。
你可以提出更改（把它们添加到暂存区），使用如下命令：
git add <filename>
git add *
这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：
git commit -m ""代码提交信息""
现在，你的改动已经提交到了 
HEAD
，但是还没到你的远端仓库。
推送改动
你的改动现在已经在本地仓库的 
HEAD
 中了。执行如下命令以将这些改动提交到远端仓库：
git push origin master
可以把 
master
 换成你想要推送的任何分支。
如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：
git remote add origin <server>
如此你就能够将你的改动推送到所添加的服务器上去了。
分支
分支是用来将特性开发绝缘开来的。在你创建仓库的时候，
master
 是""默认的""分支。在其他分支上进行开发，完成后再将它们合并到主分支上。
创建一个叫做""feature_x""的分支，并切换过去：
git checkout -b feature_x
切换回主分支：
git checkout master
再把新建的分支删掉：
git branch -d feature_x
除非你将分支推送到远端仓库，不然该分支就是 
不为他人所见的
：
git push origin <branch>
更新与合并
要更新你的本地仓库至最新改动，执行：
git pull
以在你的工作目录中 
获取（fetch）
 并 
合并（merge）
 远端的改动。
要合并其他分支到你的当前分支（例如 master），执行：
git merge
 <branch>
在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现
冲突（conflicts）
。 这时候就需要你修改这些文件来手动合并这些
冲突（conflicts）
。改完之后，你需要执行如下命令以将它们标记为合并成功：
git add <filename>
在合并改动之前，你可以使用如下命令预览差异：
git diff <source_branch> <target_branch>
标签
为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 
1.0.0
 的标签：
git tag 1.0.0 1b2e1d63ff
1b2e1d63ff
 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：
git log
你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。
替换本地改动
假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：
git checkout -- <filename>
此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。
假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：
git fetch origin
git reset --hard origin/master
实用小贴士
内建的图形化 git：
gitk
彩色的 git 输出：
git config color.ui true
显示历史记录时，每个提交的信息只显示一行：
git config format.pretty oneline
交互式添加文件到暂存区：
git add -i
 
以上是简单的github的使用教程，如果有问题，欢迎留言咨询","平常主要做R语言项目的开发，在github托管自己的
，做了几个自己的开源小项目，但2年前我也是新手...
1. 积极地report issue或者参与讨论，发表经过思考的见解
2. 不必过于崇拜所谓「大牛」，都是普通人而已，抱着学习的态度，但也不要迷信权威
3. 不一定觉得自己有更好的实现方法或者什么才去贡献代码，发现任何拼错、minor issue也可以帮忙改正然后提交pull request
4. GitHub正所谓social coding，有一定基础后可以尝试着建立自己的开源项目，然后慢慢维护，基本可以了解清楚一般的基于git的管理流程
5. 在开发过程中，有几个里程碑：第一次有人star你的项目，第一次有人
你的项目，第一次有人给你的项目提出issue，第一次有人给你send pull request，这些都是很有意思的过程，可以体会到社区的无穷魅力。","下面请出被称之为镇站之宝的GitHub项目，号称百万码农的启蒙师，而且我敢保证，用这个项目学GitHub，你一点都不会痛苦，反而会很爽♂♂♂
镇站之宝：Dress。
总所周知，GitHub是程序员分享技术、同性交友、女装的圣地。 毕竟自学编程太苦了，不如~
我随便从这个项目中里面给大家截两张图，让你们感受一下女装大佬的威力~  
建议双手打字评论，以证清白
（老板要是发现我上班时间在看这张图片，一定会锤死我，别忘记双击屏幕救救孩子。）
言归正传，其实这个项目的本意是帮助不懂编程，非程序员的朋友学习使用GitHub。
且并不要求你贡献代码，人人都可以参加。可以从这里学习从克隆项目，创建分支，提交和同步修改，到合并分支请求的整套流程，一次即可熟悉 Git/GitHub 的使用。
而且非常的有趣味♂，看着其他人的女装照片，没准不光能学到GitHub的使用，更能找到未来的男朋友♂
为此其中一位大佬专门在B站录制了教学视频，来帮助更多的同学学习GitHub的正确使用方式。
视频资源加载失败
 别忘记点赞收藏后，去体验一下分布式女装~
项目地址：
https://
github.com/komeiji-sato
ri/Dress
 （自备营养快线）
然后，你会发现GitHub的真面目：
文字版教程：
作者：
杨晓辉
，
https://www.
zhihu.com/question/2007
0065/answer/117017972
前言
鉴于网上目前的教材都太落后，github for windows已经更新了多个版本，好多界面都发生了变化，所以来写这个教程。目的是为了帮助和我一样初学github，但是苦于找不到教程的同学，为了写最详细的教程。配备了大量的图文介绍。该教程是基于
GitHub for windows (3.0.17.0)
（万字长文警告，先点赞收藏再看，以免后续找不到~）
注：
由于教程为 3.0.17.0 ，之后github对客户端进行了新版的更新，这里的图为新版与旧版对比。希望可以给大家带来帮助。
一、
什么是Github
说到什么事github，我们先看wikipedia的描述“
GitHub是一个利用Git进行版本控制、专门用于存放软件代码与内容的共享虚拟主机服务。它由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。
”
准备工作
下载
github for windows
，安装这里不赘述。
注册github账号
登陆到github for windows。
准备工作都完了，我们开始正式学习。^_^
二、
创建第一个代码库
1、认识界面
github for windows的界面非常清爽，的确符合geek的性质，个人表示非常喜欢。 我们来建立第一个仓库，点击左上角的
+号
，初次建立他会有一圈圈的涟漪，非常漂亮哦。
 打开之后有三个选项，
Add
，
Create
，
Clone
。  我们分别来介绍一下这三个功能。
2、Add功能
如果本地有工程，就可以使用Add添加 
3、
Clone功能
这个功能其实最好理解了，克隆这名字通俗易懂好理解。 如何使用Clone功能呢？  就是将在浏览器上已经创建好的项目导入到本地，换句话说就是下载到本地。
4、
Create功能
创建一个代码库， Name填写你的仓库名字。Local path写你将要保存在本地路径。
我们主要从这个功能开始github之旅。  我们在这里填写First，来创建第一个我们自己的repoeitory。 
三、
开始使用第一个代码库
修改第一个代码库中内容
我们来找到刚刚创建的代码库在本地的位置。就是刚刚在local path的地址路径，当然如果你忘了，请右键点击First。
选择Open in Explorer。这样我们就可以转到刚刚的路径下。 我们新建一个文本文档。在里面编辑。 如下
此时的github就会变成这个样子(Changs)：
你会发现此时github会出现刚刚编辑的内容。
这个是测试文本
你好  
并且前面会有
蓝色标识
，那么这个
蓝色标识
是什么用呢？ 
其实这个蓝色标识是提示你会上改变的文本。比如我第一次只想改变 
这个是测试文本
并不想把
你好
上传。 这时我们点击一下
你好
的前面的
蓝色标识
。
你会发现
你好
前面的蓝色标识没有了。 
我们填写好
Summer
和
Description
 Summer就是这次改动的总结，我们也可以理解为标题*（必填）
，而Description可以理解为详细概况
（选填）*
我们这里只选择第一个修改对象，也就是
这个是测试文本
就行修改。summer我们填写为
第一次修改
，Description我们填写为
增加了这个是测试文本
的内容，之后点击
Commit to master
。 
切换到
History
目录下  我们会发现他改变了。 这次我们把
你好
进行添加。
在
History
目录下发生了这样的改变。会在
History
目录下形成一天时间线，来指出每一次的修改标题和内容，同时会把修改的内容用
绿色标识
标出。 我们打开本地的文本，删除刚刚添加的第一行
这个是测试文本
。
此时你就会发现github发生了变化。  此时的
红色标识
标识删除。我们写好Summer和Description并点击Commit to master。 这样我们就删除了第一行。同时在
History
目录下又多了一条时间轴。 
这样我们就完成了删除。
四、
上传与同步
上传
此时，当我们打开github网页，就会发现此时你的修改的内容并没有出现在这里。这是因为你没有进行同步，仅仅是在本地就行了修改。此时我们仅仅需要点击右上角的
publish
此时你就会本地内容已经上传到网页上。 
同步
当你的代码库上传后就会发现，原来的
publish
以及变为了
Sync
。  点击
Sync
同步代码库！
五、
分支的使用
1、创建分支
我们创建第一个分支取名为
new masterh,
点击
Create new branch
创建第一个分支
。
我们发现此时的分支已经切换到了我们刚刚创建的分支
new masterch
 。
我们来修改
new masterch
分支上的内容。 我们仍旧打开
FirstDemo.txt
进行编辑。输入以下内容
创建的第一个分支。
打开github进行，填写
Summary
和
Description
之后我们点击
Commit to new-master
在
History
目录下，我们可以看到会有两条主线，分别是
master
和
new-master
并且在
new-master
的分支下又一个蓝色的
实线空心圈
和一个
虚线空心圈
。
实线圈
表示当前的节点，
空心圈
表示下一次修改时的节点。
红线
标示的部分就是当前的分支 
2、切换分支
点击
红色
划线部分就会出现分支的列表 
我们点击
master
就会切换到
master
分支。
3、上传/同步分支
这个操作和同步仓库是一个操作，点击
Publish/Sync
上传或同步分支。
4、删除分支
首先要把分支切换到你要删除的分支下，如我们要删除
new master
，将分支切换到
new master
点击右上角齿轮就会出现
Delete new master
 点击
Delete new master
就会弹出一个对话框，询问删除的内容。
第一个
yes ，Delete both
是将本地与网页全部删除；
第二个
Delete local only
仅仅是删除本地。
第三个是取消。
5、合并两个分支
将一个分支与
master
分支进行合并。 我们首先把分支切换到
master
下，点击
Update from new-branch
进行分支的合并。
此时我们查看
history
目录下就会 
六、
团队协作流程
1、认识Flow
GitHub Flow
是一个轻量级的，基于分支的工作流程，支持团队和部署在那里的定期做项目。 
2、为团队成员写入权限
在我们的队友添加一个写的权限，这样我们的队友才能很好的修改代码。 我们打开网页上的
GitHub
,点击
settings
, 
之后我们找到
collaborators
，这里会让我们验证密码，之后就有添加合作者的选项。
这样我们就能添加我们的小伙伴了！
新的小伙伴有着同样的权限去修改和管理代码。 此时我们就会看到我的小伙伴wevan的github主页上就会出现关于我创建的First的各种通知。 
3、创建分支
在我们创建一个叫
add new function
的分支。
创建一个分支 
Create a branch
 当你工作的一个项目，你会在任何给定的时间有一堆不同的功能或正在进行的想法 - 其中一些是蓄势待发，而另一些则不是。分支的存在是为了帮助你管理这个工作流程。
 
When you're working on a project, you're going to have a bunch of different features or ideas in progress at any given time C some of which are ready to go, and others which are not. Branching exists to help you manage this 
workflow
.
 
当您在项目中创建一个分支，你创造一个环境，在那里你可以尝试新的想法。你让一个分支的更改不会影响主分支，让你可以自由进行实验，并提交更改，在你的分支将不会被合并，直到它准备好知识安全的人所正在与合作进行审查。 
When you create a branch in your project, you're creating an environment where you can try out new ideas. Changes you make on a branch don't affect the master branch, so you're free to experiment and commit changes, safe in the knowledge that your branch won't be merged until it's ready to be reviewed by someone you're collaborating with.
 
ProTip 
分支在Git中是一个核心概念，整个GitHub的流量是基于它。这里只有一个规则：在任何主分支总是部署。
 
Branching is a core concept in Git, and the entire GitHub Flow is based upon it. There's only one rule: anything in the master branch is always deployable.
 
正因为如此，这是非常重要的一个功能或修复工作时，你的新分支关老爷的创建。您的分支名应该是描述（例如，重构的身份验证，用户的内容缓存键，使视网膜-化身），以便其他人可以看到正在处理。
 
Because of this, it's extremely important that your new branch is created off of master when working on a feature or a fix. Your branch name should be descriptive (e.g., refactor-authentication, user-content-cache-key, make-retina-avatars), so that others can see what is being worked on.
来自GitHub Flow
4、添加提交
我们首先把分支切换到新的分支上
add new function
修改新的版本
填写好新的
Summary
和
Description
，提交新的版本并同步。 这样小伙伴登陆到
GitHub
上就看到了就可以清楚的看到一切的修改。
添加提交 
Add commits
 一旦你的分支已经建立，现在是时候开始进行更改。无论何时添加，编辑或删除一个文件，你作出承诺，并将其添加到您的分支。提交加入这一过程保持你的进步轨迹，你在一个特性分支工作。 
Once your branch has been created, it's time to start making changes. Whenever you add, edit, or delete a file, you're making a commit, and adding them to your branch. This process of adding commits keeps track of your progress as you work on a feature branch.
 
还承诺创建工作的透明历史，其他人可以按照理解你做了什么，以及为什么。每次提交都有一个关联的提交信息，这是解释为什么一个特定的变化作出了说明。此外，每次提交被认为是变革的一个独立单元。这使您可以回滚的变化，如果发现错误，或者如果你决定在一个不同的方向前进。
 
Commits also create a transparent history of your work that others can follow to understand what you've done and why. Each commit has an associated commit message, which is a description explaining why a particular change was made. Furthermore, each commit is considered a separate unit of change. This lets you roll back changes if a bug is found, or if you decide to head in a different direction.
 ProTip
提交信息是重要的，特别是因为Git跟踪更改，然后将它们显示为承诺一旦他们推到服务器。通过字迹清晰提交信息，你可以更容易为其他人跟着，并提供反馈。 
Commit messages are important, especially since Git tracks your changes and then displays them as commits once they're pushed to the server. By writing clear commit messages, you can make it easier for other people to follow along and provide feedback.
来自GitHub Flow
5、打开一个pull请求
这个是整个流程中比较关键的一步，发布
Pull Request
。
点击客户端或者网页上的
Pull Request
发布。 我们这里点击
Pull Request
我们填写好必要的说明性文字 点击
Send Pull Request
 他既然让我们到GitHub上看，我们就听他的，点击，进入。 
我们发现小伙伴已经在下面留言了！
6、讨论和审核你的代码
你的小伙伴开始对你的代码讨论，修改，迭代。
讨论和审查你的代码 Discuss and review your code 一旦拉入请求已被打开，人或团队审查您的变化可能有疑问或意见。也许编码风格不匹配项目的指导方针，改变缺少单元测试，或者也许一切看起来不错，道具都是为了。引入请求旨在鼓励并捕获这种类型的对话。
 Once a Pull Request has been opened, the person or team reviewing your changes may have questions or comments. Perhaps the coding style doesn't match project guidelines, the change is missing unit tests, or maybe everything looks great and props are in order. Pull Requests are designed to encourage and capture this type of conversation. 
您还可以继续推送到你的分支在你提交的讨论和反馈光。如果有人评论说，你忘了做某件事，或者如果在代码中的错误，你可以在你的分支修复它，推高的变化。GitHub上会显示新的提交和其他任何意见，你可能会收到统一拉请求视图。 You can also continue to push to your branch in light of discussion and feedback about your commits. If someone comments that you forgot to do something or if there is a bug in the code, you can fix it in your branch and push up the change. GitHub will show your new commits and any additional feedback you may receive in the unified Pull Request view.
ProTip 
拉请求的意见都写在降价，所以你可以插入图片和表情符，使用预先格式化的文本块，等轻质格式。 
Pull Request comments are written in Markdown, so you can embed images and emoji, use pre-formatted text blocks, and other lightweight formatting.
7、部署
部署 Deploy 一旦你拉的请求进行了审查和部门通过你的测试，您可以部署您的更改，以验证他们的生产。如果你的分支造成的问题，您可以通过部署现有的主投产回滚
 Once your pull request has been reviewed and the branch passes your tests, you can deploy your changes to verify them in production. If your branch causes issues, you can roll it back by deploying the existing master into production.
8、合并
合并分支我们之前已经说过，这里就不再赘述。
合并 Merge 现在，您的更改在生产中得到了验证，现在是时候你的代码合并到主分支。
 Now that your changes have been verified in production, it is time to merge your code into the master branch. 
合并后，引入请求保护的历史变迁到您的代码记录。因为他们是搜索的，他们不让任何人回去的时间理解为什么以及如何决定了。
 Once merged, Pull Requests preserve a record of the historical changes to your code. Because they're searchable, they let anyone go back in time to understand why and how a decision was made.
ProTip 
通过将某些关键字到您的拉请求的文本，你可以用代码相关联的问题。当你拉入请求合并，相关问题也将被关闭。例如，输入短语关闭＃32将关闭在仓库中发行数量32。欲了解更多信息，请查看我们的帮助文章。
 By incorporating certain keywords into the text of your Pull Request, you can associate issues with code. When your Pull Request is merged, the related issues are also closed. For example, entering the phrase Closes #32 would close issue number 32 in the 
repository
. For more information, check out our help article.
基本的一些用法就完成了。看着这个操作一遍基础就差不多了。
在上述的几个教程里讲解了一些Github的基础使用，现在开始讲解一些使用技巧。
1、查找内容
在github页面上是没有搜索的按钮，如何搜索呢。 在网页上按
T
就会出现。  这样我们就能很方便的查找到我们需要的代码了。
2、评论小表情
常常在
版本描述
或者
pull request
时我们需要对伙伴的代码进行一下评论与说明，光是文字有点很死板，其实github给我有
emoji
，如何使用呢？其实很简单，只需要
冒号
就可以 ：
这样我们就可以看到emoji表情，当然默认会显示五个常用的，你也可以继续敲下emoji的名字，出现更多（
这里有所有的表情
）。 
3、忽略不想上传的文件
有些在github中的文件我们是不想上传的，我们如何过滤掉它们呢？ 在github中对不想上传的文件点击右键。就会出现下面选项。 
Ignore file
忽略这个文件 
Ignore all.txt files
 忽略所有的以.txt结尾的文件 这样就可以过滤掉你不想上传的文件
4、搜索项目
如何高效的搜索一个你想要的库呢？ 我们常常评判一个项目的标准有star数目，fork数目和跟新时间。 通过搜索命令
stars
stars:>1000
表示star数目大于1000。
fork
fork:>1000
表示fork数目大于1000。
5、语言搜索
java，html等等
综合一下就是，比如你要查找一个stars大于1000的，fork大于200的java代码。
stars:>1000 fork:>200 java
就是这样。
6、查看项目中的语言类型
一个项目中，可能使用了多种语言，我们如何一下子就能看到一个项目使用了什么语言？其实很简单，Github已经为我们统计好了。
也行你注意过，但是没有发现它有什么用。
点击下面的彩条
github已经为我们统计好这个项目所有的语言及其比例。
完工~ 建议你收藏后按着流程完全尝试一遍哦~","1, 每个项目作者一般都会在README文档中有一项 `contribute`,这里面会说明你应该怎样贡献代码或者其它东西. 另外,为一个项目做贡献不一定要直接贡献代码才算,可以检查项目的文档错误,或者在对整个项目有了解的情况下,给项目作者提 `
feature request
`
2, 用github来学习编程,这个我确实还没有发现应该怎么好好利用,我觉得最主要的原因就是这里面所有的代码都是可以直接获取到的,而且带有代码作者的提交记录,如果感兴趣的话,你可以一个commit一个commit的查看作者写成整个项目的过程,这个应该会对初学者有很大的帮助吧,可能会对为什么整个项目是现在这个架构或形式有一定的了解.
我用github的时间也不是很长,大约一年. 对github的认识就是, 它就是一个大宝库,想要的任何东西几乎都可以在github上找到.
我使用github是从关注一些人开始的.通过这些人的 star fork follow 活动,我就可以知道一些我没有follow过的人,然后我再去看这些我没有看过的人的项目,然后我又发现了一些有趣的项目,我觉得这个作者 对我很有帮助,所以我follow一下,不断的通过这种 follow项目作者的行为,我知道了非常多的人.同时也找到了非常多有意思的项目.
每天看这些人的star fork follow活动,你真的可以知道现在的技术趋势是朝向什么方向发展的,或者这一段时间什么项目最火.
如果对某个项目有兴趣的话,可以直接clone下来,看一看代码的整体是什么样的,不一定完全看懂,但是看多了,就知道大牛们大体都是怎么写代码的.对自己的好处不言而谕.
我使用github和别人协作的机会没有多少,基本都是我自己在用,存放自己的一些项目.
再一个作用就是存放自己的配置文件了,到重装系统或者到其它的机器上,直接
clone
一下,自己的配置就全部回来了.
还有一个作用就是
托管博客
了, github的 
jekyll
 很好用,也很省心.","本文千字文，从介绍开始到如何快速在GitHub上写东西，适合小白玩转GitHub。
一、认识
GitHub
和Git
课程：
GitHub是一家公司，位于旧金山，由 Chris Wanstrath, PJ Hyett 与 Tom Preston-Werner 三位开发者在2008年4月创办。
2008年4月10日，GitHub正式成立，地址：How people build software ・ GitHub ，主要提供基于git的版本托管服务。一经上线，它的发展速度惊为天人，截止目前，GitHub 已经发展成全球最大的开（同）源（性）社区。
GitHub提供基于git版本托管服务，也就是git是GitHub上用来管理项目的一个工具。
二、如何快速在Github找到我们想要的东西
来源：CSDN实验楼
在GitHub上面有：
开源项目
多人协作
可以搭建博客、个人网站或者公司官网
多角度个人简历>>很多人刷星星
高级条件组合（精确搜索）
in：readme 微服务 stars:>1000

in：readme spring security stars:>3000

 

in：name python            #在名字中包含python的项目

in：name python  stars:>5000        #过滤喜欢数

in：name python  stars:>5000   forks:>5000

 

in：readme python stars:>1500

in:description 微服务 language:go pushed:>2019-10-01             #在描述中限制

in:description 爬虫  language:python  stars:>1000  pushed:>2019-10-01
三、如何学习开源项目
全球顶级科技公司纷纷加入 GitHub ，并贡献他们自己的项目代码
Google: 
https://
github.com/google
苹果: 
https://
github.com/apple
Facebook: 
https://
github.com/facebook
Twitter：
https://
github.com/twitter
微软：
https://
github.com/microsoft
Square：
https://
github.com/square
阿里：
https://
github.com/alibaba
…
全球顶级开源项目都优先选择在 GitHub 上开源
Linux：
https://
github.com/torvalds/lin
ux
Rails：
https://
github.com/rails/rails
Nodejs：
https://
github.com/nodejs/node
Swift：
https://
github.com/apple/swift
CoffeeScript：
https://
github.com/jashkenas/co
ffeescript
Ruby：
https://
github.com/ruby/ruby
…
如果想要学习干货：知识点+笔记+书名
GitHub 上拥有大量的学习资源，从各类的文章到笔记，还有各式各样的电子书。如：
只需要搜索： 类型 + 笔记，如 操作系统 笔记 就能找到一些操作系统相关的笔记。
只需要搜索： 书名 就能找到一些和这本书相关的资源，如 重构 
改善既有代码的设计
。
四、如何在git上发布内容
注册：
创建仓库：
进入仓库：
创建完什么都没有，会提示create一些东西：
然后就是安装git工具：
安装步骤跳过了哦，大家安装完之后---cmd命令行---win+r回车
第二步：将本地仓库和
远程仓库
对应起来
命令：git remote add origin huguangcheng/git-
git remote add 远程仓库名（可以自己定义，默认是origin，初学不要乱改，以免混淆） 远程仓库地址（在这里我填的是我之前建的仓库的地址）
远程仓库的地址，我们回到github的官网，到你的仓库里新建的仓库去：
把这个地址复制，就是你远程仓库的地址
命令回车之后，git就知道你本地这个项目仓库对应的就是github上的那个仓库了
第三步：上传项目或者代码到远程仓库
上传到服务器需要三步曲：
git add . -------------添加所有的文件到缓存区
git commit -m ""备注"" ------------将缓存区的所有改动都给提交到本地仓库管理中心去
git push -u origin master ----------将本地所有改动提交都推送到远程仓库
master是github远程仓库分支（master是默认的主干，自己就是一条分支）
完整详细内容：
手把手带你入门github","GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。
Git是一个开源的
分布式版本控制系统
，可以有效、高速地处理从很小到非常大的项目版本管理。
简单来说，Git可以让你快速高效的对版本进行控制（修改）等功能。而GitHub正是使用了这个功能实现了更好的共同完成项目的功能。
当你下定决心想要使用GitHub的时候，关于git的知识是一定要理解的。
首先需要安装git
官网中对于git的安装描述得很清楚，无论你是什么操作系统。
官网链接：
git官网
关于git的知识我们先不进行详细的说明，会在下面回答你的问题的同时将需要用到的进行讲解。最后再详细说git的使用。
更多名企笔试真题解析、面试经验交流、招聘信息内推，尽在牛客！
求职之前，先上牛客！快快下载拿offer！
对项目做出贡献
如何对项目做出贡献。这就是我们经常会听到别人说的PR，当然这个pr不是编辑视频的那个，是Pull 
requests
。在每个GitHub的仓库中你都可以看到这一栏。如图
PR的具体使用：
首先你要找到你想做出贡献的仓库，先把这个仓库fork到自己的GitHub账号中
fork
完成之后，在你的仓库中会有一个跟它一摸一样的仓库。如果需要修改的地方比较少，你可以直接在GitHub中对文件进行编辑，但是如果你需要修改的比较多，你可以把仓库先拉取到本地修改完成后再上传到GitHub。
拉取到本地：
首先你需要将你的电脑和GitHub进行SSH验证。
打开刚才安装好的git
在命令行内输入
git config --global user.name ""Your Name""
git config --global user.email ""email@example.com""
--global参数表示你这台机器上所有的Git仓库都会使用这个配置。这个就是告诉git你的信息，简单点说就相当于你的账户名一样。
在git中输入
ssh-keygen -t rsa -C ""邮件地址""
 这里面的邮件地址就是你注册github用的邮箱地址 接下来就是按回车，大约按三次回车就可以了。然后找到C:\Users\你的用户名\.ssh\id_
rsa.pub
的文件，用记事本或者各种
文本编辑器
打开。把里面的内容复制下来。在github中找到setting->SSH and GPG keys 然后点击New SSH key,把你刚才复制下来的内容粘贴到key里面，title随便写一个就行,填写之后点击Add SSH key就可以了。至此，SSH配置完成。
在gitee或coding中进行SSH的配置跟这个也一样
ssh配置成功之后，你就可以把仓库拉取到本地了。找到你想存放代码的文件夹，在这下面的git命令行中输入
git init
git remote add origin url
git pull origin master
git remote add origin后面的url就是这个
你可以用Https的也可以用SSH的，但是SSH会快一点。
当你在本地已经将想要修改的修改完成后，在git中输入
git push -u origin master
-u
这个参数就是将你拉取到本地的仓库和远程仓库连接起来，只有第一次提交的时候需要有，以后再提交的时候可以不填这个参数。
当你修改完成后，就可以点击自己仓库里面的Pull requests
点击New Pull requests，这里他就会直接跳转到原来的仓库并给你显示出你的修改
确定你的修改之后，你可以点击Create Pull requests就成功地发出了一次PR的请求，以后你有什么需要继续修改的，直接修改就行了，再PR被merge之前，GitHub都会自动拉取你的修改。
PR不等于直接被接受，所以还是要保证自己的代码的正确性，真正有用，开发者才会接受这一次PR。
关于你的问题，项目本身已经完整了，核心的一些架构暂时还力不从心。
如果你觉得自己的能力还不够对项目产生功能性的贡献，首先你可以选择一个适合自己的仓库进行PR，或者提升自己的能力，然后PR（做出贡献）也不一定是非得要进行代码方面的，你可以对使用文档的部分进行更加详细，人性化的解释，甚至是对某些文档进行 翻译，翻译上的修改，等等都是可以的。Git所实现的高效的版本控制使每个人都可以简单的参与贡献。
通过GitHub学习编程
确实GitHub在编程方面可以教我们很多。但怎么来使用它还是因人而异的。
一方面通过GitHub我们可以练习跟其他伙伴共同开发同一个项目的经验。
另一方面，我们可以在GitHub上面找到很多是和我们使用或者学习的代码或者项目。因为GitHub是一个
开源社区
，我们可以仔细研究某些大牛的大项目的源码。
另一方面，不是非得说高star的项目就适合我们去学习，有可能代码需要的水平比较高我们暂时还看不懂。或者说一个新的优良项目，star数还很少，但是很适合我们去学习，去提PR。
关于如何找到适合初学者的项目进行学习
这个如果你是想学习git&github的一些操作，我推荐你可以创建两个账号，用来练习git的一些指令，还可以从两个角色来学习pr的很多操作。
如果是为了代码的学习，首先你要知道自己想要学的方面，AI？web？C？等等。然后你就可以去搜索类似的项目，其实个人认为关于使用GitHub进行代码的学习，倒不是说GitHub上面的项目里面出一个什么教程让你去学习，而是在你写代码的过程中去学习。所以说合适的项目并不是很重要，主要还是看自己是否愿意去学习。现在这个时代，基本上所有你想学的东西在网上都可以搜到，甚至有的地方还会出专门的一套课程供你免费学习，所以不要怕，跑起来就可以了！
Git&GitHub的学习
如果你想系统的学习Git，这里推荐一下GitHub&Git官方教程，资源字幕由牛客网提供，方便初学GitHub和Git的学习，全是免费的哦）
课程介绍：Git是一个分布式的版本控制系统，最初由Linus Torvalds编写，用作Linux内核代码的管理。在推出后，Git在其它项目中也取得了很大成功，尤其是在Ruby社区中。目前，包括Rubinius、Merb和Bitcoin在内的很多知名项目都使用了Git。GitHub 使用 Git 作为版本控制系统（version control system）提供在线源码托管的服务。同时是一个有社交功能的
开发者社区
。
课程链接：
GitHub&Git基础_牛客网
?
www.nowcoder.com/courses/cover/vod/2","这篇文章可以说是全网最详细的 github 教程了，来自知乎大佬 宁萌时光。
 新手小白可能会对 GitHub 有以下困惑： 
1.GitHub 是个什么网站？ 
2.为什么一说学 GitHub，就听到人家说要学 Git？这两个有什么关联吗，是不是一回事？ 
3.听说 GitHub 是个
开源社区
，可以在上面与其他人一起切磋技术、完善代码，具体是怎么与别人交流呢？
下面，我从这几个方面进行解答。
一、带你浏览 GitHub 网站，看看都有些什么？
1.注册账号
打开 
GitHub网站
，首页如下图所示，点击右上角
Sign up
按钮，进入注册页面。使用电子邮件注册，设置好用户名和密码，即可生成账号。完成注册后，点击旁边的
Sign in
按钮登录。 
注册/登录页面
2.登录 GitHub，浏览页面
登录进去后，我们见到的页面分成三大版块，如下图所示，从左至右依次为：自己的仓库(Repositories)、关注的人的动态、发现新的热门/有趣仓库。 
登陆后首页示例
可能的疑问：Repository? 仓库？
是不是有点不好理解？ 
我在初学时也遇到这一困惑。""
repository
""有""仓库""的意思，我们可以理解成存放项目所需的各类文件的仓库。等熟悉了之后，你会发现 GitHub 上各种仓库都有，不是只包含程序代码，还有学习课程文档等等，难怪会叫仓库，哈哈。Repository（仓库）在 GitHub 上有重要作用，我们以后的很多操作都是在 Repository（仓库）中进行。
点击右上角的个人头像，在下拉列表中选择
Your profile
项，到达个人主页。下图所示为我的个人主页。 
个人主页示例
你如果打开另一个人的主页，看到的界面风格也大致如此。我在图中简要注明了页面中的各项功能，此外：
1. 点击账户名下方的
Edit profile
按钮，可以修改自己的个人信息，比如这里的一句话简介，公司、地址、联系方式等。而如果是别人的个人主页，这里我们看到的就是
Follow
（关注）按钮。 
2. 粉丝和关注的人数右边有个星星图标，这就是传说中的 Star。我们看技术文章可能常会遇到如“程序员必看！GitHub 上 Star 数过万的项目！”，“该项目在 GitHub 上迅速收获上千 Star 数” 类似的介绍，看来 Star 数是个很重要的标识哦！那么，Star 是什么意思呢？比如，我们觉得一个仓库不错，在右上角点个 Star，就相当于是收藏+点赞了，之后还可以在自己的主页中点击星星图标查看。 
仓库页面-Star
3. ""Pinned""区域是自己的个人展示区，在自己的仓库中精选几个放到这里展示，让别人能很快发现你的闪光点。 
4. 活跃度表格：上面的绿色格子越多，颜色越深，说明该用户在 GitHub 上提交次数越多，是活跃用户。
二、GitHub 是 Git 软件用户的项目管理中心
1. Git
GitHub 之所以得此名，与一款分布式版本控制软件 Git 是分不开的。通俗地讲，Git 软件记录了你每次修改时的文件状态。更妙的是，如果你改着改着，又觉得以前的版本更好，还可以回溯呢，也就是说，有“后悔药”可吃了！同时， Git 也是一款极佳的协作软件。打个简单的比方，我和小红、小蓝三个人一起修改一篇文章，每个人改的地方可能都不一样，那么合并修改稿就是个头疼的事。或者，我先修改、再给小红修改、最后小蓝修改？这样效率又降低了。怎么办？用 Git，我们三个人可以建立修改分支，同时进行修改工作，最后合并分支。你可能会问，如果你们三个人在同一个地方做了不同的修改，还能合并吗？放心吧，软件考虑了这种“冲突”情况，有相应的解决办法。
既然 Git 可以协作，那总要有一个地方让使用的人们存放文件、修改等信息呀，就像控制中心一样，这样，GitHub 应运而生。这里多说一句，Git 的托管中心不是只有 GitHub 哦，GitHub 是方便个人用户、
开源项目
建立的网站。有的企业会自己搭建服务器和云盘构建托管中心，同样也是用 Git 软件进行协作管理。
那么，怎么用 Git 软件呢？ 
（1）先到 
Git官网
下载安装 Git 软件。 
（2）安装成功后，选定一个文件夹，在右键菜单中选择
Git Bash Here
，会弹出一个黑色的命令行界面，输入语句，就可以在当前文件夹中运行 Git 命令。
这里推荐学习一下
廖雪峰老师的Git教程
，讲解得明白易懂，从中我们可以了解 Git 的各种操作。然后，跟着教程的讲解，自己建个新文件夹动手练练。
2.Git 基本命令
Git 命令还是挺多的，但是
对新手来说，我们可以先掌握几个在 GitHub 上常用的 Git 基本命令
： 
（1）提交修改：
git add
和
 
git commit
git操作示意图，图片来自Git官网
上面的示意图来自 Git 官网，说明了 Git 中最重要的操作 ""git add"" 和 ""
git commit
"" 的工作流程。 Git 软件的核心是保存修改。working directory 是工作区，就是我们的电脑上当前工作的文件夹。staging area 可以理解成暂存区或者中转站，
git add .
（注意：这里 add 和
.
中间有个空格）提交了修改，放在 staging area 暂存，再通过 
git commit -m""修改说明文字""
 确定最终提交版。不要小看这个缓冲的暂存区，它为我们修改时提供了“后悔药”。这个效果就有点类似于我们平时在电脑上删除文件，文件不会直接删除，而是放到回收站中转一下。如果我们过后发现手抖误删了，还可以到回收站里把文件“还原”回去，或者确定都不需要了，就点击“清空回收站”，把这些文件都删除。
（2）与远程仓库同步：
git pull
 
和
 
git push
在多人协作的情况下，比如前面提到的我和小红、小蓝一起写文章的例子，可能每个人的修改不一致，要保持同步。而我们要从远程仓库获取更新和推送自己的修改，就要用
git pull
 和 
git push
。前面提到的 
git commit
 是确定我自己最终的修改结果，
git push
 则是将这一修改结果提交到远程（比如 GitHub上）的 repository（仓库）保存。我始终记得廖雪峰老师教程里提的要点：每天开始工作的第一件事是 
git pull
，跟上项目最新的修改进度。结束一天工作、提交修改时，先 
git pull
 再 
git push
。
（3）下载 repository（仓库）：
 
git clone
打开一个仓库，我们会看到
Code
按钮，点击后，下面出现 HTTPS 地址和 SSH 地址。我们只要复制了这个地址，然后在电脑上右键点击存放文件夹，打开 Git Bash 客户端，输入命令行：
git clone 复制的地址
，就能下载这个仓库到本地电脑。 
下载仓库示意图
需要注意的是，用 HTTPS 地址需要账户验证。使用 SSH 地址只需要第一次时提交 SSH Key 到 GitHub ，后续无需每次验证，很方便，接下来就会介绍如何配置 SSH Key。
注：写这篇文章时，我也出现了一个困惑：不知道是否因为我已经用 SSH 验证了，我用
git clone HTTPS 地址
下载时，也没有要求输入账户名和密码验证。小伙伴们请把你们实践的结果告诉我一下呀，谢谢！
三、新手必备的GitHub基本操作
1.配置SSH Key
（1）第一次使用时，要配置一下账户。
在 Git Bash 客户端，输入：
git config --global user.name ""这里输入你在GitHub的账户名""
git config --global user.email ""这里输入你在GitHub的注册邮箱名""
（2）检查是否已经有 SSH Key了，如果没有就生成。
同样在 Git Bash 客户端，先后输入：
cd ~/.ssh
和
ls
我的账户已经生成了 SSH Key，就有了下面所示的 id_rsa 和 id_rsa.pub 。请注意，id_rsa.pub 是公钥，后面要把这个公钥上传到 GitHub 上验证。id_rsa 是你自己的私钥，要保存好。
id_rsa  id_rsa.pub  known_hosts
如果没有 SSH Key，就要输入以下命令行生成：
ssh-keygen -t rsa
 -C ""这里输入你在 GitHub 的注册邮箱""
生成后再输入上面的
cd ~/.ssh
和
ls
命令，就可以看到 SSH Key 了。
（3）复制公钥。
接着在 Git Bash 客户端，输入命令行： 
cat id_rsa.pub
这样会显示公钥文件内容，我们把它复制到剪贴板。
（4）把复制的公钥添加到 GitHub 账户安装。
登录 GitHub 账户，点击右上角个人头像的下拉菜单，如图所示： 
个人头像的菜单项
依次点击 Settings > SSH and GPG Keys，在 SSH Keys 页面右上角有个
New SSH Key
按钮，点击该按钮后，粘贴上刚才复制的公钥内容。里面的 “title”项就是为自己的 SSH Key 命个名，可根据个人喜好随意。
（5）最后，检查一下 SSH Key 是否安装成功。
在 Git Bash 客户端运行命令： 
$ ssh -T git@github.com
出现类似下面的提示，表示安装成功：
Hi Juliecodestack! You've successfully authenticated, but GitHub does not provide shell access.
2.我的第一个 GitHub 项目：如何新建上传仓库
学了这么多基本功，我们终于要练手了，哈哈，先来建一个自己的仓库玩玩吧！
（1）在 GitHub 中新建仓库
如下图所示，点击个人主页的 Repositories 项，再点击右方的
New
按钮，新建一个仓库。 
仓库页面-新建按钮
我这里做了一个简单的示范，如下图所示，你可以照着我的模板填，最后点击最下方的
Create repository
按钮，即可创建一个新的仓库。 
新建仓库填写页面
打开新建的仓库，如下图所示，这个仓库的 Readme 文档的内容就是刚才填入的仓库名和描述说明。 我们点击Code按钮，复制 SSH 地址。
仓库页面-testexample2020
（2）把仓库文件下载到电脑。
假设我们要下载到电脑上的目标文件夹（为了描述方便，这里简称为文件夹 A），那么我们就右键点击文件夹 A ，在右键菜单中选择“Git Bash”，在 Git Bash 客户端输入命令行： 
git clone SSH地址
这样，仓库就会下载到文件夹 A 中。
（3）修改仓库文件，使用 Git 命令提交修改并推送至 GitHub。
下载仓库完成之后，我们会发现文件夹 A 中有了一个新的子文件夹，比如我在前一步骤下载了仓库 testexample2020，此时文件夹 A 中就出现了一个名为""testexample2020""的新文件夹，这就是下载到本地电脑的仓库。我们打开这个新文件夹（""testexample2020""），使用 VSCode 或 Atom 编辑器（编辑器的使用方法可参考我的文章：
一篇文章带你快速入门Markdown
），在 Readme 文件里增加一行： 
hello,world!
。再新建一个 main.py文件，输入一行简单的代码:
print(""hello"")
。
修改好了之后，我们右键点击文件夹 testexample2020（注意：此时不是在母文件夹 A 上使用 Git Bash 了），打开Git Bash 客户端，依次输入命令行： 
git add .
git commit -m""v0.1""
git push
这样修改就推送到了 GitHub 上的仓库中。
（4）登录 GitHub，查看一下仓库的变化。
登录 GitHub 后我们发现，刚才做的改动都同步到了 GitHub 仓库中，如下图中标示： 
仓库页面-改动后
3.和别人一起做项目：Fork 和 Pull request
前面提到过，GitHub 是个开源社区，我们可以参加到开源项目之中，那么，具体是怎么操作呢？
举个我自己的例子来说明一下这个过程吧。 
（1）Fork 一个别人的仓库
我在学习 API 接口时，网上的微博 API 工具包很多是基于 Python2 写的，我在 Github 找到了一个 Python3 的版本 
sinaweibopy3
，如下图所示。我用了一下，觉得很好，看到作者没有写 Readme，我就想添加一个 Readme 说明文档，让别人能更快地了解这个仓库的功能和使用方法。也就是说，我想对这个仓库做一些修改。这种情况下，我就要先 Fork 一下这个仓库到我自己那儿。 
sinaweibopy3仓库页面
为什么要 Fork 呢？
Fork有“叉子”的意思，也就是从原仓库复制建一个我自己的分支（分叉），这样，我做的改动只是在我自己的分支上，不会影响到原仓库，除非我提交的 Pull request 被接受后。
Fork 之后，在我的仓库里就出现了一个相同的仓库 sinaweibopy3，如下图所示。不同之处在于，仓库名下方有个备注：""Forked from olwolf/sinaweibopy3""。 
Fork的仓库
（2）对自己 Fork 的仓库做修改
接下来，我就对 Fork 的 sinaweibopy3 仓库做修改，添加了一个 Readme 文档。具体方法请参考上一步 “2.我的第一个 GitHub 项目：如何新建上传仓库” 的示例，可以先
git clone
下载到本地文件夹，修改后再
git push
推送到 GitHub。
（3） 提交Pull request
如下图所示，点击 Pull request，在弹出的界面填写一些信息，告诉原仓库的作者你做了什么修改、为什么要修改等，方便作者了解你对仓库的改动，然后提交，Pull request 请求就会发送至原仓库的作者。
Pull request示例
（4）等待原仓库的作者查看和决定是否接受修改
提交了 Pull request 后，我们就等待一段时间，原仓库的作者会决定是否接受修改。
这里，仓库 sinaweibopy3 的原作者 olwolf 合并了我的修改，如图所示，这样原仓库中也增加了 Readme 文件。同时，我也因此成为了仓库贡献者(Contributors)之一。 
接受Pull request后，原仓库的变化
四、总结
完成以上学习，我们基本上就入门了，接下来，你可以自己在 GitHub 上探索一下，比如搜索发现一些有趣的项目，关注一些高手大牛，加入到开源项目中，等等。最重要的是，动手练习！一旦上手实践，慢慢熟悉之后，你会发现没有开始想象的那么难，一起加油吧！
最后，推荐几个好的学习教程： 
1.
GitHub 帮助文档页面
2.
廖雪峰老师的Git教程
3.
GitHub如何配置SSH Key
觉得这篇文章不错的话，请点赞支持一下，谢谢！
。
来源: 
https://
zhuanlan.zhihu.com/p/33
7959303
  作者: 
宁萌时光
最近很多同学问我大厂面试的核心知识点，东哥熬夜整理出来了9大核心知识点，需要的自取：
另外，我当初在准备各大公司技术笔试的时候刷了大量的算法题，其中就是参考了
一本谷歌大神的LeetCode刷题笔记
，帮我整理了解题思路，归纳了出刷题方法，非常不出错，转给需要的同学：
最后给大家介绍一份计算机经典书籍，送大家一份硬核书籍资源：读大学跟工作期间，我买了很多书，大部分是一些技术书籍，也收集了这些书籍的电子版，都在这里，现在免费share给大家，
包括了计算机类常用电子书，包括C，C++，Java，Python，Java，Linux，Go
等，希望大家能认真阅读。
点击下方链接直达获取：
码字不易，硬核码字更难，希望大家不要吝啬自己的鼓励，给我 ：
@码农出击
一个点赞，鼓励下我！"
,,,,,,,,,,,,,,,,,,,,,
怎样成为全栈工程师（Full Stack Developer）？,"成为全栈工程师一般的学习路径是怎样的?
补充一下Full Stack Developer的定义和标准：
What is a Full Stack developer?
，这样大家讨论怎样成为Full Stack Developer时不会偏的太远。
Is it reasonable to expect mere morals to have mastery over every facet of the development stack? Probably not, but Facebook can ask for it. I was told at OSCON by a Facebook employee that they only hire ‘Full Stack’ developers.  Well, what does that mean? To me, 
a Full Stack Developer is someone with familiarity in each layer, if not mastery in many and a genuine interest in all software technology...","做这样一个简单的 app:
一个天气应用，干净清爽的界面，天气信息一目了然。它不仅可以精确预测未来 10 天的天气，还可以显示某地的历史天气信息。它具有自定义提醒功能，支持 web 版本， iOS 版， Android 版。
为什么想要做这样一个 App ？因为你喜欢旅行，但没找到一个天气 App 可以提供你下个月或者某个特定月份的天气信息；因为你懒你没有每天看天气预报的习惯，你想要在第二天温度达到 30 度以上或者温差有 +/-7 度的时候，获得温馨提示；因为你要成为一个 
Full Stack Engineer
 ，你必须不断训练每个 
stack
 的能力。
## Web版
你决定用 MySql 来存储用户数据，用 NoSql 存储历史天气数据。你用 Redis 作为 
cache
 ，缓存一些最常请求的天气数据。你用 Python 写后台，功能简单，后台不复杂，用户注册登录，抓取返回某城市的天气数据，某地的历史天气数据，很快便搞定。
后台开发并测试好了，接下来是 Web 前端。你十分清楚一个好的 UI 设计对一个 App 的重要性，你也明白 UI 的设计不只是为了美观，更重要的是提高信息的可读性和程序的可用性。幸好你平日的积累这次派上用场了。你把之前保存下来的上百个优秀的UI设计作品拿来研究，你从书架上拿出Norman 的那本经典 - The Design of Everyday Things 重新细读。最终你用白纸黑笔敲定了第一个版本的 UI，简洁直观，没有任何多余的设计，所有元素的排列间距 大小颜色都恰到好处。你相信即使天气不好，但用户只要使用这个 App 都会有着愉悦的心情。
那么开始写前端吧。啊，别急，都忘了还有 
Icon
 和 Logo ，可是不会 PS ，不会 AI ，不会 
Sketch
 怎么办呢，学吧。你平日喜欢结交不同领域的朋友，正好几周前在一个活动上你认识一位朋友做设计的。她花一个下午的时间教你基本的 Sketch 的使用，并对你的 UI 设计给出了一些意见。你请她吃了顿晚饭表示感谢，然后立即回家根据她的一些建议重新调整了 UI ，这次你在 PS 里把 UI 画了出来，
Icons
 和 Logo 也顺道一起做了。
接下来的一周，你学习 HTML，CSS，以及 Javascript，并漂亮地把前端搞定。
## 发布 App
在朋友圈发了个状态，找人帮你做 Beta 测试。他们都首先问你是什么 App，一开始你简单回答一个天气的 App。但你发现，这不能提起他们的兴趣。你觉得你需要用语言，用故事包装一下。不光是作为别人「是什么 App」提问的回答，也是成为 
Full stack Engineer
 道路上的一个重要技能。
你去看了所有你喜欢的产品的主页，从他们的文案上获得一些灵感启发；你读了经典的 
On Writing Well
 ，发现好的文案，好的设计，其实和好的代码很相似，都是重在交流，如何让他人毫不费劲地明白你要表达的内容。你的故事要吸引人，你的产品介绍要在1分钟内解释清楚，并确保你的父母可以毫无压力听明白。
一切就绪，产品上线了。反响不错，用户持续增加。很多用户希望有移动版本，于是你立即投入到iOS 版本的开发上。
## iOS 版 及 后台优化
你花一周不到时间学习了基本的语法和工具使用便投入到 App 的开发中。你知道 Learn by Doing 是最好也是最快的。由于之前学习了设计的基础，UI ，Icons 很快搞定，不久 iOS 版本便发布了。iOS 的发布带来了更多的用户增长，后台服务器的压力颇大，你知道是时候优化后台了。
你在 
AWS
 上多开了 2 台服务器，并写了一个 Script 来自动化部署过程。
你改用 uWSGi 协议，用 
uwsgi
 作为 Application Server。
你使用 Nginx 来做并发，负载均衡 ...
......
......
## 成立公司
用户持续增长，每天你都会收到十几二十封用户的邮件。你很感激这些愿意花时间给你写邮件的用户，你相信他们是你最重要的用户，是潜在的付费用户。如果你把他们像上帝一样对待，他们同样也会把你看作是上帝。所以除了睡觉时间的发来的邮件，每一封邮件，你都会在2小时内给予回复。
果然这样的付出是收获巨大的，他们不仅惊讶且非常感谢你的快速回复，他们会在app store里给你★★★★★的评价，他们在社交网站上分享你的app，他们甚至会主动提出捐款给你。
你从快速的用户增长中嗅到了商机，你开始思考如何赚钱。广告你是坚决不能允许的，你认为再精确的广告也会影响用户体验。你设计了 2 个不同的付费方案，你打算用 A/B 测试看哪个方案更好。你分别给 200 个用户发去邀请尝试付费的邮件，邮件内容你精心打磨过，并在最后写上：CEO & Founder. 通过分析 2 种方案的用户行为，你决定将使用第一种方案。
接下来，你相信差不多是时候成立个公司了。为了省时间，你花 2000 块钱找了个园区挂靠并帮你注册公司。公司的名字让你头疼了很久，你不想只是简单的用这个 App 的名字作为公司名字，你知道公司将来还会做出其他优秀的产品。你希望这个名字简单易记，同时其含义也是你公司文化的象征。
公司注册下来了，但银行那边得自己跑。你联系了一些媒体编辑，邀请他们来试用你的产品；你重新设计了产品主页，并开始写产品的 Blog ；你在各大社交网络都给 App 注册了账号，即做社区客服也为宣传... 这些事大大压缩你写代码的时间。以往你都是以代码量作为衡量自己当天工作效率的指标，所以这些天你总感觉没做啥工作。
这样的发展早已超过你的预期，这个 App 从一个 Side Project 几乎变成了你生活的全部。你跟你女朋友半个月才出去约会一次，她抱怨不断；你1个月没跟朋友出去玩耍喝酒了；你 2 个月都没锻炼过身体... 你意识到, YOU CAN NOT DO THIS ALONE，你需要帮手，你需要找人一起把这个做下去。
但你不是要成为 Full Stack Engineer 么？你现在是了么？
## Full Stack Engineer
设计，后台开发，前端开发，移动开发，运营维护，PS，文案... 好像都会了，这算 Full Stack Engineer 了么？
不，这只是踏上成为 Full Stack Engineer 的第一步。你知道目前只是每个 stack 都懂一点，离
senior
 或者 expert 还差得远，而要每个 stack 都做到极致，需要大量的时间和精力。精力有限，产品开发紧迫，力不从心啊，这条道路也太孤独，因为你不需要与任何人进行协作。难道要把一些stack的任务交给别人做么？这样算是放弃成为 Full Stack Engineer 么？
不！这不是。
什么是 Engineer？
「Engineers are versatile minds who create links between science, technology, and society」。
Engineer 的本质工作是设计，开发出应用于大众的产品。
一个真正的 Full Stack Engineer ，他从生活中发现问题，洞察需求，他设计解决方案，并开发出初始版本的产品。为了达到目标，他愿意去学习任何领域的技能和知识。同时他不追求一个人完成所有工作，如果有人可以比他在某方面做得更出色，便会十分热情的邀请他们加入。
最终他的职位也许不再是 Engineer ，他不再设计 UI ，不再写代码 ... 他的工作不再是 design and building an app or product，因为他有更大更重要的任务要做 - design and building a team or a company which builds great products. 
而这时，社会给了他们另一个称呼 - 创业者。尽管众人已忘记他们 Engineer 的身份，但在他们骨子里，内心深处，自己始终都是一个 Engineer 。当他们需要从头再来时，他们毫不犹豫从设计开发产品做起。
Nikola Tesla
，Ferdinand Porsche，Henry Ford，
Jack Dorsey
，Mark zuckerberg，
Elon Musk
 ... 细数那些改变了或正改变世界的创业者，他们大多数是 Engineer 背景，热衷于设计创造。
他们学习技能和知识，不是为了成为某个领域的专家；而是因为那些 是完成自己目标所需要的。
以上，为我认可的 Full Stack Engineer 
---
发个招聘广告！
Airbnb 北京办公室
正在招人，iOS 工程师（会 report 给我）、
Fullstack 工程师
、产品经理等都有职位空缺。欢迎感兴趣的小伙伴私信联系我。
Peng","既然原文是说，Facebook 工程师说 Facebook 只招 full stack engineer，那我就来说说 Facebook engineer 都是怎样的人啦。
我觉得任何一方面的具体经验都不重要，重要的是思维方式和学习能力。首先说思维方式，那就是不为自己设限，不会想着自己是
前端工程师
，所以后端的东西我就一点也不碰。Facebook 的工程师，级别越高就需要保持越大的影响力。如何创造更大的影响力，就是寻找当前杠杆效应最明显的问题来解决。有些问题你解决了的话，投入进去的时间每小时能换回来一千美元；有些问题你解决了的话，投入进去的时间每小时能换回来一百万美元。然而哪些问题更值得解决，这是动态的，往往还存在衰减效应。如果现在性能瓶颈在后端，你做了一个季度两个季度优化后，瓶颈就已经不在后端了，你再优化下去衰减效应就会越来越明显。等瓶颈变成前端了，你是不是就说因为你不懂，所以不愿意碰？那就相当于寄望于公司有个前端很懂性能优化的人来解决，但如果公司没有这样的人那就没有人来解决了。
Facebook 的众多海报当中，有一张写的是「任何一个 Facebook 的问题，都不是别人的问题」。有问题，你就需要去评估是否值得解决。如果值得解决，你就应该着手去解决，而不是假设公司内会有另外一个人比你更合适解决这个问题。这时候很可能你就需要去做你从来没有做过的事情，需要学习你原本可能完全不懂的技术。如果你是个专门做数学模型的博士，加入 Facebook 原本是打算做搜索结果优化的，结果发现这不是最急需解决的问题，JavaScript 性能才是最需要解决的问题，你怎么办？如果你以为 Facebook 需要的是你做数学模型的经验，那你就错了。Facebook 需要的是你完成博士学位的学习能力。你从来没做过 JavaScript 并且觉得 JavaScript 很恶心？正确的做法是立即在网上买几本 JavaScript 入门的书连夜看完，然后着手分析性能瓶颈并且解决。在你完成手动优化后，你还可以思考一下能否把这做成自动化，例如说在代码提交时分析 JavaScript 语法树并且指出可能成为性能瓶颈的地方，又或者说从用户浏览器那里收集性能数据扔到 Hive 然后再从中分析产生瓶颈的特征。这些都可能涉及到一些你没有做过也没有学过的东西，但问题摆在那里你就需要去解决，而无论这要求你去钻研什么。这就是我所说的学习能力。
这是高级工程师和初级工程师的主要差距。尽管在高级到初级这一维度上，美国工程师和中国工程师是有重叠的，但美国的教育体系和行业传统使得美国应届生比一般中国工程师更偏向于高级那一端。美国学生的优势在于，他们的教育体系让他们习惯面对开放性问题。一家公司万千问题当中，此时此刻哪一个最值得解决？这不是中国工程师擅长的问题，因为实在是太开放了。中国教育让人擅长在给定条件下解决问题，太开放反而不知道从何入手。此外因为绝大多数文献都是英文的，所以要钻研什么对于能读懂英文的人来说都可以非常成体系的学习，这对于很多拒绝阅读英文的中国工程师来说很不利。拒绝阅读英文意味着永远只能接受别人的二手资料，对于很多概念的理解只能停留在技师的层面，而无法上升到工程师或者科学家的层面。","现有的答案已经说明了，以一个正常人的精力和学习速度来说，想在 
full stack
 的每一个层面都达到顶级的精通显然是很困难的事情。但是做不到这一点就算不上 full stack developer (
FSD
) 了吗？其实我希望大家留意题主引用的那段英文的最后一句：
a genuine interest in all software technology. （
对所有的软件技术抱有一种真挚的兴趣）。
我觉得对于 FSD ，尤其是对于想成为 FSD 的人来说，这个
态度
才是最重要的事情。即使都是 FSD，每一个人各自的技能加点也肯定会不一样，有人在前端更擅长一些，有人在服务器层面更有经验... 但其实没有什么硬性的门槛，需要的是解决
任何问题
的能力和意愿。你要做到的就是不固步自封在一个领域。遇到问题，就去研究，不因为问题不在你的 comfort zone 就放弃或者推给别人。即使一开始的解决方案很笨拙也无所谓，
just learn whatever it takes to make it work.
 比如说我要做一个网站，我有一些东西没碰过，但我有足够的兴趣和动力去搞个八九不离十。（这里自学能力很重要，有好的 
mentor
 也会帮助很大）当你经历过一次这个过程以后，你就会有信心去弄明白更复杂的东西，在之前的基础上进一步去消化、改进、学更多的东西。
另外，我个人觉得这个过程应该是由实际问题驱动的，而不是漫无目的看到什么东西流行了或者觉得很NB就去学。
@庄生
 的答案里提到绝大部分的网站都活不到或者永远也达不到10k用户在线的水平，那种情况下去看 
high scalability
 的东西有什么意义？学的东西用来解决或是改进实际遇到的问题，这样你的整个知识体系覆盖面和侧重点会比较合理。打个比方就是你的技能点有限，所以加点方案得有一个主题，到处乱点的话就废了。","一年之后，终于可以真正的给这个问题一个答案。现有的高票的答案没有涉及到怎么成为全栈工程师。
实战篇
《
GitHub - phodal/growth-in-action: 全栈增长工程师实战
》
你将会看到：
如何去开发一个Web应用（博客）
如何编写单元测试、功能测试、自动化UI测试
搭建并使用持续集成
添加SEO支持――Sitemap、
站长工具
和Google Analytics
使用API，制作AutoComplete
开发相应的APP及其API――查看文章、用户登录、发表文章
制作单页面应用
自动化部署
目录：
Growth In Action Django
准备工作和工具
深入浅出Django
Django简介
Django应用架构
Django hello,world
安装Django
创建项目
Django后台
第一次提交
Django创建博客应用
Tasking
创建BlogpostAPP
生成APP
创建Model
配置URL
创建View
创建博客列表页
创建博客详情页
测试
测试首页
测试详情页
功能测试与持续集成
编写自动化测试
Selenium与第一个UI测试
搭建持续集成
Jenkins创建任务
创建shell
更多功能
静态页面
安装 flatpages
创建模板
评论功能
Sitemap
站点地图介绍
创建首页的Sitemap
创建静态页面的Sitemap
创建博客的Sitemap
提交到搜索引擎
前端框架
响应式设计
引入前端框架
页面美化
添加导航
添加标语
优化列表
添加footer
API
博客列表
Django REST Framework
创建博客列表API
测试 API
自动完成
搜索API
页面实现
跨域支持
添加跨域支持
移动应用
hello,world
构建应用
博客列表页
列表页
详情页
Profile
Json Web Tokens
Profile
创建博客
TODO
Mobile Web
移动设备处理
MVVM
UX
部署
配置管理
Fabric
理论篇
献上我写的电子书《
GitHub - phodal/growth-ebook: Growth: 全栈增长工程师指南。Growth: Learning Full Stack
》
Growth: 全栈增长工程师指南
全栈工程师是未来
技术的革新史
软件开发的核心难题：沟通
大公司的专家与小公司的全栈
全栈工程师的未来：无栈
基础知识篇
工具只是辅助
WebStorm还是Sublime?
语言也是一种工具
提高效率的工具
快速启动软件
IDE
DEBUG工具
终端或命令提示符
包管理
环境搭建
OS X
Windows
GNU/Linux
学好一门语言的艺术
一次语言学习体验
输出是最好的输入
如何应用一门新的技术
Web编程基础
从浏览器到服务器
从HTML到页面显示
HTML
hello,world
中文？
其他html标记
小结
CSS
简介
样式与目标
选择器
更有趣的CSS
JavaScript
hello,world
JavaScriptFul
面向对象
其他
前端与后台
后台语言选择
JavaScript
Python
Java
PHP
其他
MVC
Model
View
Controller
更多
后台即服务
API演进史
后台即服务
数据持久化
文件存储
数据库
搜索引擎
前端框架选择
Angular
React
Vue
jQuery系
前台与后台交互
Ajax
JSON
WebSocket
编码
编码过程
Web应用的构建系统
Web应用的构建过程
Web应用的构建实战
Git与版本控制
版本控制
Git
Tasking
如何Tasking一本书
Tasking开发任务
写代码只是在码字
内置索引与外置引擎
门户网站
内置索引与外置引擎
如何编写测试
测试金字塔
如何测试
测试替身
Stub
Mock
测试驱动开发
红-绿-重构
测试先行
可读的代码
命名
函数长度
其他
代码重构
重命名
提取变量
提炼函数
Intellij Idea重构
提炼函数
内联函数
查询取代临时变量
重构到设计模式
过度设计与设计模式
上线
隔离与运行环境
隔离硬件：虚拟机
隔离操作系统：容器虚拟化
隔离底层：Servlet容器
隔离依赖版本：虚拟环境
隔离运行环境：语言虚拟机
隔离语言：DSL
LNMP架构
GNU/Linux
HTTP服务器
Web缓存
数据库端缓存
应用层缓存
前端缓存
客户端缓存
HTML5离线缓存
可配置
环境配置
运行机制
功能开关
Feature Toggle
自动化部署
数据分析
数据分析
数据分析的过程
Hadoop分析数据
用户数据分析：Google Analytics
受众群体
流量获取
移动应用
网站监测
应用程序性能分析
关于Apdex
博客性能分析
SEO
爬虫与索引
什么样的网站需要SEO？
SEO基础知识
内容
性能优化
UX
什么是UX
UX入门
什么是简单？
进阶
用户体验要素
认知设计
流
持续交付
持续集成
前提条件
瀑布流式开发
小步前进
持续交付
配置管理
持续集成
测试
构建与部署
自动化
持续学习
持续阅读
持续编程
持续写作
遗留系统与修改代码
遗留代码
什么是遗留代码
遗留代码的来源
遗留代码的问题
如何修改遗留代码
守: 找到测试点
破: 打破依赖
离: 修改并重构
网站重构
速度优化
功能加强
模块重构
回顾与架构设计
自我总结
吾日三省吾身
Retro
四个维度
架构模式
预设计式架构
演进式架构：拥抱变化
浮现式设计
意图导向
重构
模式与演进
每个人都是架构师
如何构建一个博客系统
相关阅读资料
架构解耦
从MVC与微服务
CQRS
CQRS结合微服务","2018update:
创业失败，不过朋友的项目和我自己想做的事情，都需要一些开发者。那么各取所需，我建立个小组大家一起学，你想接现实项目可以在里面练手。
详情看这里
https://
zhuanlan.zhihu.com/p/34
454047
Update：
我又合伙创业了。招php基础的开发者，入门基础到中级的都收，有意私信。坐标上海，汽车后市场的现代化连锁化互联网化改造。
http://www.
zhuanchedao.com
如果你目前写的少基础还比较差，只要逻辑思维清晰，好学，问题不大，我会带你的。
另外说一下，开发者的概念。我们要的是开发者而不是程序员，我从入行2000年到转管理岗07年，之间的工作一直是开发者，尤其朗讯
贝尔实验室
，我们根本不管你会什么语言，我们默认你会所有的语言。就像我曾经接手一个perl的数据转换脚本的工作，迁移爱立信设备的用户数据到我们服务器上。就一周时间，我在班车上边啃骆驼书上班了边写，后面我就开始喜欢上写
perl
了。
我一直觉得，代码专家负责纯语言的底层事情，手术刀是用来做业务逻辑的，语言根本不是问题。
Update：
这个回答竟然收到的赞同比我其他所有回答都高，看来我还是转型灌技术鸡汤好了。
补充下，首先我觉得好的开发者，即使不是全栈，也要融会贯通多种技术。我从来不认为一个只专精一种技术的人有可能成为好的开发者，即使是 C，即使是汇编。（当然其实反过来看，那些大神们哪个不会搞点其他的？比如几个做服务器端开发的大神居然不懂服务器管理？）
然后从广度和深度的组合看，我认为好的开发者大概有两种类型：
1. 手术刀
2. 代码专家。
（来自《
人月神话
》）
手术刀是业务驱动的，最需要全栈的人；他们的核心价值在于：懂业务，技术全面，都能拿的起来，而且能选择最合适的技术。
代码专家是技术驱动的，即使不够
全栈
也可以用，但是技能树点的越多当然有好处。
而我提的创业逼出来的全栈，是因为，对于创业团队而言，手术刀更加重要，代码专家要依靠各种开源组织的贡献，或者临时聘请。
还有几位讲，创业的最大需求技能是整合资源的能力，找合适的人做事的能力。这个我认同，我只是说我自己，我承认我没能力忽悠一堆技术大牛策划大牛和我一起没工资的创业。我也忽悠不到前期种子投资的钱。
所以我说的，是说对于我，种子期，天使期，最重要的都是我自己作为手术刀，而不是资源整合者。
------------------------------------------
全栈工程师
不是为了工作本身，是为了方便实现自己的梦。
作为一个标准的全栈工程师来答下，全栈工程师不是培养出来的，是逼出来的~
不是公司逼的，是自己逼自己逼出来的~
因为我要创业，我经济压力又大没法辞职，我没法忽悠其他人一起免费干活......而且作为一个写了13年程序的老程序员（貌似知乎上比我老的程序不会很多了。。。。），本来工作语言就已经用过 Delphi, C++，Java，Perl，PHP，Lua，ObjectiveC，NodeJS，Tcl。这些都是工作中用的，尤其是创业那些年，遇到什么问题，我就要自己去探路，探出路来需要招聘对应的人再招聘～结果顺便把各种语言都学了一圈～
之前创业三年，一开始就我一个技术，所以运维几十台Linux 服务器我也顺便管了（我之前工作平时就工作在 Solaris 下面，差距不大），我老婆是前端工程师，所以 HTML，CSS，JS 我也一起学了。
所以多学一些语言对我来说真的不是件事情......
做过几年游戏制作人（做制作人我也同时每天 写代码....），策划，UI 都还有心得。
而且我这十三年怎么过的呢？别人朝九晚五，我每天工作到半夜2点，周末也很少休息。
谁能做到这样努力的工作（不是为了“资本家”，而是为了自己为自己工作），并且不是一直专注于一个岗位，我相信都能成为全栈工程师。
回到起点，全栈工程师不是为了工作本身，是为了方便实现自己的梦。
没错，如一些答主所说，你各方面都半吊子，我承认。
我之前有一段工作是写 C++和 Lua。Lua 部分还好，C++要遍历个 std::map 我到现在记不住，每次现搜索。作为一个 C++程序员我不够好，只能算是入门，或者说我一直是重视实现功能而非钻技术细节的人。我不关心技术上多牛，我关心功能的实现。
但我的价值根本不在于是一个 C++程序员，而是我可以从前端到后端到运维提供一揽子方案，视野广阔，任何点都可以选择最合适的技术，比如说最终选择 Lua 实现逻辑。
如果是创业，我可以自己一个人完成这个纯应用层面难度的开发的全部工作（当然，我的意思不是我一个人全做掉）。
如果不是创业，我的价值可能也就是个2w 多工资的架构师或者技术经理，这个价格远远对不起我这13年的付出。
一个真正的全栈工程师，目标只有一个：创业。","高中的时候喜欢踢球，班上有一个特别厉害的前锋，用我们对手的话就是：“挡也挡不住，跑也跑不过，绊都绊不倒”。
嗯，我认为的一个“全栈工程师”，不是仅仅能从汇编写到JavaScript，从PHP写到Objective-C。更是从代码到PhotoShop，从产品设计到地推样样行，样样懂。
从小了说，给他安排个你自己都没想太明白的任务，他给你一个惊喜。
从大了说，就是既能当CTO，又能当COO，没有各种CXO，自己也能当CEO。
==============分割线==============
说一个我一个朋友
@程一仕
的故事吧，我是在大三认识他的。当时我是学校论坛的系统管理员，正在招人接替我毕业后在学校的工作。招了好久没有入得了我法眼的，这时我师傅说找到一个不错的。
说实话，第一次见面我对他没啥好印象，因为这货抽烟，完全不像是一个搞技术的。后来一起通宵修理服务器，研究技术，慢慢发现这货是个挺有意思的人。
以后的日子里我带着他一起写Python，写C，写JS。。。我发现他就是那种能不断给我惊喜的工程师。。。
我们工作室的传统是，每年暑假大家都在学校做
封闭开发
，当时我找了个去IBM实习的机会，想让他替我留校。最后一聊，这货没空，暑假要骑自行车去西藏。。。我才发现他还是个文艺青年（当时还不是那么贬义）
后来，他到了大三，去的支付宝实习，做运维开发。
再后来跟我一样去了百度，不到三年时间，就升到了T6。。。
有一天无意发现这货豆瓣竟然有上万的粉丝，一问才知道，有一天他闲得无聊，写了篇骂豆瓣的产品的帖子，由于字字鞭辟入里，连豆瓣的产品同学都直呼骂得好（抖m的既视感），不断邀请他来豆瓣做产品，直到他亮出T6的身份，对方才作罢。
此人还对人文历史政治总有很多见解。每每觉得无聊，第一个想到拉他出来吃吃饭，每次都有新收获。
几个月前，他跟我说他前几天被一伙人拉着去融资了，那伙人是想搞云存储的，发现他对分布式存储很有研究，就生生拉上他去壮大阵容。。。
我就问，他们怎么知道你对这个有研究呢？这货拿起手中的加冰可乐，33.3°仰望天花板：“因为MooseFS有部分代码是我写的”。
后来才知道，这货已经是百度分布式存储&缓存Topic的负责人了。。。。
就在我为他要在技术的道路上超越我而惶惶不可终日的时候，有一天，他问我有没有兴趣回成都。。。
原来，这段时间他拉着几个学弟搞了个无节操（约XX）的叫“谁有空”的APP（啧啧，这名字。。），拿了几百万的融资，开始出任CEO，走向人生巅峰了。。。
他也教会我一件事，遇到比自己厉害的学弟，不要嫉妒，不要尝试去压制，因为“有些鸟注定是不会被关在笼子里的，它们的每一片羽毛都闪耀着自由的光辉”。可能有一天你就要去他公司打工呢。
所以，过了这么久，我最喜欢的一个身份还是
曾经这个
全栈工程师
的“师傅”。","全栈工程师是当今最著名和需求量最大的 IT 职位之一，很多IT 企业正在寻找全栈开发人才。但随着 IT 行业复杂性和动态性的增加，成为全栈开发人员比以往任何时候都更加困难。
国内外也有很流行的在线课程，比如：
Lynda
 ，
Udacity
 ，
Coursera
 ，
Thinkful
 ，
全栈开发基础项目课
等等。
什么是
全栈工程师
？
全栈工程师可以在应用程序的后端和前端等应用程序开发过程中的任何一个环节工作。应用程序的后端包含逻辑处理、用户身份验证、数据库交互、服务器配置等。应用程序的前端是用户能看到和与之交互的部分。
如果你想成为一名全栈工程师，你不必精通每一个细节。但是，在开发应用程序时，全栈工程师能够同时处理前端和后端，几乎对所有的技术细节都有涉猎。
 前端知识
1.基础
基础知识，就是可以写一些基本的样式，并能对页面的元素进行操作。举例来说，就是我们用Spring和JSP写了一个博客，然后我们可以用jQuery来对页面进行一些简单的操作，并可以调用一些API。因此，我们需要基本的HTML / CSS知识，以及JavaScript的开发经验。
同时，我们还需要对DOM有一些基础的了解，才能做一些基本的操作，如修改颜色等等。在这种情况下，最简单的方案就是使用jQuery这样的工具。当然，如果可以自己操作DOM是再好不过的了。
HTML/CSS
语义化的 HTML
能够解释 
CSS 盒子模型
CSS 预处理器
 的优点 （不一定需要了解如何深入使用它们，但是应该了解它们的用途以及它们对开发的帮助）
CSS Media Queries
： 定位不同的设备并编写响应式CSS
Bootstrap
：一个帮助设计和布局页面内容的框架
JavaScript
知道如何 
处理DOM
 ，同时也知道 JSON 是什么，以及如何操作
掌握重要的 
语言特性
 ，如 
functional composition(函数组合)
，prototypal inheritance(原型继承)，closures(闭包)，event delegation(事件委托)，scope(作用域)，higher-order functions(高阶函数) 等
异步流程控制，
promises
 和 
callbacks
 
学习如何正确地构建你的代码，并将代码 
模块化
 ，像 
webpack
 ，
browserify
 ，或者 
gulp
 这样的构建工具将会很有帮助
至少知道如何使用一个 
流行的框架
 ，比如
React
 或 
Angular
理解使用 
jQuery
了解有关 
测试框架
 的知识以及它们的重要性
了解一些重要的 
ES6 新特性
2.进阶
前端进阶技能，就需要我们对页面进行更复杂的操作。所以，基本上以下这些技能都是需要掌握的：
Ajax和JSON这两个技能是必须的，当我们要动态的改变页面的元素时，我们就需要从远程获取最新的数据结果
RESTful是需要掌握的，因为要提交表单到服务器；未来还需要Fetch API，ReactiveX这些技能。
HTML的语义化
DIV / CSS
模板引擎
和SCSS / SASS
后端语言
成为一名全栈工程师，一般来讲仅仅掌握一种语言是根本不够的，可以再选择一门语言学习。
Node.js
：这是一个很好的选择，因为 Node.js 本身只是一个 JavaScript 运行环境，这意味着你不需要学习一种新的语言。而且
Node.js
也有着良好的框架： 
Express
Python
：Python 是现如今最火爆的语言之一，开发的一些流行框架是 Django 和 Flask 。
Java
：涉及到全栈 Web 开发，仍然是一个需求量很大的语言。有Spring、MyBatis、Hibernate等一系列框架。
PHP
：仍然是非常需要的语言，它是当今 Web 开发的基石。可以学习的框架有
thinkphp
、yin
数据库 和 Web 存储
当学习构建 Web 应用程序时，在某些时候你可能想要在某个地方存储数据，以便以后再访问它。所以你应该很好地掌握与 数据库 和 存储 有关的以下主题
理解 关系形数据 的好处，例如：
SQL
 
学习 
NoSQL
 (非关系型) 数据库，例如：
MongoDB
 
知道如何使用你选择的后端语言连接数据库(例如： Node.js + MongoDB)
理解像 
Redis
 或 
memcached
 这样的内存数据存储的 好处 
掌握 Web storage(存储) 可以在浏览器中存储 session ，cookies 和 cached 数据
了解 
扩展数据库
 ，
ACID
 和 
ORM
 
HTTP & REST
HTTP 是互联网上的无状态应用协议――它允许客户端与服务器进行通信的方式（例如，您的 JavaScript 代码可以通过 HTTP 发起一个 AJAX 请求 ，来获取服务器上运行某些后端代码的结果）。你应该掌握的内容如下：
了解什么是 
REST
 ，以及它对 HTTP 和 web 应用的 
重要性
设计
 RESTful API 的 
最佳实践
 、
POST / GET
 请求
学习如何使用 
Chrome DevTools
 
了解 
SSL证书
 
HTTP/2 & SPDY
WebSockets
 ，Web Workers 和 
Service Worders
Web应用架构
 当你掌握了 HTML / CSS ，JavaScript ，后端编程 ，数据库 和 HTTP / REST之后，那么接下来就是棘手部分了。这时，如果你想创建一个有点复杂的 Web 应用程序，你需要知道如何构建代码，如何分离文件，在哪里存储您的大型媒体文件，如何在数据库中组织数据，在哪里执行某些计算任务（客户端 vs 服务器端）等等。
下面这些内容，可以帮助你了解如何高效地构建Web应用程序：
学习公共 
平台服务
 ，例如 
Heroku
 和 
AWS
 。Heroku 允许您轻松上传您的代码，并且不需要多少的配置 或 服务器维护就可以轻松启动和运行应用程序。AWS 提供了数十种产品和服务来帮助存储，视频处理，负载均衡等等。
针对应用和现代浏览器进行性能优化
微软的 
设计web应用指南
 。
MVC
 
最重要的是，你应该尝试和其他开发人员合作，看看 GitHub 上热门的项目代码库，并从高级开发人员那里学到尽可能多的东西。
Git
 Git 是一个 
版本控制系统
 ，允许开发团队中的开发人员跟踪代码库的所有更改。 Git 很重要，这能帮助你正确获取最新代码，更新代码，修复，并修改别人的代码，等等。
一些常见的 git 命令的参考列表
 
初学者使用Git和GitHub 的
教程
算法和数据结构
 虽然很多前端工程师、全栈工程师都觉得算法对他们来说无关紧要，但是作为一个合格的开发者，还是应该掌握基本的算法与数据结构，毕竟这才是编程的基石。
算法部分
二分搜索 Binary Search 
分治 Divide Conquer 
宽度优先搜索 Breadth First Search 

深度优先搜索
 Depth First Search
回溯法 Backtracking 

双指针
 Two Pointers 
动态规划 Dynamic Programming 
扫描线 Scan-line algorithm
快排 Quick Sort
数据结构部分
栈 Stack
队列 Queue
链表 Linked List 
数组 Array 
哈希表 Hash Table
二叉树 Binary Tree  
堆 Heap
并查集 Union Find

字典树
 Trie
学习掌握基础的算法知识，同时可以在 
LintCode 
刷题配合巩固。
总之，根据
一万小时定律
，熟练的掌握全部方向的知识内容，每天都花时间来钻研也得花10年左右的时间。所以，全栈工程师决不是一夜练成的，你需要打好技术基础，强化核心技能，并持续学习才能应对更多的挑战。
已经在准备面试了，但短时间内无法增加项目经验？项目缺少团队协作？
九章算法《
全栈开发基础项目课
》，专为转专业小白、零开发基础的同学准备。不仅有FLAG工程师亲自带你做项目，更能帮你搞定全栈开发 entry-level 的所有面试问题。
九章算法，硅谷一线工程师在线直播授课，已经帮助30000+人成功拿到心仪offer。
更多课程信息请访问：
九章算法","     看到已经有很多小伙伴分享了成为全栈工程师的答案，小编特在此贡献一篇全栈架构师的内容，以供大伙扩展：
 
老曹眼中的全栈架构师-博客-云栖社区-阿里云
看一下
工程师和架构师的区别
，简单地，
工程师关注的是功能和代码性能
，而
架构师关注的是业务和系统的性能等非功能性约束
。
全栈不是全能，只要覆盖了所使用的技术栈就是全栈
，例如LNMP，Linux＋Nginx＋Mysql＋PHP。
全栈架构师关注的是业务所采纳的全部技术栈，以及技术栈所涉及的系统性能、安全，高可用等诸多因素
。
全栈（full stack developer）好像起源于facebook中对工程师的一种称谓，
全栈架构师估计是老曹的杜撰
。全栈的出现大概有4个方面：
系统的性能瓶颈定位，团队间的沟通障碍，业务的救火灭火，以及团队的资源紧张
。尤其的小型创业团队，战力的有限会导致全栈的产生。
和习武一样，我想试图探讨一下全栈的套路，
很多能力不是通过
当头棒喝
产生的
。郭大侠需要降龙十八掌，令狐冲以无招胜有招也需要
独孤九剑
。我觉得全栈的技术栈可以主要分为3个切面：
技能，性能 和效率
。下面逐一简要阐述：
工其事必利其器，环境在效率中是第一位的
。具体可看《老曹眼中的开发学习环境》，不在赘述。
全栈应该掌握4种编程语言：Java，Objc/C/C++, Python，JavaScript。 语言没有优劣，不同语言有各自的胜场。
每个人都不是一个人在战斗，团队敏捷是整体效率的关键
。可以使用Trello或worktile之类的工具做协同，以Jinkens等工具支持CI或者CD，了解Scrum中什么是backlog，什么是UserStory，如何控制sprint。同时，
敏捷不是以质量的丧失为代价的
。
再进一步，就是
devops
了，可以参考《DevOps 全栈必备双刃剑》
从下向上看一下 全栈的所需技能，第一个就是
操作系统
，可参考《老曹眼中的Linux基础》。
数据是系统的核心，必须要了解
文件系统，对象存储和关系型数据库
，只有NoSQL至少要关注redis和mongodb，更多可以可参考《NoSQL与大数据》。
网络是一个覆盖更广的领域
，至少要了解七层协议模型，DNS，TCP/IP，HTTP，以及网络类型对网络编程的影响，会上只有简单举例，以后择机仔细探讨一下。
框架和库使用与所采用的语言是息息相关的，不同语言又有着不同的框架与库
，简直是浩如烟海，
对框架与库的选择主要从面相领域和面向场景入手，有比较才能有选择。
安全是个与非门，没事一切都好，有事就是大事。
基本上，可以从
传输，网络，代码和数据
四个层面掌握有关安全的基础知识。
至于架构方法，现在最热的莫过于微服务架构了。
服务的划分与业务密切相关，服务独立后要考虑服务的发现和服务间的通信，最后是服务治理，
可以从这四个方面专研相关的技术。
云服务的出现使得小团队可以做大事情
，关于混合云的解释可参考老曹的旧文《理解一下混合云》。 
从趋势来看，大数据必将成为工程师团队的重要战力，包括专业知识，数学算法，计算环境三个方面。
就计算环境而言，涵盖了Hadoop的生态圈，如果只有一个必备技能，老曹觉得就应该是Spark了，可以参考《架构大数据应用》旧文。 
个人以为，性能在诸多非功能性约束中第一重要，直接影响用户体验。首先要从业务和代码层面保障性能，而单元测试是一个必要条件。
正像PingCAP CTO 黄东旭所说的，“talk is cheap， show me the tests.""
接下来是运行时调优，或者认为是单机性能。从加载和依赖开始，到 JVM调优，再到Linux 内核参数调优。
 对于 JVM 调优，给朋友做个广告，中生代技术群中的 江南白衣 （公众号：春天的旁边）有一篇干货文章，特别向大家推荐。
数据库是整个系统中的慢性子，关注系统的性能，日志分析比不可少，LEK可能是第一首选。数据访问必须是高可用的，数据连接池的选择和使用都是考验功夫的。
 
缓存是减少负载，提高系统性的必备技术。可以从客户端，网络侧，服务端三个环节对缓存进行分类
，具体可以参考《老曹眼中的缓存技术》。
负载均衡同样是一种以空间换时间的技术
，具体可参考《老曹眼中的负载均衡》。
传输的性能可以依靠消息队列来提升，ZeroMQ可以用在系统内，而ActiveMQ是Java 程序猿的福音，对于高并发和高容错而言，RabbitMQ可能是不错的选择，Kafka是大量数据的传输必备
。
哩嗦，只是想探讨一下全栈的套路，也许这本身就是一个伪命题。
技术在过去的几十年里进步很快，也将在未来的几十年里发展得更快。今天技术的门槛下降得越来越快，原本需要一个团队做出来的Web应用，现在只需要一两个人就可以了。
同时，由于公司组织结构的变迁，也决定了赋予每个人的职责将会越来越多。尽管我们看到工厂化生产带来的优势，但是我们也看到了
精益思想
带来的变革。正是这种变革让越来越多的专家走向全栈，让组织内部有更好的交流。
你还将看到专家和全栈的两种不同的学习模式，以及全栈工程师的未来。
技术的革新史
从开始的CGI到MVC模式，再到前后端分离的架构模式，都在不断地降低技术的门槛。而这些门槛的降低，已经足以让一两个人来完成大部分的工作了。
CGI
二十年前的网站以静态的形式出现，这样的网站并不需要太多的人去维护、管理。接着，人们发明了CGI(通用网关接口，英语：Common Gateway Interface)来实现动态的网站。下图是一个早期网站的架构图：
　　当时这种网站的URL类似于： 
https://www.
phodal.com/cgi-bin/getb
log
(PS：这个链接是为了讲解而存在的，并没有真实存在。)
用户访问上面的网页的时候就会访问，cgi-bin的路径下对应的getblog脚本。你可以用Shell返回这个网页：
123 #!/bin/sh  echo Content-type: text/plain   echo hello,world  
Blabla，各种代码混乱地夹杂在一起。不得不说一句：这样的代码在2012年，我也看了有一些。简单地来说，这个时代的代码结构就是这样的：
　　这简直就是一场恶梦。不过，在今天好似那些PHP新手也是这样写代码的。
好了，这时候我们就可以讨论讨论MVC模式了。
MVC架构
我有理由相信Martin Fowler的《企业应用架构模式》在当时一定非常受欢迎。代码从上面的耦合状态变成了：
　　相似大家也已经对这样的架构很熟悉了，我们就不多解释了。如果你还不是非常了解的话，可以看看这本书后面的部分。
后台服务化与前端一致化架构
在今天看来，我们可以看到如下图所示的架构：
　　后台在不知不觉中已经被服务化了，即只提供API接口和服务。前端在这时已经尽量地和APP端在结合，使得他们可以保持一致。
软件开发的核心难题：沟通
软件开发在过去的几十年里都是大公司的专利，小公司根本没有足够的能力去做这样的事。在计算机发明后的几十年里，开发软件是大公司才能做得起的。一般的非技术公司无法定制自己的软件系统，只能去购买现有的软件。而随着技术成本的下降，到了今天一般的小公司也可以雇佣一两个人来做同样的事。这样的演进过程还真是有意思：
　　在这其中的每一个过程实质上都是为了解决沟通的问题。从瀑布到敏捷是为了解决组织内沟通的问题，从敏捷到精益不仅仅优化了组织内的沟通问题，还强化了与外部的关系。换句话说，精益结合了一部分的互联网思维。
瀑布式
在最开始的时候，我们预先设计好我们的功能，然后编码，在适当的时候发布我们的软件：
　　然而这种开发方式很难应对市场的变化――当我们花费了几年的时间开发出了一个软件，而这个软件是几年前人们才需要的。同时，由于软件开发本身的复杂度的限制，复制的系统在后期需要大量的系统集成工作。这样的集成工作可能要花费上大量的时间――几星期、几个月。
　　当人们意识到这个问题的时候，开始改进工作流程。出现了敏捷软件开发，这可以解释为什么产品经理会经常改需求。如果一个功能本身是没必要出现的话，那么为什么要花功夫去开发。但是如果一个功能在设计的初期就没有好好设计，那么改需求也是必然的。
敏捷式
现有的互联网公司的工作流程和敏捷软件开发在很多部分上是相似的，都有迭代、分析等等的过程：
　　但是据我的所知：国内的多数互联网公司是不写测试的、没有Code Review等等。当然，这也不是一篇关于如何实践敏捷的文章。敏捷与
瀑布式开发
在很大的区别就是：沟通问题。传统的软件开发在调研完毕后就是分析、开发等等。而
敏捷开发
则会强调这个过程中的沟通问题：
　　在整个过程中都不断地强调沟通问题，然而这时还存在一个问题：组织结构本身的问题。这样的组织结构，如下图所示：
　　如果市场部门/产品经理没有与研发团队坐一起来分析问题，那么问题就多了。当一个需求在实现的过程中遇到问题，到底是哪个部门的问题？
同样的如果我们的研发部门是这样子的结构：
　　那么在研发、上线的过程中仍然会遇到各种的沟通问题。
现在，让我们回过头来看看大公司的专家与小公司的全栈。
大公司的专家与小公司的全栈
如果你经常看一些关于全栈和专家的技术文章的时候，你就会发现不同的人在强调不同的方向。大公司的文章喜欢强调成为某个领域的专家，小公司喜欢小而美的团队――全栈工程师。
如我们所见的：大公司和小公司都在解决不同类型的问题。大公司要解决性能问题，小公司都活下去需要依赖于近乎全能的人。并且，大公司和小公司都在加班。如果从这种意义上来说，我们可以发现其实大公司是在剥削劳动力。
专家
我们所见到的那些关于技术人员应该成为专家的文章，多数是已经成为某个技术领域里的专家写的文章。并且我们可以发现很有意思的一点是：他们都是管理者。管理者出于招聘的动机，因此更需要细分领域的专家来帮助他们解决问题。
全栈
相似的，我们所看到的那些关于成为全栈工程师的文章，多数是初创公司的CTO写的。而这些初创公司的CTO也多数是全栈工程师，他们需要招聘全栈工程师来帮助他们解决问题。
两种不同的学习模型
而不知你是否也注意到一点：专家们也在强调“一专多长”。因为单纯依靠于一个领域的技术而存在的专家已经很少了，技术专家们不得不依据于公司的需求去开拓不同的领域。毕竟“公司是指全部资本由股东出资构成，以营利为目的而依法设立的一种企业组织形式；”，管理人们假设技术本身是相通的，既然你在技术领域里有相当高的长板，那么进入一个新的技术也不是一件难的事。
作为一个技术人员，我们是这个领域中的某个子领域专家。而作为这样一个专家，我们要扩展向另外一个领域的学习也不是一件很难的事。借鉴于我们先前的学习经验，我们可以很快的掌握这个新子域的知识。如我们所见，我们可以很快地补齐图中的短板：
　　在近来的探索中发现有一点非常有意思：如果依赖于20/80法则的话，那么成为专家和全栈的学习时间是相当的。在最开始的时候，我们要在我们的全栈工程和专家都在某个技术领域达到80分的水平。
那么专家，还需要80%的时间去深入这个技术领域。而全栈工程师，则可以依赖于这80%的时候去开拓四个新的领域：
　　尽管理论上是如此，但是专家存在跨领域的学习障碍――套用现有模式。而全栈也存在学习障碍――如何成为专家，但是懂得如何学习新的领域。
解决问题的思路：不同的方式
有意思的是――成为专家还是成为全栈，取决于人的天性，这也是两种不同的性格决定的。成为管理者还是技术人员看上去就像一种简单的划分，而在技术人员里成为专家还是全栈就是另外一种划分。这取决于人们对于一个问题的思考方式：这件事情是借由外部来解决，还是由内部解决。下面这张图刚好可以表达我的想法：
　　而这种思维依据于不同的事情可能会发生一些差异，但是总体上来说是相似的。当遇到一个需要创轮子的问题时，我们就会看到两种不同的方式。
对于全栈工程师来说，他们喜欢依赖于外部的思维，用于产生颠覆式思维。如Angular.js这样的框架便是例子，前端结合后端开发语言Java的思维而产生。而专家则依赖于内部的条件，创造出不一样的适应式创新。如之前流行的Backbone框架，适应当时的情况而产生。
全栈工程师的未来：无栈
全栈工程师本身不应该仅仅局限于前端和后台的开发，而可以尝试去开拓更广泛的领域――因为全栈本身是依赖于工程师本身的学习能力，正是这种优秀的学习能力可以让他们可以接触更广泛的知识。
全栈的短板
如果你也尝试过面试过
全栈工程师
，你会怎么去面试他们呢？把你知道的所有的不同领域的问题都拿出来问一遍。是的，这就是那些招聘全栈工程师的公司会问你的问题。
人们以为全栈工程师什么都会，这是一个明显的误区――然而要改变这个误区很难。最后，导致的结果是大家觉得全栈工程师的水平也就那样。换句来说，人们根本不知道什么是全栈工程师。在平时的工作里，你的队伍都知道你在不同领域有丰富的知识。而在那些不了解你的人的印象里，就是猜测你什么都会。
因此，这就会变成一个骂名，也是一个在目前看来很难改变的问题。在这方面只能尽可能地去了解一些通用的问题，并不能去了解所有的问题。在一次被面试全栈工程师的过程中，有一个面试官准备了几个不同语言（Javascript、Java、Python、Ruby)的问题来问我，我只想说Ciao――意大利语：你好！
除了这个问题――人们不了解什么是全栈工程师。还有一个问题，就是刚才我们说的成为专家的老大难问题。
无栈
让我毫不犹豫地选择当全栈工程师有两个原因：
这个世界充满了未解的迷，但是我只想解开我感兴趣的部分。
没有探索，哪来的真爱？你都没有探索过世界，你就说这是你最喜欢的领域。
当我第一次看到全栈工程师这个名字的时候，我发现我已然是一个全栈工程师。因为我的学习路线比较独特：
中小学：编程语言 -> 高中：操作系统、内核、游戏编程 -> 大学： 硬件、Web开发 -> 工作：后端 + 前端
而在当时我对SEO非常感兴趣，我发现这分析和Marketing似乎做得还可以。然后便往Growth Hacking发展了：
而这就是全栈学习带来的优势，学过的东西多，学习能力就变强。学习能力往上提的同时，你就更容易进入一个新的领域。
全栈工程师，英文 Full Stack developer，是指那些掌握多种技能，并能利用多种技能独立完成产品的人。当然，现在「全栈工程师」很吃香，非常吃香！这是因为在移动互联网时代，IT 系统变得愈加复杂，需要拥有全局思维的工程师来搞定各种「疑难杂症」。不仅要玩得转前端，还要搞得定后端，总之各种技术都懂，所以其重要性可见一斑。
近日，移动开发精英俱乐部围绕「如何成为一个全栈的工程师？」进行了讨论，主持人是优才学院的创始人伍星老师，让我们一起看看大神们的精彩言论吧！（本文系国内 ITOM 管理领军企业 
OneAPM
 工程师整理）
程序员眼中的「全栈」
伍星-优才创始人
：全栈，最早来自于 Facebook 的「我们只招全栈工程师」，从表面看是指技术栈，是完成一套产品所面要的全部技术和技能。谷歌在它的书中也提出，它们只招创意型人才，其实这是一致的、相通的！
饶培泽
：全栈，在我看来是一种态度，无路遇到何种问题都能积极的去解决。全栈，也不是说会什么，而是因为有好奇心与驱动力，所以什么都想搞明白，学习起来自然能快速上手。
iOS小码哥
：全栈，也可以说「我是一块砖，哪儿需要我，我就往哪儿填。」代表着快速学习的能力和超强的适应能力。
梦航
：全栈，在一定程度上能更好的做出架构，减少维护成本。
卓竞劲
：我支持思想和知识层面的「全栈」，而非刻意技能上的全栈。
饶培泽
：其实，能从前端写到后端的人不少，但是能专职来做吗？这么说吧，很多公司的后端都能写前端，但可不敢让他们写产品级别的代码。如果后端人才如果能去了解前端的知识点，合理去进行整合互补，这样是我们所鼓励的。
药交汇
：全栈围绕产品服务，重点是考虑问题的角度、广度。个人理解也可以看成责任感的一种体现，前端、后端都可以也不代表全栈。只不过是围绕着问题的解决方案，其根本还是本着对一件事情负责的态度，展开全方面的跟踪。
伍星-优才创始人
：从谷歌对创意型人才的描述可以看出，这更多体现在能够主动地承担工作和解决问题。比如谷歌讲过一个例子，Adwords 是几个非相关工程师主动解决了小问题带来大收益的。
Facebook 的人才培养一开始是不分工的，「新兵营」之后才分工，并且轮岗很多，这中间暗含了：学习能力要相当强，我想学什么，都能学什么，需要我做什么，都能胜任。
所以我们对全栈提出如下见解。首先要技术全面，作为全栈工程师，其技术当然要比较全面。从前端到后端、从运维到优化、从 PC 到移动都难不倒。 但又有自己比较精通的一方面。也就是说，作为全栈工程师既要有「专深」，同样也要有「广博」，这样才能在解决问题时不受局限，才能融会贯通。
第二就是思维和心态。全栈工程师以积极主动的姿态来面对和解决工作中的问题。以全局的观点来看待自己所从事的项目， 而不只是自己负责的一小部分。以做成产品、做成一件事的观点来看待整个开发流程，而不仅仅是技术实现。 因为只能这样的心态和观点，他才会积极主动地去学习其他技术，用其他技术解决问题
第三是上升能力，全栈工程师并不意味着全能，什么都会。但是全栈工程师有良好的基础技能。 这个技能，既包括计算机科学的基础，也包括英语基础，有了这个基础， 加上积极的态度，开放的心胸，就能快速地学习所需要的技术，比如像 Swift 语言，那都不是事儿。 并应用在所需要的开发工作中。
第四就是职业价值，像 Facebook 说，他们只喜欢全栈工程师，创业公司也会说，我们需要全栈工程师。无论是在大公司，还是创业公司， 全栈工程师都将成为抢手人才！那是因为，全栈工程师不但技能全面，而且心态积极，学习能力强！
伍星-优才创始人
：所以全栈不是一种技能，而是一种能力。学习能力，开放心态是优先的！
李睿君
：其实后面有段时间觉得全栈需要一方面熟悉自己本身专业的领域，另一方面需要关注另一段的技术，这样在需要另一端技术，或是沟通时都能有帮助
着建彬
：对感兴趣的东西不要当成「工作」来做，其实兴趣才是最大的动力。我觉得全栈应该是由「兴趣」驱动的。
伍星-优才创始人
：即使是领域专家，他对别的也会有了解和研究的。优秀的技术人员，对所有的技术应该有一种天然的好奇心和折腾劲
药交汇
：我前端和后端都经历过，其实，在前期人员不全的情况下，结合业务并外出调研梳理了产品线框图、PRD、流程图，到制定了设计规范，到协调资源，然后制定研发周期，最后到输出...... 曾一度以为这就是全栈，但是后来思考，这些只不过是本着对事情负责的态度，才驱动做了很多研发之外的事。就算一个人的技术全栈精通也要服务于根本产品。
伍星-优才创始人
：项目进度和管理，比全栈本身要难。因为技术还是死的，人是活的，而且多种多样的。就像业务架构师，本身曾经技术应该不错，即使学新技术，应该也是有特殊长处和见解的，不过不学不写罢了。这种人是标准的技术 leader ，技术能力并不一定是以某特定语言的写码能力而界定。
一般而言，全栈工程师在产品和沟通这块都有优势，由于技术全面，他能和各方沟通的比较愉快 。甚至和产品经理也沟通好。我也算是一个全栈，此前和各个产品经理沟通都很愉快。因为他不理解的地方，我会和他讲清楚，分析清楚，为什么这个不能做，为什么那样做不好，那样做更好，有理有据，其实，产品经理也是讲道理的，不像我们在网络上经常「吐槽」的那样。如果再加上本身的技术声望和良好沟通的方式，程序员和产品经理相处其实会很和谐的。
如果成为一个全栈工程师？
程序员：如何成为一个全栈的工程师？-博客-云栖社区-阿里云
王威
：我的理解是，不仅自己领域的精通，然后其他部分也应该快速学习。在我看来，如果想成为全栈的话，还得靠上项目了。在普通公司的话，一般每个人只关注自己的领域，对跨领域的项目一般不会碰，可以自己利用业余时间来写，比如原本做APP的，有空可以写一下后端的东西，其实开始那一步比较困难。
张洋
：全栈不只是技术，还需要心态、责任等方方面面。
江月
：我觉得 facebook 要求全栈，并不是希望程序员技术全面但不精通。而是至少有一个领域精通，而且可以快速研究另外一个领域的技术点。
伍星-优才创始人
：能成为全栈，意味着技术能达到一定高度，而高度，肯定是以长处见知的。我个人更倾向于认为，一专多能。
王威
：成为全栈的话，还得靠上项目了。。。在普通公司的话，一般每个人只关注自己的领域，对跨领域的项目一般不会碰，自己私下来写，比如原本做 APP 的，自己私下写后端的东西，其实开始那一步比较困难。
药交汇
：关键是责任感的转变，由「被动」到「主动」，才能实现自我超越。
拯救与逍遥
：我个人看法，不是先有了「我要成为全栈」的目标，而是对技术的好奇和追求，以及积极应对当前业务发展的不断挑战，最终才能锻炼出了全栈。
薄建业
：我觉得，最好的方法就是项目驱动；从另一方面也说明，说为全栈，在一定程度上，也是被逼出来的。
王威
：我比较赞成项目驱动型。比如 APP 端的，例如做个类似于云笔记的软件，那么后端数据该怎么保存，接口该怎么定，该用哪种语言来实现后端，在分析你想要的目标的时候就能找到该用哪种技术该学哪种技术。比如后端用 PhP 写，这时候就会推动自己去学 PHP，比如自己是做安卓，那么语言衔接上，有可能选择 JAVA 做后端，这时候就学 J2EE 的东西，围绕这个需求来实现，然后学数据库......其实说到底还是得有」目标项目」来进行推动。
林曦
：后端概念太泛了，不同业务需求和规模需要的技术支撑完全不同。
王威
：比如做高并发，可以 NodeJs 、 Golang 、 Erlang ，或者干脆用 Java、PHP 等等。其实做项目的第一步，后端写出业务服务接口，在业务量上来之后考虑比如性能优化，比如负载均衡，或者再比如后端架构分层等等。
文彦峰
：其实，接入也有很多要做的，一般要和终端一起做，路由、负载、流量控制、安全、监控、旁路、优化 TCP 协议栈、内核参数再到硬件的支持等等。做业务，比如网关、鉴权、微服务框架、服务治理、缓存、消息中间件；存储，单机房如何保证数据不丢，多机房是单向同步，双向同步，出了异常怎么通过日志恢复，数据的检查，静态检查点的选择。怎么做分片，怎么扩容不影响原来的分片？
王威
：所以说到底还是得有这个项目需求，围绕着需求来分析需要的技术，然后再研究技术了。感觉纯按照兴趣来学新的技术，作为对这一个技术有个优缺点简要了解，在需要的时候能快速学习。我个人还是觉得，想成为一个「全栈」，就找一个想法并实现它。
周渊
：比如，你觉得 NBA 好看，想要做一个 APP 能提醒比赛，那么每天下班后，没事写几个小时代码，三个月后，你就会发现做成了。
林曦
：我觉得做个「入门型」的全栈比较容易，真正能做到都有一定深入的了解很难，融会贯通更难。
拯救与逍遥
：先自学基础入门，进阶的话，可以随公司项目，初期不能直接参与，但是我们可以主动思考技术方案，然后参照其他同事最后落地的方案，对比总结。能力慢慢提升，真正上手的机会总会有的！
周渊
：最重要就是，Just Do It ！
林曦
：不过大公司相对有一个好处，就是能遇到「牛人」的概率也比较高，所以开发过程中，某一个部分遇到瓶颈的时候想要找人讨论或者请教，找他们也是比较好找的。
周渊
：高人点拨，确实重要，但是建立在你入门的基础上。
拯救与逍遥
：很多时候，我们不能做最想做的事情，而且要停下来推动一下，阻碍我们继续前行的事情。但是，有些坑，有些历练是必须的，别人说一万遍，我们还是得自己历练。而且很多技术选型，都是在真正落地之后，才暴露出问题。
王威
：采坑是必然的！运气好的话，采坑的代价低，运气不好的话，采坑代价可能毁掉整个项目。不过有些坑，有可能是在技术选型的时候就会暗含的，这个时候确实不好找。
王威
：我们业务在往图数据迁移的时候也踩了很多坑，因为我们是社交软件，所以很多需求是基于用户关系的，比如喜欢、不喜欢、好友等等。。。最开始觉得 
neo4j
 挺方便的，导入数据的时候发现，免费版就是个坑爹的玩具。。。收费版貌似5千刀一个月还说多少，巨贵。。。
王威
：创业有这个好处就是人少，一个人当多个人用，这个时候就有很多机会去摸新的东西，不过缺点就是没人带，自己摸石头采坑。。。
王威
：不过对于我来说收益大于采坑风险。。。所以还是得围绕这个需求，一圈一圈的挖掘更好的解决方式，这个是一种学习的过程。尤其是在风险可控范围内，绝对鼓励大家尝试新的东西。
到最后你的选择很多时候依赖你团队的水平，怎么把这些人水平带起来，你这些才能做细
最好的成长就是在业务中成长
林曦
：架构也是活的，需要不断生长，不断修改。不过，前期埋的坑也只有后期加班吞了，没有一劳永逸的架构！
董飞
：我觉得重要的还是分享，别人帮你填了坑，你也可以帮别人填坑。而媒介就是博客，大家可以互帮互助。
王威
：说到写博客，我觉得可以把思维给规范化，把想法记录下来的同时还能注意到以前没注意到得细节，绝对是学习新姿势最必要的补充。
伍星-优才创始人
：曾经，我就主动地提出来帮公司承担一些的运维方面的事情。然后就自己学习，请教，后来很自然地就成为全栈了。当然，全栈并不意味着上班学别的，我们上班时间把公司的事情做好，这才是成为全栈的前提。
伍星-优才创始人
：还有一点，就是我们在写代码的过程中，要考虑怎么优化，怎么写得更快更好，而不是像「搬砖」似的，简单的重复。「搬砖」工作很快就会被淘汰掉，积累核心竞争力才是发展的根本 。
王威
：比如做APP，在写从服务端拉取数据的时候，就可以考虑一下他们为什么要提供这样的数据结构？这样的接口如何进行实现的？有这些疑问的时候，就会促进自己去看看去了解一下相关的知识，这样才能不断通向全栈之路。
当然，完成是一码事儿，完成好是另一码事儿。全栈的意义不是全都泛泛地去做，而是在做深自己的领域同时，也能借鉴其他的技术，至少在团队开发时候沟通成本会减少很多。
赵建彬
：其实，产品并不会关心你代码怎么写，关键自己要写出让自己觉得满意的、高质量的代码。
薄建业
：全站人才可以站在更高的视角，提供「一揽子」的解决方案，避免踩深坑！
文彦峰
：热衷于技术，成全栈是早晚的事儿，技术全面某方面又比较深入，自然能解决别人解决不了的问题，能做别人做不了的事情，团队中的影响力，行业中的影响力，也自然就有了，形成正向循环，还是挺不错的！
伍星-优才创始人
：就像罗辑思维跨年公开课说的那样，核心竞争力，就是你的不可替代性。我们不能单纯地说「全栈」好，很多初学者会被误导，是因为他们不了解什么是全栈，怎么才能成为全栈。就像武功也有练「走火入魔」的。
其实，加入一个快速成长的团队创业。是成为全栈的最快捷途径。这个团队，也可能是大公司内部创业团队。也可能是大家都把工作当作创业的团队。而没有好奇心，没有折腾劲，没有学习能力，没有开放心态，是不可能成为全栈的！
http://
quanzhan.ucai.cn/intro
 （本文是优才学院创始人伍星对全栈的理解，发布后2014年4月份，到现在也没有改变，欢迎大家阅读。）","Full Stack Developer 在国内不被接受的一个主要原因是公司缺乏稳定的 T 线（技术职位晋升路线）。
太多有才华的人写了几年代码最后都去做了管理。而今天的网络相关技术，聪明又能持续学习的人，在三年之内可以在一个领域做到很高的水准。
那么如果你做五年，十年甚至十五年呢？
我以为你成为 Full Stack Developer  是很自然的选择，而且可以跟随最顶尖的技术。这种人并不罕见，我认识的人中  
@徐 乐乐
 就是个例子。
相信 Full Stack Developer 的核心并非否定团队和协作，而是更多的体现在架构设计，快速原型和 TroubleShooting 方面。
随着今天的分层越来越清晰，平台和语言越来越有特点，更加全面的技术人员可以根据不同的语言搭建整个架构。
数据一致性要求高？那么使用事务管理久经考验的 Spring？还要考虑 scale ？那么放在 Oracle 里面做还是放在 Application Server 的 Transaction 管理里面做？简单请求的高并发？那么 Node.js 也许不错。 Web App 快速原型，那么 Rails 也许不错。邮件模板和自动发送？ PHP 有现成的东西为什么不用？前端数据和交互复杂？ 为什么不试试 emberjs （ PS ：选前端框架对于架构人员来说简直像女人逛银座一样令人兴奋。甚至有人用几乎所有的框架写了同样的 Web App 来供他们试用： 
TodoMVC
）？想绕过苹果的 App Store 的审查机制频繁发布？可以考虑在 iOS Apps 里面嵌入 HTML5 。
Full Stack Developer 在快速原型上也很有优势，因为省去了大量的管理和沟通成本。而且，这并非就意味着一定在代码质量或者测试上有缩水。 
MVC 前后都可以用。一个写过 test_helper.rb 的人做前端，一定会搜索 javascript TTD 。同样，用过 javascipt lint 的人一定可以找到 stylecheck 。语言和平台会变化，聪明的方法和工具都是共通的。懂得基本的字体知识和排版审美难道和 CSS 不是天生一对？
TroubleShooting 方面 Full Stack Developer 同样优势巨大。
服务器压力太大未必需要通过后端解决，优化个 SQL 写个 Hint 是选择，而拿一部分数据和运算到前端也许是更加合理和低成本的选择。一个系统运行多年，最后遗留的问题很可能需要对业务和技术都有深入理解的人才能解决。
从以上内容可以看出， Full Stack Developer 并非杂而全 - Facebook 也不会雇庸手。他要求的是一种更加全面的深入。 一方面，他是技术人员不断学习的结果。另一方面，他也是对自己事业的一种责任：
技术人员的价值不是指派做了一半的 issue 给队友，而是更快更好的
搞定事情
。","UPDATE
：这篇答案写在问题添加了“补充说明”说明之前，对于“Full Stack Developer”的定义是我根据自己的理解来写的，现在看来我（以及另外一些朋友）的理解和补充说明里引用的那一段是
不同
的。所以这个答案与题目描述并不相符，仅供参考，请大家注意。
简单来说我以下所说的 FSD 可能更像是“全才大牛”，对任何一个领域的了解
都达到
了该领域的专业人士的平均程度，更像是 Engineer × N ；而补充说明以及 庄生 （抱歉由于重名太多不知道该at哪一个）、
@尤雨溪
 等朋友所说的 FSD 则是各领域都有一定的了解（但不必达到该领域的专业人士的水平），足够独立完成一个项目的各个方面，强调了解新领域的勇气和能力（前提自然是有充分的兴趣）。
对于后一种 FSD ，我是十分赞同将其作为一个目标而奋斗的，理由和方法其他几位也说了很多的（我很赞同独自完成一个项目，途中了解些感兴趣/有用到的、但之前不了解的新领域，永远保持一颗好奇心，真的受益匪浅）。
而对于前一种 FSD （也是我下面即将讲到的），先声明我绝对不是也不想“装逼”，做以下几点说明：
对于各个领域来说，我所举的那些例子都是我在对该领域“简单了解”之后接触到的很有限的一些概念、技术，是一些例子而已。该领域的大部分专业人士所能够做到的，但绝不是说懂了这些就是专业人士，也更谈不上“炫耀”（我自己也不会啊，所以有错误肯定在所难免，还望指正）。
这种各领域都达到专业水平的全能大牛（至少在我看来如此）真的存在么？是的，我见过一些。他们的知识广度和深度让我由衷佩服。而他们中的很多其实在工作中也只是某个领域的专业工程师而已。
以我有限的知识水平和学习经历来看，能够做到这个程度需要付出极大的努力。而所谓的“给大家泼冷水”其实倒不如说是给自己泼冷水――我也一度觉得似乎能一个人搞定一个项目（就像下面即将谈到的那个“反例”一样）就是什么都行的 FSD 了，但遇到了他们之后，我真的意识到差距真的不是一般大。因而我才产生了疑问：在我短暂的大学生涯里，把这样的“
全栈
”当成奋斗目标真的可行、值得么？是不是先把一件事情做好更好呢？
最后，下面的回答是以“基于 Web ”的全栈“开发者”例的，所以有些朋友吐槽怎么不说 native app 、怎么不说 PS 、画画之类的……好吧，可能是我太年轻了。
====================
窃以为 full stack 不是那么简单的事情。当然，不同的地方可能有不同的标准，且听我慢慢道来。
既然大家都在以 Web 为例，那我也说 Web 好了。不过事实上 full stack 也有可能是其他方面的。
租个 VPS ，从装系统配环境开始，然后拿个 PHP Python Ruby Nodejs 什么的写个后端（少不了用一些框架吧， 后端框架多如牛毛，不说 PHP ， Python 用个 django 、 Ruby 弄个 
rails
 ，都挺方便吧），再给它撸个好看的页面（表现层多半也会用个 
bootstrap
 之类的，如果设计能力强一点的话就用一些更轻便的 helper frame 然后主要自己手写；逻辑控制层高端一点弄个 backbone 甚至 angular 之类搞个重 AJAX 、带前端模板及路由的新潮 HTML5 应用）。弄好以后上线，性能出问题了，看看日志 Google 一番调调参数，甚至多买一两台 VPS 来弄个负载均衡什么的。再要不，我们换成实体机，然后顺便玩玩网络和虚拟化什么的？
这样算不算 full stack 呢？也许在一些小公司（不过现在很多互联网创业公司水平都很高，所以也不能完全看大小）可以算是了。但在真正高水平的公司，以上的任何一点都达不到相应领域“工程师”的标准。
装个系统调调参数甚至弄个简单的负载均衡就叫运维了？你确定这不是网管？从几台机器到成百上千台机器是有一个量变到质变的（虽然经过这个质变以后，对于运维工程师来说两者就差别不大了），更别说弄个机房，搞个异地数据中心什么的。不说CCNP，CCNA总该有吧？再者，如果不说这么大（这么大了可能就涉及到“架构师”了），往小一点说，也有很多可深挖的：性能调优只是根据网上的文章随便调调参数？我见过不少牛逼的 Web 运维都读过 Apache 和 nginx 甚至部分 kernel 代码。没有自动化的监控程序和运维工具难道得死死守在机器前一遍遍地敲命令？合格的运维不但熟练使用已有的工具，还会根据需要自己写脚本、工具，因为现实情况太复杂通用工具不一定适合。很多公司里，运维还要兼顾安全问题，那么又是一个大坑。备份、冗余、风控个个门道都很深。
再说后端。会用 
django
 或者 RoR 写点东西很厉害？这些本来都是 RAD 框架，就是拿来快速开发、快速上手的，降低了门槛。但不同的程序员编程功底和代码质量还是会对最终成果造成很大影响。滥用 ORM 导致性能低下的例子我就不多说了。明明用了这样的框架还能写出带有 SQL 注入的程序也不少见，有的甚至还存在逻辑安全漏洞，至于什么加盐、防 CSRF 、 XSS 、 replay attack 、 session fix 、应用层 DoS 等等，多少人都是只听说过名字知道个大概然后用一个“厉害”的框架就以为一劳永逸？不知道原理也没看过框架代码，不知道框架到底是怎么实现的、是否有一定局限……再说软件工程方面。写几个测试数据就叫单元测试了？提前写测试数据再开发就成 TDD 了？三天两头重构就叫敏捷了？ QA 、版本控制、协作、文档，都不是那么简单的事吧。
然后说前端。 HTML CSS 本来就是以方便表示内容和布局样式而开发的，只是“会写”应该不算什么难事吧？何况还有各种布局、排版库。 JS 灵活得很，有一点 C 语法基础的人学起来也很快，感谢 jQuery ，就算是不知道什么是闭包、不知道 JS 原型继承等等的三脚猫功夫也能实现大多数需求了。那么这样就是前端工程师？真是这样的话为何前几天知乎还有人问好的前端工程师为什么这么难找？能写出在所有浏览器表现一致并且方便维护的样式需要不少经验积累和勤奋实践，对浏览器渲染原理的了解也不可少。这还只是第一步，加上 JS 这玩意儿以后复杂度其实陡然上升了。在一个真正的大项目里，要保证各个组件正常运行不是一件容易的事， JS 本来就缺乏一些“软件工程”特性，导致大型代码组织不便，糟糕的 JS 程序很容易就污染了命名空间、搞错了作用域、漏掉了异常、弄错了类型、在异步和回调之中迷失……一不小心，就搞挂了页面，调起来还麻烦（就算现在有了 Chrome ）。这还没算上性能、兼容性、安全等等问题呢。这也是为什么前端工具/技术特别多的原因之一。好的前端工程师不但紧跟技术前沿，还乐于知道这些牛逼的技术都是怎么实现的，然后灵活运用。
可能有人会说人的精力有限， full stack 有了广度自然要牺牲一下深度。那么我想说，再怎么牺牲深度，如果各领域都像上文举的反例那样，那肯定是不够的。那样可能只算是一个爱折腾的 geek 而不是工程师。我一个大二学生就能很好地完成开头提到的情景，并且还可以再深一点（比方网络方面有个差不多CCNA的水平和一些经验， PHP 自认为还是比较扎实的= =，对于安全、性能优化、分布式等方面也有一些了解……），但我也只觉得自己大多数时候还只是“折腾”而已，还有太多不足和有待提高之处。事实上，上述任何一个领域中的真正的工程师都肯定能凭借自己的学习能力和极客精神轻松地在业余时间完成开头所说的那个例子：看看 github 上那些有趣的个人开源项目和搭建起来的 demo 吧，大部分作者的本职应该都只是前端、后端或其他等等的其中之一。更不用说还有很多工程师的博客也是自己写（我是指写一个博客系统）、自己搭的。
full stack
 一定是很难的。其实我自己作为一个互联网领域的学徒，也面临着这样的困惑：我发现自己什么都会一点、什么都不算精（按照某些标准大概已经算是一个“full stack”了吧）。到底以后应该怎样呢？是朝真正的 full stack 努力还是好好专精一个？看了不少招聘要求，现在就算是创业小团队也很少会直接招 full stack 的，所以觉得大概是先做好一个性价比高一些？不知道题主为何想要成为一个 full stack 呢，是因为已经是某一领域的工程师想要做做其他方面么（这个也会影响到“怎样成为”这个问题）？
不好意思，似乎跑题了。到最后自己还反倒提了个问。只是希望抛砖引玉，更踏实的回答多一些，不要太浮躁，把全栈说得太过轻易。
手机打字，如有差错还望指出，谢谢。","突然就想起这个表格了
http://
static.icybear.net/
[CN]Programmer%20competency%20matrix.htm
如果说要想全部达到
level3
，没有三四十年怕是不行吧，到时候还会有新的知识，永远达不到的。
所谓的全栈都是资本家们根据他们的业务自我衡量的，骚年们还是从基础好好打起吧。基础好，学习就快，所谓阳光下没有新鲜事嘛，学计算机你懂得的。","从全栈工程师到全栈员工，软件吞噬世界的步伐又进了一步。以下是 Chris Messina的
文章
在我离开 Google快两年之后，我开始意识到职业环境正在发生的变化。传统的管理纪律正在渐渐瓦解。要想在
职场
上成功，需要的技能比以往更加多样而难以定义。如今，要想在职场上有所成就，你必须成为一个真正的博学者，成为一名全能全栈员工。
什么是全栈员工（full-stack employee）？
就像“
全栈工程师
（full-stack engineer）”和“全栈创业（full-stack startup）”一样，全栈员工（full-stack employee）拥有超强的综合技能，有着无法估量的价值。他们可以在快速演进、变革的技术浪潮中如鱼得水。他们可以在事实稀缺、观点横飞的过剩信息中凭直觉做决定。全栈员工能够熟练运用设计语言，明白使用卡通字体无异于犯罪行为，轻车熟路地嘲弄Keynote、Sketch抑或是Skitch。他们清楚用户界面（UI）和用户体验（UX）的区别。
他们可以和人讨论工程问题，能搞清楚算法、编程，也能理解前端的等级和后端的等级根本不是一回事。虽然他们可能并不亲自编程，但他们知道GitHub、StackOverflow都是做什么的。如果必要，他们会暴力破解一段“复制粘贴”的脚本，在CSV文件中进行基础分析。
他们是最新锐的社交应用的用户，深谙自我推广 之道。他们既可以在听众面前循循善诱地耐心讲故事，也可以在看了3分钟
kickstarter
视频后就能指出：亮明要点的时间不能长于一段Instagram、Vine短视频。注意力就是这个时代的硬通货。
全栈员工对新的想法、最棒的实现路径、提升生产力和与愉悦度的事情有着“贪得无厌”的胃口。他们对世界及其运转规则充满好奇心，想知道如何留下自己的印记。正是这一点使他们与过去时代的人们区分开来。开始一份工作时，全栈员工不会戴上“眼罩”埋头苦干，而是始终与行业的发展保持同步，因为他们清楚：变革往往出现在边缘地带，不能只盯着脚下的一亩三分地。
一名全栈员工是什么样子的？
有了24小时在线的移动设备，工作和非工作之间的界限正在模糊，既然工作正在变得碎片化，全栈员工要清楚地意识到自己的生活方式也要随之变化，比如使用整体式单色衣柜、功能明确的厨具。
成为全栈员工意味着要在两极之间来回切换。他们既要适应单兵作战，自给自足（比如自己安排时间，使用自己的设备工作），也要能和团队高效协作。过去，在大型团队中，往往需要有一名 IT经理来决定使用何种技术。如今，随着人们越来越多地使用个人设备工作，员工需要自己来搞定跨设备、跨平台沟通等问题。就拿企业协作工具来说。Slack可以整合所有东西，而微软却只对自己平台上的工具开放特权。如果你不能接入其他人的 API，你已经落后于时代了。全栈员工也是如此――他们至少应该熟知所有最新的应用，这样才不会落伍出局。
全栈员工必须要在自己的领域有深刻的洞见，同时也要机动地应对优先事项的转换，胜任不同的安排。组织的扁平化已经不是新现象，变革的动力可能来自顶层，也可能来自底层，有时候需要个体来决定事情的优先级。
现场服务工程师
（FSE，Field Service Engineer）应该遍布组织内部，却又不能分布的过于稀疏。即使不用监控每一位员工，他们也应该知道每一个人在做什么，保证他们在不熟悉的事情上不会手足无措。
要成为一名全栈员工不是一件容易的事，回报却也很丰厚。首先，他们可以更自由地按照自己的方式、在自己喜欢的地方（Teleport等服务可以帮助他们找到价廉的工作地点）、喜欢的时间工作。他们可以使用最新的工具，自给自足，自我管理。由于他们的工作涉及多领域、多学科之间的协作，会带来更宽广的视野，更丰富多彩的经历。在组织内部，他们的影响力也会不断上升，对组织的成败也将担负起更大的责任，团队的成功与否更加休戚相关。
这对雇主和管理者意味着什么？
对于企业和管理者来说，在人力市场上争夺全栈员工意味着很多准备工作。首先，你们做好准备来吸引、留住这些人才了吗？其次，你们团队的工作风格是否明确，你们对远程办公的支持如何？再次，你们允许的工作时间，支持员工自主安排工作计划吗？最后，你们会给他们留出健身、养生、陪伴家人的时间吗？
Google虽然充分考虑到了员工的健康、精神需求，但反过来也要求员工高度负责。 Google的员工可以以任何方式在任何时间、任何地点工作，只要能最大程度发挥创造力。但它同时希望员工能够随时参加一场临时安排的快速议事会。你的团队准备好了吗？
如果你还没有尝试过，不妨一试，来感受下”全栈员工“的工作环境是什么样子的。不同背景的人们在一个公共空间内彼此协作。他们一直在线，通过Slack等协作对话平台交流。大多数全员协作空间都是临时搭建，多种实体、虚拟的工具混合使用（白板、投影仪、会议室、视频会议设备等）。
对于职员和管理者来说，最需要培养的是”同理心“――员工和管理者都要对彼此有一种“同情的理解”，在彼此沟通、协作、要求时能够提出具体的需求。因为未来的工作需要高度的灵活性和自主性，但这并不意味着每个人给自己下达工作命令、工作指标。管理者的角色依然是必要的。
未来的工作是什么样子的？
说未来的职场将由全栈员工引领，无疑有些夸张，但这是一个显而易见的趋势。毫无疑问，工作的定义正在发生变化，员工的最大价值是应对不确定性，能够从海量的信息中提炼出有效的战略、战术。
而且，在工作机器人大规模“入侵”之前，我们只有10年的时间。他们正在取代体育新闻、驾驶、快递等重复性工作，人们要重新思考适合自己的角色。感知和综合的能力将是第一位的，而语言、辨析力和同感力在进行复杂、敏感的任务是都是必备技能。全栈员工将帮助我们向未来过渡，将成为新的混合经济中的关键角色。","焊过电路板，调试过硬件
把弄过各种芯片硬件，写过几行fpga
研究过x86, arm, powerpc, 
mips
各种芯片
写过几万行的linux驱动，网卡，pci等等都写过
精读过linux内核几个模块的代码，写过几个os级别模块
写了无数的linux后台程序，各种c, c++, python,
ruby, java, 
erlang
, php都写过一些程序
用qt写过客户端，写过android app，写过ios app
写过windows的程序
做过网站，用过ROR，写过简单前端，js, css，html都了解一些
弄过机器学习，写过分类聚类，跑过svm。
做过通讯系统，做过强电逆变器。
看起来够fullstack了吧？很不幸告诉你，如果是这样，那么就会毁掉fullstack这个词。
做过强电逆变器，虽然控制电机可以跑起来，但是仅仅停留在跑起来，可以控制速度而已。但是波形还能烂一点不？尼玛电机噪音那个大，主流的逆变器论文看过木有？甚至我怀疑微积分都没学好。
做过机器学习，其实说白了，机器学习导论那本书你看完都可以做了，各种贝叶斯聚类分类决策树，高端点的LDA；但是这个仅仅是入门好不，底层的数学原理你足够了解了？能推导公式不？。让你做一个数字识别可以做出来，让你做一个来识别指纹呢？人脸识别呢？别告诉我说有库。
其它的等等很多都类似，别被fullstack这个词毁掉了你的一辈子，
要知道你做的东西都是别人的入门的时候做的
。
------------------------------------------------------------------------------------
回到问题：如何称为一个fullstack工程师
我觉得不要怕dirty job就可以了，一个不熟悉的领域，去找一两本导论级别的书，建立一个基本的知识框架，然后就可以开始干活了；当然，你别指望做的多好；但是绝对不会差到哪里去，知识基本都是相通的；甚至是可以相互借鉴的。
当然，如果就拿起某门语言大概看一下语法就开始干活的，我觉得这个不能算。基本每个后端工程师都会写简单的html & css & js吧？
-------------------------------------------------------------------------------------
关于发展问题：
和我一起毕业进入同一个公司（后面跳槽了）的同事，基本都是做深度路线的，很多都混的比我好（大公司核心部门核心岗位，或者在各大公司跳来跳去的）；无论是搞ACM的，还是在某个领域有足够强的积累。
他们去面试基本都可以秒杀国内主流互联网公司；但是我呢？做深度不够，做广度他们不需要，而且各大公司都会考虑成熟的技术，所以给的offer相对就没那么有吸引力了（当然，毕业后就没找过工作了，具体也不知道，哈哈）。
相反创业公司如果要找合作伙伴，都需要建立一定的信任关系，有些不了解的，让你去你都不敢去；如果是熟悉的团队，那么你只能期待公司发展顺利早点上市，哈哈。
自己创业？目前不考虑，这个是一个团队的事情，哪怕两三个人，不是你一个人可以解决的。就算你在fullstack，你也不可能兼顾到所有的事情。
-----------------------------------------------------------------------------------------------
关于优势
考虑问题会全面很多，可以做系统级别的事情，不容易陷入拿着锤子满世界都是钉子的境界。
还有，中小创业公司很喜欢这种人。
-------------------------------------------------------------------------------------------------
对自身发张的考虑
1) 知识结构体系化，更扎实一些。
2) 技术在某个方向做深。
3) 切入某个应用领域，多了解领域知识，解决领域问题。
4) 千万别沦落为民科！！！！
----------------- 2018.2.8再次更新-----------------------
随着管理团队的规模变大，事情变多，对事情有了更多的认识
走技术专家路线，是一个很不错的选择，稳扎稳打，各方面压力也不大，一些热门的岗位，会随着需求而身价快速提升
但是，如果一个各方面综合能力都很不错的
全栈工程师
，甚至对业务有不错的理解，那么会有更大的空间，包括管理团队；甚至，这些人就是为了当CEO/CTO准备的。","受苏格拉底大神的启迪，我也来谈谈全栈。
禅师：成为
全栈工程师
，这个问题等于如何成为全才，有可能吗
码农：有可能，不过可能性比较低，因为达芬奇这类人毕竟是百年一遇的奇才。不过，因为我热爱这个行业，也有一定天赋，所以只做好软件全栈的话我想还是可能的
禅师：你玩过三国志这个游戏吗
码农：我还开发过
禅师：你喜欢什么样的武将，诸葛亮怎么样？
码农：不错，虽然他武力只有20，不过智力有100，不过游戏出战不是单打独斗，我可以给他搭配武力100，智力20的吕布，在战场上所向披靡
禅师：对于一个武力65，智力65的武将，你怎么处理
码农：砍头或让他下野，浪费军粮和黄金
禅师：但是他很全面啊，两项能力综合130分，比诸葛亮和吕布的综合分还要高
码农：话虽如此但他还是太平庸，无法独挡一面
禅师：赵云怎么样
码农：这是我最喜欢的武将之一，武力97，智力80，还有一个姜维也是，武力91，智力91，这是我心中全才的标准
禅师：首先，请把一个能力发展到90，如果你还有余力把另一个能力发展到90，再称呼自己全栈吧，否则你只是一个全面发展又全面平庸的废材。
码农：我明白了，我想facebook和google标榜的全栈，也肯定不是一个c++，java，ios，php，blabla都只会编写hello world的全栈。","借宝地说句话。
    我前几天对标李笑笑6W的“
全栈
”，说了我自己认为的“全栈”，然后，很多小伙伴私信我，让我惊讶的是――他们问的不是“你为什么要这样分类”，而是：“我懂XXX，你认为我可以拿多少钱？”
于是，就有了这套“
全栈工程师
打分标准”―――
（也算我侧面回答了本楼的这个问题吧）
满分是100分。
（这是我对我公司程序员哥哥的打分标准，我公司小，我眼皮浅，欢迎来喷我^_^）
原型：（5分）                     
axure，visio，
墨刀
，Pop ，
必选一得5分。如你所见，这些更是产品经理的必懂的工具，从程序员哥哥做到全栈哥哥，居然不懂，对不起天地啊。
app：（10分）
安卓，iOS，webapp(react，vue，
angularjs
)，react native。
说明：
app都不会，微信平台不会，小程序不会，算什么全栈？
懂app开发加5分，懂webapp加5分。
页面：（5分）
html5，css，
bootstrap
，jquery 都懂加5分，懂大部分加3分。
（不负责解释什么是懂）
说明：这个是基本功。
脚本语言：（5分）
python，
lua
，ruby，php。
说明：作为全栈工程师，居然不会2种以上的脚本语言，python必须会的吧，产品经理都会，2种以上加5分，1种加3分，
函数语言：（5分）
haskell，Scala。                    
说明：以后是函数语言的天下，现在主流语言都插入函数语言功能，不会以后会被淘汰。
1样加5分。
编译语言：（10分）
java，c，c++，c#，go 。
说明：java和c++必须会，c#现在也是跨平台，go不是差不多吗？
3种以上加10分，2种加5分，1种加3分。
api 设计工具：（5分）
RESTful api，swagger。
说明：
api的设计，工具，现在非常重要，很多互联网公司就是以api为核心，会设计合格的api加3分，会自动文档和使用工具加5分。
框架：（10）
nodejs，
springboot
（springmvc）,django，rail，
thinkphp， .NET。
说明：spring在java领域最近有一统天下的趋势，现在懂语言不懂框架，没生产力，只要懂2种以上的框架才会相互借鉴，spring从rail和django获取了不少经验。
2种以上框架和微服务加10分，懂2种加7分，一种加5分。
sql：（5）
mysql，oracle，sql server 必选一，懂得sql索引优化加分，分布配置加分。
说明：
sql都不懂，算什么工程师？
no sql，
消息队列
（5）
redis，mongodb, memcached。
说明：
没有redis,
mongodb
,如何开发高并发程序？
无消息队列无法处理异步系统。
懂3种才能加5分，2种加3分，1种？额，加1分。
RPC和分布式架构（10）
thrift，web service，pb，gRPC 加分项，
dubbo,zookeeper 分布式架构，微服务。
说明：
必须要会thrift或
grpc
，这样才有利用各个语言的优势，进行大团队协助。还必须懂分布式架构，这样才能把rpc整合起来，懂rpc加5分，懂分布式架构加5分。
服务器配置（5）
nginx,tomcat,jetty,apache,
openresty
,varnish，必须2个才能加5分。
说明：
nginx和
tomcat
基本都是标配了，懂2种以上加5分，其他加2分。
开发流程和源码管理，可持续集成，容器（5）
svn，git，Jenkins，docker，jira，diffy。
说明：
如果你不懂开发流程，持续发布，自动测试，你没办法建立10人以上的团队和快速迭代，懂整个流程的加5分，懂可持续集成和源码的加3分，只懂源码控制的加2分。
大数据（10）
Hadoop，spark，
kafka
，hive，Elasticsearch。
说明：
大数据现在不仅仅是分析，现在略微大点系统都依赖于大数据。
（懂3种以上加10分，懂2种加5分，懂1种加3分）
第三方工具（5）
要知道阿里云，
七牛
，cdn,聚合api，pingxx，友盟，face++,等各种sdk（做过）
说明:
第三方工具至少要懂3个以上才能加5分。
打分说明：
60分以上勉强算全栈入门，70分算合格，80以上算资深，90以上你是大牛。
收入标准：
60分工资20-30 ，70分工资30-50， 80分以上收入50-100，90以上看你脾气。
（单位不扯，自己心里清楚，我也不想被喷）
最后再分享一下我们团队目前采用技术栈，喜欢的欢迎勾搭：
react，安卓，iOS
restfulapi swagger
springboot java
thrift c++，python
mysql，mongodb，redis
docker，docket
hadoop，essearch","我理解的全栈工程师：
对软件开发有各个环节有浓厚的兴趣。
有良好的自我驱动能力，很强的学习能力。
良好的英文阅读能力，经常使用 google/stack overflow/
quora
/wikipedia 研究软件开发方面的知识。这一点是针对非英文母语的人。
深刻理解计算机相关的这种基础知识和原理。
深刻理解工具链使用和原理。
以上两条做到融汇贯通，就快成为全栈工程师了。
找各种机会实践你的理解。
我的团队在找 
全栈工程师
，可以参考下：
创业团队招聘","先来歪楼
为什么要成为所谓full stack engineer? 这个full stack engineer 的概念要理解清楚，我个人认为不是说要成为一个全能工程师。
先讲个自己的故事，我是从90年代初就开始做技术的，那时候没有互联网、没有开放代码、没有各种平台，资料都是去书店去买，一本书里面真正有用的就10来页，雷布斯当时写了本《未公开的dos中断》，当时奉为天人，后来知道是翻译的。做应用要懂dos，要懂各种bios的中断，要会用汇编，要会用c，要会做网线，要会装服务器（那时还是netware的天下），还要会手动查查病毒，读懂分区表，要自己写sql和sqlform去实现用户应用需求，甚至在DOS里面自己做字符的界面管理和鼠标控制，还要用汇编写中断去控制调制解调器和打印机，因为用户不愿意多买服务器（当时服务器好贵）写个简单的tcp/ip的堆栈....
这个够full stack吧，当时觉得自己真的属于上知天文下知地理，但是时至今日，这些本事有什么用呢？我觉得基本没用了，而且随着经历的丰富，反而觉得过去自己浑身的本事都是雕虫小技，不懂的东西好多好多，真正有用的是留下来对项目的经验和架构的体会。IT行业发展到现在，和社会发展一样，进入了社会分工明确的时代。每个方向深入下去都是大的不得了的东西：
1 你说你懂操作系统，能给linux提补丁吗？
2 你说你会运维，sed,awk,sar,snmp这些东西你都是活字典吗？
3 你说你会数据库，一条复杂sql能不看explain就能知道怎么运行的吗？看了explain能知道数据库的索引问题在哪里吗？知道怎么改吗？
4 你说你会网络，看过tcp/ip源码吗？知道wifi里wep,wpa aes的区别吗？知道前兆线和百兆线物理上的区别嘛？
5 你说你会web编程，看过http的rfc吗？看过webkit代码嘛？
6 你说你会大数据分析，概率论的几十种分布都懂嘛？每种分布适合那种情况知道吗？或然率公式会推导吗？
7 你说你会C/C++，你知道不同编译选项出来的优化代码的顺序吗？
。。。。。
真正要懂一个技术，不是仅仅看几本书写几段例程就行的，都得实际干几个能上线的项目才能知道这个技术的坑在哪里，适合什么，不适合什么，出了问题大概怎么回事。这件事从人的精力上来看我个人觉得是不可能的，而且做到了也没什么意义，最多就成为一把瑞士军刀：什么都能对付两下，真干专业的活那样都不好使。这对一个技术人员真的不是什么好事，因为工程师是要实际动手干活的。
我建议工程师的可以成为临栈工程师而不是一个
全栈工程师
，所谓临栈就是对于自己专项工作相邻的一些技术要有一定的了解，类似母语之外的外语。比如做后台的工程师，对数据库要有点了解，或者对tcp/ip有点了解。做前台的工程师，对http要有点了解，对图形学、色彩学有点了解。这样有助于在工作中和团队中的伙伴更好的交流，实在不行时候也能对付两下子救救急，或者证明不靠谱的伙伴做的确实猪头。但是，记住了，这不是你的饭碗，除非你打定主意改行。
当然，你要是想做那种光说不做的工程师、顾问呀什么的，那是另外一回事了。瑞士军刀也是有市场的。
歪楼结束，回到问题。
如何成为全栈工程师，我觉得是机遇，就和民国初期出了一堆学贯中西的人一样，不是他们多牛，而是时代造就：
小时候读私塾，国学童子功没问题。长大取消科举，留洋好找工作，不到20岁就去留洋，回来以后一看，我靠，学贯中西呀。
如果你每3年换一个方向，每个方向都扎的很深去做实际项目，还要复习过去的知识并跟上发展，你就可以成为一个full stack工程师。祝你成功！","看到
很多答案都是采用意淫大法
，揣测全栈工程师是怎样的。
当然，很多思路也都是对的。
我就不采用意淫大法了，
用自己的实际经历
介绍下如何成为全栈工程师。并且介绍
成长路上
和
成为全栈工程师之后
要
注意的事情
。
开始了，小板凳搬好。
本回答一共分为下面几个部分：
1、Web前端
2、后端
3、客户端
----------小节
4、算法
5、运维与脚本
----------小节
6、其他可有可无
7、现在在干吗
8、最后也是最重要的一点
人没在美国，也没坐飞机。
为了说明一切都是真实的，不是意淫的，我会配上作品图。
作品会涉及到页面，如果有人说
丑
（尤其是我的页面设计部分，因为是真丑），请
将其转化为点赞
抒发出来！！！当做对我勇气的鼓励，谢谢。
1、 前端
我是从前端入手开始编程的。不，确切说是页面设计。
是的，我最开始接触互联网开发的身份是：页面设计师。就是设计和绘制网页。
那时，我大一。
一天，我有了一个想法：做一个校车查询系统。
那时候，我们学校六七个小区包围了省会。做实验、或者进城等，校车成了最好的途径。然而，学校网站提供的校车是个表是一个表格……巨难使用！
你想想，当你太阳底下背着书包，用Nokia 6300的小屏幕（10年，有个Nokia 6300就不错了）一边心疼流量（10元10M？贵的很）进入学校网站，曲曲折折找到那个表格，多麻烦！
于是，我要做一个校车查询应用。
设计出来下面的图：
然后，会PS只是第一步。前端开发我也会，三下五除二写出了前端页面。
完美。
但是还有一个问题，应用场景！
用户在查询校车时，往往是在路上。10年左右，流量那么贵，让大家访问这么漂亮（额，漂亮么？十年前的审美真是奇怪呢！）的界面浪费流量，而且那时的手机一般屏幕小，使用起来不方便。
所以，我用WAP协议（上古协议？）写了一个手机版的。
每次查询不到5k，四舍五入就是不需要流量。
对了，后来我不做页面了，也不做前端了。因为我觉着我审美太差，不合适。而且审美这东西又很难通过努力弥补。
所以，
没必要真的完全全栈，每个人都有自己的短板
。
2、后端
光写了前端没有用啊，得有后端支持啊！
不要怕，PHP是世界上最好的语言，世界上所有的网站都运行在Apache上。其他网站就不配叫网站！
PHP大法好，学起来。
于是后端就有了啊。
然后我就把它挂到了学校网站的服务器上（我是网站技术部门的成员），然后发了个QQ空间装逼。
然后，就被疯狂转发。
历史最高访问几千独立访客每天。
对的，我在里面加了CNZZ的访问统计代码。
那几天，我那个激动啊！！！
所以，到这里，至少前后端通了。
3、客户端
但是！万一用户5K都不想用呢？
或者，网络不好呢？
再说了，校车信息表一般是一个学期更新一次，直接下载下来，用户一直用多好啊。
于是，搞个客户端。
不会没关系，学啊。
Android，搞起啊。
于是有了：
它的优点是：
使用内置数据库存储信息，没有网络也能查询，有网络则会校验数据后判断是不是要更新
根据GPS信息自动判断你的出发校区
根据你的历史记录，自动判断你的目的校区
当然，那些自动判断逻辑都很弱智的，没什么AI算法。
小节
好，这个时候告一段落，我们总结下。
其实，从前端到后端到客户端，我就在做一件事情：校车查询。就这一个最简单的事情，一直做。
除了说到的这些，还有数据库、应用部署、访问统计、应用发布等等。只要盯着一件事情从头到尾做下来，都会涉及到。
所以，如果要想成为全栈工程师，你可以选择一个有意义的事情，一直做。有以下几个好处：
做一个实在的东西出来，有成就感。我看到QQ空间都在转发我的网页我就特别有成就感，有动力。
有连贯性。前后都在做一个事情，你会意识到之前做的哪些地方可以改进，这样很有连贯性，利于进步。
好了，接下来进入新的阶段。
本来那个阶段应该是：IOS客户端。
可是，我穷，没有iPhone和Mac。而且，我保研了，要去其他学校做毕设。
于是，我开始搞……算法……
4、 算法
算法很好玩。
不过我可能没那么适合，至少和我们实验室的刘博相比。
之人博闻强识，有过目不忘之术。听闻一次，便可记生人之星座爱好家乡诸类。而又善推理，常执一笔于白板急速推演，或矩阵或方程，每当吾辈称赞，则摇手羞涩曰“嗨，这有什么难的。”更甚之，其外语极佳，桌角常堆一尺论文，皆为所阅。常见其手执一笔，畅然读阅，其速若母语。吾每羡之，皆叹不能及。
然后，我后来就去某度实习了。在凤巢，就是广告算法的比较核心的部门，做广告推荐算法。
所以，算法，我也算是略知一二。至少基本的机器学习算法，都能推导。
不过那时候，就特别好奇隔壁组是怎么把我们组给出的算法给工程化的（这里是伏笔！）。然后总感觉自己是个螺丝钉。
最后，还是选择离开了某度。
5、 运维与脚本
其实在搞算法时，就经常接触Linux脚本。
因为系统的数据量极大，使用Java或者Python的效率太低，所以很多的前期处理会使用Shell进行。所以，还算了解。
然后，工作初期还真就做了底层的偏运维的部分工作。当然不是运维，是应用工程化发布部署等工作（接伏笔）。在这里，我还真就清楚地知道了算法结果是怎么工程化的。
而且，其实最近我还真在给AI项目做工程化方案。看，解答了当年的疑惑。
期间各种Shell\lua\PowerShell……都搞了一些。比较底层了。
小节
做到这，大家可以看到，我做了很多算法的工作，又做了工程化的工作。相当于，最软的和最硬的都做了。
一般人说的全栈，可能都触及不到这些，或者触及的比较少。
6、其他可有可无
然后其实我还做了一些其他可由可无的工作。一般不涉及这些工作也算是全栈工程师。
所以，我属于超全栈的。
例如，我做过强电的继电器。还考取了
注册电气工程师
。
做过弱电的电路设计。
下图是我做的一个收集空间中射频能量并供给传感器采集信息并通过Zigbee向外发送的电路板。
当然，程序也是自己写的。
应该够硬了吧。
不过这是题外话，做全栈工程师应该不需要搞这些。
7、现在在干吗
现在是软件架构师。
设计软件架构，外Java开发。我始终坚持一个原则：
虽然会页面，但是
绝不能
对组里页面小伙伴指手画脚。
虽然会前端，但是
绝不能
对组里前端小伙伴指手画脚。
虽然会后端，但是
绝不能
对组里后端小伙伴指手画脚。
以上很重要。上一张同事的杯子。
全栈是为了更好的协作
，而不是让你一个人做完所有。也没有一个人能做完所有。
所以，杯子上说的很对。
另外，虽然全栈很好！但是
不建议大家一直全栈下去
，要在
找到自己的兴趣点之后做深
！否则
精力是不够的
！
啥都会啥都不精，是会被淘汰的！
这一点也很重要。
好多年前公司组织全栈工程师培训，我还负责过前端培训。但是逐渐就不怎么做前端了。
我现在就是专注架构和后端，负责架构设计，协调开发。偶尔也自己做做开源项目，都是后端。
让我一个人做一个网站出来也行，可我的前端真的已经很菜了啊……
还有，我们组每个人都很牛，也都很全栈！
全栈很好，也很累
，希望大家有心理准备。
8、最后也是最重要的一点
不论是你
全栈工程师
还是什么工程师
永远记住！
身体最重要。
我，健身7年了，从未间断。
身体素质分在97到100之间，在公交车上常被认为是健身教练（主要因为胸大）。
身体年龄比我实际年龄小好多。
身体，才是持续进步的基础。
屏幕前的你可以忘记上面的各点，但一定要记住这一点。
最后，
健康、快乐、保持好奇、持续进步！
加油！奋斗路上的你和我。
感谢
点赞
。
也可以
关注
我，我会偶尔分享
架构设计
和
开发
方面的知识。","首先，如果您是
单纯为了工作
，没有任何其他目的的情况下，
我不建议您成为一名全栈工程师！！不服来辩！
全栈工程师
不是为了工作本身，是为了方便实现自己的梦。
一个真正的全栈工程师，目标只有一个：创业。
我相信高赞的这两句话道出了无数全栈攻城狮的心声！虽然这个回答并没有告诉大家该如何成为一名全栈开发攻城狮，有些跑题，但我还是喝下了这碗鸡汤[狗头]。我会在这篇回答中讲述一下我是如何成为一名全栈开发以及我的技术选型。
先介绍一下我做全栈的原因
首先介绍一下我自己，我本科毕业于澳洲某高校的人工智能专业(Artificial Intelligence & Robotics)。在我读大学之前，我对编程是一窍不通，更不用提什么前端后端了。
我第一次接触软件开发是在我大一那年，老师要我们做一个机械臂在限定区域内的运动轨迹优化算法，当时我苦思冥想了一周，都没有什么头绪。
结果第二周的时候，有个同学把自己的博客地址挂了出来，并且告诉大家说，他已经把可视化界面做出来了，同学们只需要填写固定的参数，就可以测试自己的算法能否成功运行了！当时全专业60号人全炸了！他的这个举动并不算是学术违规，而是实打实的降低了这个作业90%的难度因为这项作业占了平时成绩的30%，总成绩的15%！相当于你直接白的了15分！后来，大佬四年满绩点，拿了MIT的全奖直博。
虽然现在看来，只是简单的HTML+CSS甚至连框架都没用，简陋无比。但对于当时的我来说，简直如同晴天霹雳，震慑心扉，仿佛一道光照亮了我前进的道路！
每个人在求学时期，都会或多或少的有过想要创业的想法，软件基本上已经是创业者的基本工具。大佬的这一壮举，让我坚定了信念，学习了全栈开发。
国内当下环境最高效最容易上手的全栈选型：Vue+Python
感谢 
@尤雨溪
 （
前端
框架
Vue.js
的作者）@Guido van Rossu（Python之父）等等...
感谢大佬们为开源事业做出的贡献以及养活了无数开发者！
后端为什么选Python?
Python的教程多。大家在B站等平台都可以看到大量的优质的Python教程，比某些付费的培训机构强的多的多！
应用范围广，爬虫，写脚本，软测，算法AI都用它。就Web开发而言，python有Django, Flask, FastAPI等多个开发框架。Django与Flask的生态十分友好，因此首推Django与Flask。Python拥有海量的第三方库，可以满足你多方面需求！明明一个Python就能搞定的问题，为什么我非要学Java/PHP做Web开发，然后再学Python/C封装SDK？？
上手最简单！上手简单就意味着你入门快，入门快就意味着你的时间成本可以降低
我就读于AI专业，Python必定是我掌握最熟练的语言（这个是我的个人原因，大家可以忽略[狗头]）。
前端为什么选Vue?
容易上手。目前Vue是排名第三的前端框架。正是因为他简单易学，很多前端开发工程师可以很快掌握并且应用到实际开发中。
良好周边以及社区。作者是中国人，
中文论坛
更完善。大大降低了前端工程师的入职门槛。
Uni-app支持Vue做微信小程序和APP，我想你搞全栈，肯定不会只想开发网页端的应用吧，Uniapp可以帮你完成初步的小程序和app的制作，也方便你日后将用户引流到自己的app中。
Electron开发桌面应用。
大佬在知乎有账号，关注之后，没事看尤大怼憨憨，多是一件美事。
当然啦，大佬怼人的频率不高哈，一直都在解答Vue相关的问题，毕竟
学习路线
首先你要明确一个问题，你究竟是想成为一名架构师？还是一个打算创业的个人开发者？
下面是我总结的大型网站的开发架构，对初学者友好，不至于使您日后的员工觉得老板开发水平不行，也不至于你的网站在突然应对百万级的并发时突然挂了[狗头]，话说您都百万级了，还聘不起几个程序员了？
必学内容
前后端框架
务必要掌握，前端在这里不过多赘述。
后端的话，还是需要提两句，如果你选择了Python作为后端开发语言，Django和Flask是你在现阶段唯二的选择，就因为生态好，没有别的原因，你一个框架写在再完美，没有开发者，没有学习资源，没有社区都是空谈！我建议初学者选Django，因为功能性强，并且Django有用自带的管理后台，
可以让你减少前端页面的设计
。Flask是趋势, 考虑到Web开发行业在过去五年左右的时间里一直朝着较小的框架，微服务和“无服务器”平台发展的趋势，Flask超越了Django成为榜首不足为奇。但是，站在一个全栈开发者的角度上看，Django具有一切框架无法比拟的优势！自带单元测试方法和后台管理！再添加一个后台插件xadmin/simple-UI
你就告诉我，你拿什么比？？
Django-REST-framework. 
如果你选择了Django, 那么Django-REST-framework也是你必定要学的，DRF为你提供了API开发规范和模板，数据的序列化，API可视化，基于类视图的更强大的视图集等等。
关系型数据库MySQL. 
搞后端如果不会数据库，那就如同前端不会js。不理解为什么有人学前端不学js。请问您是怎么做到的？其他的关系型数据库我不做推荐，MySQL真的真的就够了，初学者就憋整那么多的花活了
非关系型数据库Redis. 
用来储存一些用户读写频率高的数据
测试. 
测试其实很简单，尤其是拥有Python基础的小伙伴，又可以省不少事
Linux
. 我用的最多的是Ubuntu18.04, 其次是RedHat. 在这里我推荐大家多学习学习Ubuntu操作系统，方便前期项目的部署，尤其是在你学习Docker之前。前期大家可以用一下虚拟机。我现在一般是在Windows下开发，其实没有太大差别
Git
. 代码管理必备，国内就连Gitee, 国外就用GitHub
部署方案Gunicorn/
uwsgi
. 
产品设计好了，就可以发布上线了，Gunicorn/uwsgi基本上只要会用就行，没有那么麻烦
有了以上技能基本上就可以部署一个合格的网站了，
额外学习
Docker.  
Docker这东西可以方便你做很多事情，用的人都说好。为什么我一定要用Docker呢？因为我的电脑不仅仅需要做开发，还需要设计原型图，登录企业微信等等软件，很多软件在Linux下无法使用，工作最重要的是沟通，而不是闭门造车。而且虚拟机实在是太卡了，我的电脑内存32G分配给虚拟机24G，都于事无补。
Docker Compose/K8s+Rancher
. 这个东西我就不多讲了，在你学完Docker的之后，自然就会明白。
对象存储方案Minio.  
如果你有大量的图片等资源存储，你就需要自己搭建一个对象存储服务了，或者你也可以上一些云服务器平台购买服务。之前我还向大家推荐了fastdfs，千万别学，跟Minio没可比性
架构思维. 
如果你想成为一名企业中合格的架构师，而不是码农，你就需要拥有架构师的思维。网站可能会遇到什么样的问题，需要什么样的解决方案。而开发者则是需要考虑逻辑，这个功能该如何实现blablabla。
Axure原型图
. 如果你是一名独立开发者，没有钱请UI，前端后端测试运维甚至UI都要自己来做的话（其他人请自动忽略此行），Axure原型图设计也是你需要学习的内容。当你学会了原型图设计之后，你就会明白，在这个项目的初期你是没有必要找UI的。UI也是根据你提供的原型图给你设计稿，而且也不一定能够让你满意，你完全可以自己比对原型图来搞前端的页面设计呀。而且身为独立开发者，你完全不需要考虑产品经理的想法，你就是你自己的产品经理！
学习工具
Pycharm
我做全栈开发用到的工具是这样的:
Pycharm => Pycharm + VSCode => Pycharm + WebStorm => Pycharm
一开始，我只用Pycharm, 当时第一个项目是Django前后端不分离的技术博客前端就到Boostrap+Jquery. 
后来，我学习了Vue，用了VScode作为前端开发工具，免费，插件多
之后，我前端改用了WebStorm. 毕竟是付费软件，确实比VScode好用一点，尤其是当你熟悉了JB家的快捷键，VSCode毕竟只是一个编辑器。
最后，我在Pycharm把前端需要的插件都安装好，只用Pycharm做Vue+Django. 还有一个原因就是为了节约成本。。。。既然Pycharm能用，我又何必多花一份钱呢？
POSTMAN/APIPOST
方便接口调试，在这里我推荐APIPost，国人开发，免费使用，支持一键生成API文档还有Mock.js功能（虽然Mock对全栈来说没一点用…）
数据库可视化
前期用的是NaviCat, 最后只用了Pycharm商业版。这个就无所谓了 
优化
我不会和你聊什么并发量和访问量等等之类的数据。我就以大白话告诉你，如果你的用户数量超过1W了，那么恭喜你，你走到了第二个台阶，在这个时候，如果你没有资本的青睐，你的收入是完全不能支持你聘请一个3年经验的软件开发工程师的，这个时候，你就面临两个选择，不管不顾还是网站优化。如果你想要学习优化的话，可以了解一下下面几点。
如果你想做网站的SEO优化，那就顺便学学Nuxt.js；
前端页面加载慢，学学懒加载，用CDN导入
面对突如其来的海量并发请求优化。学学异步Celery
数据库达到了万亿级，学学全文检索方案EleasticSearch + Django
如果你的用户量很大，redis负载均衡，数据库读写分离；
Django结构目录优化, 学CookieCutter-Django
换个好点的服务器，多买几个，前端一个服务器，后端一个，MYSQL一个，缓存一个。如果性能还是不行的话，那我就建议你不要用云服务器了，这个时候的云服务器的价格已经与你买服务器的价格相差无几了。
目前能想到的就是这些，4000个字足足码了一上午，希望大家能对大家有所帮助。如果你也是一名独立全栈开发者的话，有问题欢迎来私信我，我一般知无不言。希望大家能点点赞，点点关注！蟹蟹：）","我觉得想成为
全栈
很简单，以下过程来一遍，你不仅会成为全栈，还会变成真正的大牛。
1.学习华中科技大学的数字电路，计算机组成，用逻辑门电路自己画个cpu出来，搞定cpu。
2.学一下汇编，c语言，刷一下哈工大李志军的操作系统课程，再配合一下一个叫
于渊
写的书手动写操作系统，搞定操作系统。
3.刷一遍数据结构和算法。
3.学一下北京交通大学戴老师的c51单片机，体会一下软硬结合。
4.自己写一个玩具语言出来，有相关书籍照着来一遍。
5.自己写一个玩具编译器，有相关书籍照着来一遍。
6.学一遍html,css,js,
vue
,ts搞定前端。
7.学一遍java,javaweb,springmvc,spring,
mybatis
 搞定后端。
8.看一遍redis源码,巩固一下c语言和数据结构
9.看一遍
nginx
源码，了解一下高性能服务器怎么搞的。
10.常用的mq，zookeeper,
dubbo
,netty，springcloud学一遍，掌握网络编程和分布式架构体系。
上面的前5项，你应该在大学四年里完成。然后你就有了强大的基础。
后面5项结合你在工作中遇到的或自己规划，一年完成一项。然后你就成为了一个有5年工作经验相对厉害的程序员。
然后你是想成为前端，后端，全栈，还是架构师，自己选一项就可以了，然后就是在你选择的道路上深耕。
成为全栈其实没啥意思，也没有难度。成为某个领域的专家或大拿那才是牛逼。"
