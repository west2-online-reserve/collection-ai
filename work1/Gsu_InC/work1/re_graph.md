# 正则表达式核心语法速查表

## 一、基础字符匹配

| 语法 | 描述 | 示例 |
|------|------|------|
| `.` | 匹配除换行符外的任意单个字符 | `a.c` 匹配 "abc"、"a c" |
| `[...]` | 匹配字符集中的任意一个字符 | `[aeiou]` 匹配 "hello" 中的 "e" 和 "o" |
| `[^...]` | 匹配不在字符集中的任意字符 | `[^0-9]` 匹配 "A1" 中的 "A" |
| `[a-z]` | 匹配指定范围的字符 | `[A-Za-z]` 匹配所有英文字母 |
| `\d` | 匹配数字，等价于 `[0-9]` | `\d+` 匹配 "123" |
| `\D` | 匹配非数字，等价于 `[^0-9]` | `\D+` 匹配 "abc" |
| `\w` | 匹配单词字符（字母、数字、下划线） | `\w+` 匹配 "user_123" |
| `\W` | 匹配非单词字符 | `\W` 匹配 "@"、"!" 等 |
| `\s` | 匹配空白字符（空格、制表符等） | `\s+` 匹配空格和制表符 |
| `\S` | 匹配非空白字符 | `\S+` 匹配 "Hello" |
| `\t`, `\n`, `\r` | 匹配制表符、换行符、回车符 | `\n` 匹配换行 |
| `\\` | 匹配反斜杠本身 | `\\` 匹配 "\" |

## 二、数量限定符

| 语法 | 描述 | 示例 |
|------|------|------|
| `*` | 匹配前一个元素0次或多次（贪婪） | `a*` 匹配 ""、"a"、"aaa" |
| `+` | 匹配前一个元素1次或多次（贪婪） | `a+` 匹配 "a"、"aaa" |
| `?` | 匹配前一个元素0次或1次 | `colou?r` 匹配 "color" 和 "colour" |
| `{n}` | 匹配前一个元素恰好n次 | `a{3}` 匹配 "aaa" |
| `{n,}` | 匹配前一个元素至少n次 | `a{2,}` 匹配 "aa"、"aaa" |
| `{n,m}` | 匹配前一个元素n到m次 | `a{2,4}` 匹配 "aa"、"aaa"、"aaaa" |
| `*?`, `+?`, `??` | 非贪婪（懒惰）匹配版本 | `<.*?>` 在 `<a><b>` 中匹配 `<a>` 和 `<b>` |

## 三、位置锚点

| 语法 | 描述 | 示例 |
|------|------|------|
| `^` | 匹配字符串开头（多行模式下匹配行首） | `^Hello` 匹配以 "Hello" 开头的字符串 |
| `$` | 匹配字符串结尾（多行模式下匹配行尾） | `end$` 匹配以 "end" 结尾的字符串 |
| `\b` | 匹配单词边界 | `\bcat\b` 匹配独立单词 "cat" |
| `\B` | 匹配非单词边界 | `\Bcat\B` 匹配 "scattered" 中的 "cat" |
| `\A` | 匹配字符串开头（不受多行模式影响） | `\AStart` 只匹配整个字符串的开头 |
| `\Z` | 匹配字符串结尾（不受多行模式影响） | `end\Z` 只匹配整个字符串的结尾 |

## 四、分组与引用

| 语法 | 描述 | 示例 |
|------|------|------|
| `(pattern)` | 捕获分组，可后向引用 | `(abc)+` 匹配 "abcabc" |
| `(?:pattern)` | 非捕获分组，不存储匹配 | `(?:abc)\|(?:def)` 匹配 "abc" 或 "def" |
| `(?P<name>pattern)` | 命名捕获分组 | `(?P<year>\d{4})` 捕获名为year的组 |
| `\1`, `\2`, ... | 后向引用捕获组 | `(a)\1` 匹配 "aa" |
| `(?P=name)` | 引用命名捕获组 | `(?P<word>\w+)\s+(?P=word)` 匹配重复单词 |
| `\|` | 逻辑"或"操作符 | `cat\|dog` 匹配 "cat" 或 "dog" |

## 五、断言（零宽断言）

| 语法 | 描述 | 示例 |
|------|------|------|
| `(?=pattern)` | 正向先行断言（后面是pattern） | `Windows (?=10\|11)` 匹配 "Windows 11" 中的 "Windows " |
| `(?!pattern)` | 负向先行断言（后面不是pattern） | `Windows (?!95\|98)` 匹配 "Windows 11" 中的 "Windows " |
| `(?<=pattern)` | 正向后行断言（前面是pattern） | `(?<=\$)\d+` 匹配 "$100" 中的 "100" |
| `(?<!pattern)` | 负向后行断言（前面不是pattern） | `(?<!\$)\d+` 匹配 "¥100" 中的 "100" |

## 六、标志修饰符

| 标志 | 描述 | 示例 |
|------|------|------|
| `i` | 忽略大小写 | `/hello/i` 匹配 "Hello"、"HELLO" |
| `m` | 多行模式（^和$匹配行首行尾） | `/^start/m` 匹配多行文本中每行的"start" |
| `s` | 单行模式（.匹配包括换行符的所有字符） | `/a.b/s` 匹配 "a\nb" |
| `g` | 全局匹配（查找所有匹配） | 通常作为函数参数，如JavaScript中的`/a/g` |
| `x` | 忽略空白和注释 | `/a b c/x` 等同于 `/abc/`，忽略空格 |

## 七、常用正则表达式示例

| 用途 | 正则表达式 | 说明 |
|------|------------|------|
| 邮箱地址 | `^[\w.-]+@[\w.-]+\.\w+$` | 简单邮箱验证 |
| 手机号码 | `^1[3-9]\d{9}$` | 中国大陆手机号 |
| 身份证号 | `^\d{17}[\dXx]$` | 18位身份证号 |
| 日期（YYYY-MM-DD） | `^\d{4}-\d{2}-\d{2}$` | 简单日期格式 |
| URL | `^https?://[\w.-]+(?:\.[\w.-]+)+` | 简单URL匹配 |
| IPv4地址 | `^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$` | IPv4地址 |
| 中文字符 | `[\u4e00-\u9fff]+` | 匹配中文字符 |
| 匹配整数 | `^-?\d+$` | 正整数和负整数 |
| 匹配浮点数 | `^-?\d+\.\d+$` | 简单浮点数 |
| 匹配HTML标签 | `<([a-z][a-z0-9]*)[^>]*>` | 简单HTML标签匹配 |

## 八、Python re模块实用技巧

```python
import re

# 1. 使用原始字符串（推荐）
pattern = r'\d+'  # 使用 r 前缀

# 2. 常用函数
text = "Hello 123 World 456"

# re.match() - 从字符串开头匹配
match = re.match(r'\w+', text)  # 匹配到 "Hello"

# re.search() - 搜索整个字符串
search = re.search(r'\d+', text)  # 匹配到 "123"

# re.findall() - 返回所有匹配的列表
all_matches = re.findall(r'\d+', text)  # 返回 ['123', '456']

# re.finditer() - 返回匹配迭代器
for match in re.finditer(r'\d+', text):
    print(match.group())  # 输出 "123", "456"

# re.sub() - 替换匹配项
new_text = re.sub(r'\d+', 'NUM', text)  # "Hello NUM World NUM"

# 3. 预编译正则表达式（提高性能）
compiled_pattern = re.compile(r'\d+')
result = compiled_pattern.findall(text)  # 使用编译后的模式

# 4. 分组提取
text = "Name: John, Age: 30"
match = re.search(r'Name: (\w+), Age: (\d+)', text)
if match:
    name = match.group(1)  # "John"
    age = match.group(2)   # "30"
    print(f"{name} is {age} years old")

# 5. 使用命名分组
text = "Date: 2023-10-01"
match = re.search(r'(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})', text)
if match:
    print(match.group('year'))   # "2023"
    print(match.group('month'))  # "10"
    print(match.group('day'))    # "01"