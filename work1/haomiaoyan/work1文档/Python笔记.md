---
date: 2025-10-17
tags:
  - python
  - 作业
  - West2-OnLineAI

---
## 字典与列表（List and Dict）[^1]
[^1]: 此文档参考部分了豆包生成的内容以及[简介 - Python教程 - 廖雪峰的官方网站](https://liaoxuefeng.com/books/python/introduction/index.html)
### 列表（List）
#### 定义
- 由一系列的**有序**元素组成。 而当中的元素可以是任意类型，==甚至在一个列表中可以**混合不同类型**的元素==

- ```python
  Empty_List=[] #空列表
  Num_List=[1,2,3,4] #数字列表
  Mix_List=[1,"West2-OnLine",[1,2]] #混合数字，字符串，子列表的列表
  ```

#### 访问
- 类似与C语言的数组----列表名+`[]` , 其中中括号的从0开始计数。而 **-1，-2** 却代表了其他意思，它们表示从后往前---- **-1** 为最后一个元素

#### 增删查改

- ==修改==
- ```python
  num=[1,2,3,4]
  num[0]=5 #把num列表的第一个元素的值修改为5
  ```


- ==增加==
- ```python
  num=[1,2,3,4,5]
  num.append('10') #在末尾添加10这个元素
  ```

- ==插入==
- ```python
  num=[1,2,3,4,5]
  num.insert(0,'hello') #在0这个位置插入了hello这个字符串
  ```
  
- ==删除==
- ```python
  num=[1,2,3,4,5]
  del num[2] #删除列表num的第3个元素
  ```
- 而针对~~删除~~来说方法也是~~多种多样~~的———— **pop() , remove()** 等等 ~~这里不过多介绍~~，详细部分可通过Ai等工具了解

#### 遍历
- 在列表的操作中 _**遍历**_ 是不可或缺的一部分 说直白一点就是通过循环的操作对列表中的每个元素进行操作
- 利用==for循环==进行遍历

- ```python
  num=[1,2,3,4,5]
  for x in num:
  print(x) #这样就可以把num中的每个进行打印输出
  ```

- **range函数** 可以很方便的进行创建一个数字列表
- ```python
  num=list(range(1,6)) 
  print(num)
  ```

- ==注意== 这里range函数中1与6 但只会生成1，2，3，4，5 即后面一个数字的前面一位
- 当然我们还可以对其进行==限制步长==的操作 
- ```python
  num=list(range(2,5,2)) #这里创建了以2为间隔的偶数列表
  ```


#### 切片
- 对于列表中的部分元素，python 将其称之为 _==切片==_ 
- 操作方式跟 [[Python笔记#访问]] 很类似， 不过是在`[]` 中又多了一位参数。顾名思义就是来指定首跟尾 
- ```python
  num=[1,2,3,4,5]
  print(num[1:4]) #其实是为1，2，3 3个元素 
  ```

#### 元组（tuple）
- 这里的元组跟列表很类似，最大区别在于元组 **一旦初始化就不能改变** 

#### 特点
1. 查找和插入的时间随着元素的增加而增加；
2. 占用空间小，浪费内存很少。
### 字典（Dict）

#### 含义
- 一种灵活的 ==键值对== 数据结构，主要用于存储具有某种映射关系数据。
- 而它运行的核心在于利用 ==键(key)== 来快速的查找对应的 ==值(value)== 
- 与列表的区别为 并非通过索引来进行访问

#### 特性
##### 键的要求
- 键必须是 **不可变类型**（如字符串、数字、元组），不能是列表、字典等可变类型
- 键必须 **唯一** ，如果出现重复的键，后定义的键值对会覆盖前面的
##### 值的特性
- 值可以是 **任意类型**（字符串、数字、列表、字典、函数等），没有限制
- 值可以重复
#### 基本操作
##### 创建字典
- 除了直接用 `{}` 定义，还可以用 `dict()` 函数创建
- ```python
# 方式1：直接用{}
dict1 = {"a": 1, "b": 2}

# 方式2：用dict()函数（键为字符串时可省略引号）
dict2 = dict(name="张三", age=20)  # 等价于 {"name": "张三", "age": 20}

# 方式3：通过键值对列表创建
dict3 = dict([("x", 10), ("y", 20)])  # 等价于 {"x": 10, "y": 20}
```
##### 访问
- 通过 **`字典名[键]`** 访问对应的值，若键不存在会报错
- 也可以用 **`get(key, 默认值)`** 方法：键不存在时返回默认值（默认值可选，不填则返回 `None` ）
- ```python
student = {"name": "小明", "age": 18}

# 用[]访问
print(student["name"])  # 输出：小明

# 用get()访问（更安全）
print(student.get("age"))       # 输出：18
print(student.get("gender"))    # 输出：None（键不存在，无默认值）
print(student.get("gender", "未知"))  # 输出：未知（键不存在，返回默认值）
```
##### 删除
- `del 字典名[键]`：删除指定键值对（键不存在会报错）
- `字典名.pop(键, 默认值)`：删除并返回指定键的值（键不存在时返回默认值，避免报错）
- `字典名.clear()`：清空字典所有键值对
- ```python
fruit = {"apple": 5, "banana": 3, "orange": 4}

# del删除
del fruit["banana"]
print(fruit)  # 输出：{'apple': 5, 'orange': 4}

# pop()删除并返回值
apple_count = fruit.pop("apple")
print(apple_count)  # 输出：5
print(fruit)        # 输出：{'orange': 4}

# 清空字典
fruit.clear()
print(fruit)  # 输出：{}
```


#### 嵌套
- ```python
classroom = {
    "student1": {
        "name": "小红",
        "age": 17,
        "scores": {"math": 92, "english": 88}
    },
    "student2": {
        "name": "小刚",
        "age": 18,
        "scores": {"math": 85, "english": 90}
    }
}
#访问st1 的数学成绩
print(classroom[student1][scores][math]) #输出92
     
```
- 字典的值可以是另一个字典（称为 “嵌套字典”），适合存储多层级关系的数据（如班级→学生→信息）

#### 特点
- 查找和插入的速度极快，不会随着key的增加而变慢
- 需要占用大量的内存，内存浪费多

## 函数
### Lambda 匿名函数
- `Lambda` 是一种 **简洁的匿名函数**（即没有名字的函数），用于定义简单的、临时的函数逻辑。它的核心特点是 “一行定义，即时使用”
- 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数
#### 对比（普通函数）
比如定义一个 “求两数之和” 的函数：

```python
# 普通函数（有名字，可复用）
def add(a, b):
    return a + b

# Lambda 函数（无名字，即时定义）
add_lambda = lambda a, b: a + b  # 用变量接收，方便调用
```

调用方式相同：

```python
print(add(2, 3))        # 输出：5
print(add_lambda(2, 3)) # 输出：5
```

### Decorator 装饰器
- `Decorator`（装饰器）是一种**用于 “增强函数 / 类功能” 的工具**，本质是一个 “接收函数作为参数，并返回新函数” 的函数。它的核心作用是：**在不修改原函数代码的前提下，给函数添加额外功能** 
- 但本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：

```python
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```
### 总结
- 两者都是 Python 中 “简洁代码” 和 “功能增强” 的重要工具，合理使用能大幅提升代码效率和可读性
## 面向对象
### Class (类) 
- 对于类来说，跟C语言的是一样的----因为是同一种数据结构
- OOP 的 “模板”，定义对象的属性和方法，通过实例化创建具体对象，是 OOP 的实现载体
### OOP (面向对象编程)
- 核心是 “抽象对象、封装属性和行为”，通过继承和多态实现代码复用与灵活扩展，更贴近现实世界的思维方式
### Magic Methods (魔法方法)
- 类的 “增强工具”，通过自动触发的特殊方法，让类支持 Python 内置操作（如加减、打印），无需手动写复杂逻辑

这里就进行简单介绍，可通过AI工具了解更多
## 文本处理
- 正则表达式是一种用来 **匹配字符串** 的强有力的武器。它的 ==设计思想是用一种描述性的语言来给字符串定义一个规则== ，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的
- 而re 是 Python 中专门用于**处理正则表达式**的内置库，它提供了一系列函数，能快速实现字符串的 “ ==匹配、查找、替换、分割== ” 等操作，核心作用是通过 “正则表达式规则” 从复杂字符串中精准提取或处理目标内容
## 代码美学
### 列表推导式
- 列表推导式是 Python 中**简化列表创建**的 “语法糖”，能以一行代码替代多行长循环
#### 作用
- **基于可迭代对象（如列表、range、字符串），用一行代码生成新列表**，避免写冗余的 `for` 循环和 `append()` 操作 
##### 1. 基础语法

```python
# 格式：[表达式 for 变量 in 可迭代对象]
# 逻辑：遍历可迭代对象的每个元素，用“表达式”处理后，放入新列表
new_list = [expression for item in iterable]
```

##### 2. 注意事项
1. 不适合复杂逻辑（如多条件嵌套、循环内有多个操作），否则会让代码难以理解，此时建议用普通循环
2. 避免生成过大的列表（如 `[i for i in range(1000000)]`），会占用大量内存，可改用生成器表达式（将 `[]` 换成 `()`）

### Type Hint (类型注释)
- 是**标注变量 / 函数类型**的语法，不影响程序运行，但能 ==提升代码可读性和 IDE 智能提示能力==
- `变量名: 类型`：标注变量类型
- `def 函数名(参数名: 类型) -> 返回值类型`：标注函数参数和返回值类型
- 复杂类型（如列表、字典）需从 `typing` 模块导入（Python 3.9+ 可直接用内置类型，如 `list[int]` 替代 `List[int]`）

## 进阶技巧
### generator 生成器 (yield 关键字)
- **生成器（Generator）** 是一种特殊的迭代器（Iterator），它不需要一次性将所有数据加载到内存，而是**按需生成数据**（“惰性计算”），从而大幅节省内存，尤其适合处理海量数据或无限序列
- 生成器的核心是 `yield` 关键字，它能让函数 “暂停并返回中间结果”，下次调用时从暂停处继续执行
- 生成器（通过 `yield` 实现）是 Python 中处理 “大数据” 和 “惰性计算” 的强大工具，其核心价值在于：**不提前占用大量内存，而是按需生成数据**。无论是处理大文件、生成无限序列，还是简化迭代器代码，生成器都能显著提升程序的内存效率和运行性能
-  **如果需要一个 “序列” 但不想一次性加载所有元素到内存，用生成器；如果需要反复使用序列中的元素，用列表**
