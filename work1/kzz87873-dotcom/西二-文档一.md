## List列表
基本用法：
```python
shopping_list = []
shopping_list.append("键盘")
shopping_list.append("键帽")
shopping_list.remove("键帽")
shopping_list.append("音响")
shopping_list.append("电竞椅")
shopping_list[1] = "硬盘"

# print(shopping_list)
# print(len(shopping_list))
# print(shopping_list[0])

price = [799 , 1024 , 200 , 800]
max_price = max(price)
min_price = min(price)
sorted_price = sorted(price)
print(max_price)
print(min_price)
print(sorted_price)
# 不可变
s = "Hello"
print(s.upper())
print(s)
s = s.upper()
print(s)
# 可变
shopping_list = ["键盘"]
shopping_list.append("显示器")
print(shopping_list)
```



## Dictionary字典
dictionary与tuple基本用法：
```python
contact_1 = {"小明":"13700000000","小花":"13700000001"}
print(contact_1["小明"]) # 打印内容
# 键的类型不可变 不可用list
# 元组 tuple 不可变
example_tuple = ("键盘","键帽")
contact = {("张伟", 23):"1500000000",
           ("张伟", 34):"1500000001",
           ("张伟", 56):"1500000002"}
zhangwei23_phone = contact[("张伟", 23)]
# 字典可变
# 添加进字典 与更新值操作相同
contact["A"] = "18600000000"
"小明" in contact_1
del contact_1["小明"]
len(contact)
```



## lambda - 匿名函数
```python
def add(a, b=1):
   return a+b
print(add(10,20))
print(add(10))

add_lambda = lambda a, b=1:a+b
print(add_lambda(10,20))
print(add_lambda(10)) 
```
**lambda ==参数==: 函数体**

### 使用if条件文
```python
# 利用三项表达式
get_odd_even = lambda x:'even'if x%2 == 0 else 'odd'
print(get_odd_even(9))
print(get_odd_even(8))
```

### 无参数表达式
```python
import random
ran_lambda = lambda: randam.randam()
print(ran_lambda())
```
### map()
```python
def add(x):
   return x**2
mobj = map(add, [1,2,3,4,5])
print(list(mobj))

mobj = map(lambda x:x**2, [1,2,3,4,5])
print(list(mobj))
```




## Decorator装饰器

<u>函数可被赋值（作为变量）</u>
对函数进行包装

```python
def timing(f):
    return f
def hello():
    print('enter hello')
hello = timing(hello) #hello赋值为timing返回值（hello对象）
hello() 

import time
def timing(f): #计算hello函数执行时间
    def wrapper():
        start_time = time.time
        result = f()
        print(f'Total_time: {time.time - start_time}') #计时
        return result  #返回f() wrapper与hello等价
    return wrapper #返回函数对象
@timing   #语法糖
def hello():
    print('enter hello')
#hello = timing(hello) #timing()为装饰器Decorator
hello()


# 支持参数 (wrapper()作用)
import time
def timing(f): 
    def wrapper(n):   #但不支持hello   ====> 可传入可变参数*args, **kwargs
        start_time = time.time
        result = f(n)
        print(f'Total_time: {time.time - start_time}')
        return result  
    return wrapper 
@timing   
def greet (name):
    print(f'Hello {name}')
greet(name)    
    
#装饰类
import time
def timing(f): 
    def wrapper(*args, **kwargs):    
        start_time = time.time
        result = f(*args, **kwargs)
        print(f'Total_time: {time.time - start_time}')
        return result  
    return wrapper 
@timing   
class Foo:
    def __init__(self):
        pass
Foo()
    
    
```
~~hello = timing(hello)~~  该步骤和语法糖效果相同




## class类     面向对象编程
类（抽象）：共同结构（用于描述对象）
对象（具象）：属性+方法
- **实例化**
变量 （对象/实例）= 类（属性参数）->生成函数调用        
传参：抽象->具象
对象 = 类名(实参)     -->实例化
对象.属性        /调用属性
对象.方法()     /调用方法 
eg.
```python
class Student:
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
        self.grades = {"语文": 0, "数学": 0, "英语": 0}
        #每个对象初始值都相同，无需从参数获取
        #可进行直接定义属性

    def set_grade(self, course, grade):
        if course in self.grades:
            self.grades[course] = grade #改变字典里键的值为grade的值

    def print_grades(self):
        print(f"学生{self.name}, (学号: {self.student_id}) 的成绩为: ")
        for course in self.grades:
            print(f"{course}: {self.grades[course]}分")
chen = Student("小陈", "100618")
zeng = Student("小曾", "100622")
chen.set_grade("语文", 92)
chen.set_grade("数学", 94)
chen.print_grades()
print(chen.name)
zeng.set_grade("数学", 95)
print(zeng.grades)
```
- **子类与父类**
- eg.
```python
class Employee:
    def __init__(self, name, id):
        self.name = name
        self. id = id

    def print_info(self):
        print(f"员工名字：{self.name}, 工号：{self.id}")

class FullTimeEmployee(Employee):
    def __init__(self, name, id, monthly_salary):
        super().__init__(name, id)
        self.monthly_salary = monthly_salary

    def calculate_monthly_pay(self):
        return self.monthly_salary

class PartTimeEmployee(Employee):
    def __init__(self, name, id, daily_salary, work_days):
        super().__init__(name, id)
        self.daily_salary = daily_salary
        self.work_days = work_days

    def calculate_monthly_pay(self):
        return self.daily_salary * self.work_days

zhangsan = FullTimeEmployee("张三", "1001", 6000)#定义对象
lisi = PartTimeEmployee("李四", "1002", 230, 15)
zhangsan.print_info()#使用方法
lisi.print_info()
print(zhangsan.calculate_monthly_pay())
print(lisi.calculate_monthly_pay())
```
- **封装**
改变作用域：       ==多个函数访问同一数据，且不为全局变量，不易被修改==
```python
def __init__(self, x):
    self.n = x
def foo1(self):
    print(self.n)
def foo2(self):
    self.n += 1
```
私有属性：           ==方法控制属性==
```python
def __init__(self, x):
    self.__age = x
def set_age(self, newVal): #更改         ##对象a.__age = [  ]不可直接修改
                                     ##只能由对象a的方法操作
    self.__age = newVal
def get_age(self):      #获得值
    return self.__age
```


-**类属性 类方法 静态方法**
取得与整个类有关的信息
```python
class Student:
    student_num = 0   #类变量
    
    def __init__(self, name, sex):
        self.name = name
        self.sex = sex
        Student.student_num += 1    #通过类来访问类变量
    @classmethod      #类方法需要装饰器classmethod装饰    
    def add_students(cls, add_num):   #cls作为参数访问类变量
       cls.student_num += add_num   ##通过类来访问类方法
        
s1 = Student('qq','Female')
```
定义类方法解析输入, 再进行构造函数
eg.
```python
def from_string(cls, info): 
    name, sex = info.split('')
    return cls(name, sex)
    
s2 = Student.from_string('qq Female')  #构造对象
```
```python
@staticmethod
# 不传入参数cls或self 不可访问类和实例的私有属性
#将相关函数封装在一个类里
def name_len(name):
    return len(name)
print(f'{Student.name_len(s2.name)}')   
```
调用静态方法时也需要通过类进行调用




## 魔术方法
决定python如何对待运算符和内置函数的方法
名称形式：
   __(内置的/定义好的)__     eg. __init__
执行调用:
   满足时机时自动触发执行

**__new__**
执行时机: 类名()      在__init__之前         ##==创建空对象==
所需参数: __new__(类名, *args, **kwargs)
返回值: 当前类的一个实例 (空对象) (self)
```python
class  Person:
    def __new__(cls, *args, **kwargs):
       instance = object.__new__(cls)  #调用object父类方法
       return instance  #空对象-->self
    def __init__(self)
```

**__del__**
对象被销毁时
  所以代码结束时
```python
class  Person:
    def __del__(self):
       print('__del__方法执行')
p1 = Person()
print('最后代码')
### ......对象被销毁      ## __del__方法执行
```
**__add__**

```python
class ShoppingCart:
    def __init__(self, items: list[str]):
       self.items = items
    def __add__(self, another_cart):   #两对象
       new_cart = ShoppingCart(self.items+ another_cart.items) #两对象属性
       return new_cart    
cart1 = ShoppingCart(["apple", "banana"])
cart2 = ShoppingCart(["orange", "pear"])
new_cart = cart1 + cart2
print(new_cart.items)
```

**__str__**
```python
def __str__(self):
    return f'Cart{self.items}'
cart = ShoppingCart(["apple", "banana"])
print(cart)    #打印字符串表达式
```

**__len__**
```python
def __len__(self):
    return len(self.items)
cart = ShoppingCart(["apple", "banana"])
print(len(cart))    #向对象求长度
```
**__call__**
```python
def __call__(self, item):
    self.items.append(item)
cart = ShoppingCart(["apple", "banana"])
cart('orange')    #像函数一样调用对象 
```



## 正则表达式
<u>https://regex/01.com</u> 可用于在线验证
**==元字符:表达特别含义的字符==**

==正则表达式=>字符串==

* **. 表示匹配除了换行符之外的任意单个字符**
  .色 =>以色结尾，包括前一个字符串的词语
  正则表达式基本利用：  
```python
import re
p = re.compile(r'.色')   #创建对象 compile处于Pattern类下  
#r''-->改变py原字符用法 
for one in p.findall(content):    #调用对象方法 findall()方法返回列表
    print(one)
```

- **^*^表示匹配前面表达式的子表达式（字符）的==任意次，包括0次==。**
  ，.*    eg.绿色* 表示色可以有任意次，即可以有n个色
  紧跟在.后面，表示任意字符可以出现任意次，所以整个表达式的意思是
  在逗号后面的所有字符，包括逗号
  *逗号后未有字符时仅表示，即0次*
  
* **+表示匹配前面的子表达式一次或多次，==不包括0次==。**
* ，.+         ==至少出现一次==


- **{}表示前面的字符匹配==指定==次数**
- eg. 油{3,4}表示匹配连续的油字至少3次，至多4次
     油{3}指定出现3次
     
- **贪婪模式和非贪婪模式**
- 在正则表达式中，'^*^' '+' '?' 都是贪婪的，使用他们时，会尽可能匹配多个内容
```python
 sourse = '<html><head><title></title>'
 import re
 p = re.compile(r'<.*>')
 print(p.findall(sourse))
```
运行结果为：
```python
['<html><head><title></title>']
```
所以，<.*>中的星号一直匹配到了字符串最后</title>里的e
为解决该问题，就需使用非贪婪模式，也就是在星号后面加上1？，变为<.*?>
```python
 sourse = '<html><head><title></title>'
 import re
 p = re.compile(r'<.*?>')
 print(p.findall(sourse))
```
运行结果为：
```python
['<html>','<head>','<title>','</title>']
```


- **\ 对元字符转义**
  正则表达式中 . 表示匹配任意字符，不能表示字符本身的意思，使用\将其变为原本字符的含义
  eg.   .*\.  

  **匹配某种字符类型**
  反斜杠后面接一些字符表示匹配某种种类的字符类型
  eg.
  \d 匹配0-9之间任意一个数字字符，等价于[0-9]
  \D 匹配任意一个不是0-9之间的数字字符，等价于[^0-9]
  \s 匹配0-9之间任意一个空白字符，包括空格，tab，换行符等，等价于[\t\n\r\f\v]
  \S 匹配0-9之间任意一个非空白字符，等价于[^\t\n\r\f\v]
  \w 匹配0-9之间任意一个文字字符，包括大小写字母，数字下划线邓，等价于[a-zA-Z0-9]
  \W 匹配0-9之间任意一个非文字字符，等价于[^a-zA-Z0-9]
  \w若想只表示英文字符，使用ascli选项 p = re.compile(r'\w{2,4}',re.A) -->加标记
  


- **[] 匹配某几种类型的字符**
  eg.[abc] 可匹配a，b或c里的==任意==字符，等价于[a-c]
  [a-c]  中的 - 表示一个范围从a到c
  [12]   [123]   [1-3]
  ==元字符在方括号内失去魔法，<u>变为普通字符</u>==
  eg.[akm.] 匹配a k m . 中的任意字符

  [a-z]\d{10}
  **方括号中的^表示非方括号里字符的集合**
  [^\d]
  [^abc]  
  > 非abc字符


- **^表示匹配文本的起始位置**
 正则表达式可设定单行模式--匹配==整个文本==的开头位置
  以及多行模式--匹配==文本每行==的开头位置
  eg. ^\d+   --->     ==011==-苹果-60
  
  py默认单行模式 
  ```python
  p = re.compile(r'^\d+', re.M)   #指定多行模式 或re.MULTILINE
  ```
  
- **$表示文本结束位置**
  eg.   \d+$    
> 结尾连续数字


- **()表示组选择**
eg.  (.+)，   ，前内容作为一组取出     --->  ==苹果==，苹果是绿色的

```python
p = re.compile(r'^(.*)(，)',re.M)   # 两种字符串于元组内
for one in p.findall(content):
    print(one)
```
结果为有两元素的元组:
```python
('苹果','，')
```
常用情景：
```python
content = '张三，手机号码，15945678901'
```
^(.+)，.+(\d{13})

```python
('张三','15945678901')
```

- **?表示匹配前面子表达式的0次或1次**



- [ ] **用正则表达式切割字符串**
    eg.
```python
import re
names = '关羽；张飞，赵云，  马超，黄忠 李逵'
name = re.spilt(r'[;,\s]\s*', names)
print(name)
```
```python
['关羽','张飞','赵云','马超','黄忠''李逵']
```



## Type Hint
1.函数可读性增强
2.使用函数时显示输入输出值的Type
3.解决由类型导致的逻辑问题

静态类型检查器  .mypy

eg.  
```python
def add(a: int, b: int) -> int:
```

**Union**
```python
from typing import Union
def add(a: Union[int, float], b: Union[int, float]) -> int:
#用'='給类型起别名
Num =  Union[int, float]
def add(a: Num, b: Num) -> int:
#等价
def add(a: int | float, b: int | float) -> int:
```

**None与Optional**
```python
def add(a: int|float, b: int|float) -> Num | None:
    if a <= 0 or b <= 0:
       return None
    return a+b
    
from typing import Optional
def add(a: int|float, b: int|float) -> Optional[Num]:
```
- 验证代码有效性
```python
result = add(1.1,2.2)
def print_num(n: Num) -> None:
    print(n)
print_num(result)
```
mypy报错：
print_num函数想要的参数为int | float 类型，但result变量可能为 int | float | None 类型

修改
```python
result = add(1.1,2.2)
def print_num(n: Num) -> None:
    print(n)
if result is not None:
print_num(result)
```

**List与Sequence**
```python
num_list: List[Num] = [1,2,3]
def print_num_list(l: List[Num]) -> None:
    for n in l:
       print(n)
print_num_list(num_list)  #可执行
int_list: [int] = [1,2,3]
print_num_list(int_list)   #出错
```
可能在函数内进行加入float操作
```python
def print_num_list(l: List[Num]) -> None:
    for n in l:
       print(n)
       l.append(1.1)
```
int_list 只可导入int类型

可修改如下
```python
num_list: List[Num] = [1,2,3]
def print_num_list(l: Conquense[Num]) -> None:  #Sequence[]无append方法
    for n in l:
       print(n)) 
int_list: [int] = [1,2,3]
print_num_list(int_list)   
```
- **代码中所用的类都可以注解类型：**
  内置类型 导入类型 自定义类型

```python
from datatime import datatime      #导入类型
from typing improt Literal         #自定义类
from __future__ import annotations   #自定义类进行前向引用

class Studdents:
    def __init__(self, name: str, birthday: datatime | str, sex: Literal['male','female'], courses: list[str], scores: dict[str,float], location: tuple[float, float] | None)

def follow(self, other_student: Students):  #自定义类Students
    pass
def create_student(name, birthday, sex, courses, scores, location):
    return Students(name, birthday, sex, courses, scores, location)   
#返回自定义类Students
```
- **抽象机类**
  Iterable: 所有可进行for循环的类型
  Callable: 函数类型
  Mapping
  .....
  eg.
  x: Callable[==[int, int]==, ==str==]  --->函数注解
                 输入类型   输出类型
-   **理念**
==**输入宽松，输出明确**==
```python
def print_names(names: Iterable[str]): -> list#所有可进行for循环类型均可输入
    for name in names:                        #但list类优于其他Iterable类
       print(name)
       return name
print_names(('a','b'))
```


- **泛型**
```python
from typing import TypeVar

T = TypeVar('T', int, str)    #T为待定类型 后限制待定类型
def add_two_items(a: T, b: T) ->:    #a b 返回值类型相同
    return a+b
```
等价写法:
```python
def add_two_items[T:(int, str)](a: T, b: T) ->T:
```



## 迭代器.生成器
**在处理大量数据时可节省内存资源**

能使用for循环的对象---可迭代对象/ iterables
包含__iter__方法
```python
print(hasatter(my_str, '__iter__'))
```
for循环原理:
1.调用 iterables 的 __iter__ 获取 iterator
2.调用 iterator 的 __next__ 函数获取下一个值
3.能否获取下一个值  否:退出for循环  是:返回下一个值
4.继续(2)步骤

```python
it = iter(my_str)  #my_str.__iter__()
while True:
    try:
        print(next(it))
    except StopIteration
        break
```
**迭代器:有__iter__和__next__方法**
```python
class LineIterator:
    def __init__(self, filepath):
        self.file = open(filepath. 'r')
    def __iter__(self):
        return self
    def __next__(self):
        line = self.file.readline()
        if line:
            return
        else:
            self.file.close()
            raise StopIteration
line_iter = LineIteration(filepath)
for line in line_iter:
    print(line)
```


**生成器:迭代器的简单实现**
```python
def generator(n):
    for i in range(n):
        print('before yield')
        yield i
        print('after yield')
        
gen = generator(3)
```
==yield关键字==:生成器自动产生__iter__和__next__方法
函数执行从yield退出,再从yield继续

```python
def gen_numbers(n):
    for i in range(n):
        yield i  # 暂停并返回当前值
g = gen_numbers(3)
next(g)  # 输出0，再调用输出1、2
```

