# 🐍 Python 生成器 (Generator) 与 `yield` 速查笔记





## 💡 1. 核心概念：什么是生成器？



- **一句话定义：** 生成器是一种特殊的**迭代器 (Iterator)**，它允许你“惰性地”生成一个值序列。
- **核心特征：** 它不会一次性在内存中创建所有值，而是**在你每次向它请求（迭代）时，才“实时”计算并“产出”下一个值**。
- **关键词：** `yield`



## 🚀 2. 为什么使用生成器？（核心优势）



1. **节省内存 (Memory Efficient)：**
   - 这是最大的优点。生成器一次只在内存中保留一个值。
   - **适用场景：** 处理超大型数据集、读取巨大文件、生成无限序列。
2. **惰性求值 (Lazy Evaluation)：**
   - 只有当你需要下一个值时，它才执行计算。
   - **适用场景：** 避免不必要的计算，尤其是当你的计算非常耗时，或者你可能不需要所有结果时。
3. **可读性与简洁性：**
   - 可以用简单的函数语法（`yield`）来实现复杂的迭代器逻辑，而无需手动编写迭代器类（实现 `__iter__` 和 `__next__`）。



## 📦 3. 如何创建生成器？



有两种主要方式：



### 方法一：使用 `yield` 关键字的函数



只要一个函数中包含了 `yield` 关键字，这个函数就不再是普通函数，而是一个“生成器工厂”。调用它会返回一个生成器对象。

Python

```
def count_to_n(n):
    """一个简单的生成器函数"""
    print("-> 生成器启动")
    
    for i in range(1, n + 1):
        print(f"-> 准备 yield {i}")
        yield i  # 暂停点：产出 i，并在此暂停
        print(f"-> 从 {i} 处恢复")
        
    print("-> 生成器结束")

# --- 如何使用 ---
# 1. 调用函数，得到一个生成器对象（此时函数体 *不* 执行）
my_gen = count_to_n(3)
print(f"返回的是：{my_gen}")

# 2. 迭代时，函数体才开始执行
for num in my_gen:
    print(f"==> 循环中拿到: {num}\n")
```



### 方法二：使用生成器表达式 (Generator Expressions)



它看起来像列表推导式 (List Comprehension)，但使用圆括号 `()` 而不是方括号 `[]`。

Python

```
# 列表推导式 [ ]： 立即创建完整列表，占用内存
my_list = [x * x for x in range(10)]

# 生成器表达式 ( )： 返回一个生成器对象，几乎不占内存
my_gen = (x * x for x in range(10))

# --- 如何使用 ---
# 同样需要通过迭代来获取值
for val in my_gen:
    print(val)
```



## ⚙️ 4. 如何使用（消费）生成器？



生成器一旦被“耗尽”（即所有值都被 `yield` 完毕），就不能再次使用。



### 方法一：`for` 循环 (最常用)



`for` 循环是使用生成器最自然的方式。它会自动调用 `next()` 并处理 `StopIteration` 异常。

Python

```
gen = (x for x in range(3))
for item in gen:
    print(item)  # 输出 0, 1, 2
```



### 方法二：`next()` 函数 (手动)



`next()` 函数会请求生成器产出下一个值。这有助于理解其“暂停/恢复”的机制。

Python

```
gen = count_to_n(2) # 使用上面的函数

val1 = next(gen) # 启动生成器，执行到第一个 yield
# 输出: -> 生成器启动
#       -> 准备 yield 1
print(f"拿到: {val1}") # 拿到: 1

val2 = next(gen) # 从上个 yield 处恢复，执行到第二个 yield
# 输出: -> 从 1 处恢复
#       -> 准备 yield 2
print(f"拿到: {val2}") # 拿到: 2

# 尝试拿第三个值
try:
    next(gen)
except StopIteration:
    # 输出: -> 从 2 处恢复
    #       -> 生成器结束
    print("生成器已耗尽 (StopIteration)！")
```



## 🆚 5. 关键对比速查





### `yield` vs. `return`



| **特性**     | **yield (在生成器函数中)**                | **return (在普通函数中)**         |
| ------------ | ----------------------------------------- | --------------------------------- |
| **动作**     | **暂停** (Pause) 函数执行                 | **终止** (Terminate) 函数执行     |
| **状态**     | **保存** 函数的本地状态（变量、循环位置） | **丢弃** 函数的所有本地状态       |
| **返回值**   | “产出”一个值，并准备下次恢复              | “返回”一个值，函数彻底结束        |
| **调用次数** | 一个函数中可以有**多个** `yield`          | 一个函数只能执行**一次** `return` |



### 生成器表达式 `()` vs. 列表推导式 `[]`



| **特性** | **生成器表达式 (x for x in ...)** | **列表推导式 [x for x in ...]** |
| -------- | --------------------------------- | ------------------------------- |
| **类型** | 生成器对象 (Generator)            | 列表 (List)                     |
| **执行** | **惰性求值** (Lazy)               | **立即求值** (Eager)            |
| **内存** | **极低** (常量内存)               | **高** (随元素数量线性增长)     |
| **适用** | 超大数据集，只需迭代一次          | 需要完整列表，或多次迭代        |



## 💡 6. 关键知识点



- **`StopIteration`**：这是一个异常。当生成器中没有更多的值可以 `yield` 时（函数体执行完毕或遇到 `return`），它会自动抛出 `StopIteration`。`for` 循环会自动捕获这个异常并停止迭代。
- **无限序列**：生成器可以轻松定义无限序列（例如 `while True: yield i; i += 1`），这是列表无法做到的。
- **管道 (Pipelines)**：你可以把多个生成器串联起来，形成高效的数据处理“管道”，数据流一次只处理一个，非常节省内存。