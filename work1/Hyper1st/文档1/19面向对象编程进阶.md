# 🐍 Python 面向对象编程笔记

## 1. 类与对象

- **类（Class）**：对象的蓝图，定义属性和方法。
- **对象（Object）**：类的实例，具体的数据实体。

```python
class Student:
    def __init__(self, name):
        self.name = name

s = Student("小明")  # 创建对象
```

------

## 2. 实例方法、类方法、静态方法

| 方法类型 | 定义方式        | 第一个参数         | 调用方式                           | 典型用途                 |
| -------- | --------------- | ------------------ | ---------------------------------- | ------------------------ |
| 实例方法 | 普通 `def`      | `self`（实例对象） | `obj.method()`                     | 操作实例属性             |
| 类方法   | `@classmethod`  | `cls`（类对象）    | `Class.method()` 或 `obj.method()` | 操作类属性，工厂方法     |
| 静态方法 | `@staticmethod` | 无                 | `Class.method()` 或 `obj.method()` | 工具函数，不依赖类或实例 |

### 示例

```python
class MathTools:
    @staticmethod
    def add(x, y):
        return x + y

class Student:
    count = 0
    def __init__(self, name):
        self.name = name
        Student.count += 1

    @classmethod
    def get_count(cls):
        return cls.count
```

------

## 3. 类属性与作用域问题

### 为什么不能写 `count += 1`？

- 在方法体里，`count` 会被当作局部变量。
- `count += 1` 是“先读再写”，如果局部没有定义，就会报 `UnboundLocalError`。
- 必须写成 `Student.count += 1` 或 `cls.count += 1`。

### 哪些情况不会报错？

- 在方法里先定义局部变量：`count = 0; count += 1`
- 使用 `global count` 修改全局变量
- 使用 `nonlocal count` 修改闭包变量

------

## 4. 继承与方法覆盖（Override）

- 子类可以继承父类的方法和属性。
- 如果子类定义了同名方法，会覆盖父类的方法。
- 父类方法仍然存在，可以用 `super().method()` 调用。

```python
class Animal:
    def speak(self):
        print("Animal")

class Dog(Animal):
    def speak(self):
        super().speak()
        print("Dog")
```

------

## 5. 多态（Polymorphism）

- **定义**：同一个方法调用，在不同子类对象上表现出不同的行为。
- **好处**：调用方只需面向父类接口，不关心具体子类。

```python
class Animal:
    def speak(self): pass

class Dog(Animal):
    def speak(self): return "汪汪"

class Cat(Animal):
    def speak(self): return "喵喵"

def make_sound(animal: Animal):
    print(animal.speak())

for a in [Dog(), Cat()]:
    make_sound(a)
```

------

## 6. `super()` 函数

- **作用**：调用继承链中下一个类的方法。
- **不是**“父类”的代名词，而是遵循 **MRO（方法解析顺序）**。
- **优势**：避免硬编码父类名，支持多继承，防止重复调用。

### 示例

```python
class A:
    def show(self): print("A")

class B(A):
    def show(self):
        print("B")
        super().show()

class C(A):
    def show(self):
        print("C")
        super().show()

class D(B, C):
    def show(self):
        print("D")
        super().show()

d = D()
d.show()
```

### 输出

```
D
B
C
A
```

------

## 7. MRO（方法解析顺序）

- Python 使用 **C3 线性化算法** 计算 MRO。
- `super()` 会按照 MRO 找“下一个类”。
- 在多继承（钻石继承）中，`super()` 保证每个类的方法只执行一次。

### ASCII 调用链图

```text
调用 d.show() 时：

D.show()
   │
   ▼
B.show()
   │
   ▼
C.show()
   │
   ▼
A.show()
   │
   ▼
object.show (终点)
```

------

# 📌 总结

1. **实例方法 / 类方法 / 静态方法**：分别对应 `self`、`cls`、无参数。
2. **类属性访问**：必须用 `Class.attr` 或 `cls.attr`，不能直接写 `attr += 1`。
3. **继承与覆盖**：子类方法覆盖父类方法，可用 `super()` 调用父类版本。
4. **多态**：同一接口，不同实现。
5. **super()**：按 MRO 串联方法调用，避免重复和顺序错误。





------

# 🐍 Python OOP 知识点总结（ASCII 思维导图）

```text
面向对象编程 OOP
│
├── 1. 类与对象
│     ├─ 类：蓝图，定义属性和方法
│     └─ 对象：类的实例
│
├── 2. 方法类型
│     ├─ 实例方法 (self)
│     │     └─ 操作实例属性
│     ├─ 类方法 (cls, @classmethod)
│     │     └─ 操作类属性，工厂方法
│     └─ 静态方法 (@staticmethod)
│           └─ 工具函数，不依赖类或对象
│
├── 3. 类属性与作用域
│     ├─ 类属性：所有实例共享
│     ├─ 必须用 Class.attr 或 cls.attr 访问
│     ├─ 不能直接写 count += 1
│     │     └─ 因为会被当作局部变量 → UnboundLocalError
│     └─ 解决：
│           ├─ Student.count += 1
│           ├─ cls.count += 1
│           ├─ global / nonlocal
│           └─ 局部变量先定义
│
├── 4. 继承与方法覆盖
│     ├─ 子类继承父类属性和方法
│     ├─ 子类同名方法覆盖父类方法
│     └─ 可用 super() 调用父类版本
│
├── 5. 多态
│     ├─ 定义：同一接口，不同实现
│     ├─ 示例：Animal.speak() → Dog/ Cat/ Duck 各自不同
│     └─ 好处：调用方只需面向父类接口
│
├── 6. super() 函数
│     ├─ 作用：调用 MRO 中下一个类的方法
│     ├─ 优势：
│     │     ├─ 避免硬编码父类名
│     │     ├─ 支持多继承
│     │     └─ 防止重复调用
│     ├─ 单继承：super() ≈ 父类方法
│     └─ 多继承：super() 串联 MRO
│
└── 7. MRO（方法解析顺序）
      ├─ Python 使用 C3 线性化算法
      ├─ super() 按 MRO 找“下一个类”
      ├─ 保证每个类方法只执行一次
      └─ 示例：
            D(B, C) → MRO: [D, B, C, A, object]
            调用链: D → B → C → A
```

------

# 📌 今日问题与解答要点

1. **为什么不能写 `count += 1`？**
   - 因为方法体里会被当作局部变量，必须写 `Student.count` 或 `cls.count`。
2. **类方法里的 `cls.count` 和 `Student.count` 区别？**
   - `Student.count` 写死类名，不利于继承。
   - `cls.count` 更灵活，支持子类调用。
3. **子类方法是否覆盖父类方法？**
   - 是的，子类同名方法会覆盖父类方法。
   - 父类方法仍存在，可用 `super()` 调用。
4. **super() 为什么叫 super？**
   - 来源于 superclass（超类）。
   - 作用是调用继承链中下一个类的方法。
5. **super() 会不会执行所有父类方法？**
   - 不会自动执行所有，只调用 MRO 中的下一个类。
   - 如果每个类都继续调用 `super()`，才会形成完整链条。
6. **为什么 B 里写 `A.show(self)` 会跳过 C？**
   - 因为硬编码父类名，破坏了 MRO 链条。
   - 正确写法是 `super().show()`。
7. **多个 super() 的作用**
   - 把子类和父类的同名方法按 MRO 串起来，形成调用链。
   - 示例：`D → B → C → A`。

------

✨ 这样整理后，你就能一眼看到 **类 → 方法类型 → 类属性作用域 → 继承/多态 → super/MRO** 的完整知识脉络。