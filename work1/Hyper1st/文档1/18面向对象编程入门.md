把 **面向对象编程（OOP）** 的核心知识点整理成一个 **文本思维导图**，能一眼看到整体结构：

```text
面向对象编程 (OOP)
│
├── 基本概念
│   ├── 类 (Class) → 模板/蓝图
│   │   ├── 属性 (Attributes) → 数据/状态
│   │   └── 方法 (Methods) → 行为/功能
│   └── 对象 (Object) → 类的实例，具体个体
│
├── 关键机制
│   ├── self 参数
│   │   └── 调用方法时，Python 自动把对象本身传入 → self 指向当前实例
│   ├── __dict__
│   │   ├── 每个对象都有自己的属性字典
│   │   ├── 在 __new__ 阶段创建，初始为空
│   │   └── 在 __init__ 或赋值时填充属性
│   └── 方法查找顺序
│       ├── 先查对象的 __dict__
│       └── 找不到再去类中查找方法
│
├── OOP 三大支柱
│   ├── 封装 → 隐藏实现细节，只暴露接口
│   ├── 继承 → 子类复用父类属性和方法
│   └── 多态 → 同一方法在不同对象上表现不同实现
│
├── 对象创建流程
│   1. 调用 __new__ → 分配内存，生成空对象 + 空 __dict__
│   2. 调用 __init__ → 初始化属性，写入 __dict__
│   3. 返回对象引用
│
└── 生活类比
    ├── 类 = 说明书/设计图
    ├── 对象 = 具体产品（每台电饭煲、每个学生）
    ├── 属性 = 产品的状态（容量、学号）
    └── 方法 = 产品能做的事（煮饭、选课）
```

------

### 🔑 总结

- **类** 定义结构和行为，**对象** 是类的实例，**方法** 是类中定义的函数，由对象调用。
- **self** 代表调用方法的对象本身。
- **对象存储属性在 `__dict__`**，方法存放在类中。
- **实例化流程**：`__new__` → 创建对象和空字典 → `__init__` → 填充属性。
- **三大支柱**：封装、继承、多态。

------



# 面向对象三要素关系

把“类—对象—方法”想成现实世界的“模板—实例—能做的事”，就能把抽象落地。

------

## 文本思维导图

```text
面向对象（OOP）
└── 类（Class） ←← 模板/蓝图
    ├── 属性（Attributes） ←← 数据结构与状态
    └── 方法（Methods） ←← 面向对象的“功能/动作”
        ↑ 方法属于类的定义，但要由对象来调用

对象（Object） ←← 由类“实例化”产生的具体个体
└── 拥有：同样的“属性结构” + 同样的“方法集合”
    └── 但属性值可能不同（各自状态不同）

关系总览：
Class ──(instantiation 实例化)──▶ Object
Class ──(defines 定义)──▶ Methods
Object ──(calls 调用)──▶ Methods
Methods ──(change/observe 改变或观察)──▶ Object 的属性/状态
```

------

## 生活化类比

### 家电类比：电饭煲

- **类（模板）：** 电饭煲这个型号的设计图。
- **对象（具体个体）：** 你家厨房里的那台电饭煲、我家的那台电饭煲（同一型号，不同序列号）。
- **属性（状态）：** 容量 4L、当前模式“保温”、定时 30 分钟。
- **方法（动作）：** 开始煮饭、预约、保温、取消。
- 关系要点：
  - 类规定“有哪些按钮、能做哪些事”。
  - 每一台具体电饭煲（对象）用“开始煮饭”这个方法时，会改变自己的状态（比如由“待机”变为“烹饪中”）。

### 学校类比：学生

- **类：** 学生（Student）。
- **对象：** 张三、李四（具体学生）。
- **属性：** 年级、学号、绩点。
- **方法：** 选课、请假、参加考试。
- 关系要点：
  - 学校定义了“学生”这个角色能做的事（方法集合）。
  - 每个学生作为对象，执行方法时影响自己的属性（选课会让课程列表发生变化）。

------

## 概念要点与逻辑关系

- **类是抽象的规则集合：** 定义了属性结构与方法接口；不占具体现实的“个体位”，相当于蓝图。
- **对象是具体的存在：** 通过实例化从类“生产”出来；共享同一套方法，但有各自的属性值和状态。
- **方法绑定到类上，由对象去调用：** 方法的“定义权”在类，方法的“执行权”在对象（通过对象的上下文访问自身状态）。
- **封装与一致性：** 相同类的对象，具有一致的接口（方法名与参数形式），便于统一管理与替换。
- **多态直觉：** 不同子类对象可用同名方法表现不同实现（比如“打印”方法，激光打印机与喷墨打印机执行过程不同，但对外接口一致）。

------

## 用 Python 演示（贴合你常用学习方式）

```python
class RiceCooker:
    def __init__(self, capacity_liters):
        self.capacity_liters = capacity_liters   # 属性：容量
        self.mode = "standby"                    # 属性：当前模式

    def start_cooking(self, minutes):
        # 方法：开始煮饭（改变对象状态）
        self.mode = f"cooking({minutes} min)"
        return f"Started: {self.mode}"

    def keep_warm(self):
        self.mode = "keep_warm"
        return "Switched to keep_warm"

# 类 → 对象（实例化）
rc1 = RiceCooker(4)      # 对象1：容量4L
rc2 = RiceCooker(5)      # 对象2：容量5L（不同状态/属性）

# 对象调用方法（同一方法，不同对象，结果绑定各自状态）
print(rc1.start_cooking(30))  # 影响 rc1.mode
print(rc2.keep_warm())        # 影响 rc2.mode
```

- **类定义了“有哪些属性”和“能做哪些动作”。**
- **不同对象共享同一套方法，但各自维护独立的属性与状态。**
- **方法通过对象上下文（如 `self`）读写该对象的状态。**

------

## 常见误区与澄清

- **误区：方法属于对象。** 澄清：方法的“定义”在类，调用时“绑定到对象”，因此对象用同名方法操作自己的状态。
- **误区：对象之间会互相影响默认属性。** 澄清：实例属性是独立的；只有类属性或共享可变默认值时才会出现“串扰”风险（避免把可变对象设为类属性或默认参数）。
- **误区：类只是数据结构。** 澄清：类同时承载“行为”（方法）与“状态”（属性），是数据与操作的统一体。

------





一份 **“实例方法 vs 类方法 vs 静态方法”** 的对比表，快速区分三者的角色和使用场景。

------

## 📊 方法类型对比表

| 方法类型     | 定义方式                        | 第一个参数         | 绑定对象        | 典型用途                                                     | 调用方式示例                       |
| ------------ | ------------------------------- | ------------------ | --------------- | ------------------------------------------------------------ | ---------------------------------- |
| **实例方法** | 在类中正常定义（默认）          | `self`（实例本身） | 绑定到 **对象** | 操作或访问对象的属性和状态；最常见的方法类型                 | `obj.method()`                     |
| **类方法**   | 使用 `@classmethod` 装饰器定义  | `cls`（类本身）    | 绑定到 **类**   | 访问或修改类属性；工厂方法（返回类的实例）；对所有对象共享的逻辑 | `Class.method()` 或 `obj.method()` |
| **静态方法** | 使用 `@staticmethod` 装饰器定义 | 无（不自动传参）   | 不绑定类或对象  | 工具函数，与类逻辑相关但不依赖类或对象的属性；逻辑上属于类的命名空间 | `Class.method()` 或 `obj.method()` |

------

## 🔑 关键点总结

- **实例方法**：最常见，操作对象的属性，必须有 `self`。
- **类方法**：操作类级别的数据，必须有 `cls`。
- **静态方法**：和类逻辑相关，但不依赖类或对象的状态，不需要 `self` 或 `cls`。

------

## 🧪 示例代码

```python
class Demo:
    class_attr = "类属性"

    def __init__(self, value):
        self.value = value

    # 实例方法
    def show_value(self):
        return f"实例属性: {self.value}"

    # 类方法
    @classmethod
    def show_class_attr(cls):
        return f"类属性: {cls.class_attr}"

    # 静态方法
    @staticmethod
    def add(a, b):
        return a + b

d = Demo(10)

print(d.show_value())        # 实例方法 → 实例属性: 10
print(Demo.show_class_attr())# 类方法 → 类属性: 类属性
print(Demo.add(3, 5))        # 静态方法 → 8
```

------

✅ 这样你就能清楚地区分三种方法的 **定义方式、绑定对象、用途和调用方式**。
