# 📘 函数高级应用总结

## 🎀 装饰器（Decorator）

- **定义**：装饰器是一个高阶函数，用来“包装”另一个函数，在不修改原函数代码的情况下，增强其功能。

- 结构

  ：

  ```python
  def decorator(func):
      def wrapper(*args, **kwargs):
          # 前置逻辑
          result = func(*args, **kwargs)
          # 后置逻辑
          return result
      return wrapper
  ```

- 关键点

  ：

  - `*args, **kwargs`：保证装饰器能适配任意参数的函数。
  - `func.__name__`：获取被装饰函数的名字。
  - `functools.wraps(func)`：保留原函数的元信息，并提供 `__wrapped__` 属性。

- 使用方式

  ：

  - 手动替换：`download = record_time(download)`
  - 语法糖：`@record_time`

- **取消装饰器**：通过 `func.__wrapped__` 调用原始函数。

- **参数化装饰器**：装饰器本身也可以接收参数（进阶用法）。

------

## ⏱️ 示例：记录函数执行时间

```python
import time
from functools import wraps

def record_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__}执行时间: {end - start:.2f}秒")
        return result
    return wrapper
```

------

## 🔁 递归调用（Recursion）

- **定义**：函数直接或间接调用自身。

- 要素

  ：

  - **递归公式**：问题的递归定义（如 (n! = n \times (n-1)!)）。
  - **收敛条件**：递归结束的条件（如 `if n in (0,1): return 1`）。

- 栈机制

  ：

  - 每次函数调用会入栈，保存执行现场。
  - 函数返回时出栈，恢复现场。
  - 栈是 **先进后出**，递归过深会导致 **栈溢出**（RecursionError）。
  - CPython 默认最大递归深度为 1000。

------

## 🧮 递归示例

### 阶乘

```python
def fac(n):
    if n in (0, 1):
        return 1
    return n * fac(n - 1)
```

### 斐波那契数列（递归版）

```python
def fib1(n):
    if n in (1, 2):
        return 1
    return fib1(n - 1) + fib1(n - 2)
```

- 缺点：大量重复计算，时间复杂度 O(2^n)。

### 斐波那契数列（循环版）

```python
def fib2(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
```

- 优点：时间复杂度 O(n)，效率高。

### 使用缓存优化递归

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fib1(n):
    if n in (1, 2):
        return 1
    return fib1(n - 1) + fib1(n - 2)
```

- `lru_cache`：缓存函数结果，避免重复计算。
- `maxsize`：缓存容量，默认 128；可设为 `None` 表示无限缓存。

------

## 📌 总结要点

1. **装饰器**：增强函数功能的优雅方式，常用于日志、计时、缓存、权限控制等。

2. **递归调用**：适合解决递归定义的问题，但必须有收敛条件，否则会栈溢出。

3. 性能优化

   ：

   - 循环往往比递归高效。
   - `lru_cache` 可以显著提升递归性能。

4. **栈机制**：函数调用依赖栈保存现场，递归深度过大容易导致 `RecursionError`。



------

# 📊 函数高级应用对照表

| 知识点                   | 定义                                             | 用途                                     | 优点                                    | 缺点 / 注意事项                                      | 典型应用                           |
| ------------------------ | ------------------------------------------------ | ---------------------------------------- | --------------------------------------- | ---------------------------------------------------- | ---------------------------------- |
| **装饰器 (Decorator)**   | 一个高阶函数，接收函数作为参数并返回增强后的函数 | 在不修改原函数代码的情况下，动态增加功能 | 代码复用、逻辑分离、语法糖 `@` 简洁优雅 | 需要理解函数作为对象的概念；多层装饰器可能增加复杂度 | 日志记录、性能计时、权限控制、缓存 |
| **record_time 装饰器**   | 在函数执行前后记录时间并打印耗时                 | 性能分析、调试                           | 一劳永逸，通用性强（`*args, **kwargs`） | 仅能测量整体耗时，无法细分内部步骤                   | 下载/上传耗时统计、函数性能测试    |
| **递归调用 (Recursion)** | 函数直接或间接调用自身                           | 解决递归定义的问题（如阶乘、斐波那契）   | 代码简洁，贴合数学定义                  | 容易栈溢出；效率低（如斐波那契）                     | 阶乘、斐波那契、树/图遍历          |
| **递归要素**             | 递归公式 + 收敛条件                              | 保证递归能正确计算并终止                 | 逻辑清晰                                | 收敛条件缺失会导致死循环                             | 阶乘公式、斐波那契公式             |
| **栈 (Stack)**           | 函数调用时保存执行现场的数据结构                 | 管理函数调用顺序                         | 自动管理，先进后出                      | 栈空间有限，递归过深会溢出                           | 函数调用、递归展开与回溯           |
| **循环迭代 (Iteration)** | 用循环代替递归                                   | 高效计算                                 | 时间复杂度 O(n)，避免栈溢出             | 代码可能不如递归直观                                 | 高效计算斐波那契、阶乘             |
| **lru_cache 装饰器**     | 缓存函数结果，避免重复计算                       | 优化递归性能                             | 将复杂度从 O(2^n) 降到 O(n)             | 占用内存；`maxsize` 需合理设置                       | 优化斐波那契、动态规划问题         |

------

# 📌 总结

- **装饰器**：增强函数功能的“外挂”，常用于日志、计时、缓存。
- **递归**：适合数学定义类问题，但要注意收敛条件和性能。
- **栈**：递归的底层机制，先进后出，栈深度有限。
- **优化**：循环和 `lru_cache` 是递归性能优化的关键手段。

------

