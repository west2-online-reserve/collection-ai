# Python 学习笔记

## 基础容器的使用技巧

### List

> 列表是由一系元素按特定顺序构成的数据序列,可以用它在存储一系列变量

#### 列表的使用

相较于其他语言(如C,C++),python的列表功能更加完善,易于使用

##### 列表的基础操作

- 使用`+`运算来拼接两个列表
- 使用`in`和`not in`判断元素是否在列表中
- 通过`[]`来用索引访问列表中的元素
- 通过`[start:end:stride]`列表切片访问列表中的部分内容
  - `start`:访问开始的位置
  - `end`:访问结束的位置
  - `stride`:访问的跨度,间隔几个元素访问
- `for-in`循环来实现对列表的遍历

##### 列表的方法

- 元素的添加
  - `insert`
    - `list.insert(n,element)` 向指定位置插入元素
  - `append`
    - `list.append(element)`添加到列表的末端
- 元素的删除
  - `remove`
    - `list.remove(element)`删除指定元素(不在列表中会报错)
  - `pop`
    - `list.pop(n)`默认弹出最后一个元素
- 元素的位置
  - `index`
    - `list.index(element,n)`从n以后查找指定元素的下标
- 元素的频次
  - `count`
    - `list.count(element)`统计元素个数
- 元素的排序
  - `sort`
    - `list.sort()`排序列表
- 元素的翻转
  - `reverse`
    - `list.reverse()`翻转列表

### dict

> 用键值对的方式把数值组织到一起,相当于用元素来作为元素的索引

#### 字典的创建

- python 中通过`{}`来创建字典,字典中的元素由`:`分割的两个元素构成
- 使用内置函数`dict`创建字典
- 字典中的键必须是不可变类型

#### 字典的使用

##### 字典的运算

- `in`成员运算
  - 检测键是否在字典内
- `for-in`
  - `for a in dict`在字典键中遍历
  - `for a,b in dict`在键,值中遍历

##### 字典的方法

- `dict.get(element)`取得键所对的值(不会报错)
- `dict.keys()`取得所有的键
- `dict.values()`取得所有的值
- `dict.items()`把所有的键与值封装成二元组返回
- `dict.update(dict)`更新字典里的值(没有的会被添加)
- `dict.pop()`删除元素,返回值
- `dict.popitem()`删除元素,返回键值二元组

## 函数

### Lambda 匿名函数

> 使用于需要临时使用函数的场景,快速定义短小、一次性的简单函数,可以简化代码,提升代码可读性

#### 匿名函数创建方式

```python
lambda x : x * 2 #返回输入数*2
```

#### 使用场景

- 适用于函数的参数为函数时例如`map()`,`sort()`

### Decorator 装饰器

> 正如字面意思,它的作用是装饰一个现有的函数,在不改变原函数的代码和调用方式的情况下,让它拥有额外的功能

#### 装饰器创建方式

```python
import time

# 1. 定义装饰器函数（接收原函数作为参数）
def timer_decorator(func):
    # 2. 定义包装函数（接收原函数的参数，*args 适配任意位置参数，**kwargs 适配任意关键字参数）
    def wrapper(*args, **kwargs):
        # 3. 新增功能：执行前记录开始时间
        start_time = time.time()
        
        # 4. 调用原函数，并获取返回值（确保原函数的返回值不丢失）
        result = func(*args, **kwargs)
        
        # 5. 新增功能：执行后计算耗时
        end_time = time.time()
        print(f"函数 {func.__name__} 执行耗时：{end_time - start_time:.4f} 秒")
        
        # 6. 返回原函数的返回值
        return result
    
    # 7. 返回包装函数（替代原函数）
    return wrapper
```

#### 装饰器使用方式

- 调用装饰器创建
  
    ```python
    my_func = timer_decorator(func)
    ```

- @语法糖

    ```python
    @timer_decorator
    def my_func:
        ...
    ```

## 面向对象

### 类

> 封装了事物的属性和方法,把现实中的事物抽象成类

核心要点

- **属性** : 事物的静态特征,如人的姓名,对应类中的成员变量
- **方法** : 事物的动态操作,如人的行为动作,对应类中的成员函数
- **实例化** : 类通过实例化创建对象,对象是类的具体载体，占用内存并执行实际逻辑

### 魔法方法

> 是一组以 __（双下划线）开头和结尾的特殊方法,在类内提供特殊功能

由 Python 解释器自动调用，无需手动触发
核心作用是 **为自定义类赋予 “内置类型的行为”**

#### 常用魔法方法

- 初始化与构造
  - `__init__(self, ...)` 构造方法，创建对象时自动调用
  - `__new__(cls, ...)` 实例创建方法, 极少重写
- 字符串表示
  - `__str__(self)` `print(obj)` 或 `str(obj)` 时调用
  - `__repr__(self)` `repr(obj)` 或交互式环境下直接输入对象时调用
- 运算符重载
  - `__add__(self,other)` 加法
  - `__sub__(self,other)` 减法
  - `__eq__(self,other)` 等于
  - `__gt__(self,other)` 大于
  - `__len__(self)` `len()`时调用
- 容器行为
  - `__getitem__(self, key)` $\rarr$ `obj[key]`
  - `__setitem__(self, key, val)` $\rarr$ `obj[key] = val`
  - `__delitem__(self, key)` $\rarr$ `del obj[key]`
  - `__iter__(self)` 和 `__next__(self)` $\rarr$ `for x in obj`
  - `__contains__(self, x)` $\rarr$ `x in obj`

### OOP思想

> oop的编程方式,通过把现实世界的事物抽象到代码中,使得代码符合人的日常认知,使用起来更加简洁,符合人的直觉,代码容易复用,更加容易维护

核心思想:用对象映射现实,一切物体都为对象,拥有特定属性,物体的动作都为方法

#### OOP四大特性

- **封装** : 隐藏内部实现的细节,外部仅通过公有接口访问
- **继承** : 代码的复用,建立层次关系
- **多态** : 子类重写方法,实现同一接口不同功能
- **抽象** : 提炼核心要点,忽略次要细节

#### OOP常见关系

| OOP 关系       | 核心语义             | 极简总结关键词       |
|----------------|-----------------------------------|----------------------|
| 继承（Inheritance） | 子类是父类的一种，复用共性并扩展   | `is-a`（是一种）     |
| 组合（Composition） | 整体包含部分，部分不可独立（生命周期绑定） | `is-part-of`（是组成部分） |
| 聚合（Aggregation） | 整体包含部分，部分可独立（生命周期分离） | `has-a`（包含）      |
| 关联（Association） | 两个对象长期关联，互相持有引用     | `has-a`（拥有）      |
| 依赖（Dependency）  | 一个对象临时使用另一个对象当工具   | `uses-a`（使用）     |

## 正则表达式

> 正则表达式是一种 文本模式匹配工具，通过特殊字符组合成 “规则字符串”，快速实现文本的查找、替换、分割、提取等操作.
> Python 中通过 re 模块提供完整支持，核心价值是：简洁高效处理复杂文本逻辑（如验证手机号、提取 URL、清理无效字符等）。

### re核心函数

- `re.match(pattern, string)`
  - 功能描述：从字符串 **开头** 匹配模式
  - 关键参数 / 返回值：匹配成功返回 `Match` 对象，失败返回 `None`

- `re.search(pattern, string)`
  - 功能描述：在字符串 **任意位置** 匹配第一个符合规则的子串
  - 关键参数 / 返回值：同上（与 `match` 区别：不局限于开头）

- `re.findall(pattern, string)`
  - 功能描述：查找字符串中 **所有** 符合规则的子串
  - 关键参数 / 返回值：返回列表（元素为匹配到的字符串）

- `re.sub(pattern, repl, string)`
  - 功能描述：替换所有符合规则的子串
  - 关键参数 / 返回值：`repl` 为替换后的字符串 / 函数，返回新字符串

- `re.split(pattern, string)`
  - 功能描述：按匹配到的子串 **分割** 字符串
  - 关键参数 / 返回值：返回分割后的列表

- `re.compile(pattern)`
  - 功能描述：编译正则表达式（重复使用时提升效率）
  - 关键参数 / 返回值：返回 `Pattern` 对象，可调用上述所有方法

### re修饰符

| 修饰符常量       | 简写 | 功能描述                                   | 应用示例                                                                 |
|------------------|------|--------------------------------------------|--------------------------------------------------------------------------|
| `re.IGNORECASE`  | `re.I` | 忽略大小写匹配（不区分字母大小写）         | `re.findall(r"python", "Python PYTHON", flags=re.I)` → `['Python', 'PYTHON']` |
| `re.DOTALL`      | `re.S` | 让 `.` 匹配所有字符（包括换行符 `\n`）     | `re.match(r"a.*b", "a\n b", flags=re.S)` → 匹配成功（默认 `.` 不匹配 `\n`） |
| `re.MULTILINE`   | `re.M` | 多行模式：让 `^` 匹配每行开头，`$` 匹配每行结尾 | `re.findall(r"^hello", "hello\nhello world", flags=re.M)` → `['hello', 'hello']` |
| `re.VERBOSE`     | `re.X` | 允许正则表达式换行、添加注释（提高可读性） |                                                             |
| `re.ASCII`       | `re.A` | 让 `\w`、`\d` 等仅匹配 ASCII 字符（默认匹配 Unicode） | `re.findall(r"\w", "中文abc", flags=re.A)` → `['a', 'b', 'c']`（不匹配中文） |

### 正则表达式基本符号

| 元字符     | 功能描述                         | 示例                             |
|-----------|----------------------------------|----------------------------------|
| `.`       | 匹配任意 **单个字符**（除换行 `\n`） | `a.b` 匹配 `acb`,`aab`,`a3b`     |
| `^`       | 匹配字符串 **开头**（与 `match` 功能呼应） | `^Python` 匹配以 Python 开头的字符串    |
| `$`       | 匹配字符串 **结尾**             | `fun$` 匹配以 fun 结尾的字符串          |
| `*`       | 匹配前面的字符 **0 次或多次**   | `ab*` 匹配 `a`、`ab`、`abb`、`abbb` |
| `+`       | 匹配前面的字符 **1 次或多次**   | `ab+` 匹配 `ab`、`abb`（不匹配 `a`）   |
| `?`       | 匹配前面的字符 **0 次或 1 次**（可选） | `ab?` 匹配 `a`、`ab`              |
| `{n}`     | 匹配前面的字符 **恰好 n 次**   | `a{3}` 匹配 `aaa`                |
| `{n,}`    | 匹配前面的字符 **至少 n 次**   | `a{2,}` 匹配 `aa`、`aaa`、`aaaa`   |
| `{n,m}`   | 匹配前面的字符 **n 到 m 次**（含边界） | `a{2,3}` 匹配 `aa`、`aaa`         |
| `[]`      | 字符集：匹配其中 **任意一个字符** | `[a-zA-Z0-9]` 匹配字母或数字          |
| `[^]`     | 否定字符集：匹配 **不在其中的字符** | `[^0-9]` 匹配非数字字符               |
| `\|`       | 逻辑或：匹配左右任意一个模式     | `a\|b` 匹配 `a` 或 `b`；`(ab)\|(cd)` 匹配 `ab` 或 `cd` |
| `()`      | 分组：提取子匹配项，改变优先级  | `(ab)+` 匹配 `ab`、`abab`；`a(b\|c)` 匹配 `ab` 或 `ac` |
| `\`       | 转义字符：取消元字符的特殊含义  | `\.` 匹配 `.`，`\*` 匹配 `*`        |

### 正则表达式常用字符集

| 预定义字符集 | 等价写法            | 功能描述                                   | 示例                     |
|--------------|---------------------|--------------------------------------------|--------------------------|
| `\d`         | `[0-9]`             | 匹配任意十进制数字（0-9）                   | `\d{3}` 匹配 `123`、`456` |
| `\D`         | `[^0-9]`            | 匹配任意非数字字符                         | `\D+` 匹配 `abc`、`！@#`  |
| `\w`         | `[a-zA-Z0-9_]`      | 匹配字母（大小写）、数字、下划线           | `\w+` 匹配 `Python123_`  |
| `\W`         | `[^a-zA-Z0-9_]`     | 匹配非字母、非数字、非下划线的字符         | `\W` 匹配 `@`、`空格`、`。` |
| `\s`         | `[ \t\n\r\f]`       | 匹配任意空白字符（空格、制表符、换行等）   | `a\sb` 匹配 `a b`、`a\tb` |
| `\S`         | `[^ \t\n\r\f]`      | 匹配任意非空白字符                         | `\S+` 匹配 `hello`、`123_` |
| `\b`         | -                   | 匹配单词边界（单词与非单词的分隔处）       | `\bPython\b` 匹配独立的 `Python`（不匹配 `Pythonic`） |
| `\B`         | -                   | 匹配非单词边界（单词内部或非单词之间）     | `\BPython\B` 匹配 `aPythonb` 中的 `Python` |

## 代码格式

### 列表推导式

> 通过一行代码创建一个列表的高效表达式,代码简洁,性能更好,可读性更强

### 基本用法

```python
new_list = [表达式 for 变量 in 可迭代对象 if 条件]
```

### 类型注释

> python是一门不需要指定变量类型的语言,因为系统会帮你决定,但与此同时代码可读性下降,所以python引入类型注释,像其他语言那样,可以知道指定的变量的数据类型,使代码可读性更强

#### 类型注释使用方法

- **变量类型注释**
  `变量名 : 类型 = 值`
- **函数类型注释**
  `def 函数名(参数) -> 返回值类型:`

## 生成器

> 生成器是一种特殊的迭代器,它不会一次性计算所有数据,仅仅在需要的时候计算,节省了大量性能,同时比创建迭代器更加简单,是一种高效开发的方式

### 生成器基本用法

- 生成器函数创建

  ```python
  def 生成器函数名(参数):
      函数体
      yield 表达式  # 暂停函数执行，返回当前表达式的值作为下一个元素
      函数体（暂停后继续执行的逻辑）
  ```

- 生成器创建

  ```python
  生成器 = 生成器函数(参数)
  ```

- 生成器使用

  ```python
  next(生成器)
  生成器.next()
  ```
生成器会在next调用时执行到yield时暂停并返回值,直到下一次调用