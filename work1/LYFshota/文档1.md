# 知识点笔记
- ### 基础容器:List（列表）、Dict（字典）的使用技巧
    - 列表的优势是可以灵活的增删改查操作，比较适合存储有序数据。使用起来也比较方便。
    - tips:访问元素时，有的时候除了正向索引，反向索引会更便捷，用切片操作还可以快速截取子列表或者反转列表等。

    - 字典优势是查询效率很高，适合用来存储有映射关系的数据。添加新键只需要直接赋值新键值对（快得很呐），删除则可以用 `del` 、`pop ()`、`clear ()`等关键字快速删除

- ### 函数：Lambda 匿名函数、Decorator 装饰器
    - Lambda 匿名函数的特点是没有函数名，只包含一个表达式，表达式的结果就是返回值，不需要写return语句。所以比较适合定义简单、临时使用的逻辑（用完就扔了）。常用的场景是结合一些内置函数来使用，比如在 `sort ()` 里面指定排序规则，在`map ()`里面来定义应用的函数

    - Decorator 装饰器可以接收原函数作为参数，返回一个新函数，可以在不修改原函数代码和调用方式的前提下，添加一些额外功能，相当于在函数外面添加了一层包装。比较简洁的用法可以直接用
     
            @decorator 
            def function():
                ... 
    来实现

- ### 面向对象：Class（类）与 Magic Methods（魔法方法），以及 OOP（面向对象编程）的思想
    - 面向对象编程的核心思想是把数据和操作数据的方法都封装在“对象”里面，通过抽象、封装、继承、多态，实现代码的模块化、复用性和可维护性。而类是对象的 “模板”，定义了对象的属性和方法。 （就比如宝可梦代码里面就需要不同类来实现便捷的添加不同的宝可梦，技能等） 
    类的属性分为实例属性和类属性。类的方法分为实例方法、类方法和静态方法。
    - 魔法方法是一类以双下划线开头和结尾的特殊方法，用来定义类的内置行为，不需要手动调用，会在特定场景下自动触发。比如说类一开始的数值初始化`__init__`就有点像C++的析构函数（），合理使用魔法方法可以让自定义类的行为更贴近Python的内置类型，让代码更一致性更好读。
    
- ### 文本处理：re 正则表达式
    - re正则表达式用于快速实现复杂的文本查找、替换、分割、提取等操作，比python字符串内置方法更加灵活、高效。（但是看起来复杂好多）
    - re模块常用的函数有：`match () `从字符串开头匹配；`search ()` 在整个字符串中查找第一个匹配项；`findall () `查找所有匹配项，返回列表；`finditer () `查找所有匹配项，返回迭代器；`sub () `替换匹配项；`split () `按匹配模式分割字符串，返回列表。
    
- ### 代码格式：列表推导式、Type Hint（类型注释）
    - 列表推导式核心作用是用一行代码替代 “循环 + 条件判断 + append ()” 的传统列表创建方式，可以让代码更简洁、可读性更强。列表推导式还可以多层嵌套.

            a_range = range(10)
            a_list = [x * x for x in a_range]
            print(a_list)
            输出结果：
            [0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64, 81]

    - 类型注释的作用是用于为变量、函数参数等标注数据类型，可以直接看出要输入的数据是什么类型还有返回什么类型的值。可以提升代码可读性以及便于编译器进行类型检查。如果遇到复杂类型比如说列表、字典、元组之类还可以从 typing 模块导入对应的类型。
    
            def a(first: int,second: str) -> str
            #传入first为int类型，second为str类型，返回值为str类型
    
- ### 六、进阶技巧：generator 生成器（yield 关键字）
    生成器的核心作用是不一次性生成所有数据并存储在内存中，而是在迭代时动态生成下一个元素，可以节省大量内存，适合处理大量数据。生成器的创建方式有两种，第一种是生成器表达式，语法与列表推导式类似，将 [] 改为 ()就可以，第二种是生成器函数，在函数中用 yield 关键字替代 return，这时候在函数调用时不会执行函数体，而是返回一个生成器对象。
    当生成器对象被迭代时，函数执行到yield语句时就会暂停，返回 yield 后面的值作为当前迭代的元素，下次迭代的时候，函数会从暂停的位置继续执行，直到再次遇到yield或者函数结束。