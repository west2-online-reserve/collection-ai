# Python学习文档

> 102501316

## 数据结构List、Dict的使用

+ Python的List和Dict是真好用吧，不但允许各种数据类型的相互嵌套，还内置的许多函数。单单一个`append()`放在C++就得写指针了。List的功能比数组强太多了，Dict还提供了非常方便的索引方式。List和Dict之间还允许相互嵌套，储存数据相当方便。

**【2025.10.19补充】**   
+ 在写作业零-斗地主发牌时发现，dict有两个内置函数`keys()`和`values()`，分别可以获取字典的键和值，但是返回值有点诡异，用`type()`测出来是这个`<class 'dict_keys'>`，实际要用得用`list()`转成列表。

+ List有一个内置函数`sort()`调用时会直接修改原列表，并且返回值为None，类似于赋值，所以不能直接写进条件表达式之类的东西里。`list1.sort() == list2.sort()`的返回值恒为True。　　

**【2025.10.23补充】**   
+ 实际上大部分情况下不需要用`list()`转化，`dict_keys`可以直接用for遍历,之前是我在一个列表里嵌套了一堆只有一个键的字典,所以很难搞。

+ 我曾尝试使用`sort()`来判断两个列表是否等价，但其实有更好的方法`set()`

## Lambda匿名函数

+ 感觉就是用来简化代码的，只能用于简单函数。可以和`map()`等函数结合使用。

**【2025.10.19补充】**  
+ 之前在网上查的时候，说这个在需要一次性函数时会非常好用，然而我根本想象不到会有哪里需要用到一次性函数，直到我用了`sort()`，它有一个参数`key`是直接接收一个函数的，这时候就需要用到一次性函数了，大概Python中这样的函数挺多的。

## Decorator装饰器

+ 函数嵌套，不过代码比较清晰简洁，便于调试。大概有不少应用场景，具体怎么使用还得继续研究。（日志记录，性能分析，权限控制……）

## 类Class、Magic Methods的使用

+ 类用于封装代码，实现代码的复用，如果函数是代码的封装，类则是多个函数的封装。  
魔术方法则使类的功能更加强大，最常用的比如初始化`__init__`（我用了这么久第一次知道这东西叫魔术方法，我真的很想吐槽这个名字）

## re正则表达式的使用

+ 正则表达式用于检索字符串，应用范围很广，我第一次接触是在尝试格式化网上下的txt小说。Python中的re库提供了完整的正则表达式功能，不过和一般直接使用的正则表达式语法上有所不同。

## 列表推导式

+ 额，这感觉就是`map()`的简化版，就跟Lambda是def的简化版一个样，没啥好说的。  

**【2025.10.19补充】**  
+ 简化就是好用啊，有些时候`map()`需要专门写一个函数，哪怕是用Lambda也显的很繁琐，这时候用列表推导式就很舒服了。

## generator生成器（yield关键字）

+ 按我相当浅显的理解，这是用于优化代码结构的。在一个迭代过程中，我们有一个变量`tmp`来储存数据，另外有一段代码`func`来完成对`tmp`的调用。但我们要将迭代的循环封装进一个函数中时，我们必须将`func`一同封装进这个函数中，因为tmp的值马上就会被覆盖，因此我们必须要原地调用，但如果使用了`yield`关键字，就可以让`func`独立于该函数之外，通过另一个循环来完成调用。　　

**【2025.10.23补充】**  
+ 首先是关于我为什么认为`yield`用于优化代码结构:

  ```python
  # 普通函数：一次性返回所有结果
  def get_numbers_list(n):
      numbers = []
      for i in range(n):
          numbers.append(i * i)
      return numbers  # 立即计算并返回所有结果

  # 生成器函数：按需生成每个结果
  def get_numbers_generator(n):
      for i in range(n):
          yield i * i  # 每次调用只计算一个结果

  # 使用对比
  list_result = get_numbers_list(1000000)      # 立即分配大量内存
  gen_result = get_numbers_generator(1000000)   # 几乎不占用额外内存
  ```

  以上为我查到的代码，第一种情况下确实会占用较大内存，所以我当时认为应该这么写

  ```python
  def get_numbers_list(i):
      return i*i
  for i in range(n):
      print(get_numbers_list(i))
  ```

  简单来讲，就是靠一个主循环解决问题，在这种情况下，每一个值都只需调用一次，即`print`，同样的，使用`yield`时，生成的值也只能遍历一次，这样两种效果应该是差不多的，但使用yield可以将代码完全封装进函数里，并且不需要全局变量，在一些复杂的情况下会非常方便，所以我认为`yield`很好的优化了代码结构。  

+ 随后我了解到`yield`还有其他用途，比如大型文件的处理，确实相当舒适。此外还有管道处理，双向通信，流式输出等等感觉都特别有用。我之前的理解确实很浅显。不过这东西还是需要后续实践来理解，现在根本没有一点实感。

## OOP面向对象编程思想

+ 面向对象就是将各种功能抽象为一个个对象，最后在通过一个主程序完成这些对象的互动。有着封装，继承，多态三个特点。  
+ 以游戏开发为例，封装就是把一个角色的所有功能都包装在一个类中，包括移动攻击等等。继承则允许子类使用父类的所用属性，比如要让一个角色升级，通过继承则可以保留角色已有的能力，并添加额外能力。多态允许不同类的对象通过相同的接口执行不同的行为，假设一个游戏允许玩家选择不同的角色，因为每个角色的技能不同，所以为每个角色都定义了一个类，但是这些角色拥有的功能是相同的，这时我们可以一行相同的代码调用不同角色的相同功能。  

## Type Hint类型注释

+ 提高代码的可读性，便于开源，团队合作等。Python内置库好像都有类型注释。  

**【2025.10.19补充】**  
+ 对于一个类内部的函数，如果要将其参数注释为这个类本身，可以用以下代码：  

  ```python
  from __future__ import annotations
  ```
