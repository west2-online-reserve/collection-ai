Python special

支持复数：
    a=2+3j
空类型：
    a=None
    和其他类型比较恒返回False
    b=0
    b==a ->> False
进制表示：
    0b...二进制
    0o...八进制
    0x...十六进制
布尔类型：
    a=True
    b=False
运算：
    Python是弱类型的，自带高精度
    5/2==2.5

    地板除 // 
        保留整数部分：5//2==2
    幂运算(优先级同数学) **
        2**3==8
            a**=b ->> a=a**b 

对象绑定/赋值（数组）:
    a=[1,2,3] #方括号
    b=a
    a[0]=100
    b[0]==100 ->> true  # b=a这一步吧b绑定至a而非拷贝 （指针）
    #浅拷贝

赋值的特殊语法：
    a=10;b=20 ->> a,b=10,20

is / is not语句：
    判断变量绑定（指向）是否相同
        a=[1,2]
        x=a;y=a
        (x is y)==True

    is not 反之

del:
    del a删除（释放）a这个变量（若可以尝试析构？）

关系：
    <> ->> != (仅python2)

    python允许：
        80<x<90 ->> x是否在80和90之间

生成对象的函数（像c的类型转换）：
    a=1;b="23"
    c=a+int(b) ->> c==24

    转字符串str()

    不给参数默认返回对应类型的0

变量作用域：
    存在 全局作用域 和 函数作用域
    if while等语句块不产生局部作用域

语句：
    注意缩进
    多条语句同一行用;分开
    \表示下一行也是该语句的一部分

    条件语句：
        if 真值表达式: 
            语句
        elif 真值表达式:
            语句
        else:
            语句

    循环语句：
        while 真值表达式:
            语句
        else:   #False时执行一次，可省略
            语句

        for 变量列表 in 可迭代对象: #字符串str，列表list，元组tuple，字典dict，集合set，固定集合frozenset，迭代器
            语句
        else:   #False时执行一次，可省略
            语句

    空语句：
        pass

    条件表达式（python版三目运算符）：
        表达式1 if 真值表达式 else 表达式2 
            真值表达式True返回表达式1，反之2

运算符:
    bool运算符：
        not(!in c) and(&&in c) or(||in c)
    位运算：同c

字符串：
    py没有字符数据结构，均为字符串,末尾为\0
    表示方法：
        """abc"""   可以识别enter为换行符
        '''abc'''   同上
        'abc'   只能一行字符串
        "abc"   同上
        定义四种更灵活
        要打印"可以'"',少用了转义符
    
    转义同c
    \uXXXX      #X表示数字，Unicode 16的十六进制字符
    \UXXXXXXXX  #Unicode 32

    指定字符编码的指令：
        源文件头写：
            # coding=utf-8
            # coding=gbk
            或者# -*- coding:utf-8 -*-

    隐式连接：
        a="abc""bcd" ->> a="abcbcd"

    运算：
        +， 比较，同cpp std::string
        *,*= 例如：
            "abc"*2=="abcabc"

    slice切片：
        str[(开始):(结束):(步长)] #括号括起来表示可省，开始与结束左闭右开,python类c语言，索引（index）从0开始
            a="123456"
            a[1:2:]->>"23" #cpp 取子串
        可以倒着来
            a[-1::]->>"6" #倒数第一个

    raw （r）字符串：
        作用：让\失效，写什么就是什么(包含\本身)
        r"ab\n" ->> 字符串信息即为 ab\n

    u"字符串":
        转为Unicode

列表（list）：

    支持泛型的序列（sequence）

    空列表：
        L=[]
        L=list()
    非空创建：
        L=[1,2,3,4]
        L=["asd",1,"sda","sd"] 可以混起来
        L=[1,2,[3,4]] 可嵌套，可包含各种类型元素（元组，集合等）

    列表生成函数list():
        list()->>[]
        list("hello")->>['h','e','l','l','o'] 要是可迭代对象

    运算：类似于字符串
        +,+=拼接
        *，*=
        比较运算符（遇到类型不一样不可比，会错TypeError）
        in运算
        []索引，正向和负向
        slice[::] 访问的是原本的列表（本质索引），可赋值（对应部分更改）
            赋值为字符串的时候，是把字符串拆开的，即hello把各个字母赋值给各个位置

        del 某个元素 用于删除元素
        同L.remove()

        list为可迭代对象
            for i in L: #L=[1,2,3]
                print(i) #1 2 3

        列表推导式：
            语法：[表达式(填充入的值) for 变量 in 可迭代对象] 或 [表达式 for 变量 in 可迭代对象 if 真值表达式]
                L=[i**2 for i in range(1,3)]->>[1,4]
                L=[i**2 for i in range(1,3) if i%2==0]->>[4]
            嵌套
                L=[x*y for x in range(1,3) for y in range(4,5)]

元组(tuple):
    只读的list(可拼接，但元素值不可变)
    T=(1,2,3)
    
    swap:
        a,b=b,a 将两值交换

字典（dict）：
    唯一的键值对应其所指向的值，利用键值索引
    无序
    类似cpp stl的unordered_map 映射，访问复杂度为平均O(1)

    创建：
        d={}
        d=dict()

        d={"key":"value"}
            访问：
            d["key"]=="value"    

    key必须是不可变类型

    字典的遍历：
        for i,j in d.item():
            print(i,":",j)

        直接对字典迭代即对key迭代

    添加：
        key存在为修改，不存在则添加
        d={}
        d["key"]=13 #添加了"key":13

    删除：
        del d[key]

    in / not in 运算
        仅判断key是否存在

    字典推导式：（同列表推导式）
        {key表达式 ：值表达式 for 变量 in 可迭代对象 （if ...） }

集合（set）:
    可变容器，元素唯一，无序，可以理解为只有key的字典
    创建：  
        set()
        set([1,2,3]) ->> {1,2,3}
        
        也可以s={1,2,3}

    使用数学上集合的运算：交并补子超
        - 生成补集：
            A={1,2,3}
            B={2,3,4}
            A-B=={1}
            B-A={4}
            #除去被减集元素
        | 并集
        & 交集
        ^ 生成对称补集 ->> (A-B) | (B-A)

        >,< 判断超级和真子集
        ==,!= 判断相同与否
        >=,<= 略
            
    集合推导式：同上

不可变类型：
    除了 list set dict 为可变类型,此三者不能充当dict的key

生成器：
    Python中，这种一边循环一边计算的机制，称为生成器：generator。
    可迭代
    generator保存的是算法

    创建：
        g = (x * x for x in range(10))

    yield：
        yield 语句返回，再次执行时从上次返回的yield语句处继续执行。

    用函数定义generator：
        def fib(max):
            n, a, b = 0, 0, 1
            while n < max:
                yield b # 保留现状的
                a, b = b, a + b
                n = n + 1
            return 'done' # 结束

    这时函数已经是generator函数，返回一个generator（关键：用了yield）
    每次调用都会生成一个独立的generator
        a=fib(max)
        b=fib(max)
        next(a)
        ...

    但是用for迭代得不到return值（只有yield值）：
        for不会触发异常StopIteration
        而return值在异常中（e.value）
        故而访问return值需要用next()抛出异常后捕获再访问

函数：
    定义：
        def 函数名([参数列表]):     
            [注释块]
            语句块(代码块)
            return [返回值] # 不写返回None

        例如：
            def add(a,b):
                return a+b

    函数可以返回一组值：
        return max,min #实际上是(max,min)(tuple)
    
    函数传参：
        def sum(a,b,c): #py自带泛型
            ...

            可以提示期望的输入类型:
            def fn(a:list):
                ...
        
        位置传参：
            sum(1,2,3)
        关键字传参：
            sum(a=1,c=3,b=2)
        序列（tuple list str）传参：
            *s ->> 传参拆分
            s=[1,2,3]
            sum(*s) ->> sum(s[0],s[1],s[2]) #数量要匹配,等价于拆开传进去，不是传字典进去
                                            #传字典进去直接def sum(d) ; sum(d) 即可，因为py是泛型的
        字典传参：
            d={"a":1,"b":2,"c":3}
            sum(**d) #key要是字符串，和变量名对应

        不定长传参：
            def f(*t): #元组传参，*t表示元组的形参，意即传进来的一系列参数合成一个元组，不是直接传元组
                ...

            f(a,b,c,d,e,...)

        命名关键字传参：
            *（仅作为分隔号）或*arg 后的参数只能通过关键字传参方式（a=...）
                def fn(*arg,a,b,c):
                def fn(a,*,b,c,d):

        字典形参传参：
            def fn(**d):

            调用：
                d(name="Peter",age=19)

        可变/不可变类型：
            py的变量改变方式是以绑定的方式进行的，不可变类型实际上是释放原本并申请新空间再次绑定，可变类型是直接改变元素
            可变类型可以在函数里改变；不可变类型不能在函数里改变，是不一样的对象

            py的赋值x=1默认是创建新变量

    作用域：
        全局变量：定义在函数外模块内
        局部变量：定义在函数内的（包括形参）

        py可以在函数内再定义一个函数（嵌套）
            def fn1:
                def fn2:
                    ...
                ...
        
        global：在局部作用域里使用全局变量（::x）
            global x,y,z... （不能和形参同名）
            ...

            全局变量可以直接读取，但不能改（有歧义），改动需要global声明

        nonlocal：
            声明变量不是局部也不全局，而是外部嵌套函数作用域

        globals()/locals() 返回当前全局/局部变量的字典

    函数式编程（思想）

    函数名也是变量：
        def fn():
            ...
        f1=fn 
        f1() ->> fn()

    高阶函数：
        接受函数为参数或返回值为函数
            def fn():
                def f1():

                return f1;

    匿名函数：
        lambda x,y : x+y ->> def fn(x,y):
                                return x+y

    闭包的概念
    装饰器函数（@deco）


模块（Module）
    通常一个.py一个模块

    模块导入：
        import 模块名 [as 别名]
        import math,sys

        from 模块名 import 单个的对象
        from module import * 导入全部 

        导入自己的模块：
            同目录：直接import

包：
    把.py用文件夹打包
    导入：
        包目录下一定要有文件"__init__.py"来识别该目录为 包，里面可以为空，也可以import依赖包
        import 包名 [as 包别名]
        import 包名.模块
        import 包名.子包.模块

        from 包 import ...
        from 包 import * #只导入__all__属性列出的

面向对象：
    1.类的创建：
        class class_name (继承列表):
            "文档"
            实例方法        # 只能实例使用
            类变量          # 属于类的变量而非实例,不在__init__定义,而直接在类内定义
            类方法          # 既可以实例使用，也可以类使用
            静态方法
            
        属性命名前面加了“__”且后面没加时，为私有，外部不可访问


        ## py中的面向对象更深一层：
            定义类本身也看做（像定义函数一样）一个对象(Object)。所以类的上一层有一个 元类 ，类的下一层对象称之为 实例(Instance)
            
    2.实例方法：
        self（关键字，表示实例自己）(类似c的this)：
            调用实例变量：self.value

        __init__(self,...) #用于定义实例变量，类似构造函数
            eg：
            def __init__(self,a): # 第一个参数一定是self，后面是形参
                self.value=a

            没有return的话返回自身self

            调用：  
            a=class_name(1) 

        定义实例方法：
            def method_name(self,...):
                ...

            调用：  
                instance.method_name(...)
                或者
                class_name.method_name(instance,...)

        __del__(self) #析构
            一般只有一条pass，py的垃圾回收机制会自动处理
            可以不定义，默认存在
    
    3.类方法：
        类方法是属于类的只能访问类变量的方法：
        语法：  
            @classmethod # 关键字
            def 函数名(cls): # cls关键字，表示这个类本身
                ...

    4.静态方法：
        是普通函数
        不需要传入self或cls
        不能访问类变量和实例变量
        
        @staticmethod
        def 函数(...):
            ...

    5.@property
        @属性.setter
        ....
